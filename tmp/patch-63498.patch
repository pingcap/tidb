From e188790ed75c7ab576b4889d50271895f38044ce Mon Sep 17 00:00:00 2001
From: 0xPoe <techregister@pm.me>
Date: Sun, 14 Sep 2025 11:29:48 +0800
Subject: [PATCH 01/14] statistics: support specify table IDs for non-lite init
 stats

refactor: better code

refactor: add maxTidStrategy

feat: add table list strategy

fix: remove useless uint64

feat: use table list strategy

feat: pass table IDs

fix: make lint happy

fix: use the correct total count

test: add unit tests

fix: update bazel
---
 pkg/statistics/handle/bootstrap.go            | 152 ++++++++++++------
 .../handle/handletest/initstats/BUILD.bazel   |   2 +-
 .../handletest/initstats/init_stats_test.go   |  63 ++++++++
 .../handle/initstats/load_stats_page.go       |   9 +-
 4 files changed, 169 insertions(+), 57 deletions(-)

diff --git a/pkg/statistics/handle/bootstrap.go b/pkg/statistics/handle/bootstrap.go
index 92823070015b3..374cd22a6819f 100644
--- a/pkg/statistics/handle/bootstrap.go
+++ b/pkg/statistics/handle/bootstrap.go
@@ -431,27 +431,83 @@ func (h *Handle) initStatsHistogramsByPaging(is infoschema.InfoSchema, cache sta
 	return nil
 }
 
-func (h *Handle) initStatsHistogramsConcurrently(is infoschema.InfoSchema, cache statstypes.StatsCache, totalMemory uint64, concurrency int) error {
-	var maxTid = maxTidRecord.tid.Load()
+type loadStrategy interface {
+	calcuateTotalTaskCnt() uint64
+	generateTasks(worker *initstats.RangeWorker)
+}
+
+type maxTidStrategy struct {
+	maxTid int64
+}
+
+func newMaxTidStrategy() maxTidStrategy {
+	return maxTidStrategy{
+		maxTid: maxTidRecord.tid.Load(),
+	}
+}
+
+func (maxTidStrategy) calcuateTotalTaskCnt() uint64 {
+	maxTid := maxTidRecord.tid.Load()
+	totalTaskCnt := int64(1)
+	if maxTid > initStatsStep*2 {
+		totalTaskCnt = maxTid / initStatsStep
+	}
+	return uint64(totalTaskCnt)
+}
+
+func (m maxTidStrategy) generateTasks(worker *initstats.RangeWorker) {
 	tid := int64(0)
+	for tid <= m.maxTid {
+		worker.SendTask(initstats.Task{
+			StartTid: tid,
+			EndTid:   tid + initStatsStep,
+		})
+		tid += initStatsStep
+	}
+}
+
+type tableListStrategy struct {
+	tableIDs []int64
+}
+
+func newTableListStrategy(tableIDs []int64) tableListStrategy {
+	return tableListStrategy{
+		tableIDs: tableIDs,
+	}
+}
+
+func (t tableListStrategy) calcuateTotalTaskCnt() uint64 {
+	return uint64(len(t.tableIDs))
+}
+
+func (t tableListStrategy) generateTasks(worker *initstats.RangeWorker) {
+	for _, tableID := range t.tableIDs {
+		worker.SendTask(initstats.Task{
+			StartTid: tableID,
+			EndTid:   tableID + 1,
+		})
+	}
+}
+
+func (h *Handle) initStatsHistogramsConcurrently(is infoschema.InfoSchema, cache statstypes.StatsCache, totalMemory uint64, concurrency int, tableIDs ...int64) error {
+	var s loadStrategy
+	if len(tableIDs) == 0 {
+		s = newMaxTidStrategy()
+	} else {
+		s = newTableListStrategy(tableIDs)
+	}
+	totalTaskCnt := s.calcuateTotalTaskCnt()
 	ls := initstats.NewRangeWorker(
 		"histogram",
 		func(task initstats.Task) error {
 			return h.initStatsHistogramsByPaging(is, cache, task, totalMemory)
 		},
 		concurrency,
-		uint64(maxTid),
-		uint64(initStatsStep),
+		totalTaskCnt,
 		initStatsPercentageInterval,
 	)
 	ls.LoadStats()
-	for tid <= maxTid {
-		ls.SendTask(initstats.Task{
-			StartTid: tid,
-			EndTid:   tid + initStatsStep,
-		})
-		tid += initStatsStep
-	}
+	s.generateTasks(ls)
 	ls.Wait()
 	return nil
 }
@@ -544,12 +600,17 @@ func (h *Handle) initStatsTopNByPaging(cache statstypes.StatsCache, task initsta
 	return nil
 }
 
-func (h *Handle) initStatsTopNConcurrently(cache statstypes.StatsCache, totalMemory uint64, concurrency int) error {
+func (h *Handle) initStatsTopNConcurrently(cache statstypes.StatsCache, totalMemory uint64, concurrency int, tableIDs ...int64) error {
 	if IsFullCacheFunc(cache, totalMemory) {
 		return nil
 	}
-	var maxTid = maxTidRecord.tid.Load()
-	tid := int64(0)
+	var s loadStrategy
+	if len(tableIDs) == 0 {
+		s = newMaxTidStrategy()
+	} else {
+		s = newTableListStrategy(tableIDs)
+	}
+	totalTaskCnt := s.calcuateTotalTaskCnt()
 	ls := initstats.NewRangeWorker(
 		"TopN",
 		func(task initstats.Task) error {
@@ -559,21 +620,11 @@ func (h *Handle) initStatsTopNConcurrently(cache statstypes.StatsCache, totalMem
 			return h.initStatsTopNByPaging(cache, task, totalMemory)
 		},
 		concurrency,
-		uint64(maxTid),
-		uint64(initStatsStep),
+		totalTaskCnt,
 		initStatsPercentageInterval,
 	)
 	ls.LoadStats()
-	for tid <= maxTid {
-		if IsFullCacheFunc(cache, totalMemory) {
-			break
-		}
-		ls.SendTask(initstats.Task{
-			StartTid: tid,
-			EndTid:   tid + initStatsStep,
-		})
-		tid += initStatsStep
-	}
+	s.generateTasks(ls)
 	ls.Wait()
 	return nil
 }
@@ -611,6 +662,7 @@ func (*Handle) initStatsBuckets4Chunk(cache statstypes.StatsCache, iter *chunk.I
 		hist.AppendBucketWithNDV(&lower, &upper, row.GetInt64(2) /*count*/, row.GetInt64(3) /*repeats*/, row.GetInt64(6) /*ndv*/)
 	}
 	if table != nil {
+		table.SetAllIndexFullLoadForBootstrap()
 		cache.Put(table.PhysicalID, table) // put this table in the cache because all statstics of the table have been read.
 	}
 	if hasErr {
@@ -630,11 +682,11 @@ func genInitStatsBucketsSQLForIndexes(isPaging bool) string {
 	return selectPrefix + " and table_id >= %? and table_id < %?" + orderSuffix
 }
 
-func (h *Handle) initStatsBuckets(cache statstypes.StatsCache, totalMemory uint64) error {
+func (h *Handle) initStatsBuckets(cache statstypes.StatsCache, totalMemory uint64, tableIDs ...int64) error {
 	if IsFullCacheFunc(cache, totalMemory) {
 		return nil
 	}
-	err := h.initStatsBucketsConcurrently(cache, totalMemory, initstats.GetConcurrency())
+	err := h.initStatsBucketsConcurrently(cache, totalMemory, initstats.GetConcurrency(), tableIDs...)
 	if err != nil {
 		return errors.Trace(err)
 	}
@@ -683,12 +735,17 @@ func (h *Handle) initStatsBucketsByPaging(cache statstypes.StatsCache, task init
 	return nil
 }
 
-func (h *Handle) initStatsBucketsConcurrently(cache statstypes.StatsCache, totalMemory uint64, concurrency int) error {
+func (h *Handle) initStatsBucketsConcurrently(cache statstypes.StatsCache, totalMemory uint64, concurrency int, tableIDs ...int64) error {
 	if IsFullCacheFunc(cache, totalMemory) {
 		return nil
 	}
-	var maxTid = maxTidRecord.tid.Load()
-	tid := int64(0)
+	var s loadStrategy
+	if len(tableIDs) == 0 {
+		s = newMaxTidStrategy()
+	} else {
+		s = newTableListStrategy(tableIDs)
+	}
+	totalTaskCnt := s.calcuateTotalTaskCnt()
 	ls := initstats.NewRangeWorker(
 		"bucket",
 		func(task initstats.Task) error {
@@ -698,21 +755,11 @@ func (h *Handle) initStatsBucketsConcurrently(cache statstypes.StatsCache, total
 			return h.initStatsBucketsByPaging(cache, task)
 		},
 		concurrency,
-		uint64(maxTid),
-		uint64(initStatsStep),
+		totalTaskCnt,
 		initStatsPercentageInterval,
 	)
 	ls.LoadStats()
-	for tid <= maxTid {
-		ls.SendTask(initstats.Task{
-			StartTid: tid,
-			EndTid:   tid + initStatsStep,
-		})
-		tid += initStatsStep
-		if IsFullCacheFunc(cache, totalMemory) {
-			break
-		}
-	}
+	s.generateTasks(ls)
 	ls.Wait()
 	return nil
 }
@@ -770,7 +817,7 @@ func (h *Handle) InitStatsLite(ctx context.Context, tableIDs ...int64) (err erro
 // 2. Column stats are marked as existing or not by initializing the table.ColAndIdxExistenceMap, based on data from mysql.stats_histograms)
 // To work with auto-analyze's needs, we need to read all stats meta info into memory.
 // The sync/async load of the stats or other process haven't done a full initialization of the table.ColAndIdxExistenceMap. So we need to it here.
-func (h *Handle) InitStats(ctx context.Context, is infoschema.InfoSchema) (err error) {
+func (h *Handle) InitStats(ctx context.Context, is infoschema.InfoSchema, tableIDs ...int64) (err error) {
 	totalMemory, err := memory.MemTotal()
 	if err != nil {
 		return err
@@ -781,37 +828,44 @@ func (h *Handle) InitStats(ctx context.Context, is infoschema.InfoSchema) (err e
 			err = err1
 		}
 	}()
+
 	_, err = util.Exec(h.initStatsCtx, "begin")
 	if err != nil {
 		return err
 	}
 	failpoint.Inject("beforeInitStats", func() {})
+
 	start := time.Now()
-	cache, err := h.initStatsMeta(ctx)
+	cache, err := h.initStatsMeta(ctx, tableIDs...)
 	if err != nil {
 		return errors.Trace(err)
 	}
 	statslogutil.StatsLogger().Info("Complete loading the stats meta", zap.Duration("duration", time.Since(start)))
 	initstats.InitStatsPercentage.Store(initStatsPercentageInterval)
+
+	concurrency := initstats.GetConcurrency()
 	start = time.Now()
-	err = h.initStatsHistogramsConcurrently(is, cache, totalMemory, initstats.GetConcurrency())
+	err = h.initStatsHistogramsConcurrently(is, cache, totalMemory, concurrency, tableIDs...)
 	if err != nil {
 		return errors.Trace(err)
 	}
 	statslogutil.StatsLogger().Info("Complete loading the histogram", zap.Duration("duration", time.Since(start)))
+
 	start = time.Now()
-	err = h.initStatsTopNConcurrently(cache, totalMemory, initstats.GetConcurrency())
+	err = h.initStatsTopNConcurrently(cache, totalMemory, concurrency, tableIDs...)
 	if err != nil {
 		return err
 	}
 	initstats.InitStatsPercentage.Store(initStatsPercentageInterval * 2)
 	statslogutil.StatsLogger().Info("Complete loading the topn", zap.Duration("duration", time.Since(start)))
+
 	start = time.Now()
-	err = h.initStatsBuckets(cache, totalMemory)
-	statslogutil.StatsLogger().Info("Complete loading the bucket", zap.Duration("duration", time.Since(start)))
+	err = h.initStatsBuckets(cache, totalMemory, tableIDs...)
 	if err != nil {
 		return errors.Trace(err)
 	}
+	statslogutil.StatsLogger().Info("Complete loading the bucket", zap.Duration("duration", time.Since(start)))
+
 	h.Replace(cache)
 	return nil
 }
diff --git a/pkg/statistics/handle/handletest/initstats/BUILD.bazel b/pkg/statistics/handle/handletest/initstats/BUILD.bazel
index 134c139b84c77..800db7a761e0b 100644
--- a/pkg/statistics/handle/handletest/initstats/BUILD.bazel
+++ b/pkg/statistics/handle/handletest/initstats/BUILD.bazel
@@ -8,7 +8,7 @@ go_test(
         "main_test.go",
     ],
     flaky = True,
-    shard_count = 6,
+    shard_count = 7,
     deps = [
         "//pkg/config",
         "//pkg/config/kerneltype",
diff --git a/pkg/statistics/handle/handletest/initstats/init_stats_test.go b/pkg/statistics/handle/handletest/initstats/init_stats_test.go
index 493b72e706e3f..2e700f97c4ab5 100644
--- a/pkg/statistics/handle/handletest/initstats/init_stats_test.go
+++ b/pkg/statistics/handle/handletest/initstats/init_stats_test.go
@@ -86,6 +86,69 @@ func TestLiteInitStatsWithTableIDs(t *testing.T) {
 	dom.Close()
 }
 
+func TestNonLiteInitStatsWithTableIDs(t *testing.T) {
+	store, dom := session.CreateStoreAndBootstrap(t)
+	defer store.Close()
+	se := session.CreateSessionAndSetID(t, store)
+	session.MustExec(t, se, "use test")
+	session.MustExec(t, se, "create table t1( id int, a int, b int, index idx(id, a));")
+	session.MustExec(t, se, "create table t2( id int, a int, b int, index idx(id, a));")
+	session.MustExec(t, se, "create table t3( id int, a int, b int, index idx(id, a));")
+	session.MustExec(t, se, "insert into t1 values (1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4), (5, 5, 5);")
+	session.MustExec(t, se, "insert into t2 values (1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4), (5, 5, 5);")
+	session.MustExec(t, se, "insert into t3 values (1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4), (5, 5, 5);")
+	session.MustExec(t, se, "analyze table t1, t2, t3 all columns with 1 topn, 10 buckets;")
+	is := dom.InfoSchema()
+	tbl1, err := is.TableByName(context.Background(), ast.NewCIStr("test"), ast.NewCIStr("t1"))
+	require.NoError(t, err)
+	tbl2, err := is.TableByName(context.Background(), ast.NewCIStr("test"), ast.NewCIStr("t2"))
+	require.NoError(t, err)
+	tbl3, err := is.TableByName(context.Background(), ast.NewCIStr("test"), ast.NewCIStr("t3"))
+	require.NoError(t, err)
+
+	dom.Close()
+
+	vardef.SetStatsLease(-1)
+	dom, err = session.BootstrapSession(store)
+	require.NoError(t, err)
+	is = dom.InfoSchema()
+	h := dom.StatsHandle()
+	_, ok := h.Get(tbl1.Meta().ID)
+	require.False(t, ok)
+	require.NoError(t, h.InitStats(context.Background(), is, tbl1.Meta().ID))
+	stats1, ok := h.Get(tbl1.Meta().ID)
+	require.True(t, ok)
+	require.True(t, stats1.GetIdx(1).IsFullLoad())
+	_, ok = h.Get(tbl2.Meta().ID)
+	require.False(t, ok)
+	_, ok = h.Get(tbl3.Meta().ID)
+	require.False(t, ok)
+
+	// Make sure it can be loaded multiple times.
+	require.NoError(t, h.InitStats(context.Background(), is, tbl1.Meta().ID, tbl2.Meta().ID))
+	stats1, ok = h.Get(tbl1.Meta().ID)
+	require.True(t, ok)
+	require.True(t, stats1.GetIdx(1).IsFullLoad())
+	stats2, ok := h.Get(tbl2.Meta().ID)
+	require.True(t, ok)
+	require.True(t, stats2.GetIdx(1).IsFullLoad())
+	_, ok = h.Get(tbl3.Meta().ID)
+	require.False(t, ok)
+
+	require.NoError(t, h.InitStats(context.Background(), is))
+	stats1, ok = h.Get(tbl1.Meta().ID)
+	require.True(t, ok)
+	require.True(t, stats1.GetIdx(1).IsFullLoad())
+	stats2, ok = h.Get(tbl2.Meta().ID)
+	require.True(t, ok)
+	require.True(t, stats2.GetIdx(1).IsFullLoad())
+	stats3, ok := h.Get(tbl3.Meta().ID)
+	require.True(t, ok)
+	require.True(t, stats3.GetIdx(1).IsFullLoad())
+
+	dom.Close()
+}
+
 func TestConcurrentlyInitStatsWithMemoryLimit(t *testing.T) {
 	restore := config.RestoreFunc()
 	defer restore()
diff --git a/pkg/statistics/handle/initstats/load_stats_page.go b/pkg/statistics/handle/initstats/load_stats_page.go
index f4e3131ddec6d..cb8bca6be6ff2 100644
--- a/pkg/statistics/handle/initstats/load_stats_page.go
+++ b/pkg/statistics/handle/initstats/load_stats_page.go
@@ -69,20 +69,15 @@ func NewRangeWorker(
 	taskName string,
 	processTask func(task Task) error,
 	concurrency int,
-	maxTid,
-	initStatsStep uint64,
+	totalTaskCnt uint64,
 	totalPercentageStep float64,
 ) *RangeWorker {
-	taskCnt := uint64(1)
-	if maxTid > initStatsStep*2 {
-		taskCnt = maxTid / initStatsStep
-	}
 	worker := &RangeWorker{
 		taskName:            taskName,
 		processTask:         processTask,
 		concurrency:         concurrency,
 		taskChan:            make(chan Task, 1),
-		taskCnt:             taskCnt,
+		taskCnt:             totalTaskCnt,
 		totalPercentage:     InitStatsPercentage.Load(),
 		totalPercentageStep: totalPercentageStep,
 	}

From 9fea2b7ff199c229aa6443fdb5a69d9a5f11c661 Mon Sep 17 00:00:00 2001
From: 0xPoe <techregister@pm.me>
Date: Fri, 19 Sep 2025 10:08:55 +0200
Subject: [PATCH 02/14] fix: better API name

---
 pkg/statistics/handle/bootstrap.go | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/pkg/statistics/handle/bootstrap.go b/pkg/statistics/handle/bootstrap.go
index 374cd22a6819f..56e439e69f0a7 100644
--- a/pkg/statistics/handle/bootstrap.go
+++ b/pkg/statistics/handle/bootstrap.go
@@ -433,7 +433,7 @@ func (h *Handle) initStatsHistogramsByPaging(is infoschema.InfoSchema, cache sta
 
 type loadStrategy interface {
 	calcuateTotalTaskCnt() uint64
-	generateTasks(worker *initstats.RangeWorker)
+	generateAndSendTasks(worker *initstats.RangeWorker)
 }
 
 type maxTidStrategy struct {
@@ -455,7 +455,7 @@ func (maxTidStrategy) calcuateTotalTaskCnt() uint64 {
 	return uint64(totalTaskCnt)
 }
 
-func (m maxTidStrategy) generateTasks(worker *initstats.RangeWorker) {
+func (m maxTidStrategy) generateAndSendTasks(worker *initstats.RangeWorker) {
 	tid := int64(0)
 	for tid <= m.maxTid {
 		worker.SendTask(initstats.Task{
@@ -480,7 +480,7 @@ func (t tableListStrategy) calcuateTotalTaskCnt() uint64 {
 	return uint64(len(t.tableIDs))
 }
 
-func (t tableListStrategy) generateTasks(worker *initstats.RangeWorker) {
+func (t tableListStrategy) generateAndSendTasks(worker *initstats.RangeWorker) {
 	for _, tableID := range t.tableIDs {
 		worker.SendTask(initstats.Task{
 			StartTid: tableID,
@@ -507,7 +507,7 @@ func (h *Handle) initStatsHistogramsConcurrently(is infoschema.InfoSchema, cache
 		initStatsPercentageInterval,
 	)
 	ls.LoadStats()
-	s.generateTasks(ls)
+	s.generateAndSendTasks(ls)
 	ls.Wait()
 	return nil
 }
@@ -624,7 +624,7 @@ func (h *Handle) initStatsTopNConcurrently(cache statstypes.StatsCache, totalMem
 		initStatsPercentageInterval,
 	)
 	ls.LoadStats()
-	s.generateTasks(ls)
+	s.generateAndSendTasks(ls)
 	ls.Wait()
 	return nil
 }
@@ -759,7 +759,7 @@ func (h *Handle) initStatsBucketsConcurrently(cache statstypes.StatsCache, total
 		initStatsPercentageInterval,
 	)
 	ls.LoadStats()
-	s.generateTasks(ls)
+	s.generateAndSendTasks(ls)
 	ls.Wait()
 	return nil
 }

From 95bc464fc63b4c183e0201ad3e39389f4fb84a88 Mon Sep 17 00:00:00 2001
From: 0xPoe <techregister@pm.me>
Date: Fri, 19 Sep 2025 10:12:49 +0200
Subject: [PATCH 03/14] fix: update the cache correctly

---
 pkg/statistics/handle/bootstrap.go | 14 +++++++++++++-
 1 file changed, 13 insertions(+), 1 deletion(-)

diff --git a/pkg/statistics/handle/bootstrap.go b/pkg/statistics/handle/bootstrap.go
index 56e439e69f0a7..7fe0a0e4952c3 100644
--- a/pkg/statistics/handle/bootstrap.go
+++ b/pkg/statistics/handle/bootstrap.go
@@ -866,7 +866,19 @@ func (h *Handle) InitStats(ctx context.Context, is infoschema.InfoSchema, tableI
 	}
 	statslogutil.StatsLogger().Info("Complete loading the bucket", zap.Duration("duration", time.Since(start)))
 
-	h.Replace(cache)
+	// If tableIDs is empty, it means we load all the tables' stats meta and histograms.
+	// So we can replace the global cache with the new cache.
+	if len(tableIDs) == 0 {
+		h.Replace(cache)
+	} else {
+		tables := cache.Values()
+		for _, table := range tables {
+			intest.Assert(table != nil, "table should not be nil")
+			h.Put(table.PhysicalID, table)
+		}
+		// Do not forget to close the new cache. Otherwise it would cause the goroutine leak issue.
+		cache.Close()
+	}
 	return nil
 }
 

From 56058466c6028a6bccf3062365eb63766c258df6 Mon Sep 17 00:00:00 2001
From: 0xPoe <techregister@pm.me>
Date: Fri, 19 Sep 2025 10:17:10 +0200
Subject: [PATCH 04/14] fix: refine comments

---
 pkg/statistics/handle/bootstrap.go | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/pkg/statistics/handle/bootstrap.go b/pkg/statistics/handle/bootstrap.go
index 7fe0a0e4952c3..2920760dfdb90 100644
--- a/pkg/statistics/handle/bootstrap.go
+++ b/pkg/statistics/handle/bootstrap.go
@@ -866,7 +866,7 @@ func (h *Handle) InitStats(ctx context.Context, is infoschema.InfoSchema, tableI
 	}
 	statslogutil.StatsLogger().Info("Complete loading the bucket", zap.Duration("duration", time.Since(start)))
 
-	// If tableIDs is empty, it means we load all the tables' stats meta and histograms.
+	// If tableIDs is empty, it means we load all the tables' stats.
 	// So we can replace the global cache with the new cache.
 	if len(tableIDs) == 0 {
 		h.Replace(cache)

From 47f118585953edb54e63056ebbb82378035a4c82 Mon Sep 17 00:00:00 2001
From: 0xPoe <techregister@pm.me>
Date: Fri, 19 Sep 2025 10:55:55 +0200
Subject: [PATCH 05/14] refactor: pass the concrrency

---
 pkg/statistics/handle/bootstrap.go | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/pkg/statistics/handle/bootstrap.go b/pkg/statistics/handle/bootstrap.go
index 2920760dfdb90..2c6727ff5d084 100644
--- a/pkg/statistics/handle/bootstrap.go
+++ b/pkg/statistics/handle/bootstrap.go
@@ -682,11 +682,11 @@ func genInitStatsBucketsSQLForIndexes(isPaging bool) string {
 	return selectPrefix + " and table_id >= %? and table_id < %?" + orderSuffix
 }
 
-func (h *Handle) initStatsBuckets(cache statstypes.StatsCache, totalMemory uint64, tableIDs ...int64) error {
+func (h *Handle) initStatsBucketsAndCalcPreScalar(cache statstypes.StatsCache, totalMemory uint64, concurrency int, tableIDs ...int64) error {
 	if IsFullCacheFunc(cache, totalMemory) {
 		return nil
 	}
-	err := h.initStatsBucketsConcurrently(cache, totalMemory, initstats.GetConcurrency(), tableIDs...)
+	err := h.initStatsBucketsConcurrently(cache, totalMemory, concurrency, tableIDs...)
 	if err != nil {
 		return errors.Trace(err)
 	}
@@ -860,7 +860,7 @@ func (h *Handle) InitStats(ctx context.Context, is infoschema.InfoSchema, tableI
 	statslogutil.StatsLogger().Info("Complete loading the topn", zap.Duration("duration", time.Since(start)))
 
 	start = time.Now()
-	err = h.initStatsBuckets(cache, totalMemory, tableIDs...)
+	err = h.initStatsBucketsAndCalcPreScalar(cache, totalMemory, concurrency, tableIDs...)
 	if err != nil {
 		return errors.Trace(err)
 	}

From d2be6ed1d667010c3f7c0d91db726120d32e3e16 Mon Sep 17 00:00:00 2001
From: 0xPoe <techregister@pm.me>
Date: Fri, 19 Sep 2025 11:13:18 +0200
Subject: [PATCH 06/14] refactor: better gen topN function

---
 pkg/statistics/handle/bootstrap.go | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/pkg/statistics/handle/bootstrap.go b/pkg/statistics/handle/bootstrap.go
index 2c6727ff5d084..d7ff813e14674 100644
--- a/pkg/statistics/handle/bootstrap.go
+++ b/pkg/statistics/handle/bootstrap.go
@@ -555,13 +555,15 @@ func (*Handle) initStatsTopN4Chunk(cache statstypes.StatsCache, iter *chunk.Iter
 // genInitStatsTopNSQLForIndexes generates the SQL to load all stats_top_n records for indexes.
 // We only need to load the indexes' since we only record the existence of columns in ColAndIdxExistenceMap.
 // The stats of the column is not loaded during the bootstrap process.
-func genInitStatsTopNSQLForIndexes(isPaging bool) string {
+func genInitStatsTopNSQLForIndexes(isPaging bool, tableRange [2]int64) string {
 	selectPrefix := "select /*+ ORDER_INDEX(mysql.stats_top_n,tbl) */ HIGH_PRIORITY table_id, hist_id, value, count from mysql.stats_top_n where is_index = 1"
 	orderSuffix := " order by table_id"
 	if !isPaging {
 		return selectPrefix + orderSuffix
 	}
-	return selectPrefix + " and table_id >= %? and table_id < %?" + orderSuffix
+	rangeStartClause := " where table_id >= " + strconv.FormatInt(tableRange[0], 10)
+	rangeEndClause := " and table_id < " + strconv.FormatInt(tableRange[1], 10)
+	return selectPrefix + rangeStartClause + rangeEndClause + orderSuffix
 }
 
 func (h *Handle) initStatsTopNByPaging(cache statstypes.StatsCache, task initstats.Task, totalMemory uint64) error {
@@ -578,8 +580,8 @@ func (h *Handle) initStatsTopNByPaging(cache statstypes.StatsCache, task initsta
 		}
 	}()
 	sctx := se.(sessionctx.Context)
-	sql := genInitStatsTopNSQLForIndexes(true)
-	rc, err := util.Exec(sctx, sql, task.StartTid, task.EndTid)
+	sql := genInitStatsTopNSQLForIndexes(true, [2]int64{task.StartTid, task.EndTid})
+	rc, err := util.Exec(sctx, sql)
 	if err != nil {
 		return errors.Trace(err)
 	}

From b4fa16e1657d42ade4f771f8dd78859afb67ddd4 Mon Sep 17 00:00:00 2001
From: 0xPoe <techregister@pm.me>
Date: Fri, 19 Sep 2025 11:20:43 +0200
Subject: [PATCH 07/14] fix: correct the SQL statement

---
 pkg/statistics/handle/bootstrap.go | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/pkg/statistics/handle/bootstrap.go b/pkg/statistics/handle/bootstrap.go
index d7ff813e14674..17a4a6071f223 100644
--- a/pkg/statistics/handle/bootstrap.go
+++ b/pkg/statistics/handle/bootstrap.go
@@ -561,7 +561,7 @@ func genInitStatsTopNSQLForIndexes(isPaging bool, tableRange [2]int64) string {
 	if !isPaging {
 		return selectPrefix + orderSuffix
 	}
-	rangeStartClause := " where table_id >= " + strconv.FormatInt(tableRange[0], 10)
+	rangeStartClause := " and table_id >= " + strconv.FormatInt(tableRange[0], 10)
 	rangeEndClause := " and table_id < " + strconv.FormatInt(tableRange[1], 10)
 	return selectPrefix + rangeStartClause + rangeEndClause + orderSuffix
 }
@@ -675,13 +675,15 @@ func (*Handle) initStatsBuckets4Chunk(cache statstypes.StatsCache, iter *chunk.I
 // genInitStatsBucketsSQLForIndexes generates the SQL to load all stats_buckets records for indexes.
 // We only need to load the indexes' since we only record the existence of columns in ColAndIdxExistenceMap.
 // The stats of the column is not loaded during the bootstrap process.
-func genInitStatsBucketsSQLForIndexes(isPaging bool) string {
+func genInitStatsBucketsSQLForIndexes(isPaging bool, tableRange [2]int64) string {
 	selectPrefix := "select /*+ ORDER_INDEX(mysql.stats_buckets,tbl) */ HIGH_PRIORITY table_id, hist_id, count, repeats, lower_bound, upper_bound, ndv from mysql.stats_buckets where is_index=1"
 	orderSuffix := " order by table_id"
 	if !isPaging {
 		return selectPrefix + orderSuffix
 	}
-	return selectPrefix + " and table_id >= %? and table_id < %?" + orderSuffix
+	rangeStartClause := " and table_id >= " + strconv.FormatInt(tableRange[0], 10)
+	rangeEndClause := " and table_id < " + strconv.FormatInt(tableRange[1], 10)
+	return selectPrefix + rangeStartClause + rangeEndClause + orderSuffix
 }
 
 func (h *Handle) initStatsBucketsAndCalcPreScalar(cache statstypes.StatsCache, totalMemory uint64, concurrency int, tableIDs ...int64) error {
@@ -715,8 +717,8 @@ func (h *Handle) initStatsBucketsByPaging(cache statstypes.StatsCache, task init
 		}
 	}()
 	sctx := se.(sessionctx.Context)
-	sql := genInitStatsBucketsSQLForIndexes(true)
-	rc, err := util.Exec(sctx, sql, task.StartTid, task.EndTid)
+	sql := genInitStatsBucketsSQLForIndexes(true, [2]int64{task.StartTid, task.EndTid})
+	rc, err := util.Exec(sctx, sql)
 	if err != nil {
 		return errors.Trace(err)
 	}

From 4ed034d5a1b431fc899e312e5f9b44ae1172bc3a Mon Sep 17 00:00:00 2001
From: 0xPoe <techregister@pm.me>
Date: Mon, 22 Sep 2025 09:50:05 +0200
Subject: [PATCH 08/14] fix: typos

---
 pkg/statistics/handle/bootstrap.go | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/pkg/statistics/handle/bootstrap.go b/pkg/statistics/handle/bootstrap.go
index 17a4a6071f223..f691fc56d4a45 100644
--- a/pkg/statistics/handle/bootstrap.go
+++ b/pkg/statistics/handle/bootstrap.go
@@ -432,7 +432,7 @@ func (h *Handle) initStatsHistogramsByPaging(is infoschema.InfoSchema, cache sta
 }
 
 type loadStrategy interface {
-	calcuateTotalTaskCnt() uint64
+	calculateTotalTaskCnt() uint64
 	generateAndSendTasks(worker *initstats.RangeWorker)
 }
 
@@ -446,7 +446,7 @@ func newMaxTidStrategy() maxTidStrategy {
 	}
 }
 
-func (maxTidStrategy) calcuateTotalTaskCnt() uint64 {
+func (maxTidStrategy) calculateTotalTaskCnt() uint64 {
 	maxTid := maxTidRecord.tid.Load()
 	totalTaskCnt := int64(1)
 	if maxTid > initStatsStep*2 {
@@ -476,7 +476,7 @@ func newTableListStrategy(tableIDs []int64) tableListStrategy {
 	}
 }
 
-func (t tableListStrategy) calcuateTotalTaskCnt() uint64 {
+func (t tableListStrategy) calculateTotalTaskCnt() uint64 {
 	return uint64(len(t.tableIDs))
 }
 
@@ -496,7 +496,7 @@ func (h *Handle) initStatsHistogramsConcurrently(is infoschema.InfoSchema, cache
 	} else {
 		s = newTableListStrategy(tableIDs)
 	}
-	totalTaskCnt := s.calcuateTotalTaskCnt()
+	totalTaskCnt := s.calculateTotalTaskCnt()
 	ls := initstats.NewRangeWorker(
 		"histogram",
 		func(task initstats.Task) error {
@@ -612,7 +612,7 @@ func (h *Handle) initStatsTopNConcurrently(cache statstypes.StatsCache, totalMem
 	} else {
 		s = newTableListStrategy(tableIDs)
 	}
-	totalTaskCnt := s.calcuateTotalTaskCnt()
+	totalTaskCnt := s.calculateTotalTaskCnt()
 	ls := initstats.NewRangeWorker(
 		"TopN",
 		func(task initstats.Task) error {
@@ -749,7 +749,7 @@ func (h *Handle) initStatsBucketsConcurrently(cache statstypes.StatsCache, total
 	} else {
 		s = newTableListStrategy(tableIDs)
 	}
-	totalTaskCnt := s.calcuateTotalTaskCnt()
+	totalTaskCnt := s.calculateTotalTaskCnt()
 	ls := initstats.NewRangeWorker(
 		"bucket",
 		func(task initstats.Task) error {

From 4423e85b8d8131f8d783ab6a54503e2f93d67b71 Mon Sep 17 00:00:00 2001
From: 0xPoe <techregister@pm.me>
Date: Mon, 22 Sep 2025 09:54:59 +0200
Subject: [PATCH 09/14] fix: use the stored value

---
 pkg/statistics/handle/bootstrap.go | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/pkg/statistics/handle/bootstrap.go b/pkg/statistics/handle/bootstrap.go
index f691fc56d4a45..e8eaa48d04cac 100644
--- a/pkg/statistics/handle/bootstrap.go
+++ b/pkg/statistics/handle/bootstrap.go
@@ -446,8 +446,8 @@ func newMaxTidStrategy() maxTidStrategy {
 	}
 }
 
-func (maxTidStrategy) calculateTotalTaskCnt() uint64 {
-	maxTid := maxTidRecord.tid.Load()
+func (m maxTidStrategy) calculateTotalTaskCnt() uint64 {
+	maxTid := m.maxTid
 	totalTaskCnt := int64(1)
 	if maxTid > initStatsStep*2 {
 		totalTaskCnt = maxTid / initStatsStep

From 872593ca1d4f4ae331946dcc833f6bb9e9c439f1 Mon Sep 17 00:00:00 2001
From: 0xPoe <techregister@pm.me>
Date: Mon, 22 Sep 2025 09:56:14 +0200
Subject: [PATCH 10/14] fix: add assert

---
 pkg/statistics/handle/bootstrap.go | 1 +
 1 file changed, 1 insertion(+)

diff --git a/pkg/statistics/handle/bootstrap.go b/pkg/statistics/handle/bootstrap.go
index e8eaa48d04cac..56d0512395a29 100644
--- a/pkg/statistics/handle/bootstrap.go
+++ b/pkg/statistics/handle/bootstrap.go
@@ -448,6 +448,7 @@ func newMaxTidStrategy() maxTidStrategy {
 
 func (m maxTidStrategy) calculateTotalTaskCnt() uint64 {
 	maxTid := m.maxTid
+	intest.Assert(maxTid == maxTidRecord.tid.Load(), "maxTid should be equal to the recorded maxTid")
 	totalTaskCnt := int64(1)
 	if maxTid > initStatsStep*2 {
 		totalTaskCnt = maxTid / initStatsStep

From d58cdd89e03eb655f03e6c9666b83a078422aa24 Mon Sep 17 00:00:00 2001
From: 0xPoe <techregister@pm.me>
Date: Mon, 22 Sep 2025 10:01:26 +0200
Subject: [PATCH 11/14] fix: add more asserts

---
 pkg/statistics/handle/bootstrap.go | 1 +
 1 file changed, 1 insertion(+)

diff --git a/pkg/statistics/handle/bootstrap.go b/pkg/statistics/handle/bootstrap.go
index 56d0512395a29..b1343766254b1 100644
--- a/pkg/statistics/handle/bootstrap.go
+++ b/pkg/statistics/handle/bootstrap.go
@@ -448,6 +448,7 @@ func newMaxTidStrategy() maxTidStrategy {
 
 func (m maxTidStrategy) calculateTotalTaskCnt() uint64 {
 	maxTid := m.maxTid
+	intest.Assert(maxTid >= 0, "maxTid should be non-negative")
 	intest.Assert(maxTid == maxTidRecord.tid.Load(), "maxTid should be equal to the recorded maxTid")
 	totalTaskCnt := int64(1)
 	if maxTid > initStatsStep*2 {

From b670fb095f32b24634be43bb31bd0808ef0e1176 Mon Sep 17 00:00:00 2001
From: 0xPoe <techregister@pm.me>
Date: Mon, 22 Sep 2025 10:03:59 +0200
Subject: [PATCH 12/14] docs: add comments

---
 pkg/statistics/handle/bootstrap.go | 1 +
 1 file changed, 1 insertion(+)

diff --git a/pkg/statistics/handle/bootstrap.go b/pkg/statistics/handle/bootstrap.go
index b1343766254b1..e92b5b162d7d7 100644
--- a/pkg/statistics/handle/bootstrap.go
+++ b/pkg/statistics/handle/bootstrap.go
@@ -823,6 +823,7 @@ func (h *Handle) InitStatsLite(ctx context.Context, tableIDs ...int64) (err erro
 // 2. Column stats are marked as existing or not by initializing the table.ColAndIdxExistenceMap, based on data from mysql.stats_histograms)
 // To work with auto-analyze's needs, we need to read all stats meta info into memory.
 // The sync/async load of the stats or other process haven't done a full initialization of the table.ColAndIdxExistenceMap. So we need to it here.
+// If tableIDs is provided, we only load the stats for the specified tables.
 func (h *Handle) InitStats(ctx context.Context, is infoschema.InfoSchema, tableIDs ...int64) (err error) {
 	totalMemory, err := memory.MemTotal()
 	if err != nil {

From 3234026489f3a8648126b170091e3b3e2065d628 Mon Sep 17 00:00:00 2001
From: 0xPoe <techregister@pm.me>
Date: Mon, 22 Sep 2025 14:05:15 +0200
Subject: [PATCH 13/14] fix: add more asserts

---
 pkg/statistics/handle/bootstrap.go | 1 +
 1 file changed, 1 insertion(+)

diff --git a/pkg/statistics/handle/bootstrap.go b/pkg/statistics/handle/bootstrap.go
index e92b5b162d7d7..fdf9693aeeb4f 100644
--- a/pkg/statistics/handle/bootstrap.go
+++ b/pkg/statistics/handle/bootstrap.go
@@ -479,6 +479,7 @@ func newTableListStrategy(tableIDs []int64) tableListStrategy {
 }
 
 func (t tableListStrategy) calculateTotalTaskCnt() uint64 {
+	intest.Assert(len(t.tableIDs) > 0, "tableIDs should not be empty")
 	return uint64(len(t.tableIDs))
 }
 

From a40917f42c1792ab6bf9fa78d1e7609af4594aa0 Mon Sep 17 00:00:00 2001
From: 0xPoe <techregister@pm.me>
Date: Mon, 22 Sep 2025 14:09:07 +0200
Subject: [PATCH 14/14] fix: add more assestions

---
 pkg/statistics/handle/bootstrap.go | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/pkg/statistics/handle/bootstrap.go b/pkg/statistics/handle/bootstrap.go
index fdf9693aeeb4f..d9bd2754013ba 100644
--- a/pkg/statistics/handle/bootstrap.go
+++ b/pkg/statistics/handle/bootstrap.go
@@ -564,6 +564,7 @@ func genInitStatsTopNSQLForIndexes(isPaging bool, tableRange [2]int64) string {
 	if !isPaging {
 		return selectPrefix + orderSuffix
 	}
+	intest.Assert(tableRange[0] < tableRange[1], "invalid table range")
 	rangeStartClause := " and table_id >= " + strconv.FormatInt(tableRange[0], 10)
 	rangeEndClause := " and table_id < " + strconv.FormatInt(tableRange[1], 10)
 	return selectPrefix + rangeStartClause + rangeEndClause + orderSuffix
@@ -684,6 +685,7 @@ func genInitStatsBucketsSQLForIndexes(isPaging bool, tableRange [2]int64) string
 	if !isPaging {
 		return selectPrefix + orderSuffix
 	}
+	intest.Assert(tableRange[0] < tableRange[1], "invalid table range")
 	rangeStartClause := " and table_id >= " + strconv.FormatInt(tableRange[0], 10)
 	rangeEndClause := " and table_id < " + strconv.FormatInt(tableRange[1], 10)
 	return selectPrefix + rangeStartClause + rangeEndClause + orderSuffix
