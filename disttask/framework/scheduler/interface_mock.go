// Code generated by MockGen. DO NOT EDIT.
// Source: disttask/framework/scheduler/interface.go

// Package scheduler is a generated GoMock package.
package scheduler

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	proto "github.com/pingcap/tidb/disttask/framework/proto"
)

// MockTaskTable is a mock of TaskTable interface.
type MockTaskTable struct {
	ctrl     *gomock.Controller
	recorder *MockTaskTableMockRecorder
}

// MockTaskTableMockRecorder is the mock recorder for MockTaskTable.
type MockTaskTableMockRecorder struct {
	mock *MockTaskTable
}

// NewMockTaskTable creates a new mock instance.
func NewMockTaskTable(ctrl *gomock.Controller) *MockTaskTable {
	mock := &MockTaskTable{ctrl: ctrl}
	mock.recorder = &MockTaskTableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTaskTable) EXPECT() *MockTaskTableMockRecorder {
	return m.recorder
}

// FinishSubtask mocks base method.
func (m *MockTaskTable) FinishSubtask(id int64, meta []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FinishSubtask", id, meta)
	ret0, _ := ret[0].(error)
	return ret0
}

// FinishSubtask indicates an expected call of FinishSubtask.
func (mr *MockTaskTableMockRecorder) FinishSubtask(id, meta interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FinishSubtask", reflect.TypeOf((*MockTaskTable)(nil).FinishSubtask), id, meta)
}

// GetGlobalTaskByID mocks base method.
func (m *MockTaskTable) GetGlobalTaskByID(taskID int64) (*proto.Task, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetGlobalTaskByID", taskID)
	ret0, _ := ret[0].(*proto.Task)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetGlobalTaskByID indicates an expected call of GetGlobalTaskByID.
func (mr *MockTaskTableMockRecorder) GetGlobalTaskByID(taskID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetGlobalTaskByID", reflect.TypeOf((*MockTaskTable)(nil).GetGlobalTaskByID), taskID)
}

// GetGlobalTasksInStates mocks base method.
func (m *MockTaskTable) GetGlobalTasksInStates(states ...interface{}) ([]*proto.Task, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range states {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetGlobalTasksInStates", varargs...)
	ret0, _ := ret[0].([]*proto.Task)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetGlobalTasksInStates indicates an expected call of GetGlobalTasksInStates.
func (mr *MockTaskTableMockRecorder) GetGlobalTasksInStates(states ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetGlobalTasksInStates", reflect.TypeOf((*MockTaskTable)(nil).GetGlobalTasksInStates), states...)
}

// GetSubtaskInStates mocks base method.
func (m *MockTaskTable) GetSubtaskInStates(instanceID string, taskID int64, states ...interface{}) (*proto.Subtask, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{instanceID, taskID}
	for _, a := range states {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetSubtaskInStates", varargs...)
	ret0, _ := ret[0].(*proto.Subtask)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSubtaskInStates indicates an expected call of GetSubtaskInStates.
func (mr *MockTaskTableMockRecorder) GetSubtaskInStates(instanceID, taskID interface{}, states ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{instanceID, taskID}, states...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubtaskInStates", reflect.TypeOf((*MockTaskTable)(nil).GetSubtaskInStates), varargs...)
}

// HasSubtasksInStates mocks base method.
func (m *MockTaskTable) HasSubtasksInStates(instanceID string, taskID int64, states ...interface{}) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{instanceID, taskID}
	for _, a := range states {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HasSubtasksInStates", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HasSubtasksInStates indicates an expected call of HasSubtasksInStates.
func (mr *MockTaskTableMockRecorder) HasSubtasksInStates(instanceID, taskID interface{}, states ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{instanceID, taskID}, states...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSubtasksInStates", reflect.TypeOf((*MockTaskTable)(nil).HasSubtasksInStates), varargs...)
}

// UpdateErrorToSubtask mocks base method.
func (m *MockTaskTable) UpdateErrorToSubtask(tidbID string, err error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateErrorToSubtask", tidbID, err)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateErrorToSubtask indicates an expected call of UpdateErrorToSubtask.
func (mr *MockTaskTableMockRecorder) UpdateErrorToSubtask(tidbID, err interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateErrorToSubtask", reflect.TypeOf((*MockTaskTable)(nil).UpdateErrorToSubtask), tidbID, err)
}

// UpdateSubtaskStateAndError mocks base method.
func (m *MockTaskTable) UpdateSubtaskStateAndError(id int64, state string, err error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateSubtaskStateAndError", id, state, err)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateSubtaskStateAndError indicates an expected call of UpdateSubtaskStateAndError.
func (mr *MockTaskTableMockRecorder) UpdateSubtaskStateAndError(id, state, err interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateSubtaskStateAndError", reflect.TypeOf((*MockTaskTable)(nil).UpdateSubtaskStateAndError), id, state, err)
}

// MockPool is a mock of Pool interface.
type MockPool struct {
	ctrl     *gomock.Controller
	recorder *MockPoolMockRecorder
}

// MockPoolMockRecorder is the mock recorder for MockPool.
type MockPoolMockRecorder struct {
	mock *MockPool
}

// NewMockPool creates a new mock instance.
func NewMockPool(ctrl *gomock.Controller) *MockPool {
	mock := &MockPool{ctrl: ctrl}
	mock.recorder = &MockPoolMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPool) EXPECT() *MockPoolMockRecorder {
	return m.recorder
}

// ReleaseAndWait mocks base method.
func (m *MockPool) ReleaseAndWait() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReleaseAndWait")
}

// ReleaseAndWait indicates an expected call of ReleaseAndWait.
func (mr *MockPoolMockRecorder) ReleaseAndWait() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReleaseAndWait", reflect.TypeOf((*MockPool)(nil).ReleaseAndWait))
}

// Run mocks base method.
func (m *MockPool) Run(arg0 func()) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockPoolMockRecorder) Run(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockPool)(nil).Run), arg0)
}

// RunWithConcurrency mocks base method.
func (m *MockPool) RunWithConcurrency(arg0 chan func(), arg1 uint32) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunWithConcurrency", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// RunWithConcurrency indicates an expected call of RunWithConcurrency.
func (mr *MockPoolMockRecorder) RunWithConcurrency(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunWithConcurrency", reflect.TypeOf((*MockPool)(nil).RunWithConcurrency), arg0, arg1)
}

// MockInternalScheduler is a mock of InternalScheduler interface.
type MockInternalScheduler struct {
	ctrl     *gomock.Controller
	recorder *MockInternalSchedulerMockRecorder
}

// MockInternalSchedulerMockRecorder is the mock recorder for MockInternalScheduler.
type MockInternalSchedulerMockRecorder struct {
	mock *MockInternalScheduler
}

// NewMockInternalScheduler creates a new mock instance.
func NewMockInternalScheduler(ctrl *gomock.Controller) *MockInternalScheduler {
	mock := &MockInternalScheduler{ctrl: ctrl}
	mock.recorder = &MockInternalSchedulerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInternalScheduler) EXPECT() *MockInternalSchedulerMockRecorder {
	return m.recorder
}

// Rollback mocks base method.
func (m *MockInternalScheduler) Rollback(arg0 context.Context, arg1 *proto.Task) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockInternalSchedulerMockRecorder) Rollback(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockInternalScheduler)(nil).Rollback), arg0, arg1)
}

// Run mocks base method.
func (m *MockInternalScheduler) Run(arg0 context.Context, arg1 *proto.Task) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockInternalSchedulerMockRecorder) Run(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockInternalScheduler)(nil).Run), arg0, arg1)
}

// Start mocks base method.
func (m *MockInternalScheduler) Start() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Start")
}

// Start indicates an expected call of Start.
func (mr *MockInternalSchedulerMockRecorder) Start() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockInternalScheduler)(nil).Start))
}

// Stop mocks base method.
func (m *MockInternalScheduler) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop.
func (mr *MockInternalSchedulerMockRecorder) Stop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockInternalScheduler)(nil).Stop))
}

// MockScheduler is a mock of Scheduler interface.
type MockScheduler struct {
	ctrl     *gomock.Controller
	recorder *MockSchedulerMockRecorder
}

// MockSchedulerMockRecorder is the mock recorder for MockScheduler.
type MockSchedulerMockRecorder struct {
	mock *MockScheduler
}

// NewMockScheduler creates a new mock instance.
func NewMockScheduler(ctrl *gomock.Controller) *MockScheduler {
	mock := &MockScheduler{ctrl: ctrl}
	mock.recorder = &MockSchedulerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockScheduler) EXPECT() *MockSchedulerMockRecorder {
	return m.recorder
}

// CleanupSubtaskExecEnv mocks base method.
func (m *MockScheduler) CleanupSubtaskExecEnv(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CleanupSubtaskExecEnv", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// CleanupSubtaskExecEnv indicates an expected call of CleanupSubtaskExecEnv.
func (mr *MockSchedulerMockRecorder) CleanupSubtaskExecEnv(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CleanupSubtaskExecEnv", reflect.TypeOf((*MockScheduler)(nil).CleanupSubtaskExecEnv), arg0)
}

// InitSubtaskExecEnv mocks base method.
func (m *MockScheduler) InitSubtaskExecEnv(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InitSubtaskExecEnv", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// InitSubtaskExecEnv indicates an expected call of InitSubtaskExecEnv.
func (mr *MockSchedulerMockRecorder) InitSubtaskExecEnv(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InitSubtaskExecEnv", reflect.TypeOf((*MockScheduler)(nil).InitSubtaskExecEnv), arg0)
}

// OnSubtaskFinished mocks base method.
func (m *MockScheduler) OnSubtaskFinished(ctx context.Context, subtask []byte) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnSubtaskFinished", ctx, subtask)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OnSubtaskFinished indicates an expected call of OnSubtaskFinished.
func (mr *MockSchedulerMockRecorder) OnSubtaskFinished(ctx, subtask interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnSubtaskFinished", reflect.TypeOf((*MockScheduler)(nil).OnSubtaskFinished), ctx, subtask)
}

// Rollback mocks base method.
func (m *MockScheduler) Rollback(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockSchedulerMockRecorder) Rollback(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockScheduler)(nil).Rollback), arg0)
}

// SplitSubtask mocks base method.
func (m *MockScheduler) SplitSubtask(ctx context.Context, subtask []byte) ([]proto.MinimalTask, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SplitSubtask", ctx, subtask)
	ret0, _ := ret[0].([]proto.MinimalTask)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SplitSubtask indicates an expected call of SplitSubtask.
func (mr *MockSchedulerMockRecorder) SplitSubtask(ctx, subtask interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SplitSubtask", reflect.TypeOf((*MockScheduler)(nil).SplitSubtask), ctx, subtask)
}

// MockSubtaskExecutor is a mock of SubtaskExecutor interface.
type MockSubtaskExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockSubtaskExecutorMockRecorder
}

// MockSubtaskExecutorMockRecorder is the mock recorder for MockSubtaskExecutor.
type MockSubtaskExecutorMockRecorder struct {
	mock *MockSubtaskExecutor
}

// NewMockSubtaskExecutor creates a new mock instance.
func NewMockSubtaskExecutor(ctrl *gomock.Controller) *MockSubtaskExecutor {
	mock := &MockSubtaskExecutor{ctrl: ctrl}
	mock.recorder = &MockSubtaskExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSubtaskExecutor) EXPECT() *MockSubtaskExecutorMockRecorder {
	return m.recorder
}

// Run mocks base method.
func (m *MockSubtaskExecutor) Run(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockSubtaskExecutorMockRecorder) Run(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockSubtaskExecutor)(nil).Run), ctx)
}
