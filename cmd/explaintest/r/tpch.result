CREATE DATABASE IF NOT EXISTS TPCH;
USE TPCH;
CREATE TABLE IF NOT EXISTS nation  ( N_NATIONKEY  INTEGER NOT NULL,
N_NAME       CHAR(25) NOT NULL,
N_REGIONKEY  INTEGER NOT NULL,
N_COMMENT    VARCHAR(152),
PRIMARY KEY (N_NATIONKEY));
CREATE TABLE IF NOT EXISTS region  ( R_REGIONKEY  INTEGER NOT NULL,
R_NAME       CHAR(25) NOT NULL,
R_COMMENT    VARCHAR(152),
PRIMARY KEY (R_REGIONKEY));
CREATE TABLE IF NOT EXISTS part  ( P_PARTKEY     INTEGER NOT NULL,
P_NAME        VARCHAR(55) NOT NULL,
P_MFGR        CHAR(25) NOT NULL,
P_BRAND       CHAR(10) NOT NULL,
P_TYPE        VARCHAR(25) NOT NULL,
P_SIZE        INTEGER NOT NULL,
P_CONTAINER   CHAR(10) NOT NULL,
P_RETAILPRICE DECIMAL(15,2) NOT NULL,
P_COMMENT     VARCHAR(23) NOT NULL,
PRIMARY KEY (P_PARTKEY));
CREATE TABLE IF NOT EXISTS supplier  ( S_SUPPKEY     INTEGER NOT NULL,
S_NAME        CHAR(25) NOT NULL,
S_ADDRESS     VARCHAR(40) NOT NULL,
S_NATIONKEY   INTEGER NOT NULL,
S_PHONE       CHAR(15) NOT NULL,
S_ACCTBAL     DECIMAL(15,2) NOT NULL,
S_COMMENT     VARCHAR(101) NOT NULL,
PRIMARY KEY (S_SUPPKEY),
CONSTRAINT FOREIGN KEY SUPPLIER_FK1 (S_NATIONKEY) references nation(N_NATIONKEY));
CREATE TABLE IF NOT EXISTS partsupp ( PS_PARTKEY     INTEGER NOT NULL,
PS_SUPPKEY     INTEGER NOT NULL,
PS_AVAILQTY    INTEGER NOT NULL,
PS_SUPPLYCOST  DECIMAL(15,2)  NOT NULL,
PS_COMMENT     VARCHAR(199) NOT NULL,
PRIMARY KEY (PS_PARTKEY,PS_SUPPKEY),
CONSTRAINT FOREIGN KEY PARTSUPP_FK1 (PS_SUPPKEY) references supplier(S_SUPPKEY),
CONSTRAINT FOREIGN KEY PARTSUPP_FK2 (PS_PARTKEY) references part(P_PARTKEY));
CREATE TABLE IF NOT EXISTS customer  ( C_CUSTKEY     INTEGER NOT NULL,
C_NAME        VARCHAR(25) NOT NULL,
C_ADDRESS     VARCHAR(40) NOT NULL,
C_NATIONKEY   INTEGER NOT NULL,
C_PHONE       CHAR(15) NOT NULL,
C_ACCTBAL     DECIMAL(15,2)   NOT NULL,
C_MKTSEGMENT  CHAR(10) NOT NULL,
C_COMMENT     VARCHAR(117) NOT NULL,
PRIMARY KEY (C_CUSTKEY),
CONSTRAINT FOREIGN KEY CUSTOMER_FK1 (C_NATIONKEY) references nation(N_NATIONKEY));
CREATE TABLE IF NOT EXISTS orders  ( O_ORDERKEY       INTEGER NOT NULL,
O_CUSTKEY        INTEGER NOT NULL,
O_ORDERSTATUS    CHAR(1) NOT NULL,
O_TOTALPRICE     DECIMAL(15,2) NOT NULL,
O_ORDERDATE      DATE NOT NULL,
O_ORDERPRIORITY  CHAR(15) NOT NULL,
O_CLERK          CHAR(15) NOT NULL,
O_SHIPPRIORITY   INTEGER NOT NULL,
O_COMMENT        VARCHAR(79) NOT NULL,
PRIMARY KEY (O_ORDERKEY),
CONSTRAINT FOREIGN KEY ORDERS_FK1 (O_CUSTKEY) references customer(C_CUSTKEY));
CREATE TABLE IF NOT EXISTS lineitem ( L_ORDERKEY    INTEGER NOT NULL,
L_PARTKEY     INTEGER NOT NULL,
L_SUPPKEY     INTEGER NOT NULL,
L_LINENUMBER  INTEGER NOT NULL,
L_QUANTITY    DECIMAL(15,2) NOT NULL,
L_EXTENDEDPRICE  DECIMAL(15,2) NOT NULL,
L_DISCOUNT    DECIMAL(15,2) NOT NULL,
L_TAX         DECIMAL(15,2) NOT NULL,
L_RETURNFLAG  CHAR(1) NOT NULL,
L_LINESTATUS  CHAR(1) NOT NULL,
L_SHIPDATE    DATE NOT NULL,
L_COMMITDATE  DATE NOT NULL,
L_RECEIPTDATE DATE NOT NULL,
L_SHIPINSTRUCT CHAR(25) NOT NULL,
L_SHIPMODE     CHAR(10) NOT NULL,
L_COMMENT      VARCHAR(44) NOT NULL,
PRIMARY KEY (L_ORDERKEY,L_LINENUMBER),
CONSTRAINT FOREIGN KEY LINEITEM_FK1 (L_ORDERKEY)  references orders(O_ORDERKEY),
CONSTRAINT FOREIGN KEY LINEITEM_FK2 (L_PARTKEY,L_SUPPKEY) references partsupp(PS_PARTKEY, PS_SUPPKEY));
load stats 's/tpch_stats/nation.json';
load stats 's/tpch_stats/region.json';
load stats 's/tpch_stats/part.json';
load stats 's/tpch_stats/supplier.json';
load stats 's/tpch_stats/partsupp.json';
load stats 's/tpch_stats/customer.json';
load stats 's/tpch_stats/orders.json';
load stats 's/tpch_stats/lineitem.json';
set @@session.tidb_opt_agg_push_down = 0;
/*
Q1 Pricing Summary Report
This query reports the amount of business that was billed, shipped, and returned.
The Pricing Summary Report Query provides a summary pricing report for all lineitems shipped as of a given date.
The date is within 60 - 120 days of the greatest ship date contained in the database. The query lists totals for
extended price, discounted extended price, discounted extended price plus tax, average quantity, average extended
price, and average discount. These aggregates are grouped by RETURNFLAG and LINESTATUS, and listed in
ascending order of RETURNFLAG and LINESTATUS. A count of the number of lineitems in each group is
included.
Planner enhancement: none.
*/
explain
select
l_returnflag,
l_linestatus,
sum(l_quantity) as sum_qty,
sum(l_extendedprice) as sum_base_price,
sum(l_extendedprice * (1 - l_discount)) as sum_disc_price,
sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) as sum_charge,
avg(l_quantity) as avg_qty,
avg(l_extendedprice) as avg_price,
avg(l_discount) as avg_disc,
count(*) as count_order
from
lineitem
where
l_shipdate <= date_sub('1998-12-01', interval 108 day)
group by
l_returnflag,
l_linestatus
order by
l_returnflag,
l_linestatus;
id	count	task	operator info
Sort_6	2.94	root	tpch.lineitem.l_returnflag:asc, tpch.lineitem.l_linestatus:asc
└─Projection_8	2.94	root	tpch.lineitem.l_returnflag, tpch.lineitem.l_linestatus, 3_col_0, 3_col_1, 3_col_2, 3_col_3, 3_col_4, 3_col_5, 3_col_6, 3_col_7
  └─HashAgg_14	2.94	root	group by:col_13, col_14, funcs:sum(col_0), sum(col_1), sum(col_2), sum(col_3), avg(col_4, col_5), avg(col_6, col_7), avg(col_8, col_9), count(col_10), firstrow(col_11), firstrow(col_12)
    └─TableReader_15	2.94	root	data:HashAgg_9
      └─HashAgg_9	2.94	cop	group by:tpch.lineitem.l_linestatus, tpch.lineitem.l_returnflag, funcs:sum(tpch.lineitem.l_quantity), sum(tpch.lineitem.l_extendedprice), sum(mul(tpch.lineitem.l_extendedprice, minus(1, tpch.lineitem.l_discount))), sum(mul(mul(tpch.lineitem.l_extendedprice, minus(1, tpch.lineitem.l_discount)), plus(1, tpch.lineitem.l_tax))), avg(tpch.lineitem.l_quantity), avg(tpch.lineitem.l_extendedprice), avg(tpch.lineitem.l_discount), count(1), firstrow(tpch.lineitem.l_returnflag), firstrow(tpch.lineitem.l_linestatus)
        └─Selection_13	293795345.00	cop	le(tpch.lineitem.l_shipdate, 1998-08-15)
          └─TableScan_12	300005811.00	cop	table:lineitem, range:[-inf,+inf], keep order:false
/*
Q2 Minimum Cost Supplier Query
This query finds which supplier should be selected to place an order for a given part in a given region.
The Minimum Cost Supplier Query finds, in a given region, for each part of a certain type and size, the supplier who
can supply it at minimum cost. If several suppliers in that region offer the desired part type and size at the same
(minimum) cost, the query lists the parts from suppliers with the 100 highest account balances. For each supplier,
the query lists the supplier's account balance, name and nation; the part's number and manufacturer; the supplier's
address, phone number and comment information.
Planner enhancement: join reorder.
*/
explain
select
s_acctbal,
s_name,
n_name,
p_partkey,
p_mfgr,
s_address,
s_phone,
s_comment
from
part,
supplier,
partsupp,
nation,
region
where
p_partkey = ps_partkey
and s_suppkey = ps_suppkey
and p_size = 30
and p_type like '%STEEL'
and s_nationkey = n_nationkey
and n_regionkey = r_regionkey
and r_name = 'ASIA'
and ps_supplycost = (
select
min(ps_supplycost)
from
partsupp,
supplier,
nation,
region
where
p_partkey = ps_partkey
and s_suppkey = ps_suppkey
and s_nationkey = n_nationkey
and n_regionkey = r_regionkey
and r_name = 'ASIA'
)
order by
s_acctbal desc,
n_name,
s_name,
p_partkey
limit 100;
id	count	task	operator info
<<<<<<< HEAD
Projection_34	100.00	root	tpch.supplier.s_acctbal, tpch.supplier.s_name, tpch.nation.n_name, tpch.part.p_partkey, tpch.part.p_mfgr, tpch.supplier.s_address, tpch.supplier.s_phone, tpch.supplier.s_comment
└─TopN_37	100.00	root	tpch.supplier.s_acctbal:desc, tpch.nation.n_name:asc, tpch.supplier.s_name:asc, tpch.part.p_partkey:asc, offset:0, count:100
  └─HashRightJoin_39	125109.42	root	inner join, inner:HashLeftJoin_44, equal:[eq(tpch.part.p_partkey, tpch.partsupp.ps_partkey) eq(tpch.partsupp.ps_supplycost, min(ps_supplycost))]
    ├─HashLeftJoin_44	125109.42	root	inner join, inner:TableReader_86, equal:[eq(tpch.nation.n_regionkey, tpch.region.r_regionkey)]
    │ ├─HashLeftJoin_49	625547.12	root	inner join, inner:TableReader_83, equal:[eq(tpch.supplier.s_nationkey, tpch.nation.n_nationkey)]
    │ │ ├─IndexJoin_53	625547.12	root	inner join, inner:TableReader_52, outer key:tpch.partsupp.ps_suppkey, inner key:tpch.supplier.s_suppkey
    │ │ │ ├─IndexJoin_60	625547.12	root	inner join, inner:IndexLookUp_59, outer key:tpch.part.p_partkey, inner key:tpch.partsupp.ps_partkey
    │ │ │ │ ├─TableReader_77	155496.00	root	data:Selection_76
    │ │ │ │ │ └─Selection_76	155496.00	cop	eq(tpch.part.p_size, 30), like(tpch.part.p_type, "%STEEL", 92)
    │ │ │ │ │   └─TableScan_75	10000000.00	cop	table:part, range:[-inf,+inf], keep order:false
    │ │ │ │ └─IndexLookUp_59	1.00	root	
    │ │ │ │   ├─IndexScan_57	1.00	cop	table:partsupp, index:PS_PARTKEY, PS_SUPPKEY, range: decided by [tpch.part.p_partkey], keep order:false
    │ │ │ │   └─TableScan_58	1.00	cop	table:partsupp, keep order:false
    │ │ │ └─TableReader_52	1.00	root	data:TableScan_51
    │ │ │   └─TableScan_51	1.00	cop	table:supplier, range: decided by [tpch.partsupp.ps_suppkey], keep order:false
    │ │ └─TableReader_83	25.00	root	data:TableScan_82
    │ │   └─TableScan_82	25.00	cop	table:nation, range:[-inf,+inf], keep order:false
    │ └─TableReader_86	1.00	root	data:Selection_85
    │   └─Selection_85	1.00	cop	eq(tpch.region.r_name, "ASIA")
    │     └─TableScan_84	5.00	cop	table:region, range:[-inf,+inf], keep order:false
    └─HashAgg_89	8155010.44	root	group by:tpch.partsupp.ps_partkey, funcs:min(tpch.partsupp.ps_supplycost), firstrow(tpch.partsupp.ps_partkey)
      └─HashRightJoin_93	8155010.44	root	inner join, inner:HashRightJoin_95, equal:[eq(tpch.supplier.s_suppkey, tpch.partsupp.ps_suppkey)]
        ├─HashRightJoin_95	100000.00	root	inner join, inner:HashRightJoin_101, equal:[eq(tpch.nation.n_nationkey, tpch.supplier.s_nationkey)]
        │ ├─HashRightJoin_101	5.00	root	inner join, inner:TableReader_106, equal:[eq(tpch.region.r_regionkey, tpch.nation.n_regionkey)]
        │ │ ├─TableReader_106	1.00	root	data:Selection_105
        │ │ │ └─Selection_105	1.00	cop	eq(tpch.region.r_name, "ASIA")
        │ │ │   └─TableScan_104	5.00	cop	table:region, range:[-inf,+inf], keep order:false
        │ │ └─TableReader_103	25.00	root	data:TableScan_102
        │ │   └─TableScan_102	25.00	cop	table:nation, range:[-inf,+inf], keep order:false
        │ └─TableReader_108	500000.00	root	data:TableScan_107
        │   └─TableScan_107	500000.00	cop	table:supplier, range:[-inf,+inf], keep order:false
        └─TableReader_110	40000000.00	root	data:TableScan_109
          └─TableScan_109	40000000.00	cop	table:partsupp, range:[-inf,+inf], keep order:false
=======
Projection_37	100.00	root	tpch.supplier.s_acctbal, tpch.supplier.s_name, tpch.nation.n_name, tpch.part.p_partkey, tpch.part.p_mfgr, tpch.supplier.s_address, tpch.supplier.s_phone, tpch.supplier.s_comment
└─TopN_40	100.00	root	tpch.supplier.s_acctbal:desc, tpch.nation.n_name:asc, tpch.supplier.s_name:asc, tpch.part.p_partkey:asc, offset:0, count:100
  └─HashRightJoin_45	155496.00	root	inner join, inner:HashLeftJoin_51, equal:[eq(tpch.part.p_partkey, tpch.partsupp.ps_partkey) eq(tpch.partsupp.ps_supplycost, min(ps_supplycost))]
    ├─HashLeftJoin_51	155496.00	root	inner join, inner:TableReader_74, equal:[eq(tpch.partsupp.ps_partkey, tpch.part.p_partkey)]
    │ ├─HashRightJoin_54	8155010.44	root	inner join, inner:HashRightJoin_56, equal:[eq(tpch.supplier.s_suppkey, tpch.partsupp.ps_suppkey)]
    │ │ ├─HashRightJoin_56	100000.00	root	inner join, inner:HashRightJoin_62, equal:[eq(tpch.nation.n_nationkey, tpch.supplier.s_nationkey)]
    │ │ │ ├─HashRightJoin_62	5.00	root	inner join, inner:TableReader_67, equal:[eq(tpch.region.r_regionkey, tpch.nation.n_regionkey)]
    │ │ │ │ ├─TableReader_67	1.00	root	data:Selection_66
    │ │ │ │ │ └─Selection_66	1.00	cop	eq(tpch.region.r_name, "ASIA")
    │ │ │ │ │   └─TableScan_65	5.00	cop	table:region, range:[-inf,+inf], keep order:false
    │ │ │ │ └─TableReader_64	25.00	root	data:TableScan_63
    │ │ │ │   └─TableScan_63	25.00	cop	table:nation, range:[-inf,+inf], keep order:false
    │ │ │ └─TableReader_69	500000.00	root	data:TableScan_68
    │ │ │   └─TableScan_68	500000.00	cop	table:supplier, range:[-inf,+inf], keep order:false
    │ │ └─TableReader_71	40000000.00	root	data:TableScan_70
    │ │   └─TableScan_70	40000000.00	cop	table:partsupp, range:[-inf,+inf], keep order:false
    │ └─TableReader_74	155496.00	root	data:Selection_73
    │   └─Selection_73	155496.00	cop	eq(tpch.part.p_size, 30), like(tpch.part.p_type, "%STEEL", 92)
    │     └─TableScan_72	10000000.00	cop	table:part, range:[-inf,+inf], keep order:false
    └─Selection_75	6524008.35	root	not(isnull(min(ps_supplycost)))
      └─HashAgg_78	8155010.44	root	group by:tpch.partsupp.ps_partkey, funcs:min(tpch.partsupp.ps_supplycost), firstrow(tpch.partsupp.ps_partkey)
        └─HashRightJoin_82	8155010.44	root	inner join, inner:HashRightJoin_84, equal:[eq(tpch.supplier.s_suppkey, tpch.partsupp.ps_suppkey)]
          ├─HashRightJoin_84	100000.00	root	inner join, inner:HashRightJoin_90, equal:[eq(tpch.nation.n_nationkey, tpch.supplier.s_nationkey)]
          │ ├─HashRightJoin_90	5.00	root	inner join, inner:TableReader_95, equal:[eq(tpch.region.r_regionkey, tpch.nation.n_regionkey)]
          │ │ ├─TableReader_95	1.00	root	data:Selection_94
          │ │ │ └─Selection_94	1.00	cop	eq(tpch.region.r_name, "ASIA")
          │ │ │   └─TableScan_93	5.00	cop	table:region, range:[-inf,+inf], keep order:false
          │ │ └─TableReader_92	25.00	root	data:TableScan_91
          │ │   └─TableScan_91	25.00	cop	table:nation, range:[-inf,+inf], keep order:false
          │ └─TableReader_97	500000.00	root	data:TableScan_96
          │   └─TableScan_96	500000.00	cop	table:supplier, range:[-inf,+inf], keep order:false
          └─TableReader_99	40000000.00	root	data:TableScan_98
            └─TableScan_98	40000000.00	cop	table:partsupp, range:[-inf,+inf], keep order:false
>>>>>>> 829ba98... expression: remove the NotNullFlag for aggregation func MAX/MIN when inferring type (#11343)
/*
Q3 Shipping Priority Query
This query retrieves the 10 unshipped orders with the highest value.
The Shipping Priority Query retrieves the shipping priority and potential revenue, defined as the sum of
l_extendedprice * (1-l_discount), of the orders having the largest revenue among those that had not been shipped as
of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10
orders with the largest revenue are listed.
planner enhancement: if group-by item have primary key, non-priamry key is useless.
*/
explain
select
l_orderkey,
sum(l_extendedprice * (1 - l_discount)) as revenue,
o_orderdate,
o_shippriority
from
customer,
orders,
lineitem
where
c_mktsegment = 'AUTOMOBILE'
and c_custkey = o_custkey
and l_orderkey = o_orderkey
and o_orderdate < '1995-03-13'
and l_shipdate > '1995-03-13'
group by
l_orderkey,
o_orderdate,
o_shippriority
order by
revenue desc,
o_orderdate
limit 10;
id	count	task	operator info
Projection_14	10.00	root	tpch.lineitem.l_orderkey, 7_col_0, tpch.orders.o_orderdate, tpch.orders.o_shippriority
└─TopN_17	10.00	root	7_col_0:desc, tpch.orders.o_orderdate:asc, offset:0, count:10
  └─HashAgg_20	40252367.98	root	group by:col_4, col_5, col_6, funcs:sum(col_0), firstrow(col_1), firstrow(col_2), firstrow(col_3)
    └─Projection_57	91515927.49	root	mul(tpch.lineitem.l_extendedprice, minus(1, tpch.lineitem.l_discount)), tpch.orders.o_orderdate, tpch.orders.o_shippriority, tpch.lineitem.l_orderkey, tpch.lineitem.l_orderkey, tpch.orders.o_orderdate, tpch.orders.o_shippriority
      └─IndexJoin_26	91515927.49	root	inner join, inner:IndexLookUp_25, outer key:tpch.orders.o_orderkey, inner key:tpch.lineitem.l_orderkey
        ├─HashRightJoin_47	22592975.51	root	inner join, inner:TableReader_53, equal:[eq(tpch.customer.c_custkey, tpch.orders.o_custkey)]
        │ ├─TableReader_53	1498236.00	root	data:Selection_52
        │ │ └─Selection_52	1498236.00	cop	eq(tpch.customer.c_mktsegment, "AUTOMOBILE")
        │ │   └─TableScan_51	7500000.00	cop	table:customer, range:[-inf,+inf], keep order:false
        │ └─TableReader_50	36870000.00	root	data:Selection_49
        │   └─Selection_49	36870000.00	cop	lt(tpch.orders.o_orderdate, 1995-03-13 00:00:00.000000)
        │     └─TableScan_48	75000000.00	cop	table:orders, range:[-inf,+inf], keep order:false
        └─IndexLookUp_25	0.54	root	
          ├─IndexScan_22	1.00	cop	table:lineitem, index:L_ORDERKEY, L_LINENUMBER, range: decided by [tpch.orders.o_orderkey], keep order:false
          └─Selection_24	0.54	cop	gt(tpch.lineitem.l_shipdate, 1995-03-13 00:00:00.000000)
            └─TableScan_23	1.00	cop	table:lineitem, keep order:false
/*
Q4 Order Priority Checking Query
This query determines how well the order priority system is working and gives an assessment of customer satisfaction.
The Order Priority Checking Query counts the number of orders ordered in a given quarter of a given year in which
at least one lineitem was received by the customer later than its committed date. The query lists the count of such
orders for each order priority sorted in ascending priority order.
*/
explain
select
o_orderpriority,
count(*) as order_count
from
orders
where
o_orderdate >= '1995-01-01'
and o_orderdate < date_add('1995-01-01', interval '3' month)
and exists (
select
*
from
lineitem
where
l_orderkey = o_orderkey
and l_commitdate < l_receiptdate
)
group by
o_orderpriority
order by
o_orderpriority;
id	count	task	operator info
Sort_10	1.00	root	tpch.orders.o_orderpriority:asc
└─Projection_12	1.00	root	tpch.orders.o_orderpriority, 7_col_0
  └─HashAgg_15	1.00	root	group by:tpch.orders.o_orderpriority, funcs:count(1), firstrow(tpch.orders.o_orderpriority)
    └─IndexJoin_21	2340750.00	root	semi join, inner:IndexLookUp_20, outer key:tpch.orders.o_orderkey, inner key:tpch.lineitem.l_orderkey
      ├─TableReader_34	2925937.50	root	data:Selection_33
      │ └─Selection_33	2925937.50	cop	ge(tpch.orders.o_orderdate, 1995-01-01 00:00:00.000000), lt(tpch.orders.o_orderdate, 1995-04-01)
      │   └─TableScan_32	75000000.00	cop	table:orders, range:[-inf,+inf], keep order:false
      └─IndexLookUp_20	0.80	root	
        ├─IndexScan_17	1.00	cop	table:lineitem, index:L_ORDERKEY, L_LINENUMBER, range: decided by [tpch.orders.o_orderkey], keep order:false
        └─Selection_19	0.80	cop	lt(tpch.lineitem.l_commitdate, tpch.lineitem.l_receiptdate)
          └─TableScan_18	1.00	cop	table:lineitem, keep order:false
/*
Q5 Local Supplier Volume Query
This query lists the revenue volume done through local suppliers.
The Local Supplier Volume Query lists for each nation in a region the revenue volume that resulted from lineitem
transactions in which the customer ordering parts and the supplier filling them were both within that nation. The
query is run in order to determine whether to institute local distribution centers in a given region. The query considers
only parts ordered in a given year. The query displays the nations and revenue volume in descending order by
revenue. Revenue volume for all qualifying lineitems in a particular nation is defined as sum(l_extendedprice * (1 -
l_discount)).
Planner enhancement: join reorder.
*/
explain
select
n_name,
sum(l_extendedprice * (1 - l_discount)) as revenue
from
customer,
orders,
lineitem,
supplier,
nation,
region
where
c_custkey = o_custkey
and l_orderkey = o_orderkey
and l_suppkey = s_suppkey
and c_nationkey = s_nationkey
and s_nationkey = n_nationkey
and n_regionkey = r_regionkey
and r_name = 'MIDDLE EAST'
and o_orderdate >= '1994-01-01'
and o_orderdate < date_add('1994-01-01', interval '1' year)
group by
n_name
order by
revenue desc;
id	count	task	operator info
Sort_21	25.00	root	revenue:desc
└─Projection_23	25.00	root	tpch.nation.n_name, 13_col_0
  └─HashAgg_26	25.00	root	group by:col_2, funcs:sum(col_0), firstrow(col_1)
    └─Projection_67	191559655555.87	root	mul(tpch.lineitem.l_extendedprice, minus(1, tpch.lineitem.l_discount)), tpch.nation.n_name, tpch.nation.n_name
      └─HashLeftJoin_31	191559655555.87	root	inner join, inner:TableReader_65, equal:[eq(tpch.nation.n_regionkey, tpch.region.r_regionkey)]
        ├─HashLeftJoin_36	957798277779.33	root	inner join, inner:TableReader_62, equal:[eq(tpch.supplier.s_nationkey, tpch.nation.n_nationkey)]
        │ ├─HashLeftJoin_43	957798277779.33	root	inner join, inner:TableReader_60, equal:[eq(tpch.orders.o_orderkey, tpch.lineitem.l_orderkey) eq(tpch.supplier.s_suppkey, tpch.lineitem.l_suppkey)]
        │ │ ├─HashLeftJoin_45	236456250000.00	root	inner join, inner:TableReader_58, equal:[eq(tpch.customer.c_nationkey, tpch.supplier.s_nationkey)]
        │ │ │ ├─IndexJoin_49	11822812.50	root	inner join, inner:TableReader_48, outer key:tpch.orders.o_custkey, inner key:tpch.customer.c_custkey
        │ │ │ │ ├─TableReader_54	11822812.50	root	data:Selection_53
        │ │ │ │ │ └─Selection_53	11822812.50	cop	ge(tpch.orders.o_orderdate, 1994-01-01 00:00:00.000000), lt(tpch.orders.o_orderdate, 1995-01-01)
        │ │ │ │ │   └─TableScan_52	75000000.00	cop	table:orders, range:[-inf,+inf], keep order:false
        │ │ │ │ └─TableReader_48	1.00	root	data:TableScan_47
        │ │ │ │   └─TableScan_47	1.00	cop	table:customer, range: decided by [tpch.orders.o_custkey], keep order:false
        │ │ │ └─TableReader_58	500000.00	root	data:TableScan_57
        │ │ │   └─TableScan_57	500000.00	cop	table:supplier, range:[-inf,+inf], keep order:false
        │ │ └─TableReader_60	300005811.00	root	data:TableScan_59
        │ │   └─TableScan_59	300005811.00	cop	table:lineitem, range:[-inf,+inf], keep order:false
        │ └─TableReader_62	25.00	root	data:TableScan_61
        │   └─TableScan_61	25.00	cop	table:nation, range:[-inf,+inf], keep order:false
        └─TableReader_65	1.00	root	data:Selection_64
          └─Selection_64	1.00	cop	eq(tpch.region.r_name, "MIDDLE EAST")
            └─TableScan_63	5.00	cop	table:region, range:[-inf,+inf], keep order:false
/*
Q6 Forecasting Revenue Change Query
This query quantifies the amount of revenue increase that would have resulted from eliminating certain companywide
discounts in a given percentage range in a given year. Asking this type of "what if" query can be used to look
for ways to increase revenues.
The Forecasting Revenue Change Query considers all the lineitems shipped in a given year with discounts between
DISCOUNT-0.01 and DISCOUNT+0.01. The query lists the amount by which the total revenue would have
increased if these discounts had been eliminated for lineitems with l_quantity less than quantity. Note that the
potential revenue increase is equal to the sum of [l_extendedprice * l_discount] for all lineitems with discounts and
quantities in the qualifying range.
*/
explain
select
sum(l_extendedprice * l_discount) as revenue
from
lineitem
where
l_shipdate >= '1994-01-01'
and l_shipdate < date_add('1994-01-01', interval '1' year)
and l_discount between 0.06 - 0.01 and 0.06 + 0.01
and l_quantity < 24;
id	count	task	operator info
StreamAgg_20	1.00	root	funcs:sum(col_0)
└─TableReader_21	1.00	root	data:StreamAgg_9
  └─StreamAgg_9	1.00	cop	funcs:sum(mul(tpch.lineitem.l_extendedprice, tpch.lineitem.l_discount))
    └─Selection_19	3713857.91	cop	ge(tpch.lineitem.l_discount, 0.05), ge(tpch.lineitem.l_shipdate, 1994-01-01 00:00:00.000000), le(tpch.lineitem.l_discount, 0.07), lt(tpch.lineitem.l_quantity, 24), lt(tpch.lineitem.l_shipdate, 1995-01-01)
      └─TableScan_18	300005811.00	cop	table:lineitem, range:[-inf,+inf], keep order:false
/*
Q7 Volume Shipping Query
This query determines the value of goods shipped between certain nations to help in the re-negotiation of shipping
contracts.
The Volume Shipping Query finds, for two given nations, the gross discounted revenues derived from lineitems in
which parts were shipped from a supplier in either nation to a customer in the other nation during 1995 and 1996.
The query lists the supplier nation, the customer nation, the year, and the revenue from shipments that took place in
that year. The query orders the answer by Supplier nation, Customer nation, and year (all ascending).
Planner enahancement: join reorder.
*/
explain
select
supp_nation,
cust_nation,
l_year,
sum(volume) as revenue
from
(
select
n1.n_name as supp_nation,
n2.n_name as cust_nation,
extract(year from l_shipdate) as l_year,
l_extendedprice * (1 - l_discount) as volume
from
supplier,
lineitem,
orders,
customer,
nation n1,
nation n2
where
s_suppkey = l_suppkey
and o_orderkey = l_orderkey
and c_custkey = o_custkey
and s_nationkey = n1.n_nationkey
and c_nationkey = n2.n_nationkey
and (
(n1.n_name = 'JAPAN' and n2.n_name = 'INDIA')
or (n1.n_name = 'INDIA' and n2.n_name = 'JAPAN')
)
and l_shipdate between '1995-01-01' and '1996-12-31'
) as shipping
group by
supp_nation,
cust_nation,
l_year
order by
supp_nation,
cust_nation,
l_year;
id	count	task	operator info
Sort_22	769.96	root	tpch.shipping.supp_nation:asc, tpch.shipping.cust_nation:asc, shipping.l_year:asc
└─Projection_24	769.96	root	tpch.shipping.supp_nation, tpch.shipping.cust_nation, shipping.l_year, 14_col_0
  └─HashAgg_27	769.96	root	group by:shipping.l_year, tpch.shipping.cust_nation, tpch.shipping.supp_nation, funcs:sum(shipping.volume), firstrow(tpch.shipping.supp_nation), firstrow(tpch.shipping.cust_nation), firstrow(shipping.l_year)
    └─Projection_28	585255.87	root	tpch.n1.n_name, tpch.n2.n_name, extract("YEAR", tpch.lineitem.l_shipdate), mul(tpch.lineitem.l_extendedprice, minus(1, tpch.lineitem.l_discount))
      └─HashLeftJoin_33	585255.87	root	inner join, inner:TableReader_86, equal:[eq(tpch.customer.c_nationkey, tpch.n2.n_nationkey)], other cond:or(and(eq(tpch.n1.n_name, "JAPAN"), eq(tpch.n2.n_name, "INDIA")), and(eq(tpch.n1.n_name, "INDIA"), eq(tpch.n2.n_name, "JAPAN")))
        ├─IndexJoin_37	7315698.42	root	inner join, inner:TableReader_36, outer key:tpch.orders.o_custkey, inner key:tpch.customer.c_custkey
        │ ├─IndexJoin_43	7315698.42	root	inner join, inner:TableReader_42, outer key:tpch.lineitem.l_orderkey, inner key:tpch.orders.o_orderkey
        │ │ ├─HashLeftJoin_65	7315698.42	root	inner join, inner:TableReader_79, equal:[eq(tpch.supplier.s_nationkey, tpch.n1.n_nationkey)]
        │ │ │ ├─HashLeftJoin_70	91446230.29	root	inner join, inner:TableReader_76, equal:[eq(tpch.lineitem.l_suppkey, tpch.supplier.s_suppkey)]
        │ │ │ │ ├─TableReader_74	91446230.29	root	data:Selection_73
        │ │ │ │ │ └─Selection_73	91446230.29	cop	ge(tpch.lineitem.l_shipdate, 1995-01-01 00:00:00.000000), le(tpch.lineitem.l_shipdate, 1996-12-31 00:00:00.000000)
        │ │ │ │ │   └─TableScan_72	300005811.00	cop	table:lineitem, range:[-inf,+inf], keep order:false
        │ │ │ │ └─TableReader_76	500000.00	root	data:TableScan_75
        │ │ │ │   └─TableScan_75	500000.00	cop	table:supplier, range:[-inf,+inf], keep order:false
        │ │ │ └─TableReader_79	2.00	root	data:Selection_78
        │ │ │   └─Selection_78	2.00	cop	or(eq(tpch.n1.n_name, "JAPAN"), eq(tpch.n1.n_name, "INDIA"))
        │ │ │     └─TableScan_77	25.00	cop	table:n1, range:[-inf,+inf], keep order:false
        │ │ └─TableReader_42	1.00	root	data:TableScan_41
        │ │   └─TableScan_41	1.00	cop	table:orders, range: decided by [tpch.lineitem.l_orderkey], keep order:false
        │ └─TableReader_36	1.00	root	data:TableScan_35
        │   └─TableScan_35	1.00	cop	table:customer, range: decided by [tpch.orders.o_custkey], keep order:false
        └─TableReader_86	2.00	root	data:Selection_85
          └─Selection_85	2.00	cop	or(eq(tpch.n2.n_name, "INDIA"), eq(tpch.n2.n_name, "JAPAN"))
            └─TableScan_84	25.00	cop	table:n2, range:[-inf,+inf], keep order:false
/*
Q8 National Market Share Query
This query determines how the market share of a given nation within a given region has changed over two years for
a given part type.
The market share for a given nation within a given region is defined as the fraction of the revenue, the sum of
[l_extendedprice * (1-l_discount)], from the products of a specified type in that region that was supplied by suppliers
from the given nation. The query determines this for the years 1995 and 1996 presented in this order.
Planner enhancement: join reorder.
*/
explain
select
o_year,
sum(case
when nation = 'INDIA' then volume
else 0
end) / sum(volume) as mkt_share
from
(
select
extract(year from o_orderdate) as o_year,
l_extendedprice * (1 - l_discount) as volume,
n2.n_name as nation
from
part,
supplier,
lineitem,
orders,
customer,
nation n1,
nation n2,
region
where
p_partkey = l_partkey
and s_suppkey = l_suppkey
and l_orderkey = o_orderkey
and o_custkey = c_custkey
and c_nationkey = n1.n_nationkey
and n1.n_regionkey = r_regionkey
and r_name = 'ASIA'
and s_nationkey = n2.n_nationkey
and o_orderdate between '1995-01-01' and '1996-12-31'
and p_type = 'SMALL PLATED COPPER'
) as all_nations
group by
o_year
order by
o_year;
id	count	task	operator info
Sort_28	719.02	root	all_nations.o_year:asc
└─Projection_30	719.02	root	all_nations.o_year, div(18_col_0, 18_col_1)
  └─HashAgg_33	719.02	root	group by:col_3, funcs:sum(col_0), sum(col_1), firstrow(col_2)
    └─Projection_106	112627.20	root	case(eq(tpch.all_nations.nation, "INDIA"), all_nations.volume, 0), all_nations.volume, all_nations.o_year, all_nations.o_year
      └─Projection_34	112627.20	root	extract("YEAR", tpch.orders.o_orderdate), mul(tpch.lineitem.l_extendedprice, minus(1, tpch.lineitem.l_discount)), tpch.n2.n_name
        └─HashLeftJoin_39	112627.20	root	inner join, inner:TableReader_104, equal:[eq(tpch.n1.n_regionkey, tpch.region.r_regionkey)]
          ├─HashLeftJoin_44	563136.02	root	inner join, inner:TableReader_101, equal:[eq(tpch.customer.c_nationkey, tpch.n1.n_nationkey)]
          │ ├─IndexJoin_48	563136.02	root	inner join, inner:TableReader_47, outer key:tpch.orders.o_custkey, inner key:tpch.customer.c_custkey
          │ │ ├─HashLeftJoin_54	563136.02	root	inner join, inner:TableReader_97, equal:[eq(tpch.supplier.s_nationkey, tpch.n2.n_nationkey)]
          │ │ │ ├─IndexJoin_58	563136.02	root	inner join, inner:TableReader_57, outer key:tpch.lineitem.l_suppkey, inner key:tpch.supplier.s_suppkey
          │ │ │ │ ├─HashLeftJoin_65	563136.02	root	inner join, inner:TableReader_93, equal:[eq(tpch.lineitem.l_partkey, tpch.part.p_partkey)]
          │ │ │ │ │ ├─IndexJoin_71	90788402.51	root	inner join, inner:IndexLookUp_70, outer key:tpch.orders.o_orderkey, inner key:tpch.lineitem.l_orderkey
          │ │ │ │ │ │ ├─TableReader_88	22413367.93	root	data:Selection_87
          │ │ │ │ │ │ │ └─Selection_87	22413367.93	cop	ge(tpch.orders.o_orderdate, 1995-01-01 00:00:00.000000), le(tpch.orders.o_orderdate, 1996-12-31 00:00:00.000000)
          │ │ │ │ │ │ │   └─TableScan_86	75000000.00	cop	table:orders, range:[-inf,+inf], keep order:false
          │ │ │ │ │ │ └─IndexLookUp_70	1.00	root	
          │ │ │ │ │ │   ├─IndexScan_68	1.00	cop	table:lineitem, index:L_ORDERKEY, L_LINENUMBER, range: decided by [tpch.orders.o_orderkey], keep order:false
          │ │ │ │ │ │   └─TableScan_69	1.00	cop	table:lineitem, keep order:false
          │ │ │ │ │ └─TableReader_93	61674.00	root	data:Selection_92
          │ │ │ │ │   └─Selection_92	61674.00	cop	eq(tpch.part.p_type, "SMALL PLATED COPPER")
          │ │ │ │ │     └─TableScan_91	10000000.00	cop	table:part, range:[-inf,+inf], keep order:false
          │ │ │ │ └─TableReader_57	1.00	root	data:TableScan_56
          │ │ │ │   └─TableScan_56	1.00	cop	table:supplier, range: decided by [tpch.lineitem.l_suppkey], keep order:false
          │ │ │ └─TableReader_97	25.00	root	data:TableScan_96
          │ │ │   └─TableScan_96	25.00	cop	table:n2, range:[-inf,+inf], keep order:false
          │ │ └─TableReader_47	1.00	root	data:TableScan_46
          │ │   └─TableScan_46	1.00	cop	table:customer, range: decided by [tpch.orders.o_custkey], keep order:false
          │ └─TableReader_101	25.00	root	data:TableScan_100
          │   └─TableScan_100	25.00	cop	table:n1, range:[-inf,+inf], keep order:false
          └─TableReader_104	1.00	root	data:Selection_103
            └─Selection_103	1.00	cop	eq(tpch.region.r_name, "ASIA")
              └─TableScan_102	5.00	cop	table:region, range:[-inf,+inf], keep order:false
/*
Q9 Product Type Profit Measure Query
This query determines how much profit is made on a given line of parts, broken out by supplier nation and year.
The Product Type Profit Measure Query finds, for each nation and each year, the profit for all parts ordered in that
year that contain a specified substring in their names and that were filled by a supplier in that nation. The profit is
defined as the sum of [(l_extendedprice*(1-l_discount)) - (ps_supplycost * l_quantity)] for all lineitems describing
parts in the specified line. The query lists the nations in ascending alphabetical order and, for each nation, the year
and profit in descending order by year (most recent first).
Planner enhancement: join reorder.
*/
explain
select
nation,
o_year,
sum(amount) as sum_profit
from
(
select
n_name as nation,
extract(year from o_orderdate) as o_year,
l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity as amount
from
part,
supplier,
lineitem,
partsupp,
orders,
nation
where
s_suppkey = l_suppkey
and ps_suppkey = l_suppkey
and ps_partkey = l_partkey
and p_partkey = l_partkey
and o_orderkey = l_orderkey
and s_nationkey = n_nationkey
and p_name like '%dim%'
) as profit
group by
nation,
o_year
order by
nation,
o_year desc;
id	count	task	operator info
Sort_22	2406.00	root	tpch.profit.nation:asc, profit.o_year:desc
└─Projection_23	2406.00	root	tpch.profit.nation, profit.o_year, 14_col_0
  └─HashAgg_26	2406.00	root	group by:profit.o_year, tpch.profit.nation, funcs:sum(profit.amount), firstrow(tpch.profit.nation), firstrow(profit.o_year)
    └─Projection_27	971049283.51	root	tpch.nation.n_name, extract("YEAR", tpch.orders.o_orderdate), minus(mul(tpch.lineitem.l_extendedprice, minus(1, tpch.lineitem.l_discount)), mul(tpch.partsupp.ps_supplycost, tpch.lineitem.l_quantity))
      └─MergeJoin_28	971049283.51	root	inner join, left key:tpch.lineitem.l_orderkey, right key:tpch.orders.o_orderkey
        ├─IndexJoin_37	971049283.51	root	inner join, inner:IndexLookUp_36, outer key:tpch.lineitem.l_suppkey, tpch.lineitem.l_partkey, inner key:tpch.partsupp.ps_suppkey, tpch.partsupp.ps_partkey
        │ ├─IndexJoin_40	241379546.70	root	inner join, inner:TableReader_39, outer key:tpch.supplier.s_nationkey, inner key:tpch.nation.n_nationkey
        │ │ ├─IndexJoin_43	241379546.70	root	inner join, inner:TableReader_42, outer key:tpch.lineitem.l_suppkey, inner key:tpch.supplier.s_suppkey
        │ │ │ ├─IndexJoin_47	241379546.70	root	inner join, inner:TableReader_46, outer key:tpch.lineitem.l_partkey, inner key:tpch.part.p_partkey
        │ │ │ │ ├─TableReader_46	0.80	root	data:Selection_45
        │ │ │ │ │ └─Selection_45	0.80	cop	like(tpch.part.p_name, "%dim%", 92)
        │ │ │ │ │   └─TableScan_44	1.00	cop	table:part, range: decided by [tpch.lineitem.l_partkey], keep order:false
        │ │ │ │ └─Projection_52	300005811.00	root	tpch.lineitem.l_orderkey, tpch.lineitem.l_partkey, tpch.lineitem.l_suppkey, tpch.lineitem.l_quantity, tpch.lineitem.l_extendedprice, tpch.lineitem.l_discount
        │ │ │ │   └─IndexLookUp_51	300005811.00	root	
        │ │ │ │     ├─IndexScan_49	300005811.00	cop	table:lineitem, index:L_ORDERKEY, L_LINENUMBER, range:[NULL,+inf], keep order:true
        │ │ │ │     └─TableScan_50	300005811.00	cop	table:lineitem, keep order:false
        │ │ │ └─TableReader_42	1.00	root	data:TableScan_41
        │ │ │   └─TableScan_41	1.00	cop	table:supplier, range: decided by [tpch.lineitem.l_suppkey], keep order:false
        │ │ └─TableReader_39	1.00	root	data:TableScan_38
        │ │   └─TableScan_38	1.00	cop	table:nation, range: decided by [tpch.supplier.s_nationkey], keep order:false
        │ └─IndexLookUp_36	1.00	root	
        │   ├─IndexScan_34	1.00	cop	table:partsupp, index:PS_PARTKEY, PS_SUPPKEY, range: decided by [tpch.lineitem.l_suppkey tpch.lineitem.l_partkey], keep order:false
        │   └─TableScan_35	1.00	cop	table:partsupp, keep order:false
        └─TableReader_54	75000000.00	root	data:TableScan_53
          └─TableScan_53	75000000.00	cop	table:orders, range:[-inf,+inf], keep order:true
/*
Q10 Returned Item Reporting Query
The query identifies customers who might be having problems with the parts that are shipped to them.
The Returned Item Reporting Query finds the top 20 customers, in terms of their effect on lost revenue for a given
quarter, who have returned parts. The query considers only parts that were ordered in the specified quarter. The
query lists the customer's name, address, nation, phone number, account balance, comment information and revenue
lost. The customers are listed in descending order of lost revenue. Revenue lost is defined as
sum(l_extendedprice*(1-l_discount)) for all qualifying lineitems.
Planner enhancement: join reorder, if group-by item have primary key, non-priamry key is useless.
*/
explain
select
c_custkey,
c_name,
sum(l_extendedprice * (1 - l_discount)) as revenue,
c_acctbal,
n_name,
c_address,
c_phone,
c_comment
from
customer,
orders,
lineitem,
nation
where
c_custkey = o_custkey
and l_orderkey = o_orderkey
and o_orderdate >= '1993-08-01'
and o_orderdate < date_add('1993-08-01', interval '3' month)
and l_returnflag = 'R'
and c_nationkey = n_nationkey
group by
c_custkey,
c_name,
c_acctbal,
c_phone,
n_name,
c_address,
c_comment
order by
revenue desc
limit 20;
id	count	task	operator info
Projection_17	20.00	root	tpch.customer.c_custkey, tpch.customer.c_name, 9_col_0, tpch.customer.c_acctbal, tpch.nation.n_name, tpch.customer.c_address, tpch.customer.c_phone, tpch.customer.c_comment
└─TopN_20	20.00	root	9_col_0:desc, offset:0, count:20
  └─HashAgg_26	7500000.00	root	group by:col_10, col_11, col_12, col_13, col_14, col_8, col_9, funcs:sum(col_0), firstrow(col_1), firstrow(col_2), firstrow(col_3), firstrow(col_4), firstrow(col_5), firstrow(col_6), firstrow(col_7)
    └─Projection_68	12222016.17	root	mul(tpch.lineitem.l_extendedprice, minus(1, tpch.lineitem.l_discount)), tpch.customer.c_custkey, tpch.customer.c_name, tpch.customer.c_address, tpch.customer.c_phone, tpch.customer.c_acctbal, tpch.customer.c_comment, tpch.nation.n_name, tpch.customer.c_custkey, tpch.customer.c_name, tpch.customer.c_acctbal, tpch.customer.c_phone, tpch.nation.n_name, tpch.customer.c_address, tpch.customer.c_comment
      └─HashLeftJoin_30	12222016.17	root	inner join, inner:TableReader_67, equal:[eq(tpch.customer.c_nationkey, tpch.nation.n_nationkey)]
        ├─IndexJoin_34	12222016.17	root	inner join, inner:TableReader_33, outer key:tpch.orders.o_custkey, inner key:tpch.customer.c_custkey
        │ ├─IndexJoin_42	12222016.17	root	inner join, inner:IndexLookUp_41, outer key:tpch.orders.o_orderkey, inner key:tpch.lineitem.l_orderkey
        │ │ ├─TableReader_60	3017307.69	root	data:Selection_59
        │ │ │ └─Selection_59	3017307.69	cop	ge(tpch.orders.o_orderdate, 1993-08-01 00:00:00.000000), lt(tpch.orders.o_orderdate, 1993-11-01)
        │ │ │   └─TableScan_58	75000000.00	cop	table:orders, range:[-inf,+inf], keep order:false
        │ │ └─IndexLookUp_41	0.25	root	
        │ │   ├─IndexScan_38	1.00	cop	table:lineitem, index:L_ORDERKEY, L_LINENUMBER, range: decided by [tpch.orders.o_orderkey], keep order:false
        │ │   └─Selection_40	0.25	cop	eq(tpch.lineitem.l_returnflag, "R")
        │ │     └─TableScan_39	1.00	cop	table:lineitem, keep order:false
        │ └─TableReader_33	1.00	root	data:TableScan_32
        │   └─TableScan_32	1.00	cop	table:customer, range: decided by [tpch.orders.o_custkey], keep order:false
        └─TableReader_67	25.00	root	data:TableScan_66
          └─TableScan_66	25.00	cop	table:nation, range:[-inf,+inf], keep order:false
/*
Q11 Important Stock Identification Query
This query finds the most important subset of suppliers' stock in a given nation.
The Important Stock Identification Query finds, from scanning the available stock of suppliers in a given nation, all
the parts that represent a significant percentage of the total value of all available parts. The query displays the part
number and the value of those parts in descending order of value.
*/
explain
select
ps_partkey,
sum(ps_supplycost * ps_availqty) as value
from
partsupp,
supplier,
nation
where
ps_suppkey = s_suppkey
and s_nationkey = n_nationkey
and n_name = 'MOZAMBIQUE'
group by
ps_partkey having
sum(ps_supplycost * ps_availqty) > (
select
sum(ps_supplycost * ps_availqty) * 0.0001000000
from
partsupp,
supplier,
nation
where
ps_suppkey = s_suppkey
and s_nationkey = n_nationkey
and n_name = 'MOZAMBIQUE'
)
order by
value desc;
id	count	task	operator info
Projection_50	1304801.67	root	tpch.partsupp.ps_partkey, value
└─Sort_51	1304801.67	root	value:desc
  └─Selection_53	1304801.67	root	gt(sel_agg_4, NULL)
    └─HashAgg_56	1631002.09	root	group by:col_2, funcs:sum(col_0), firstrow(col_1)
      └─Projection_75	1631002.09	root	mul(tpch.partsupp.ps_supplycost, cast(tpch.partsupp.ps_availqty)), tpch.partsupp.ps_partkey, tpch.partsupp.ps_partkey
        └─HashRightJoin_60	1631002.09	root	inner join, inner:HashRightJoin_66, equal:[eq(tpch.supplier.s_suppkey, tpch.partsupp.ps_suppkey)]
          ├─HashRightJoin_66	20000.00	root	inner join, inner:TableReader_71, equal:[eq(tpch.nation.n_nationkey, tpch.supplier.s_nationkey)]
          │ ├─TableReader_71	1.00	root	data:Selection_70
          │ │ └─Selection_70	1.00	cop	eq(tpch.nation.n_name, "MOZAMBIQUE")
          │ │   └─TableScan_69	25.00	cop	table:nation, range:[-inf,+inf], keep order:false
          │ └─TableReader_68	500000.00	root	data:TableScan_67
          │   └─TableScan_67	500000.00	cop	table:supplier, range:[-inf,+inf], keep order:false
          └─TableReader_73	40000000.00	root	data:TableScan_72
            └─TableScan_72	40000000.00	cop	table:partsupp, range:[-inf,+inf], keep order:false
/*
Q12 Shipping Modes and Order Priority Query
This query determines whether selecting less expensive modes of shipping is negatively affecting the critical-priority
orders by causing more parts to be received by customers after the committed date.
The Shipping Modes and Order Priority Query counts, by ship mode, for lineitems actually received by customers in
a given year, the number of lineitems belonging to orders for which the l_receiptdate exceeds the l_commitdate for
two different specified ship modes. Only lineitems that were actually shipped before the l_commitdate are considered.
The late lineitems are partitioned into two groups, those with priority URGENT or HIGH, and those with a
priority other than URGENT or HIGH.
*/
explain
select
l_shipmode,
sum(case
when o_orderpriority = '1-URGENT'
or o_orderpriority = '2-HIGH'
then 1
else 0
end) as high_line_count,
sum(case
when o_orderpriority <> '1-URGENT'
and o_orderpriority <> '2-HIGH'
then 1
else 0
end) as low_line_count
from
orders,
lineitem
where
o_orderkey = l_orderkey
and l_shipmode in ('RAIL', 'FOB')
and l_commitdate < l_receiptdate
and l_shipdate < l_commitdate
and l_receiptdate >= '1997-01-01'
and l_receiptdate < date_add('1997-01-01', interval '1' year)
group by
l_shipmode
order by
l_shipmode;
id	count	task	operator info
Sort_9	1.00	root	tpch.lineitem.l_shipmode:asc
└─Projection_11	1.00	root	tpch.lineitem.l_shipmode, 5_col_0, 5_col_1
  └─HashAgg_14	1.00	root	group by:col_3, funcs:sum(col_0), sum(col_1), firstrow(col_2)
    └─Projection_40	10023369.01	root	cast(case(or(eq(tpch.orders.o_orderpriority, "1-URGENT"), eq(tpch.orders.o_orderpriority, "2-HIGH")), 1, 0)), cast(case(and(ne(tpch.orders.o_orderpriority, "1-URGENT"), ne(tpch.orders.o_orderpriority, "2-HIGH")), 1, 0)), tpch.lineitem.l_shipmode, tpch.lineitem.l_shipmode
      └─IndexJoin_18	10023369.01	root	inner join, inner:TableReader_17, outer key:tpch.lineitem.l_orderkey, inner key:tpch.orders.o_orderkey
        ├─TableReader_36	10023369.01	root	data:Selection_35
        │ └─Selection_35	10023369.01	cop	ge(tpch.lineitem.l_receiptdate, 1997-01-01 00:00:00.000000), in(tpch.lineitem.l_shipmode, "RAIL", "FOB"), lt(tpch.lineitem.l_commitdate, tpch.lineitem.l_receiptdate), lt(tpch.lineitem.l_receiptdate, 1998-01-01), lt(tpch.lineitem.l_shipdate, tpch.lineitem.l_commitdate)
        │   └─TableScan_34	300005811.00	cop	table:lineitem, range:[-inf,+inf], keep order:false
        └─TableReader_17	1.00	root	data:TableScan_16
          └─TableScan_16	1.00	cop	table:orders, range: decided by [tpch.lineitem.l_orderkey], keep order:false
/*
Q13 Customer Distribution Query
This query seeks relationships between customers and the size of their orders.
This query determines the distribution of customers by the number of orders they have made, including customers
who have no record of orders, past or present. It counts and reports how many customers have no orders, how many
have 1, 2, 3, etc. A check is made to ensure that the orders counted do not fall into one of several special categories
of orders. Special categories are identified in the order comment column by looking for a particular pattern.
*/
explain
select
c_count,
count(*) as custdist
from
(
select
c_custkey,
count(o_orderkey) as c_count
from
customer left outer join orders on
c_custkey = o_custkey
and o_comment not like '%pending%deposits%'
group by
c_custkey
) c_orders
group by
c_count
order by
custdist desc,
c_count desc;
id	count	task	operator info
Sort_9	7500000.00	root	custdist:desc, c_orders.c_count:desc
└─Projection_11	7500000.00	root	c_count, 6_col_0
  └─HashAgg_14	7500000.00	root	group by:c_count, funcs:count(1), firstrow(c_count)
    └─HashAgg_17	7500000.00	root	group by:tpch.customer.c_custkey, funcs:count(tpch.orders.o_orderkey)
      └─HashLeftJoin_20	60000000.00	root	left outer join, inner:TableReader_25, equal:[eq(tpch.customer.c_custkey, tpch.orders.o_custkey)]
        ├─TableReader_22	7500000.00	root	data:TableScan_21
        │ └─TableScan_21	7500000.00	cop	table:customer, range:[-inf,+inf], keep order:false
        └─TableReader_25	60000000.00	root	data:Selection_24
          └─Selection_24	60000000.00	cop	not(like(tpch.orders.o_comment, "%pending%deposits%", 92))
            └─TableScan_23	75000000.00	cop	table:orders, range:[-inf,+inf], keep order:false
/*
Q14 Promotion Effect Query
This query monitors the market response to a promotion such as TV advertisements or a special campaign.
The Promotion Effect Query determines what percentage of the revenue in a given year and month was derived from
promotional parts. The query considers only parts actually shipped in that month and gives the percentage. Revenue
is defined as (l_extendedprice * (1-l_discount)).
*/
explain
select
100.00 * sum(case
when p_type like 'PROMO%'
then l_extendedprice * (1 - l_discount)
else 0
end) / sum(l_extendedprice * (1 - l_discount)) as promo_revenue
from
lineitem,
part
where
l_partkey = p_partkey
and l_shipdate >= '1996-12-01'
and l_shipdate < date_add('1996-12-01', interval '1' month);
id	count	task	operator info
Projection_8	1.00	root	div(mul(100.00, 5_col_0), 5_col_1)
└─StreamAgg_13	1.00	root	funcs:sum(col_0), sum(col_1)
  └─Projection_29	4121984.49	root	case(like(tpch.part.p_type, "PROMO%", 92), mul(tpch.lineitem.l_extendedprice, minus(1, tpch.lineitem.l_discount)), 0), mul(tpch.lineitem.l_extendedprice, minus(1, tpch.lineitem.l_discount))
    └─IndexJoin_26	4121984.49	root	inner join, inner:TableReader_25, outer key:tpch.lineitem.l_partkey, inner key:tpch.part.p_partkey
      ├─TableReader_21	4121984.49	root	data:Selection_20
      │ └─Selection_20	4121984.49	cop	ge(tpch.lineitem.l_shipdate, 1996-12-01 00:00:00.000000), lt(tpch.lineitem.l_shipdate, 1997-01-01)
      │   └─TableScan_19	300005811.00	cop	table:lineitem, range:[-inf,+inf], keep order:false
      └─TableReader_25	1.00	root	data:TableScan_24
        └─TableScan_24	1.00	cop	table:part, range: decided by [tpch.lineitem.l_partkey], keep order:false
/*
Q15 Top Supplier Query
This query determines the top supplier so it can be rewarded, given more business, or identified for special recognition.
The Top Supplier Query finds the supplier who contributed the most to the overall revenue for parts shipped during
a given quarter of a given year. In case of a tie, the query lists all suppliers whose contribution was equal to the
maximum, presented in supplier number order.
Planner enhancement: support view.
create view revenue0 (supplier_no, total_revenue) as
select
l_suppkey,
sum(l_extendedprice * (1 - l_discount))
from
lineitem
where
l_shipdate >= '1997-07-01'
and l_shipdate < date_add('1997-07-01', interval '3' month)
group by
l_suppkey
select
s_suppkey,
s_name,
s_address,
s_phone,
total_revenue
from
supplier,
revenue0
where
s_suppkey = supplier_no
and total_revenue = (
select
max(total_revenue)
from
revenue0
)
order by
s_suppkey
drop view revenue0
*/
/*
Q16 Parts/Supplier Relationship Query
This query finds out how many suppliers can supply parts with given attributes. It might be used, for example, to
determine whether there is a sufficient number of suppliers for heavily ordered parts.
The Parts/Supplier Relationship Query counts the number of suppliers who can supply parts that satisfy a particular
customer's requirements. The customer is interested in parts of eight different sizes as long as they are not of a given
type, not of a given brand, and not from a supplier who has had complaints registered at the Better Business Bureau.
Results must be presented in descending count and ascending brand, type, and size.
*/
explain
select
p_brand,
p_type,
p_size,
count(distinct ps_suppkey) as supplier_cnt
from
partsupp,
part
where
p_partkey = ps_partkey
and p_brand <> 'Brand#34'
and p_type not like 'LARGE BRUSHED%'
and p_size in (48, 19, 12, 4, 41, 7, 21, 39)
and ps_suppkey not in (
select
s_suppkey
from
supplier
where
s_comment like '%Customer%Complaints%'
)
group by
p_brand,
p_type,
p_size
order by
supplier_cnt desc,
p_brand,
p_type,
p_size;
id	count	task	operator info
Sort_13	14.41	root	supplier_cnt:desc, tpch.part.p_brand:asc, tpch.part.p_type:asc, tpch.part.p_size:asc
└─Projection_14	14.41	root	tpch.part.p_brand, tpch.part.p_type, tpch.part.p_size, 9_col_0
  └─HashAgg_17	14.41	root	group by:tpch.part.p_brand, tpch.part.p_size, tpch.part.p_type, funcs:count(distinct tpch.partsupp.ps_suppkey), firstrow(tpch.part.p_brand), firstrow(tpch.part.p_type), firstrow(tpch.part.p_size)
    └─HashLeftJoin_22	3863988.24	root	anti semi join, inner:TableReader_45, equal:[eq(tpch.partsupp.ps_suppkey, tpch.supplier.s_suppkey)]
      ├─IndexJoin_26	4829985.30	root	inner join, inner:IndexReader_25, outer key:tpch.part.p_partkey, inner key:tpch.partsupp.ps_partkey
      │ ├─TableReader_40	1200618.43	root	data:Selection_39
      │ │ └─Selection_39	1200618.43	cop	in(tpch.part.p_size, 48, 19, 12, 4, 41, 7, 21, 39), ne(tpch.part.p_brand, "Brand#34"), not(like(tpch.part.p_type, "LARGE BRUSHED%", 92))
      │ │   └─TableScan_38	10000000.00	cop	table:part, range:[-inf,+inf], keep order:false
      │ └─IndexReader_25	1.00	root	index:IndexScan_24
      │   └─IndexScan_24	1.00	cop	table:partsupp, index:PS_PARTKEY, PS_SUPPKEY, range: decided by [tpch.part.p_partkey], keep order:false
      └─TableReader_45	400000.00	root	data:Selection_44
        └─Selection_44	400000.00	cop	like(tpch.supplier.s_comment, "%Customer%Complaints%", 92)
          └─TableScan_43	500000.00	cop	table:supplier, range:[-inf,+inf], keep order:false
/*
Q17 Small-Quantity-Order Revenue Query
This query determines how much average yearly revenue would be lost if orders were no longer filled for small
quantities of certain parts. This may reduce overhead expenses by concentrating sales on larger shipments.
The Small-Quantity-Order Revenue Query considers parts of a given brand and with a given container type and
determines the average lineitem quantity of such parts ordered for all orders (past and pending) in the 7-year database.
What would be the average yearly gross (undiscounted) loss in revenue if orders for these parts with a quantity
of less than 20% of this average were no longer taken?
Planner enahancement: aggregation pull up through join.
*/
explain
select
sum(l_extendedprice) / 7.0 as avg_yearly
from
lineitem,
part
where
p_partkey = l_partkey
and p_brand = 'Brand#44'
and p_container = 'WRAP PKG'
and l_quantity < (
select
0.2 * avg(l_quantity)
from
lineitem
where
l_partkey = p_partkey
);
id	count	task	operator info
Projection_14	1.00	root	div(11_col_0, 7.0)
└─StreamAgg_19	1.00	root	funcs:sum(tpch.lineitem.l_extendedprice)
  └─Projection_42	293773.83	root	tpch.lineitem.l_partkey, tpch.lineitem.l_quantity, tpch.lineitem.l_extendedprice, tpch.part.p_partkey, tpch.part.p_brand, tpch.part.p_container, mul(0.2, 7_col_0)
    └─HashRightJoin_44	293773.83	root	inner join, inner:HashRightJoin_28, equal:[eq(tpch.part.p_partkey, tpch.lineitem.l_partkey)], other cond:lt(tpch.lineitem.l_quantity, mul(0.2, 7_col_0))
      ├─HashRightJoin_28	293773.83	root	inner join, inner:TableReader_33, equal:[eq(tpch.part.p_partkey, tpch.lineitem.l_partkey)]
      │ ├─TableReader_33	9736.49	root	data:Selection_32
      │ │ └─Selection_32	9736.49	cop	eq(tpch.part.p_brand, "Brand#44"), eq(tpch.part.p_container, "WRAP PKG")
      │ │   └─TableScan_31	10000000.00	cop	table:part, range:[-inf,+inf], keep order:false
      │ └─TableReader_30	300005811.00	root	data:TableScan_29
      │   └─TableScan_29	300005811.00	cop	table:lineitem, range:[-inf,+inf], keep order:false
      └─HashAgg_38	9943040.00	root	group by:col_3, funcs:avg(col_0, col_1), firstrow(col_2)
        └─TableReader_39	9943040.00	root	data:HashAgg_34
          └─HashAgg_34	9943040.00	cop	group by:tpch.lineitem.l_partkey, funcs:avg(tpch.lineitem.l_quantity), firstrow(tpch.lineitem.l_partkey)
            └─TableScan_37	300005811.00	cop	table:lineitem, range:[-inf,+inf], keep order:false
/*
Q18 Large Volume Customer Query
The Large Volume Customer Query ranks customers based on their having placed a large quantity order. Large
quantity orders are defined as those orders whose total quantity is above a certain level.
The Large Volume Customer Query finds a list of the top 100 customers who have ever placed large quantity orders.
The query lists the customer name, customer key, the order key, date and total price and the quantity for the order.
Planner enhancement: unfold in subquery.
*/
explain
select
c_name,
c_custkey,
o_orderkey,
o_orderdate,
o_totalprice,
sum(l_quantity)
from
customer,
orders,
lineitem
where
o_orderkey in (
select
l_orderkey
from
lineitem
group by
l_orderkey having
sum(l_quantity) > 314
)
and c_custkey = o_custkey
and o_orderkey = l_orderkey
group by
c_name,
c_custkey,
o_orderkey,
o_orderdate,
o_totalprice
order by
o_totalprice desc,
o_orderdate
limit 100;
id	count	task	operator info
Projection_20	100.00	root	tpch.customer.c_name, tpch.customer.c_custkey, tpch.orders.o_orderkey, tpch.orders.o_orderdate, tpch.orders.o_totalprice, 13_col_0
└─TopN_23	100.00	root	tpch.orders.o_totalprice:desc, tpch.orders.o_orderdate:asc, offset:0, count:100
  └─HashAgg_26	60000000.00	root	group by:tpch.customer.c_custkey, tpch.customer.c_name, tpch.orders.o_orderdate, tpch.orders.o_orderkey, tpch.orders.o_totalprice, funcs:sum(tpch.lineitem.l_quantity), firstrow(tpch.customer.c_custkey), firstrow(tpch.customer.c_name), firstrow(tpch.orders.o_orderkey), firstrow(tpch.orders.o_totalprice), firstrow(tpch.orders.o_orderdate)
    └─HashLeftJoin_27	240004648.80	root	semi join, inner:Selection_56, equal:[eq(tpch.orders.o_orderkey, tpch.lineitem.l_orderkey)]
      ├─IndexJoin_32	300005811.00	root	inner join, inner:IndexLookUp_31, outer key:tpch.orders.o_orderkey, inner key:tpch.lineitem.l_orderkey
      │ ├─HashRightJoin_49	75000000.00	root	inner join, inner:TableReader_53, equal:[eq(tpch.customer.c_custkey, tpch.orders.o_custkey)]
      │ │ ├─TableReader_53	7500000.00	root	data:TableScan_52
      │ │ │ └─TableScan_52	7500000.00	cop	table:customer, range:[-inf,+inf], keep order:false
      │ │ └─TableReader_51	75000000.00	root	data:TableScan_50
      │ │   └─TableScan_50	75000000.00	cop	table:orders, range:[-inf,+inf], keep order:false
      │ └─IndexLookUp_31	1.00	root	
      │   ├─IndexScan_29	1.00	cop	table:lineitem, index:L_ORDERKEY, L_LINENUMBER, range: decided by [tpch.orders.o_orderkey], keep order:false
      │   └─TableScan_30	1.00	cop	table:lineitem, keep order:false
      └─Selection_56	59251097.60	root	gt(sel_agg_2, 314)
        └─HashAgg_63	74063872.00	root	group by:col_2, funcs:sum(col_0), firstrow(col_1)
          └─TableReader_64	74063872.00	root	data:HashAgg_57
            └─HashAgg_57	74063872.00	cop	group by:tpch.lineitem.l_orderkey, funcs:sum(tpch.lineitem.l_quantity), firstrow(tpch.lineitem.l_orderkey)
              └─TableScan_62	300005811.00	cop	table:lineitem, range:[-inf,+inf], keep order:false
/*
Q19 Discounted Revenue Query
The Discounted Revenue Query reports the gross discounted revenue attributed to the sale of selected parts handled
in a particular manner. This query is an example of code such as might be produced programmatically by a data
mining tool.
The Discounted Revenue query finds the gross discounted revenue for all orders for three different types of parts
that were shipped by air and delivered in person. Parts are selected based on the combination of specific brands, a
list of containers, and a range of sizes.
*/
explain
select
sum(l_extendedprice* (1 - l_discount)) as revenue
from
lineitem,
part
where
(
p_partkey = l_partkey
and p_brand = 'Brand#52'
and p_container in ('SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')
and l_quantity >= 4 and l_quantity <= 4 + 10
and p_size between 1 and 5
and l_shipmode in ('AIR', 'AIR REG')
and l_shipinstruct = 'DELIVER IN PERSON'
)
or
(
p_partkey = l_partkey
and p_brand = 'Brand#11'
and p_container in ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')
and l_quantity >= 18 and l_quantity <= 18 + 10
and p_size between 1 and 10
and l_shipmode in ('AIR', 'AIR REG')
and l_shipinstruct = 'DELIVER IN PERSON'
)
or
(
p_partkey = l_partkey
and p_brand = 'Brand#51'
and p_container in ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')
and l_quantity >= 29 and l_quantity <= 29 + 10
and p_size between 1 and 15
and l_shipmode in ('AIR', 'AIR REG')
and l_shipinstruct = 'DELIVER IN PERSON'
);
id	count	task	operator info
StreamAgg_13	1.00	root	funcs:sum(col_0)
└─Projection_32	6286493.79	root	mul(tpch.lineitem.l_extendedprice, minus(1, tpch.lineitem.l_discount))
  └─IndexJoin_29	6286493.79	root	inner join, inner:TableReader_28, outer key:tpch.lineitem.l_partkey, inner key:tpch.part.p_partkey, other cond:or(and(and(eq(tpch.part.p_brand, "Brand#52"), in(tpch.part.p_container, "SM CASE", "SM BOX", "SM PACK", "SM PKG")), and(ge(tpch.lineitem.l_quantity, 4), and(le(tpch.lineitem.l_quantity, 14), le(tpch.part.p_size, 5)))), or(and(and(eq(tpch.part.p_brand, "Brand#11"), in(tpch.part.p_container, "MED BAG", "MED BOX", "MED PKG", "MED PACK")), and(ge(tpch.lineitem.l_quantity, 18), and(le(tpch.lineitem.l_quantity, 28), le(tpch.part.p_size, 10)))), and(and(eq(tpch.part.p_brand, "Brand#51"), in(tpch.part.p_container, "LG CASE", "LG BOX", "LG PACK", "LG PKG")), and(ge(tpch.lineitem.l_quantity, 29), and(le(tpch.lineitem.l_quantity, 39), le(tpch.part.p_size, 15))))))
    ├─TableReader_22	6286493.79	root	data:Selection_21
    │ └─Selection_21	6286493.79	cop	eq(tpch.lineitem.l_shipinstruct, "DELIVER IN PERSON"), in(tpch.lineitem.l_shipmode, "AIR", "AIR REG"), or(and(ge(tpch.lineitem.l_quantity, 4), le(tpch.lineitem.l_quantity, 14)), or(and(ge(tpch.lineitem.l_quantity, 18), le(tpch.lineitem.l_quantity, 28)), and(ge(tpch.lineitem.l_quantity, 29), le(tpch.lineitem.l_quantity, 39))))
    │   └─TableScan_20	300005811.00	cop	table:lineitem, range:[-inf,+inf], keep order:false
    └─TableReader_28	0.80	root	data:Selection_27
      └─Selection_27	0.80	cop	ge(tpch.part.p_size, 1), or(and(eq(tpch.part.p_brand, "Brand#52"), and(in(tpch.part.p_container, "SM CASE", "SM BOX", "SM PACK", "SM PKG"), le(tpch.part.p_size, 5))), or(and(eq(tpch.part.p_brand, "Brand#11"), and(in(tpch.part.p_container, "MED BAG", "MED BOX", "MED PKG", "MED PACK"), le(tpch.part.p_size, 10))), and(eq(tpch.part.p_brand, "Brand#51"), and(in(tpch.part.p_container, "LG CASE", "LG BOX", "LG PACK", "LG PKG"), le(tpch.part.p_size, 15)))))
        └─TableScan_26	1.00	cop	table:part, range: decided by [tpch.lineitem.l_partkey], keep order:false
/*
Q20 Potential Part Promotion Query
The Potential Part Promotion Query identifies suppliers in a particular nation having selected parts that may be candidates
for a promotional offer.
The Potential Part Promotion query identifies suppliers who have an excess of a given part available; an excess is
defined to be more than 50% of the parts like the given part that the supplier shipped in a given year for a given
nation. Only parts whose names share a certain naming convention are considered.
*/
explain
select
s_name,
s_address
from
supplier,
nation
where
s_suppkey in (
select
ps_suppkey
from
partsupp
where
ps_partkey in (
select
p_partkey
from
part
where
p_name like 'green%'
)
and ps_availqty > (
select
0.5 * sum(l_quantity)
from
lineitem
where
l_partkey = ps_partkey
and l_suppkey = ps_suppkey
and l_shipdate >= '1993-01-01'
and l_shipdate < date_add('1993-01-01', interval '1' year)
)
)
and s_nationkey = n_nationkey
and n_name = 'ALGERIA'
order by
s_name;
id	count	task	operator info
Sort_23	16000.00	root	tpch.supplier.s_name:asc
└─Projection_25	16000.00	root	tpch.supplier.s_name, tpch.supplier.s_address
  └─HashLeftJoin_26	16000.00	root	semi join, inner:Projection_38, equal:[eq(tpch.supplier.s_suppkey, tpch.partsupp.ps_suppkey)]
    ├─HashRightJoin_32	20000.00	root	inner join, inner:TableReader_37, equal:[eq(tpch.nation.n_nationkey, tpch.supplier.s_nationkey)]
    │ ├─TableReader_37	1.00	root	data:Selection_36
    │ │ └─Selection_36	1.00	cop	eq(tpch.nation.n_name, "ALGERIA")
    │ │   └─TableScan_35	25.00	cop	table:nation, range:[-inf,+inf], keep order:false
    │ └─TableReader_34	500000.00	root	data:TableScan_33
    │   └─TableScan_33	500000.00	cop	table:supplier, range:[-inf,+inf], keep order:false
    └─Projection_38	6363545.60	root	tpch.partsupp.ps_partkey, tpch.partsupp.ps_suppkey, tpch.partsupp.ps_availqty, mul(0.5, 13_col_0)
      └─Selection_39	6363545.60	root	gt(cast(tpch.partsupp.ps_availqty), mul(0.5, 13_col_0))
        └─HashAgg_42	7954432.00	root	group by:tpch.partsupp.ps_partkey, tpch.partsupp.ps_suppkey, funcs:firstrow(tpch.partsupp.ps_partkey), firstrow(tpch.partsupp.ps_suppkey), firstrow(tpch.partsupp.ps_availqty), sum(tpch.lineitem.l_quantity)
          └─HashLeftJoin_45	177770004.55	root	left outer join, inner:TableReader_67, equal:[eq(tpch.partsupp.ps_partkey, tpch.lineitem.l_partkey) eq(tpch.partsupp.ps_suppkey, tpch.lineitem.l_suppkey)]
            ├─MergeJoin_46	32000000.00	root	semi join, left key:tpch.partsupp.ps_partkey, right key:tpch.part.p_partkey
            │ ├─Projection_56	40000000.00	root	tpch.partsupp.ps_partkey, tpch.partsupp.ps_suppkey, tpch.partsupp.ps_availqty
            │ │ └─IndexLookUp_55	40000000.00	root	
            │ │   ├─IndexScan_53	40000000.00	cop	table:partsupp, index:PS_PARTKEY, PS_SUPPKEY, range:[NULL,+inf], keep order:true
            │ │   └─TableScan_54	40000000.00	cop	table:partsupp, keep order:false
            │ └─TableReader_59	80007.93	root	data:Selection_58
            │   └─Selection_58	80007.93	cop	like(tpch.part.p_name, "green%", 92)
            │     └─TableScan_57	10000000.00	cop	table:part, range:[-inf,+inf], keep order:true
            └─TableReader_67	44189356.65	root	data:Selection_66
              └─Selection_66	44189356.65	cop	ge(tpch.lineitem.l_shipdate, 1993-01-01 00:00:00.000000), lt(tpch.lineitem.l_shipdate, 1994-01-01)
                └─TableScan_65	300005811.00	cop	table:lineitem, range:[-inf,+inf], keep order:false
/*
Q21 Suppliers Who Kept Orders Waiting Query
This query identifies certain suppliers who were not able to ship required parts in a timely manner.
The Suppliers Who Kept Orders Waiting query identifies suppliers, for a given nation, whose product was part of a
multi-supplier order (with current status of 'F') where they were the only supplier who failed to meet the committed
delivery date.
*/
explain
select
s_name,
count(*) as numwait
from
supplier,
lineitem l1,
orders,
nation
where
s_suppkey = l1.l_suppkey
and o_orderkey = l1.l_orderkey
and o_orderstatus = 'F'
and l1.l_receiptdate > l1.l_commitdate
and exists (
select
*
from
lineitem l2
where
l2.l_orderkey = l1.l_orderkey
and l2.l_suppkey <> l1.l_suppkey
)
and not exists (
select
*
from
lineitem l3
where
l3.l_orderkey = l1.l_orderkey
and l3.l_suppkey <> l1.l_suppkey
and l3.l_receiptdate > l3.l_commitdate
)
and s_nationkey = n_nationkey
and n_name = 'EGYPT'
group by
s_name
order by
numwait desc,
s_name
limit 100;
id	count	task	operator info
Projection_25	100.00	root	tpch.supplier.s_name, 17_col_0
└─TopN_28	100.00	root	17_col_0:desc, tpch.supplier.s_name:asc, offset:0, count:100
  └─HashAgg_31	320000.00	root	group by:tpch.supplier.s_name, funcs:count(1), firstrow(tpch.supplier.s_name)
    └─IndexJoin_37	3786715.90	root	anti semi join, inner:IndexLookUp_36, outer key:tpch.l1.l_orderkey, inner key:tpch.l3.l_orderkey, other cond:ne(tpch.l3.l_suppkey, tpch.l1.l_suppkey)
      ├─IndexJoin_84	4733394.87	root	semi join, inner:IndexLookUp_83, outer key:tpch.l1.l_orderkey, inner key:tpch.l2.l_orderkey, other cond:ne(tpch.l2.l_suppkey, tpch.l1.l_suppkey), ne(tpch.l2.l_suppkey, tpch.supplier.s_suppkey)
      │ ├─HashLeftJoin_90	5916743.59	root	inner join, inner:TableReader_119, equal:[eq(tpch.supplier.s_nationkey, tpch.nation.n_nationkey)]
      │ │ ├─HashLeftJoin_95	147918589.81	root	inner join, inner:TableReader_116, equal:[eq(tpch.l1.l_suppkey, tpch.supplier.s_suppkey)]
      │ │ │ ├─IndexJoin_102	147918589.81	root	inner join, inner:IndexLookUp_101, outer key:tpch.orders.o_orderkey, inner key:tpch.l1.l_orderkey
      │ │ │ │ ├─TableReader_111	36517371.00	root	data:Selection_110
      │ │ │ │ │ └─Selection_110	36517371.00	cop	eq(tpch.orders.o_orderstatus, "F")
      │ │ │ │ │   └─TableScan_109	75000000.00	cop	table:orders, range:[-inf,+inf], keep order:false
      │ │ │ │ └─IndexLookUp_101	0.80	root	
      │ │ │ │   ├─IndexScan_98	1.00	cop	table:l1, index:L_ORDERKEY, L_LINENUMBER, range: decided by [tpch.orders.o_orderkey], keep order:false
      │ │ │ │   └─Selection_100	0.80	cop	gt(tpch.l1.l_receiptdate, tpch.l1.l_commitdate)
      │ │ │ │     └─TableScan_99	1.00	cop	table:lineitem, keep order:false
      │ │ │ └─TableReader_116	500000.00	root	data:TableScan_115
      │ │ │   └─TableScan_115	500000.00	cop	table:supplier, range:[-inf,+inf], keep order:false
      │ │ └─TableReader_119	1.00	root	data:Selection_118
      │ │   └─Selection_118	1.00	cop	eq(tpch.nation.n_name, "EGYPT")
      │ │     └─TableScan_117	25.00	cop	table:nation, range:[-inf,+inf], keep order:false
      │ └─IndexLookUp_83	1.00	root	
      │   ├─IndexScan_81	1.00	cop	table:l2, index:L_ORDERKEY, L_LINENUMBER, range: decided by [tpch.l1.l_orderkey], keep order:false
      │   └─TableScan_82	1.00	cop	table:lineitem, keep order:false
      └─IndexLookUp_36	0.80	root	
        ├─IndexScan_33	1.00	cop	table:l3, index:L_ORDERKEY, L_LINENUMBER, range: decided by [tpch.l1.l_orderkey], keep order:false
        └─Selection_35	0.80	cop	gt(tpch.l3.l_receiptdate, tpch.l3.l_commitdate)
          └─TableScan_34	1.00	cop	table:lineitem, keep order:false
/*
Q22 Global Sales Opportunity Query
The Global Sales Opportunity Query identifies geographies where there are customers who may be likely to make a
purchase.
This query counts how many customers within a specific range of country codes have not placed orders for 7 years
but who have a greater than average “positive” account balance. It also reflects the magnitude of that balance.
Country code is defined as the first two characters of c_phone.
*/
explain
select
cntrycode,
count(*) as numcust,
sum(c_acctbal) as totacctbal
from
(
select
substring(c_phone from 1 for 2) as cntrycode,
c_acctbal
from
customer
where
substring(c_phone from 1 for 2) in
('20', '40', '22', '30', '39', '42', '21')
and c_acctbal > (
select
avg(c_acctbal)
from
customer
where
c_acctbal > 0.00
and substring(c_phone from 1 for 2) in
('20', '40', '22', '30', '39', '42', '21')
)
and not exists (
select
*
from
orders
where
o_custkey = c_custkey
)
) as custsale
group by
cntrycode
order by
cntrycode;
id	count	task	operator info
Sort_32	1.00	root	custsale.cntrycode:asc
└─Projection_34	1.00	root	custsale.cntrycode, 28_col_0, 28_col_1
  └─HashAgg_37	1.00	root	group by:custsale.cntrycode, funcs:count(1), sum(tpch.custsale.c_acctbal), firstrow(custsale.cntrycode)
    └─Projection_38	0.00	root	substring(tpch.customer.c_phone, 1, 2), tpch.customer.c_acctbal
      └─HashLeftJoin_39	0.00	root	anti semi join, inner:TableReader_45, equal:[eq(tpch.customer.c_custkey, tpch.orders.o_custkey)]
        ├─Selection_40	0.00	root	in(substring(tpch.customer.c_phone, 1, 2), "20", "40", "22", "30", "39", "42", "21")
        │ └─TableReader_43	0.00	root	data:Selection_42
        │   └─Selection_42	0.00	cop	gt(tpch.customer.c_acctbal, NULL)
        │     └─TableScan_41	7500000.00	cop	table:customer, range:[-inf,+inf], keep order:false
        └─TableReader_45	75000000.00	root	data:TableScan_44
          └─TableScan_44	75000000.00	cop	table:orders, range:[-inf,+inf], keep order:false
