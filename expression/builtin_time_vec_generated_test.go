// Copyright 2019 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by go generate in expression/generator; DO NOT EDIT.

package expression

import (
	"math"
	"testing"

	. "github.com/pingcap/check"
	"github.com/pingcap/parser/ast"
	"github.com/pingcap/parser/mysql"
	"github.com/pingcap/tidb/types"
)

type gener struct {
	defaultGener
}

func (g gener) gen() interface{} {
	result := g.defaultGener.gen()
	if _, ok := result.(string); ok {
		dg := newDefaultGener(0, types.ETDuration)
		d := dg.gen().(types.Duration)
		if int8(d.Duration)%2 == 0 {
			d.Fsp = 0
		} else {
			d.Fsp = 1
		}
		result = d.String()
	}
	return result
}

var vecBuiltinTimeGeneratedCases = map[string][]vecExprBenchCase{
	ast.AddTime: {
		// builtinAddDatetimeAndDurationSig
		{
			retEvalType:   types.ETDatetime,
			childrenTypes: []types.EvalType{types.ETDatetime, types.ETDuration},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDatetime)},
				gener{*newDefaultGener(0.2, types.ETDuration)},
			},
		},
		// builtinAddDatetimeAndStringSig
		{
			retEvalType:   types.ETDatetime,
			childrenTypes: []types.EvalType{types.ETDatetime, types.ETString},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDatetime)},
				gener{*newDefaultGener(0.2, types.ETString)},
			},
		},
		// builtinAddDurationAndDurationSig
		{
			retEvalType:   types.ETDuration,
			childrenTypes: []types.EvalType{types.ETDuration, types.ETDuration},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDuration)},
				gener{*newDefaultGener(0.2, types.ETDuration)},
			},
		},
		// builtinAddDurationAndStringSig
		{
			retEvalType:   types.ETDuration,
			childrenTypes: []types.EvalType{types.ETDuration, types.ETString},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDuration)},
				gener{*newDefaultGener(0.2, types.ETString)},
			},
		},
		// builtinAddStringAndDurationSig
		{
			retEvalType:   types.ETString,
			childrenTypes: []types.EvalType{types.ETString, types.ETDuration},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETString)},
				gener{*newDefaultGener(0.2, types.ETDuration)},
			},
		},
		// builtinAddStringAndStringSig
		{
			retEvalType:   types.ETString,
			childrenTypes: []types.EvalType{types.ETString, types.ETString},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETString)},
				gener{*newDefaultGener(0.2, types.ETString)},
			},
		},
		// builtinAddDateAndDurationSig
		{
			retEvalType:        types.ETString,
			childrenTypes:      []types.EvalType{types.ETDatetime, types.ETDuration},
			childrenFieldTypes: []*types.FieldType{types.NewFieldType(mysql.TypeDate), types.NewFieldType(mysql.TypeDuration)},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDatetime)},
				gener{*newDefaultGener(0.2, types.ETDuration)},
			},
		},
		// builtinAddDateAndStringSig
		{
			retEvalType:        types.ETString,
			childrenTypes:      []types.EvalType{types.ETDatetime, types.ETString},
			childrenFieldTypes: []*types.FieldType{types.NewFieldType(mysql.TypeDate), types.NewFieldType(mysql.TypeString)},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDatetime)},
				gener{*newDefaultGener(0.2, types.ETString)},
			},
		},
		// builtinAddTimeDateTimeNullSig
		{
			retEvalType:   types.ETDatetime,
			childrenTypes: []types.EvalType{types.ETDatetime, types.ETDatetime},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDatetime)},
				gener{*newDefaultGener(0.2, types.ETDatetime)},
			},
		},
		// builtinAddTimeStringNullSig
		{
			retEvalType:        types.ETString,
			childrenTypes:      []types.EvalType{types.ETDatetime, types.ETDatetime},
			childrenFieldTypes: []*types.FieldType{types.NewFieldType(mysql.TypeDate), types.NewFieldType(mysql.TypeDatetime)},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDatetime)},
				gener{*newDefaultGener(0.2, types.ETDatetime)},
			},
		},
		// builtinAddTimeDurationNullSig
		{
			retEvalType:   types.ETDuration,
			childrenTypes: []types.EvalType{types.ETDuration, types.ETDatetime},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDuration)},
				gener{*newDefaultGener(0.2, types.ETDatetime)},
			},
		},
	},

	ast.SubTime: {
		// builtinSubDatetimeAndDurationSig
		{
			retEvalType:   types.ETDatetime,
			childrenTypes: []types.EvalType{types.ETDatetime, types.ETDuration},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDatetime)},
				gener{*newDefaultGener(0.2, types.ETDuration)},
			},
		},
		// builtinSubDatetimeAndStringSig
		{
			retEvalType:   types.ETDatetime,
			childrenTypes: []types.EvalType{types.ETDatetime, types.ETString},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDatetime)},
				gener{*newDefaultGener(0.2, types.ETString)},
			},
		},
		// builtinSubDurationAndDurationSig
		{
			retEvalType:   types.ETDuration,
			childrenTypes: []types.EvalType{types.ETDuration, types.ETDuration},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDuration)},
				gener{*newDefaultGener(0.2, types.ETDuration)},
			},
		},
		// builtinSubDurationAndStringSig
		{
			retEvalType:   types.ETDuration,
			childrenTypes: []types.EvalType{types.ETDuration, types.ETString},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDuration)},
				gener{*newDefaultGener(0.2, types.ETString)},
			},
		},
		// builtinSubStringAndDurationSig
		{
			retEvalType:   types.ETString,
			childrenTypes: []types.EvalType{types.ETString, types.ETDuration},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETString)},
				gener{*newDefaultGener(0.2, types.ETDuration)},
			},
		},
		// builtinSubStringAndStringSig
		{
			retEvalType:   types.ETString,
			childrenTypes: []types.EvalType{types.ETString, types.ETString},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETString)},
				gener{*newDefaultGener(0.2, types.ETString)},
			},
		},
		// builtinSubDateAndDurationSig
		{
			retEvalType:        types.ETString,
			childrenTypes:      []types.EvalType{types.ETDatetime, types.ETDuration},
			childrenFieldTypes: []*types.FieldType{types.NewFieldType(mysql.TypeDate), types.NewFieldType(mysql.TypeDuration)},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDatetime)},
				gener{*newDefaultGener(0.2, types.ETDuration)},
			},
		},
		// builtinSubDateAndStringSig
		{
			retEvalType:        types.ETString,
			childrenTypes:      []types.EvalType{types.ETDatetime, types.ETString},
			childrenFieldTypes: []*types.FieldType{types.NewFieldType(mysql.TypeDate), types.NewFieldType(mysql.TypeString)},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDatetime)},
				gener{*newDefaultGener(0.2, types.ETString)},
			},
		},
		// builtinSubTimeDateTimeNullSig
		{
			retEvalType:   types.ETDatetime,
			childrenTypes: []types.EvalType{types.ETDatetime, types.ETDatetime},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDatetime)},
				gener{*newDefaultGener(0.2, types.ETDatetime)},
			},
		},
		// builtinSubTimeStringNullSig
		{
			retEvalType:        types.ETString,
			childrenTypes:      []types.EvalType{types.ETDatetime, types.ETDatetime},
			childrenFieldTypes: []*types.FieldType{types.NewFieldType(mysql.TypeDate), types.NewFieldType(mysql.TypeDatetime)},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDatetime)},
				gener{*newDefaultGener(0.2, types.ETDatetime)},
			},
		},
		// builtinSubTimeDurationNullSig
		{
			retEvalType:   types.ETDuration,
			childrenTypes: []types.EvalType{types.ETDuration, types.ETDatetime},
			geners: []dataGenerator{
				gener{*newDefaultGener(0.2, types.ETDuration)},
				gener{*newDefaultGener(0.2, types.ETDatetime)},
			},
		},
	},

	ast.TimeDiff: {
		// builtinNullTimeDiffSig
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETDuration, types.ETDatetime}},
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETDuration, types.ETTimestamp}},
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETDatetime, types.ETDuration}},
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETTimestamp, types.ETDuration}},
		// builtinDurationDurationTimeDiffSig
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETDuration, types.ETDuration}},
		// builtinDurationStringTimeDiffSig
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETDuration, types.ETString}, geners: []dataGenerator{nil, &dateTimeStrGener{Year: 2019, Month: 11, randGen: newDefaultRandGen()}}},
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETDuration, types.ETString}, geners: []dataGenerator{nil, &dateTimeStrGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}}},
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETDuration, types.ETString}, geners: []dataGenerator{nil, &dateTimeStrGener{Year: 2019, Month: 10, Fsp: 4, randGen: newDefaultRandGen()}}},
		// builtinTimeTimeTimeDiffSig
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETDatetime, types.ETDatetime}, geners: []dataGenerator{&dateTimeGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}, &dateTimeGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}}},
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETDatetime, types.ETTimestamp}, geners: []dataGenerator{&dateTimeGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}, &dateTimeGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}}},
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETTimestamp, types.ETTimestamp}, geners: []dataGenerator{&dateTimeGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}, &dateTimeGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}}},
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETTimestamp, types.ETDatetime}, geners: []dataGenerator{&dateTimeGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}, &dateTimeGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}}},
		// builtinTimeStringTimeDiffSig
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETDatetime, types.ETString}, geners: []dataGenerator{&dateTimeGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}, &dateTimeStrGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}}},
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETTimestamp, types.ETString}, geners: []dataGenerator{&dateTimeGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}, &dateTimeStrGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}}},
		// builtinStringDurationTimeDiffSig
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETString, types.ETDuration}, geners: []dataGenerator{&dateTimeStrGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}, nil}},
		// builtinStringTimeTimeDiffSig
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETString, types.ETDatetime}, geners: []dataGenerator{&dateTimeStrGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}, &dateTimeGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}}},
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETString, types.ETTimestamp}, geners: []dataGenerator{&dateTimeStrGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}, &dateTimeGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}}},
		// builtinStringStringTimeDiffSig
		{retEvalType: types.ETDuration, childrenTypes: []types.EvalType{types.ETString, types.ETString}, geners: []dataGenerator{&dateTimeStrGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}, &dateTimeStrGener{Year: 2019, Month: 10, randGen: newDefaultRandGen()}}},
	},
}

func (s *testVectorizeSuite1) TestVectorizedBuiltinTimeEvalOneVecGenerated(c *C) {
	testVectorizedEvalOneVec(c, vecBuiltinTimeGeneratedCases)
}

func (s *testVectorizeSuite1) TestVectorizedBuiltinTimeFuncGenerated(c *C) {
	testVectorizedBuiltinFunc(c, vecBuiltinTimeGeneratedCases)
}

func BenchmarkVectorizedBuiltinTimeEvalOneVecGenerated(b *testing.B) {
	benchmarkVectorizedEvalOneVec(b, vecBuiltinTimeGeneratedCases)
}

func BenchmarkVectorizedBuiltinTimeFuncGenerated(b *testing.B) {
	benchmarkVectorizedBuiltinFunc(b, vecBuiltinTimeGeneratedCases)
}

var unitForAddSubDate = []string{"MICROSECOND", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR", "SECOND_MICROSECOND", "MINUTE_MICROSECOND", "MINUTE_SECOND", "HOUR_MICROSECOND", "HOUR_SECOND", "HOUR_MINUTE", "DAY_MICROSECOND", "DAY_SECOND", "DAY_MINUTE", "DAY_HOUR", "YEAR_MONTH"}

func genVecExprBenchCaseForAddSubDate(funcName string, unit string) map[string][]vecExprBenchCase {
	tps := [][]types.EvalType{
		// retType, arg0Type, arg1Type
		{types.ETDatetime, types.ETString, types.ETString},    // builtinAddDateStringStringSig
		{types.ETDatetime, types.ETString, types.ETInt},       // builtinAddDateStringIntSig
		{types.ETDatetime, types.ETString, types.ETReal},      // builtinAddDateStringRealSig
		{types.ETDatetime, types.ETString, types.ETDecimal},   // builtinAddDateStringDecimalSig
		{types.ETDatetime, types.ETString, types.ETInt},       // builtinAddDateIntStringSig
		{types.ETDatetime, types.ETInt, types.ETInt},          // builtinAddDateIntIntSig
		{types.ETDatetime, types.ETInt, types.ETReal},         // builtinAddDateIntRealSig
		{types.ETDatetime, types.ETInt, types.ETDecimal},      // builtinAddDateIntDecimalSig
		{types.ETDatetime, types.ETDatetime, types.ETString},  // builtinAddDateDatetimeStringSig
		{types.ETDatetime, types.ETDatetime, types.ETInt},     // builtinAddDateDatetimeIntSig
		{types.ETDatetime, types.ETDatetime, types.ETInt},     // builtinAddDateDatetimeRealSig
		{types.ETDatetime, types.ETDatetime, types.ETInt},     // builtinAddDateDatetimeDecimalSig
		{types.ETDuration, types.ETDuration, types.ETString},  // builtinAddDateDurationStringSig
		{types.ETDuration, types.ETDuration, types.ETInt},     // builtinAddDateDurationIntSig
		{types.ETDuration, types.ETDuration, types.ETReal},    // builtinAddDateDurationRealSig
		{types.ETDuration, types.ETDuration, types.ETDecimal}, // builtinAddDateDurationDecimalSig
	}
	var benchCase []vecExprBenchCase
	for _, tp := range tps {
		var geners []dataGenerator
		switch tp[1] {
		case types.ETString:
			geners = append(geners, &dateStrGener{NullRation: 0.2, randGen: newDefaultRandGen()})
		case types.ETInt:
			geners = append(geners, &dateTimeIntGener{dateTimeGener: dateTimeGener{randGen: newDefaultRandGen()}, nullRation: 0.2})
		case types.ETDatetime:
			geners = append(geners, newDefaultGener(0.2, types.ETDatetime))
		case types.ETDuration:
			geners = append(geners, newDefaultGener(0.2, types.ETDuration))
		}
		switch tp[2] {
		case types.ETInt:
			geners = append(geners, newDefaultGener(0.2, types.ETInt))
		case types.ETReal:
			geners = append(geners, newDefaultGener(0.2, types.ETReal))
		case types.ETString:
			geners = append(geners, &numStrGener{rangeInt64Gener{math.MinInt32 + 1, math.MaxInt32, newDefaultRandGen()}})
		case types.ETDecimal:
			geners = append(geners, newDefaultGener(0.2, types.ETDecimal))
		}
		benchCase = append(benchCase,
			vecExprBenchCase{
				retEvalType:   tp[0],
				childrenTypes: []types.EvalType{tp[1], tp[2], types.ETString},
				geners:        geners,
				constants:     []*Constant{nil, nil, {Value: types.NewStringDatum(unit), RetType: types.NewFieldType(mysql.TypeString)}},
				chunkSize:     128,
			})
	}
	result := map[string][]vecExprBenchCase{
		funcName: benchCase,
	}
	return result
}

func genCasesByModForAddSubDate(funcName string, mod int) (cases []map[string][]vecExprBenchCase) {
	for i, unit := range unitForAddSubDate {
		if mod == -1 || i%4 == mod {
			cases = append(cases, genVecExprBenchCaseForAddSubDate(funcName, unit))
		}
	}
	return cases
}

func (s *testVectorizeSuite1) TestVectorizedAddDateSubDate0(c *C) {
	cases := genCasesByModForAddSubDate(ast.AddDate, 0)
	for _, testCase := range cases {
		testVectorizedEvalOneVec(c, testCase)
		testVectorizedBuiltinFunc(c, testCase)
	}

	cases = genCasesByModForAddSubDate(ast.SubDate, 0)
	for _, testCase := range cases {
		testVectorizedEvalOneVec(c, testCase)
		testVectorizedBuiltinFunc(c, testCase)
	}
}

func (s *testVectorizeSuite1) TestVectorizedAddDateSubDate1(c *C) {
	cases := genCasesByModForAddSubDate(ast.AddDate, 1)
	for _, testCase := range cases {
		testVectorizedEvalOneVec(c, testCase)
		testVectorizedBuiltinFunc(c, testCase)
	}

	cases = genCasesByModForAddSubDate(ast.SubDate, 1)
	for _, testCase := range cases {
		testVectorizedEvalOneVec(c, testCase)
		testVectorizedBuiltinFunc(c, testCase)
	}
}

func (s *testVectorizeSuite1) TestVectorizedAddDateSubDate2(c *C) {
	cases := genCasesByModForAddSubDate(ast.AddDate, 2)
	for _, testCase := range cases {
		testVectorizedEvalOneVec(c, testCase)
		testVectorizedBuiltinFunc(c, testCase)
	}

	cases = genCasesByModForAddSubDate(ast.SubDate, 2)
	for _, testCase := range cases {
		testVectorizedEvalOneVec(c, testCase)
		testVectorizedBuiltinFunc(c, testCase)
	}
}

func (s *testVectorizeSuite1) TestVectorizedAddDateSubDate3(c *C) {
	cases := genCasesByModForAddSubDate(ast.AddDate, 3)
	for _, testCase := range cases {
		testVectorizedEvalOneVec(c, testCase)
		testVectorizedBuiltinFunc(c, testCase)
	}

	cases = genCasesByModForAddSubDate(ast.SubDate, 3)
	for _, testCase := range cases {
		testVectorizedEvalOneVec(c, testCase)
		testVectorizedBuiltinFunc(c, testCase)
	}
}

func BenchmarkVectorizedAddDateEvalOneVecGenerated(b *testing.B) {
	benchmarkVectorizedEvalOneVec(b, genCasesByModForAddSubDate(ast.AddDate, -1)[0])
}

func BenchmarkVectorizedSubDateEvalOneVecGenerated(b *testing.B) {
	benchmarkVectorizedEvalOneVec(b, genCasesByModForAddSubDate(ast.SubDate, -1)[0])
}

func BenchmarkVectorizedAddDateGenerated(b *testing.B) {
	benchmarkVectorizedBuiltinFunc(b, genCasesByModForAddSubDate(ast.AddDate, -1)[0])
}

func BenchmarkVectorizedSubDateGenerated(b *testing.B) {
	benchmarkVectorizedBuiltinFunc(b, genCasesByModForAddSubDate(ast.SubDate, -1)[0])
}
