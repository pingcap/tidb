// Copyright 2024 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tikv

import (
	"context"
	"encoding/json"
	"strings"
	"testing"

	"github.com/cockroachdb/pebble"
	"github.com/cockroachdb/pebble/sstable"
	"github.com/cockroachdb/pebble/vfs"
	"github.com/google/uuid"
	rockssst "github.com/lance6716/pebble/sstable"
	"github.com/pingcap/errors"
	"github.com/pingcap/kvproto/pkg/import_sstpb"
	"github.com/pingcap/kvproto/pkg/kvrpcpb"
	"github.com/stretchr/testify/require"
	pd "github.com/tikv/pd/client"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

var (
	sortedKVs = [][2][]byte{
		{[]byte("a"), []byte("1")},
	}
	ts uint64 = 1
)

// write2ImportService4Test writes these sorted key-value pairs to the TiKV
// cluster. SST files are generated by TiKV and saved in import directory if no
// error happens.
func write2ImportService4Test(
	ctx context.Context,
	pdAddrs []string,
	sortedKVs [][2][]byte,
	ts uint64,
) ([]*import_sstpb.SSTMeta, error) {
	pdClient, err := pd.NewClient(pdAddrs, pd.SecurityOption{})
	if err != nil {
		return nil, errors.Trace(err)
	}
	defer pdClient.Close()

	r0, err := pdClient.GetRegion(ctx, sortedKVs[0][0])
	if err != nil {
		return nil, errors.Trace(err)
	}
	r1, err := pdClient.GetRegion(ctx, sortedKVs[len(sortedKVs)-1][0])
	if err != nil {
		return nil, errors.Trace(err)
	}
	if r0.Meta.Id != r1.Meta.Id {
		return nil, errors.Errorf(
			"only support write to the same region, "+
				"first key: %X, last key: %X, "+
				"first region id: %d, last region id: %d",
			sortedKVs[0][0], sortedKVs[len(sortedKVs)-1][0],
			r0.Meta.Id, r1.Meta.Id,
		)
	}

	store, err := pdClient.GetStore(ctx, r0.Leader.GetStoreId())
	if err != nil {
		return nil, errors.Trace(err)
	}
	conn, err := grpc.DialContext(
		ctx, store.GetAddress(),
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithBlock(),
	)
	if err != nil {
		return nil, errors.Trace(err)
	}
	defer conn.Close()

	ingestClient := import_sstpb.NewImportSSTClient(conn)
	writeStream, err := ingestClient.Write(ctx)
	if err != nil {
		return nil, errors.Trace(err)
	}
	u := uuid.New()
	writeMeta := &import_sstpb.SSTMeta{
		Uuid:        u[:],
		RegionId:    r0.Meta.Id,
		RegionEpoch: r0.Meta.RegionEpoch,
		Range: &import_sstpb.Range{
			Start: sortedKVs[0][0],
			End:   sortedKVs[len(sortedKVs)-1][0],
		},
	}
	rpcCtx := kvrpcpb.Context{
		RegionId:    r0.Meta.Id,
		RegionEpoch: r0.Meta.RegionEpoch,
		Peer:        r0.Leader,
	}
	err = writeStream.Send(&import_sstpb.WriteRequest{
		Chunk:   &import_sstpb.WriteRequest_Meta{Meta: writeMeta},
		Context: &rpcCtx,
	})
	if err != nil {
		return nil, errors.Trace(err)
	}

	batch := &import_sstpb.WriteBatch{
		CommitTs: ts,
		Pairs:    make([]*import_sstpb.Pair, 0, len(sortedKVs)),
	}
	for _, kv := range sortedKVs {
		batch.Pairs = append(batch.Pairs, &import_sstpb.Pair{
			Key:   kv[0],
			Value: kv[1],
		})
	}
	err = writeStream.Send(&import_sstpb.WriteRequest{
		Chunk:   &import_sstpb.WriteRequest_Batch{Batch: batch},
		Context: &rpcCtx,
	})
	if err != nil {
		return nil, errors.Trace(err)
	}
	resp, err := writeStream.CloseAndRecv()
	if err != nil {
		return nil, errors.Trace(err)
	}
	if resp.GetError() != nil {
		return nil, errors.Errorf("write failed: %s", resp.GetError())
	}
	return resp.Metas, nil
}

func TestGRPCWriteToTiKV(t *testing.T) {
	t.Skip(`This is a manual test. You can use tiup playground and run this test.
After the test is finished, find the SST files in the import directory of the TiKV node.`)

	ctx := context.Background()
	pdAddrs := []string{"127.0.0.1:2379"}

	metas, err := write2ImportService4Test(ctx, pdAddrs, sortedKVs, ts)
	require.NoError(t, err)
	for _, meta := range metas {
		t.Logf("meta UUID: %v", uuid.UUID(meta.Uuid).String())
	}
}

func TestPebbleWriteSST(t *testing.T) {
	sstPath := "/tmp/test-write.sst"
	writer, err := newWriteCFWriter(sstPath, ts, &rockssst.Identity{
		DB:                 "SST Writer",
		Host:               "lance6716-nuc10i7fnh",
		Session:            "DS38NDUWK5HLG8SSL5M7",
		OriginalFileNumber: 1,
	})
	require.NoError(t, err)

	for _, kv := range sortedKVs {
		err = writer.set(kv[0], kv[1])
		require.NoError(t, err)
	}

	err = writer.close()
	require.NoError(t, err)

	f, err := vfs.Default.Open(sstPath)
	require.NoError(t, err)
	readable, err := rockssst.NewSimpleReadable(f)
	require.NoError(t, err)
	reader, err := rockssst.NewReader(readable, rockssst.ReaderOptions{})
	require.NoError(t, err)
	defer reader.Close()

	layout, err := reader.Layout()
	require.NoError(t, err)

	infos := layout.BlockInfos(reader)
	expected := `
[
	{"Offset":0,"Length":42,"Name":"data","Compression":0,"Checksum":2258416982},
	{"Offset":121,"Length":39,"Name":"index","Compression":0,"Checksum":3727189474},
	{"Offset":165,"Length":1253,"Name":"properties","Compression":0,"Checksum":561778464},
	{"Offset":1423,"Length":79,"Name":"meta-index","Compression":0,"Checksum":955781521},
	{"Offset":1507,"Length":53,"Name":"footer","Compression":0,"Checksum":0}
]`
	var expectedInfos []*rockssst.BlockInfo
	err = json.Unmarshal([]byte(expected), &expectedInfos)
	require.NoError(t, err)
	require.Equal(t, expectedInfos, infos)
}

func TestDebugReadSST(t *testing.T) {
	t.Skip("this is a manual test")

	sstPath := "/tmp/test-write.sst"
	t.Logf("read sst: %s", sstPath)
	f, err := vfs.Default.Open(sstPath)
	require.NoError(t, err)
	readable, err := sstable.NewSimpleReadable(f)
	require.NoError(t, err)
	reader, err := sstable.NewReader(readable, sstable.ReaderOptions{})
	require.NoError(t, err)
	defer reader.Close()

	layout, err := reader.Layout()
	require.NoError(t, err)

	content := &strings.Builder{}
	layout.Describe(content, true, reader, nil)

	t.Logf("layout:\n %s", content.String())
	t.Logf("properties:\n %s", reader.Properties.String())

	iter, err := reader.NewIter(nil, nil)
	require.NoError(t, err)
	defer iter.Close()

	k, v := iter.First()
	if k == nil {
		return
	}
	getValue := func(v pebble.LazyValue) []byte {
		realV, _, err2 := v.Value(nil)
		require.NoError(t, err2)
		return realV
	}
	t.Logf("key: %X\nvalue: %X", k.UserKey, getValue(v))
	for {
		k, v = iter.Next()
		if k == nil {
			break
		}
		t.Logf("key: %X\nvalue: %X", k.UserKey, getValue(v))
	}
}
