// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/pingcap/tidb/pkg/disttask/framework/scheduler (interfaces: Extension)
//
// Generated by this command:
//
//	mockgen -destination pkg/disttask/framework/scheduler/mock/scheduler_mock.go -package mock github.com/pingcap/tidb/pkg/disttask/framework/scheduler Extension
//

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	proto "github.com/pingcap/tidb/pkg/disttask/framework/proto"
	storage "github.com/pingcap/tidb/pkg/disttask/framework/storage"
	gomock "go.uber.org/mock/gomock"
)

// MockExtension is a mock of Extension interface.
type MockExtension struct {
	ctrl     *gomock.Controller
	recorder *MockExtensionMockRecorder
	isgomock struct{}
}

// MockExtensionMockRecorder is the mock recorder for MockExtension.
type MockExtensionMockRecorder struct {
	mock *MockExtension
}

// NewMockExtension creates a new mock instance.
func NewMockExtension(ctrl *gomock.Controller) *MockExtension {
	mock := &MockExtension{ctrl: ctrl}
	mock.recorder = &MockExtensionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExtension) EXPECT() *MockExtensionMockRecorder {
	return m.recorder
}

// GetEligibleInstances mocks base method.
func (m *MockExtension) GetEligibleInstances(ctx context.Context, task *proto.Task) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEligibleInstances", ctx, task)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetEligibleInstances indicates an expected call of GetEligibleInstances.
func (mr *MockExtensionMockRecorder) GetEligibleInstances(ctx, task any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEligibleInstances", reflect.TypeOf((*MockExtension)(nil).GetEligibleInstances), ctx, task)
}

// GetNextStep mocks base method.
func (m *MockExtension) GetNextStep(task *proto.TaskBase) proto.Step {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNextStep", task)
	ret0, _ := ret[0].(proto.Step)
	return ret0
}

// GetNextStep indicates an expected call of GetNextStep.
func (mr *MockExtensionMockRecorder) GetNextStep(task any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNextStep", reflect.TypeOf((*MockExtension)(nil).GetNextStep), task)
}

// IsRetryableErr mocks base method.
func (m *MockExtension) IsRetryableErr(err error) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsRetryableErr", err)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsRetryableErr indicates an expected call of IsRetryableErr.
func (mr *MockExtensionMockRecorder) IsRetryableErr(err any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsRetryableErr", reflect.TypeOf((*MockExtension)(nil).IsRetryableErr), err)
}

// OnDone mocks base method.
func (m *MockExtension) OnDone(ctx context.Context, h storage.TaskHandle, task *proto.Task) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnDone", ctx, h, task)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnDone indicates an expected call of OnDone.
func (mr *MockExtensionMockRecorder) OnDone(ctx, h, task any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnDone", reflect.TypeOf((*MockExtension)(nil).OnDone), ctx, h, task)
}

// OnNextSubtasksBatch mocks base method.
func (m *MockExtension) OnNextSubtasksBatch(ctx context.Context, h storage.TaskHandle, task *proto.Task, execIDs []string, step proto.Step) ([][]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnNextSubtasksBatch", ctx, h, task, execIDs, step)
	ret0, _ := ret[0].([][]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OnNextSubtasksBatch indicates an expected call of OnNextSubtasksBatch.
func (mr *MockExtensionMockRecorder) OnNextSubtasksBatch(ctx, h, task, execIDs, step any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnNextSubtasksBatch", reflect.TypeOf((*MockExtension)(nil).OnNextSubtasksBatch), ctx, h, task, execIDs, step)
}

// OnTick mocks base method.
func (m *MockExtension) OnTick(ctx context.Context, task *proto.Task) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "OnTick", ctx, task)
}

// OnTick indicates an expected call of OnTick.
func (mr *MockExtensionMockRecorder) OnTick(ctx, task any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnTick", reflect.TypeOf((*MockExtension)(nil).OnTick), ctx, task)
}
