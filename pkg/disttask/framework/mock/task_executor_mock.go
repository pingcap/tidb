// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/pingcap/tidb/pkg/disttask/framework/taskexecutor (interfaces: TaskTable,Pool,TaskExecutor,Extension)
//
// Generated by this command:
//
//	mockgen -package mock github.com/pingcap/tidb/pkg/disttask/framework/taskexecutor TaskTable,Pool,TaskExecutor,Extension
//

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	proto "github.com/pingcap/tidb/pkg/disttask/framework/proto"
	storage "github.com/pingcap/tidb/pkg/disttask/framework/storage"
	execute "github.com/pingcap/tidb/pkg/disttask/framework/taskexecutor/execute"
	gomock "go.uber.org/mock/gomock"
)

// MockTaskTable is a mock of TaskTable interface.
type MockTaskTable struct {
	ctrl     *gomock.Controller
	recorder *MockTaskTableMockRecorder
	isgomock struct{}
}

// MockTaskTableMockRecorder is the mock recorder for MockTaskTable.
type MockTaskTableMockRecorder struct {
	mock *MockTaskTable
}

// NewMockTaskTable creates a new mock instance.
func NewMockTaskTable(ctrl *gomock.Controller) *MockTaskTable {
	mock := &MockTaskTable{ctrl: ctrl}
	mock.recorder = &MockTaskTableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTaskTable) EXPECT() *MockTaskTableMockRecorder {
	return m.recorder
}

// CancelSubtask mocks base method.
func (m *MockTaskTable) CancelSubtask(ctx context.Context, exe string, taskID int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CancelSubtask", ctx, exe, taskID)
	ret0, _ := ret[0].(error)
	return ret0
}

// CancelSubtask indicates an expected call of CancelSubtask.
func (mr *MockTaskTableMockRecorder) CancelSubtask(ctx, exe, taskID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CancelSubtask", reflect.TypeOf((*MockTaskTable)(nil).CancelSubtask), ctx, exe, taskID)
}

// FailSubtask mocks base method.
func (m *MockTaskTable) FailSubtask(ctx context.Context, execID string, taskID int64, err error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FailSubtask", ctx, execID, taskID, err)
	ret0, _ := ret[0].(error)
	return ret0
}

// FailSubtask indicates an expected call of FailSubtask.
func (mr *MockTaskTableMockRecorder) FailSubtask(ctx, execID, taskID, err any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FailSubtask", reflect.TypeOf((*MockTaskTable)(nil).FailSubtask), ctx, execID, taskID, err)
}

// FinishSubtask mocks base method.
func (m *MockTaskTable) FinishSubtask(ctx context.Context, execID string, subtaskID int64, meta []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FinishSubtask", ctx, execID, subtaskID, meta)
	ret0, _ := ret[0].(error)
	return ret0
}

// FinishSubtask indicates an expected call of FinishSubtask.
func (mr *MockTaskTableMockRecorder) FinishSubtask(ctx, execID, subtaskID, meta any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FinishSubtask", reflect.TypeOf((*MockTaskTable)(nil).FinishSubtask), ctx, execID, subtaskID, meta)
}

// GetFirstSubtaskInStates mocks base method.
func (m *MockTaskTable) GetFirstSubtaskInStates(ctx context.Context, instanceID string, taskID int64, step proto.Step, states ...proto.SubtaskState) (*proto.Subtask, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, instanceID, taskID, step}
	for _, a := range states {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetFirstSubtaskInStates", varargs...)
	ret0, _ := ret[0].(*proto.Subtask)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetFirstSubtaskInStates indicates an expected call of GetFirstSubtaskInStates.
func (mr *MockTaskTableMockRecorder) GetFirstSubtaskInStates(ctx, instanceID, taskID, step any, states ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, instanceID, taskID, step}, states...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFirstSubtaskInStates", reflect.TypeOf((*MockTaskTable)(nil).GetFirstSubtaskInStates), varargs...)
}

// GetSubtasksByExecIDAndStepAndStates mocks base method.
func (m *MockTaskTable) GetSubtasksByExecIDAndStepAndStates(ctx context.Context, execID string, taskID int64, step proto.Step, states ...proto.SubtaskState) ([]*proto.Subtask, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, execID, taskID, step}
	for _, a := range states {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetSubtasksByExecIDAndStepAndStates", varargs...)
	ret0, _ := ret[0].([]*proto.Subtask)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSubtasksByExecIDAndStepAndStates indicates an expected call of GetSubtasksByExecIDAndStepAndStates.
func (mr *MockTaskTableMockRecorder) GetSubtasksByExecIDAndStepAndStates(ctx, execID, taskID, step any, states ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, execID, taskID, step}, states...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubtasksByExecIDAndStepAndStates", reflect.TypeOf((*MockTaskTable)(nil).GetSubtasksByExecIDAndStepAndStates), varargs...)
}

// GetTaskBaseByID mocks base method.
func (m *MockTaskTable) GetTaskBaseByID(ctx context.Context, taskID int64) (*proto.TaskBase, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTaskBaseByID", ctx, taskID)
	ret0, _ := ret[0].(*proto.TaskBase)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTaskBaseByID indicates an expected call of GetTaskBaseByID.
func (mr *MockTaskTableMockRecorder) GetTaskBaseByID(ctx, taskID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTaskBaseByID", reflect.TypeOf((*MockTaskTable)(nil).GetTaskBaseByID), ctx, taskID)
}

// GetTaskByID mocks base method.
func (m *MockTaskTable) GetTaskByID(ctx context.Context, taskID int64) (*proto.Task, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTaskByID", ctx, taskID)
	ret0, _ := ret[0].(*proto.Task)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTaskByID indicates an expected call of GetTaskByID.
func (mr *MockTaskTableMockRecorder) GetTaskByID(ctx, taskID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTaskByID", reflect.TypeOf((*MockTaskTable)(nil).GetTaskByID), ctx, taskID)
}

// GetTaskExecInfoByExecID mocks base method.
func (m *MockTaskTable) GetTaskExecInfoByExecID(ctx context.Context, execID string) ([]*storage.TaskExecInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTaskExecInfoByExecID", ctx, execID)
	ret0, _ := ret[0].([]*storage.TaskExecInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTaskExecInfoByExecID indicates an expected call of GetTaskExecInfoByExecID.
func (mr *MockTaskTableMockRecorder) GetTaskExecInfoByExecID(ctx, execID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTaskExecInfoByExecID", reflect.TypeOf((*MockTaskTable)(nil).GetTaskExecInfoByExecID), ctx, execID)
}

// GetTasksInStates mocks base method.
func (m *MockTaskTable) GetTasksInStates(ctx context.Context, states ...any) ([]*proto.Task, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range states {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetTasksInStates", varargs...)
	ret0, _ := ret[0].([]*proto.Task)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTasksInStates indicates an expected call of GetTasksInStates.
func (mr *MockTaskTableMockRecorder) GetTasksInStates(ctx any, states ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, states...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTasksInStates", reflect.TypeOf((*MockTaskTable)(nil).GetTasksInStates), varargs...)
}

// HasSubtasksInStates mocks base method.
func (m *MockTaskTable) HasSubtasksInStates(ctx context.Context, execID string, taskID int64, step proto.Step, states ...proto.SubtaskState) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, execID, taskID, step}
	for _, a := range states {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HasSubtasksInStates", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HasSubtasksInStates indicates an expected call of HasSubtasksInStates.
func (mr *MockTaskTableMockRecorder) HasSubtasksInStates(ctx, execID, taskID, step any, states ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, execID, taskID, step}, states...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSubtasksInStates", reflect.TypeOf((*MockTaskTable)(nil).HasSubtasksInStates), varargs...)
}

// InitMeta mocks base method.
func (m *MockTaskTable) InitMeta(ctx context.Context, execID, role string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InitMeta", ctx, execID, role)
	ret0, _ := ret[0].(error)
	return ret0
}

// InitMeta indicates an expected call of InitMeta.
func (mr *MockTaskTableMockRecorder) InitMeta(ctx, execID, role any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InitMeta", reflect.TypeOf((*MockTaskTable)(nil).InitMeta), ctx, execID, role)
}

// PauseSubtasks mocks base method.
func (m *MockTaskTable) PauseSubtasks(ctx context.Context, execID string, taskID int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PauseSubtasks", ctx, execID, taskID)
	ret0, _ := ret[0].(error)
	return ret0
}

// PauseSubtasks indicates an expected call of PauseSubtasks.
func (mr *MockTaskTableMockRecorder) PauseSubtasks(ctx, execID, taskID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PauseSubtasks", reflect.TypeOf((*MockTaskTable)(nil).PauseSubtasks), ctx, execID, taskID)
}

// RecoverMeta mocks base method.
func (m *MockTaskTable) RecoverMeta(ctx context.Context, execID, role string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RecoverMeta", ctx, execID, role)
	ret0, _ := ret[0].(error)
	return ret0
}

// RecoverMeta indicates an expected call of RecoverMeta.
func (mr *MockTaskTableMockRecorder) RecoverMeta(ctx, execID, role any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RecoverMeta", reflect.TypeOf((*MockTaskTable)(nil).RecoverMeta), ctx, execID, role)
}

// RunningSubtasksBack2Pending mocks base method.
func (m *MockTaskTable) RunningSubtasksBack2Pending(ctx context.Context, subtasks []*proto.SubtaskBase) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunningSubtasksBack2Pending", ctx, subtasks)
	ret0, _ := ret[0].(error)
	return ret0
}

// RunningSubtasksBack2Pending indicates an expected call of RunningSubtasksBack2Pending.
func (mr *MockTaskTableMockRecorder) RunningSubtasksBack2Pending(ctx, subtasks any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunningSubtasksBack2Pending", reflect.TypeOf((*MockTaskTable)(nil).RunningSubtasksBack2Pending), ctx, subtasks)
}

// StartSubtask mocks base method.
func (m *MockTaskTable) StartSubtask(ctx context.Context, subtaskID int64, execID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StartSubtask", ctx, subtaskID, execID)
	ret0, _ := ret[0].(error)
	return ret0
}

// StartSubtask indicates an expected call of StartSubtask.
func (mr *MockTaskTableMockRecorder) StartSubtask(ctx, subtaskID, execID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartSubtask", reflect.TypeOf((*MockTaskTable)(nil).StartSubtask), ctx, subtaskID, execID)
}

// UpdateSubtaskStateAndError mocks base method.
func (m *MockTaskTable) UpdateSubtaskStateAndError(ctx context.Context, execID string, subtaskID int64, state proto.SubtaskState, err error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateSubtaskStateAndError", ctx, execID, subtaskID, state, err)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateSubtaskStateAndError indicates an expected call of UpdateSubtaskStateAndError.
func (mr *MockTaskTableMockRecorder) UpdateSubtaskStateAndError(ctx, execID, subtaskID, state, err any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateSubtaskStateAndError", reflect.TypeOf((*MockTaskTable)(nil).UpdateSubtaskStateAndError), ctx, execID, subtaskID, state, err)
}

// MockPool is a mock of Pool interface.
type MockPool struct {
	ctrl     *gomock.Controller
	recorder *MockPoolMockRecorder
	isgomock struct{}
}

// MockPoolMockRecorder is the mock recorder for MockPool.
type MockPoolMockRecorder struct {
	mock *MockPool
}

// NewMockPool creates a new mock instance.
func NewMockPool(ctrl *gomock.Controller) *MockPool {
	mock := &MockPool{ctrl: ctrl}
	mock.recorder = &MockPoolMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPool) EXPECT() *MockPoolMockRecorder {
	return m.recorder
}

// ReleaseAndWait mocks base method.
func (m *MockPool) ReleaseAndWait() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReleaseAndWait")
}

// ReleaseAndWait indicates an expected call of ReleaseAndWait.
func (mr *MockPoolMockRecorder) ReleaseAndWait() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReleaseAndWait", reflect.TypeOf((*MockPool)(nil).ReleaseAndWait))
}

// Run mocks base method.
func (m *MockPool) Run(arg0 func()) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockPoolMockRecorder) Run(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockPool)(nil).Run), arg0)
}

// RunWithConcurrency mocks base method.
func (m *MockPool) RunWithConcurrency(arg0 chan func(), arg1 uint32) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunWithConcurrency", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// RunWithConcurrency indicates an expected call of RunWithConcurrency.
func (mr *MockPoolMockRecorder) RunWithConcurrency(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunWithConcurrency", reflect.TypeOf((*MockPool)(nil).RunWithConcurrency), arg0, arg1)
}

// MockTaskExecutor is a mock of TaskExecutor interface.
type MockTaskExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockTaskExecutorMockRecorder
	isgomock struct{}
}

// MockTaskExecutorMockRecorder is the mock recorder for MockTaskExecutor.
type MockTaskExecutorMockRecorder struct {
	mock *MockTaskExecutor
}

// NewMockTaskExecutor creates a new mock instance.
func NewMockTaskExecutor(ctrl *gomock.Controller) *MockTaskExecutor {
	mock := &MockTaskExecutor{ctrl: ctrl}
	mock.recorder = &MockTaskExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTaskExecutor) EXPECT() *MockTaskExecutorMockRecorder {
	return m.recorder
}

// Cancel mocks base method.
func (m *MockTaskExecutor) Cancel() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Cancel")
}

// Cancel indicates an expected call of Cancel.
func (mr *MockTaskExecutorMockRecorder) Cancel() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cancel", reflect.TypeOf((*MockTaskExecutor)(nil).Cancel))
}

// CancelRunningSubtask mocks base method.
func (m *MockTaskExecutor) CancelRunningSubtask() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "CancelRunningSubtask")
}

// CancelRunningSubtask indicates an expected call of CancelRunningSubtask.
func (mr *MockTaskExecutorMockRecorder) CancelRunningSubtask() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CancelRunningSubtask", reflect.TypeOf((*MockTaskExecutor)(nil).CancelRunningSubtask))
}

// Close mocks base method.
func (m *MockTaskExecutor) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockTaskExecutorMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockTaskExecutor)(nil).Close))
}

// GetTaskBase mocks base method.
func (m *MockTaskExecutor) GetTaskBase() *proto.TaskBase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTaskBase")
	ret0, _ := ret[0].(*proto.TaskBase)
	return ret0
}

// GetTaskBase indicates an expected call of GetTaskBase.
func (mr *MockTaskExecutorMockRecorder) GetTaskBase() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTaskBase", reflect.TypeOf((*MockTaskExecutor)(nil).GetTaskBase))
}

// Init mocks base method.
func (m *MockTaskExecutor) Init(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Init", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Init indicates an expected call of Init.
func (mr *MockTaskExecutorMockRecorder) Init(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockTaskExecutor)(nil).Init), arg0)
}

// IsRetryableError mocks base method.
func (m *MockTaskExecutor) IsRetryableError(err error) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsRetryableError", err)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsRetryableError indicates an expected call of IsRetryableError.
func (mr *MockTaskExecutorMockRecorder) IsRetryableError(err any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsRetryableError", reflect.TypeOf((*MockTaskExecutor)(nil).IsRetryableError), err)
}

// Run mocks base method.
func (m *MockTaskExecutor) Run(resource *proto.StepResource) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Run", resource)
}

// Run indicates an expected call of Run.
func (mr *MockTaskExecutorMockRecorder) Run(resource any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockTaskExecutor)(nil).Run), resource)
}

// MockExtension is a mock of Extension interface.
type MockExtension struct {
	ctrl     *gomock.Controller
	recorder *MockExtensionMockRecorder
	isgomock struct{}
}

// MockExtensionMockRecorder is the mock recorder for MockExtension.
type MockExtensionMockRecorder struct {
	mock *MockExtension
}

// NewMockExtension creates a new mock instance.
func NewMockExtension(ctrl *gomock.Controller) *MockExtension {
	mock := &MockExtension{ctrl: ctrl}
	mock.recorder = &MockExtensionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExtension) EXPECT() *MockExtensionMockRecorder {
	return m.recorder
}

// GetStepExecutor mocks base method.
func (m *MockExtension) GetStepExecutor(task *proto.Task) (execute.StepExecutor, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStepExecutor", task)
	ret0, _ := ret[0].(execute.StepExecutor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetStepExecutor indicates an expected call of GetStepExecutor.
func (mr *MockExtensionMockRecorder) GetStepExecutor(task any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStepExecutor", reflect.TypeOf((*MockExtension)(nil).GetStepExecutor), task)
}

// IsIdempotent mocks base method.
func (m *MockExtension) IsIdempotent(subtask *proto.Subtask) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsIdempotent", subtask)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsIdempotent indicates an expected call of IsIdempotent.
func (mr *MockExtensionMockRecorder) IsIdempotent(subtask any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsIdempotent", reflect.TypeOf((*MockExtension)(nil).IsIdempotent), subtask)
}

// IsRetryableError mocks base method.
func (m *MockExtension) IsRetryableError(err error) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsRetryableError", err)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsRetryableError indicates an expected call of IsRetryableError.
func (mr *MockExtensionMockRecorder) IsRetryableError(err any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsRetryableError", reflect.TypeOf((*MockExtension)(nil).IsRetryableError), err)
}
