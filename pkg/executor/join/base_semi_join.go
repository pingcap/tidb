// Copyright 2024 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package join

import (
	"github.com/pingcap/tidb/pkg/util/chunk"
	"github.com/pingcap/tidb/pkg/util/sqlkiller"
)

type baseSemiJoin struct {
	baseJoinProbe
	isLeftSideBuild bool

	// used when right side is build side and has other condition
	// One probe row may match several build rows and generate many result rows.
	// We see these result rows that generated by the same probe row as one group.
	groupMark []int

	// used when left side is build side
	rowIter *rowIter

	undeterminedProbeRowsIdx map[int]struct{}
}

func newBaseSemiJoin(base baseJoinProbe, isLeftSideBuild bool) *baseSemiJoin {
	return &baseSemiJoin{
		baseJoinProbe:            base,
		isLeftSideBuild:          isLeftSideBuild,
		groupMark:                make([]int, 0),
		undeterminedProbeRowsIdx: make(map[int]struct{}),
	}
}

func (b *baseSemiJoin) initProbe(probeRowNum int) {
	clear(b.undeterminedProbeRowsIdx)
	for i := 0; i < probeRowNum; i++ {
		b.undeterminedProbeRowsIdx[i] = struct{}{}
	}
}

func (b *baseSemiJoin) matchMultiBuildRows(joinedChk *chunk.Chunk, joinedChkRemainCap *int, isRightSideBuild bool) {
	tagHelper := b.ctx.hashTableContext.tagHelper
	meta := b.ctx.hashTableMeta
	for b.matchedRowsHeaders[b.currentProbeRow] != 0 && *joinedChkRemainCap > 0 && b.matchedRowsForCurrentProbeRow < maxMatchedRowNum {
		candidateRow := tagHelper.toUnsafePointer(b.matchedRowsHeaders[b.currentProbeRow])
		if isRightSideBuild {
			if isKeyMatched(meta.keyMode, b.serializedKeys[b.currentProbeRow], candidateRow, meta) {
				b.appendBuildRowToCachedBuildRowsV1(b.currentProbeRow, candidateRow, joinedChk, 0, true)
				b.matchedRowsForCurrentProbeRow++
				*joinedChkRemainCap--
				b.groupMark = append(b.groupMark, b.currentProbeRow)
			} else {
				b.probeCollision++
			}
		} else {
			if !meta.isCurrentRowUsedWithAtomic(candidateRow) {
				if isKeyMatched(meta.keyMode, b.serializedKeys[b.currentProbeRow], candidateRow, meta) {
					b.appendBuildRowToCachedBuildRowsV1(b.currentProbeRow, candidateRow, joinedChk, 0, true)
					b.matchedRowsForCurrentProbeRow++
					*joinedChkRemainCap--
				} else {
					b.probeCollision++
				}
			}
		}
		b.matchedRowsHeaders[b.currentProbeRow] = getNextRowAddress(candidateRow, tagHelper, b.matchedRowsHashValue[b.currentProbeRow])
	}

	b.finishLookupCurrentProbeRow()
}

func (b *baseSemiJoin) concatenateProbeAndBuildRows(joinedChk *chunk.Chunk, sqlKiller *sqlkiller.SQLKiller, isRightSideBuild bool) error {
	b.groupMark = b.groupMark[:0]
	joinedChkRemainCap := joinedChk.Capacity()
	joinedChkRemainCap = 30

	for joinedChkRemainCap > 0 && len(b.undeterminedProbeRowsIdx) != 0 {
		for probeRowIdx := range b.undeterminedProbeRowsIdx {
			b.currentProbeRow = probeRowIdx
			b.matchMultiBuildRows(joinedChk, &joinedChkRemainCap, isRightSideBuild)

			if b.matchedRowsHeaders[probeRowIdx] == 0 {
				delete(b.undeterminedProbeRowsIdx, probeRowIdx)
			}

			if joinedChkRemainCap == 0 {
				break
			}
		}
	}

	err := checkSQLKiller(sqlKiller, "killedDuringProbe")
	if err != nil {
		return err
	}

	b.finishCurrentLookupLoop(joinedChk)
	return nil
}
