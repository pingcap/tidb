// Copyright 2024 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package join

import (
	"github.com/pingcap/tidb/pkg/expression"
	"github.com/pingcap/tidb/pkg/util/chunk"
	"github.com/pingcap/tidb/pkg/util/logutil"
	"github.com/pingcap/tidb/pkg/util/sqlkiller"
	"go.uber.org/zap"
)

type leftOuterSemiJoinProbe struct {
	baseJoinProbe
	// used when use inner side to build, isNotMatchedRows is indexed by logical row index
	isNotMatchedRows []bool
	// build/probe side used columns and offset in result chunk
	probeColUsed []int

	// One probe row may match multi build rows and generate multi result rows.
	// We see these result rows that generated by the same probe row as one group.
	groupMark              []int
	nextProcessProbeRowIdx int

	// used in other condition to record which rows are being processed now
	processedProbeRowIdxSet map[int]struct{}

	// used in other condition to record if `j.selected` of this row has been set to true
	// so that we can skip this row.
	skipRowIdxSet map[int]struct{}
}

var _ ProbeV2 = &leftOuterSemiJoinProbe{}

func newLeftOuterSemiJoinProbe(base baseJoinProbe) *leftOuterSemiJoinProbe {
	probe := &leftOuterSemiJoinProbe{
		baseJoinProbe:           base,
		processedProbeRowIdxSet: make(map[int]struct{}),
		skipRowIdxSet:           make(map[int]struct{}),
	}
	probe.probeColUsed = base.lUsed
	logutil.BgLogger().Info("newLeftOuterSemiJoinProbe", zap.Any("probeColUsed", probe.probeColUsed))
	return probe
}

func (j *leftOuterSemiJoinProbe) SetChunkForProbe(chunk *chunk.Chunk) (err error) {
	err = j.baseJoinProbe.SetChunkForProbe(chunk)
	if err != nil {
		return err
	}
	j.isNotMatchedRows = j.isNotMatchedRows[:0]
	for i := 0; i < j.chunkRows; i++ {
		j.isNotMatchedRows = append(j.isNotMatchedRows, true)
	}
	return nil
}

func (j *leftOuterSemiJoinProbe) NeedScanRowTable() bool {
	return false
}

func (j *leftOuterSemiJoinProbe) IsScanRowTableDone() bool {
	panic("should not reach here")
}

func (j *leftOuterSemiJoinProbe) InitForScanRowTable() {
	panic("should not reach here")
}

func (j *leftOuterSemiJoinProbe) ClearProbeState() {
	j.baseJoinProbe.ClearProbeState()
}

func (j *leftOuterSemiJoinProbe) ScanRowTable(joinResult *hashjoinWorkerResult, sqlKiller *sqlkiller.SQLKiller) *hashjoinWorkerResult {
	return joinResult
}

func (j *leftOuterSemiJoinProbe) Probe(joinResult *hashjoinWorkerResult, sqlKiller *sqlkiller.SQLKiller) (ok bool, _ *hashjoinWorkerResult) {
	if joinResult.chk.IsFull() {
		return true, joinResult
	}
	joinedChk, remainCap, err := j.prepareForProbe(joinResult.chk)
	if err != nil {
		joinResult.err = err
		return false, joinResult
	}
	isInCompleteChunk := joinedChk.IsInCompleteChunk()
	// in case that virtual rows is not maintained correctly
	joinedChk.SetNumVirtualRows(joinedChk.NumRows())
	// always set in complete chunk during probe
	joinedChk.SetInCompleteChunk(true)
	defer joinedChk.SetInCompleteChunk(isInCompleteChunk)

	if j.ctx.hasOtherCondition() {
		err = j.probeForInnerSideBuildWithOtherCondition(joinResult.chk, joinedChk, remainCap, sqlKiller)
	} else {
		err = j.probeForInnerSideBuildWithoutOtherCondition(joinResult.chk, joinedChk, remainCap, sqlKiller)
	}
	if err != nil {
		joinResult.err = err
		return false, joinResult
	}
	return true, joinResult
}

func (j *leftOuterSemiJoinProbe) probeForInnerSideBuildWithOtherCondition(chk, joinedChk *chunk.Chunk, remainCap int, sqlKiller *sqlkiller.SQLKiller) (err error) {
	startProbeRow := j.currentProbeRow
	err = j.concatenateProbeAndBuildRows(joinedChk, sqlKiller)
	if err != nil {
		return err
	}

	// To avoid `Previous chunk is not probed yet` error
	j.currentProbeRow = j.nextProcessProbeRowIdx
	if joinedChk.NumRows() > 0 {
		j.selected = j.selected[:0]
		j.selected, err = expression.VectorizedFilter(j.ctx.SessCtx.GetExprCtx().GetEvalCtx(), j.ctx.SessCtx.GetSessionVars().EnableVectorizedExpression, j.ctx.OtherCondition, chunk.NewIterator4Chunk(joinedChk), j.selected)
		if err != nil {
			return err
		}

		j.truncateSelect()
		j.removeMatchedProbeRow()
		j.buildResultForMatchedRowsAfterOtherCondition(chk, joinedChk)
		j.buildResultForNotMatchedRows(chk, startProbeRow)
	}
	return
}

func (j *leftOuterSemiJoinProbe) buildResultForMatchedRowsAfterOtherCondition(chk, joinedChk *chunk.Chunk) {
	probeColOffsetInJoinedChunk := 0
	rowCount := chk.NumRows()
	markedJoined := false
	for index, colIndex := range j.probeColUsed {
		dstCol := chk.Column(index)
		if joinedChk.Column(colIndex+probeColOffsetInJoinedChunk).Rows() > 0 {
			// probe column that is already in joinedChk
			srcCol := joinedChk.Column(colIndex + probeColOffsetInJoinedChunk)
			chunk.CopySelectedRows(dstCol, srcCol, j.selected)
		} else {
			markedJoined = true
			srcCol := j.currentChunk.Column(colIndex)
			chunk.CopySelectedRowsWithRowIDFunc(dstCol, srcCol, j.selected, 0, len(j.selected), func(i int) int {
				ret := j.rowIndexInfos[i].probeRowIndex
				j.isNotMatchedRows[ret] = false
				return j.usedRows[ret]
			})
		}
	}
	hasRemainCols := false
	if hasRemainCols {
		j.nextCachedBuildRowIndex = 0
		markedJoined = true
		meta := j.ctx.hashTableMeta
		for index, result := range j.selected {
			if result {
				rowIndexInfo := j.rowIndexInfos[index]
				j.isNotMatchedRows[rowIndexInfo.probeRowIndex] = false
				j.appendBuildRowToCachedBuildRowsV2(&rowIndexInfo, chk, meta.columnCountNeededForOtherCondition, false)
			}
		}
		if j.nextCachedBuildRowIndex > 0 {
			j.batchConstructBuildRows(chk, meta.columnCountNeededForOtherCondition, false)
		}
	}
	if !markedJoined {
		for index, result := range j.selected {
			if result {
				j.isNotMatchedRows[j.rowIndexInfos[index].probeRowIndex] = false
			}
		}
	}
	rowsAdded := 0
	for _, result := range j.selected {
		if result {
			rowsAdded++
		}
	}
	chk.SetNumVirtualRows(rowCount + rowsAdded)
	dstCol := chk.Column(len(j.probeColUsed))
	for i := 0; i < rowsAdded; i++ {
		dstCol.AppendInt64(1)
	}
}

func (j *leftOuterSemiJoinProbe) probeForInnerSideBuildWithoutOtherCondition(chk, joinedChk *chunk.Chunk, remainCap int, sqlKiller *sqlkiller.SQLKiller) (err error) {
	meta := j.ctx.hashTableMeta
	startProbeRow := j.currentProbeRow
	tagHelper := j.ctx.hashTableContext.tagHelper

	for remainCap > 0 && j.currentProbeRow < j.chunkRows {
		if j.matchedRowsHeaders[j.currentProbeRow] != 0 {
			candidateRow := tagHelper.toUnsafePointer(j.matchedRowsHeaders[j.currentProbeRow])
			if isKeyMatched(meta.keyMode, j.serializedKeys[j.currentProbeRow], candidateRow, meta) {
				j.appendBuildRowToCachedBuildRowsV1(j.currentProbeRow, candidateRow, joinedChk, 0, false)
				j.isNotMatchedRows[j.currentProbeRow] = false
				j.matchedRowsHeaders[j.currentProbeRow] = 0
				j.matchedRowsForCurrentProbeRow++
			} else {
				j.probeCollision++
			}
			j.matchedRowsHeaders[j.currentProbeRow] = getNextRowAddress(candidateRow, tagHelper, j.matchedRowsHashValue[j.currentProbeRow])
		} else {
			j.finishLookupCurrentProbeRow()
			j.currentProbeRow++
		}
		remainCap--
	}

	err = checkSQLKiller(sqlKiller, "killedDuringProbe")

	if err != nil {
		return err
	}

	j.finishCurrentLookupLoop(joinedChk)
	// if no the condition, chk == joinedChk, and the matched rows are already in joinedChk
	j.buildResultForNotMatchedRows(joinedChk, startProbeRow)
	return nil
}

func (j *leftOuterSemiJoinProbe) buildResultForNotMatchedRows(chk *chunk.Chunk, startProbeRow int) {
	// append not matched rows
	// for not matched rows, probe col is appended using original cols, and build column is appended using nulls
	prevRows := chk.NumRows()
	afterRows := prevRows
	for index, colIndex := range j.probeColUsed {
		dstCol := chk.Column(index)
		srcCol := j.currentChunk.Column(colIndex)
		chunk.CopySelectedRowsWithRowIDFunc(dstCol, srcCol, j.isNotMatchedRows, startProbeRow, j.currentProbeRow, func(i int) int {
			return j.usedRows[i]
		})
		afterRows = dstCol.Rows()
	}
	nullRows := afterRows - prevRows
	if len(j.probeColUsed) == 0 {
		for i := startProbeRow; i < j.currentProbeRow; i++ {
			if j.isNotMatchedRows[i] {
				nullRows++
			}
		}
	}
	if nullRows > 0 {
		dstCol := chk.Column(len(j.probeColUsed))
		for i := 0; i < nullRows; i++ {
			dstCol.AppendInt64(0)
		}
		chk.SetNumVirtualRows(prevRows + nullRows)
	}
}

func (j *leftOuterSemiJoinProbe) finishCurrentLookupLoop(joinedChk *chunk.Chunk) {
	j.baseJoinProbe.finishCurrentLookupLoop(joinedChk)
	if !j.ctx.hasOtherCondition() {
		for i := 0; i < j.currentProbeRow; i++ {
			if !j.isNotMatchedRows[i] {
				joinedChk.AppendInt64(len(j.probeColUsed), 1)
			}
		}
	}
}

var maxMatchedRowNum = 4

func (j *leftOuterSemiJoinProbe) matchMultiBuildRows(joinedChk *chunk.Chunk, joinedChkRemainCap *int) {
	tagHelper := j.ctx.hashTableContext.tagHelper
	meta := j.ctx.hashTableMeta
	for j.matchedRowsHeaders[j.currentProbeRow] != 0 && *joinedChkRemainCap > 0 && j.matchedRowsForCurrentProbeRow < maxMatchedRowNum {
		candidateRow := tagHelper.toUnsafePointer(j.matchedRowsHeaders[j.currentProbeRow])
		if isKeyMatched(meta.keyMode, j.serializedKeys[j.currentProbeRow], candidateRow, meta) {
			j.appendBuildRowToCachedBuildRowsV1(j.currentProbeRow, candidateRow, joinedChk, 0, true)
			j.matchedRowsForCurrentProbeRow++
			*joinedChkRemainCap--
			j.groupMark = append(j.groupMark, j.currentProbeRow)
		} else {
			j.probeCollision++
		}
		j.matchedRowsHeaders[j.currentProbeRow] = getNextRowAddress(candidateRow, tagHelper, j.matchedRowsHashValue[j.currentProbeRow])
	}

	j.finishLookupCurrentProbeRow()
}

func (j *leftOuterSemiJoinProbe) concatenateProbeAndBuildRows(joinedChk *chunk.Chunk, sqlKiller *sqlkiller.SQLKiller) error {
	j.groupMark = j.groupMark[:0]
	joinedChkRemainCap := joinedChk.Capacity()

	for joinedChkRemainCap > 0 && (len(j.processedProbeRowIdxSet) > 0 || j.nextProcessProbeRowIdx < j.chunkRows) {
		for probeRowIdx := range j.processedProbeRowIdxSet {
			j.currentProbeRow = probeRowIdx
			j.matchMultiBuildRows(joinedChk, &joinedChkRemainCap)

			if j.matchedRowsHeaders[probeRowIdx] == 0 {
				delete(j.processedProbeRowIdxSet, probeRowIdx)
			}

			if joinedChkRemainCap == 0 {
				break
			}
		}

		for joinedChkRemainCap > 0 && j.nextProcessProbeRowIdx < j.chunkRows {
			j.currentProbeRow = j.nextProcessProbeRowIdx
			j.matchMultiBuildRows(joinedChk, &joinedChkRemainCap)

			if j.matchedRowsHeaders[j.currentProbeRow] != 0 {
				j.processedProbeRowIdxSet[j.currentProbeRow] = struct{}{}
			}
			j.nextProcessProbeRowIdx++
		}
	}

	err := checkSQLKiller(sqlKiller, "killedDuringProbe")
	if err != nil {
		return err
	}

	j.finishCurrentLookupLoop(joinedChk)
	return nil
}

// One probe row may match multi build rows and generate multi result rows.
// In semi join, we only need one row when left table is probe side, so we need to truncate
// the `j.select` to meet the rule that one probe row outputs at most one result row.
func (j *leftOuterSemiJoinProbe) truncateSelect() {
	clear(j.skipRowIdxSet)

	// scannedGroupIdx refers to which group we are scanning now
	scannedGroupIdx := -1
	selectLen := len(j.selected)

	// Set it to true when we encounter true in a group
	encounterTrue := false

	for i := 0; i < selectLen; i++ {
		currentGroupIdx := j.groupMark[i]
		if scannedGroupIdx != currentGroupIdx {
			// Switch to a new group
			_, ok := j.skipRowIdxSet[currentGroupIdx]
			if ok {
				// When row index n is set to true in `j.selected`, it will be outputed as result.
				// However, in semi join, rows in left side should be outputed for only once.
				//
				// When one left side row has been set to true before, we should not output it again.
				// groupMark: | 0 | 0 | 0 | 0 | 1 | 1 | 2 | 2 | 2 | 0 | 0 | 1 | 2 |
				// selected:  | T | F | T | F | T | T | F | F | F | T | F | F | T |
				//              ▲                                   ▲
				//              └ output index 0 here               |
				//                                                  |
				//                       index 0 was true before, we should not output it again
				encounterTrue = true
				j.selected[i] = false
			} else {
				encounterTrue = j.selected[i]
				if encounterTrue {
					j.skipRowIdxSet[currentGroupIdx] = struct{}{}
				}
			}

			scannedGroupIdx = currentGroupIdx
			continue
		}

		if encounterTrue {
			// When we have encountered true in a group,
			// we need to set the rest of selected values to false.
			j.selected[i] = false
			continue
		}

		encounterTrue = j.selected[i]
		if encounterTrue {
			j.skipRowIdxSet[currentGroupIdx] = struct{}{}
		}
	}
}

func (j *leftOuterSemiJoinProbe) removeMatchedProbeRow() {
	for idx, selected := range j.selected {
		if selected {
			delete(j.processedProbeRowIdxSet, j.groupMark[idx])
		}
	}
}
