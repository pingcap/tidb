// Copyright 2024 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package join

import (
	"fmt"
	"unsafe"

	"github.com/pingcap/log"
	"github.com/pingcap/tidb/pkg/expression"
	"github.com/pingcap/tidb/pkg/util/chunk"
	"github.com/pingcap/tidb/pkg/util/sqlkiller"
)

// TODO outer join also has scanning row table function, and there are many codes similiar to semi join
// TODO so we need to extract codes that related with scanning row table in this pr.
type semiJoinProbe struct {
	baseJoinProbe
	isLeftSideBuild bool

	// used when right side is build side and has other condition
	// One probe row may match multi build rows and generate multi result rows.
	// We see these result rows that generated by the same probe row as one group.
	groupMark []int

	// used when left side is build side
	rowIter *rowIter

	isNotMatchedRows []bool // TODO do we need it? If we need, we should initialize it in `SetChunkProbe`

	// TODO do we need these variables?
	// build/probe side used columns and offset in result chunk
	buildColUsed              []int
	buildColOffsetInResultChk int
	probeColUsed              []int
	probeColOffsetInResultChk int

	setUsedFlagNum int
}

func newSemiJoinProbe(base baseJoinProbe, isLeftSideBuild bool) *semiJoinProbe {
	probe := &semiJoinProbe{
		baseJoinProbe:   base,
		isLeftSideBuild: isLeftSideBuild,
	}
	if isLeftSideBuild {
		probe.buildColUsed = base.lUsed
		probe.buildColOffsetInResultChk = 0
		probe.probeColUsed = base.rUsed
		probe.probeColOffsetInResultChk = len(base.lUsed)
	} else {
		probe.buildColUsed = base.rUsed
		probe.buildColOffsetInResultChk = len(base.lUsed)
		probe.probeColUsed = base.lUsed
		probe.probeColOffsetInResultChk = 0
	}
	return probe
}

func (j *semiJoinProbe) InitForScanRowTable() {
	if !j.isLeftSideBuild {
		panic("should not reach here")
	}
	totalRowCount := j.ctx.hashTableContext.hashTable.totalRowCount()
	concurrency := j.ctx.Concurrency
	workID := uint64(j.workID)
	avgRowPerWorker := totalRowCount / uint64(concurrency)
	startIndex := workID * avgRowPerWorker
	endIndex := (workID + 1) * avgRowPerWorker
	if workID == uint64(concurrency-1) {
		endIndex = totalRowCount
	}
	if endIndex > totalRowCount {
		endIndex = totalRowCount
	}
	j.rowIter = j.ctx.hashTableContext.hashTable.createRowIter(startIndex, endIndex)
}

func (j *semiJoinProbe) NeedScanRowTable() bool {
	return j.isLeftSideBuild
}

func (j *semiJoinProbe) IsScanRowTableDone() bool {
	if !j.isLeftSideBuild {
		panic("should not reach here")
	}
	return j.rowIter.isEnd()
}

// TODO maybe we can extract some common codes from semi join and outer join
func (j *semiJoinProbe) ScanRowTable(joinResult *hashjoinWorkerResult, sqlKiller *sqlkiller.SQLKiller) *hashjoinWorkerResult {
	// TODO delete
	if j.setUsedFlagNum >= 0 {
		log.Info(fmt.Sprintf("set used flag num %d", j.setUsedFlagNum))
		j.setUsedFlagNum = -1
	}

	if !j.isLeftSideBuild {
		panic("should not reach here")
	}
	if joinResult.chk.IsFull() {
		return joinResult
	}
	if j.rowIter == nil {
		panic("scanRowTable before init")
	}
	j.nextCachedBuildRowIndex = 0
	meta := j.ctx.hashTableMeta
	insertedRows := 0
	remainCap := joinResult.chk.RequiredRows() - joinResult.chk.NumRows()
	for insertedRows < remainCap && !j.rowIter.isEnd() {
		currentRow := j.rowIter.getValue()
		if meta.isCurrentRowUsed(currentRow) {
			// append build side of this row
			j.appendBuildRowToCachedBuildRowsV1(0, currentRow, joinResult.chk, 0, false)
			insertedRows++
		}
		j.rowIter.next()
	}
	err := checkSQLKiller(sqlKiller, "killedDuringProbe")
	if err != nil {
		joinResult.err = err
		return joinResult
	}
	if j.nextCachedBuildRowIndex > 0 {
		j.batchConstructBuildRows(joinResult.chk, 0, false)
	}
	return joinResult
}

func (j *semiJoinProbe) ResetProbe() {
	j.rowIter = nil
	j.baseJoinProbe.ResetProbe()
}

func (j *semiJoinProbe) Probe(joinResult *hashjoinWorkerResult, sqlKiller *sqlkiller.SQLKiller) (ok bool, _ *hashjoinWorkerResult) {
	if joinResult.chk.IsFull() {
		return true, joinResult
	}

	joinedChk, remainCap, err := j.prepareForProbe(joinResult.chk)
	if err != nil {
		joinResult.err = err
		return false, joinResult
	}

	isInCompleteChunk := joinedChk.IsInCompleteChunk()
	// in case that virtual rows is not maintained correctly
	joinedChk.SetNumVirtualRows(joinedChk.NumRows())
	// always set in complete chunk during probe
	joinedChk.SetInCompleteChunk(true)
	defer joinedChk.SetInCompleteChunk(isInCompleteChunk)

	hasOtherCondition := j.ctx.hasOtherCondition()
	if j.isLeftSideBuild {
		if hasOtherCondition {
			err = j.probeForLeftSideBuildHasOtherCondition(joinedChk, remainCap, sqlKiller)
		} else {
			err = j.probeForLeftSideBuildNoOtherCondition(remainCap, sqlKiller)
		}
	} else {
		if hasOtherCondition {

		} else {
			err = j.probeForRightSideBuildNoOtherCondition(joinResult.chk, remainCap, sqlKiller)
		}
	}
	if err != nil {
		joinResult.err = err
		return false, joinResult
	}
	return true, joinResult
}

// TODO test it in ut
// One probe row may match multi build rows and generate multi result rows.
// In semi join, we only need one row when left table is probe side, so we need to truncate
// the `j.select` to meet the rule that one probe row outputs at most one result row.
func (j *semiJoinProbe) truncateSelect() {
	// scannedGroupIdx refers to which group we are scanning now
	scannedGroupIdx := -1
	selectLen := len(j.selected)

	// Set it to true when we encounter true in a group
	encounterTrue := false

	for i := 0; i < selectLen; i++ {
		currentGroupIdx := j.groupMark[i]
		if scannedGroupIdx != currentGroupIdx {
			// Switch to a new group
			encounterTrue = j.selected[i]
			scannedGroupIdx = currentGroupIdx
			continue
		}

		if encounterTrue {
			// When we have encountered true in a group,
			// we need to set the rest of selected values to false.
			j.selected[i] = false
			continue
		}

		encounterTrue = j.selected[i]
	}
}

func (j *semiJoinProbe) probeForLeftSideBuildHasOtherCondition(joinedChk *chunk.Chunk, remainCap int, sqlKiller *sqlkiller.SQLKiller) (err error) {
	meta := j.ctx.hashTableMeta
	tagHelper := j.ctx.hashTableContext.tagHelper

	for remainCap > 0 && j.currentProbeRow < j.chunkRows {
		if j.matchedRowsHeaders[j.currentProbeRow] != 0 {
			candidateRow := tagHelper.toUnsafePointer(j.matchedRowsHeaders[j.currentProbeRow])
			if isKeyMatched(meta.keyMode, j.serializedKeys[j.currentProbeRow], candidateRow, meta) {
				j.appendBuildRowToCachedBuildRowsV1(j.currentProbeRow, candidateRow, joinedChk, 0, true)
				j.matchedRowsForCurrentProbeRow++
				remainCap--
			} else {
				j.probeCollision++
			}
			j.matchedRowsHeaders[j.currentProbeRow] = getNextRowAddress(candidateRow, tagHelper, j.matchedRowsHashValue[j.currentProbeRow])
		} else {
			j.finishLookupCurrentProbeRow()
			j.currentProbeRow++
		}
	}

	err = checkSQLKiller(sqlKiller, "killedDuringProbe")
	if err != nil {
		return err
	}

	j.finishCurrentLookupLoop(joinedChk)

	if joinedChk.NumRows() > 0 {
		j.selected, err = expression.VectorizedFilter(j.ctx.SessCtx.GetExprCtx().GetEvalCtx(), j.ctx.SessCtx.GetSessionVars().EnableVectorizedExpression, j.ctx.OtherCondition, chunk.NewIterator4Chunk(joinedChk), j.selected)
		if err != nil {
			return err
		}

		for index, result := range j.selected {
			if result {
				meta.setUsedFlag(*(*unsafe.Pointer)(unsafe.Pointer(&j.rowIndexInfos[index].buildRowStart)))
			}
		}
	}

	return
}

func (j *semiJoinProbe) probeForLeftSideBuildNoOtherCondition(remainCap int, sqlKiller *sqlkiller.SQLKiller) (err error) {
	meta := j.ctx.hashTableMeta
	tagHelper := j.ctx.hashTableContext.tagHelper

	for remainCap > 0 && j.currentProbeRow < j.chunkRows {
		if j.matchedRowsHeaders[j.currentProbeRow] != 0 {
			candidateRow := tagHelper.toUnsafePointer(j.matchedRowsHeaders[j.currentProbeRow])
			if isKeyMatched(meta.keyMode, j.serializedKeys[j.currentProbeRow], candidateRow, meta) {
				meta.setUsedFlag(candidateRow)
				remainCap--
				j.matchedRowsHeaders[j.currentProbeRow] = 0
				j.setUsedFlagNum++
			} else {
				j.probeCollision++
				j.matchedRowsHeaders[j.currentProbeRow] = getNextRowAddress(candidateRow, tagHelper, j.matchedRowsHashValue[j.currentProbeRow])
			}
		} else {
			j.currentProbeRow++
		}
	}

	err = checkSQLKiller(sqlKiller, "killedDuringProbe")
	if err != nil {
		return err
	}
	return
}

func (j *semiJoinProbe) probeForRightSideBuildHasOtherCondition(chk, joinedChk *chunk.Chunk, remainCap int, sqlKiller *sqlkiller.SQLKiller) (err error) {
	j.groupMark = j.groupMark[:0]
	meta := j.ctx.hashTableMeta
	tagHelper := j.ctx.hashTableContext.tagHelper
	currentGroupIdx := 0

	for remainCap > 0 && j.currentProbeRow < j.chunkRows {
		if j.matchedRowsHeaders[j.currentProbeRow] != 0 {
			candidateRow := tagHelper.toUnsafePointer(j.matchedRowsHeaders[j.currentProbeRow])
			if isKeyMatched(meta.keyMode, j.serializedKeys[j.currentProbeRow], candidateRow, meta) {
				j.appendBuildRowToCachedBuildRowsV1(j.currentProbeRow, candidateRow, joinedChk, 0, true)
				j.matchedRowsForCurrentProbeRow++
				remainCap--
				j.groupMark = append(j.groupMark, currentGroupIdx)
			} else {
				j.probeCollision++
			}
			j.matchedRowsHeaders[j.currentProbeRow] = getNextRowAddress(candidateRow, tagHelper, j.matchedRowsHashValue[j.currentProbeRow])
		} else {
			j.finishLookupCurrentProbeRow()
			j.currentProbeRow++
			currentGroupIdx++
		}
	}

	err = checkSQLKiller(sqlKiller, "killedDuringProbe")
	if err != nil {
		return err
	}

	j.finishCurrentLookupLoop(joinedChk)

	if joinedChk.NumRows() > 0 {
		j.selected = j.selected[:0]
		j.selected, err = expression.VectorizedFilter(j.ctx.SessCtx.GetExprCtx().GetEvalCtx(), j.ctx.SessCtx.GetSessionVars().EnableVectorizedExpression, j.ctx.OtherCondition, chunk.NewIterator4Chunk(joinedChk), j.selected)
		if err != nil {
			return err
		}

		j.truncateSelect()
		return j.buildResultAfterOtherCondition(chk, joinedChk)
	}
	return
}

func (j *semiJoinProbe) probeForRightSideBuildNoOtherCondition(chk *chunk.Chunk, remainCap int, sqlKiller *sqlkiller.SQLKiller) (err error) {
	meta := j.ctx.hashTableMeta
	tagHelper := j.ctx.hashTableContext.tagHelper

	for remainCap > 0 && j.currentProbeRow < j.chunkRows {
		if j.matchedRowsHeaders[j.currentProbeRow] != 0 {
			candidateRow := tagHelper.toUnsafePointer(j.matchedRowsHeaders[j.currentProbeRow])
			if isKeyMatched(meta.keyMode, j.serializedKeys[j.currentProbeRow], candidateRow, meta) {
				j.matchedRowsHeaders[j.currentProbeRow] = 0
				j.matchedRowsForCurrentProbeRow++
				remainCap--
			} else {
				j.probeCollision++
				j.matchedRowsHeaders[j.currentProbeRow] = getNextRowAddress(candidateRow, tagHelper, j.matchedRowsHashValue[j.currentProbeRow])
			}
		} else {
			j.finishLookupCurrentProbeRow()
			j.currentProbeRow++
		}
	}

	err = checkSQLKiller(sqlKiller, "killedDuringProbe")
	if err != nil {
		return err
	}

	j.finishCurrentLookupLoop(chk)
	return
}
