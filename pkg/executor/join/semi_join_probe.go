// Copyright 2024 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package join

import (
	"unsafe"

	"github.com/pingcap/tidb/pkg/expression"
	"github.com/pingcap/tidb/pkg/util/chunk"
	"github.com/pingcap/tidb/pkg/util/sqlkiller"
)

// The following described case has other condition.
// During the probe, when a probe matches one build row, we need to put the probe and build rows
// together and generate a new row. If one probe row could match n build row, then we will get
// n new rows. If n is very big, there will generate too much rows. In order to avoid this case
// we need to limit the max generated row number. This variable describe this max number.
// NOTE: Suppose probe chunk has n rows and n*maxMatchedRowNum << chunkRemainingCapacity.
// We will keep on join probe rows that have been matched before with build rows, though
// probe row with idex i may have produced `maxMatchedRowNum` number rows before. So that
// we can process as many rows as possible.
const maxMatchedRowNum = 4

type semiJoinProbe struct {
	baseJoinProbe
	isLeftSideBuild bool

	// used when right side is build side and has other condition
	// One probe row may match multi build rows and generate multi result rows.
	// We see these result rows that generated by the same probe row as one group.
	groupMark []int

	// used when left side is build side
	rowIter *rowIter

	nextProcessProbeRowIdx int

	// used in other condition to record which rows are being processed now
	processedProbeRowIdxSet map[int]struct{}

	// used in other condition to record if `j.selected` of this row has been set to true
	// so that we can skip this row.
	skipRowIdxSet map[int]struct{}
}

func newSemiJoinProbe(base baseJoinProbe, isLeftSideBuild bool) *semiJoinProbe {
	ret := &semiJoinProbe{
		baseJoinProbe:           base,
		isLeftSideBuild:         isLeftSideBuild,
		processedProbeRowIdxSet: make(map[int]struct{}),
		skipRowIdxSet:           make(map[int]struct{}),
	}
	return ret
}

func (s *semiJoinProbe) InitForScanRowTable() {
	if !s.isLeftSideBuild {
		panic("should not reach here")
	}
	s.rowIter = commonInitForScanRowTable(&s.baseJoinProbe)
}

func (s *semiJoinProbe) initProbe() {
	s.nextProcessProbeRowIdx = 0
	clear(s.processedProbeRowIdxSet)
}

func (s *semiJoinProbe) SetChunkForProbe(chunk *chunk.Chunk) (err error) {
	err = s.baseJoinProbe.SetChunkForProbe(chunk)
	if err != nil {
		return err
	}

	s.initProbe()
	return nil
}

func (s *semiJoinProbe) SetRestoredChunkForProbe(chk *chunk.Chunk) error {
	err := s.baseJoinProbe.SetRestoredChunkForProbe(chk)
	if err != nil {
		return err
	}

	s.initProbe()
	return nil
}

func (s *semiJoinProbe) NeedScanRowTable() bool {
	return s.isLeftSideBuild
}

func (s *semiJoinProbe) IsScanRowTableDone() bool {
	if !s.isLeftSideBuild {
		panic("should not reach here")
	}
	return s.rowIter.isEnd()
}

func (s *semiJoinProbe) ScanRowTable(joinResult *hashjoinWorkerResult, sqlKiller *sqlkiller.SQLKiller) *hashjoinWorkerResult {
	if !s.isLeftSideBuild {
		panic("should not reach here")
	}
	if joinResult.chk.IsFull() {
		return joinResult
	}
	if s.rowIter == nil {
		panic("scanRowTable before init")
	}
	s.nextCachedBuildRowIndex = 0
	meta := s.ctx.hashTableMeta
	insertedRows := 0
	remainCap := joinResult.chk.RequiredRows() - joinResult.chk.NumRows()
	for insertedRows < remainCap && !s.rowIter.isEnd() {
		currentRow := s.rowIter.getValue()
		if meta.isCurrentRowUsed(currentRow) {
			// append build side of this row
			s.appendBuildRowToCachedBuildRowsV1(0, currentRow, joinResult.chk, 0, false)
			insertedRows++
		}
		s.rowIter.next()
	}
	err := checkSQLKiller(sqlKiller, "killedDuringProbe")
	if err != nil {
		joinResult.err = err
		return joinResult
	}
	if s.nextCachedBuildRowIndex > 0 {
		s.batchConstructBuildRows(joinResult.chk, 0, false)
	}
	return joinResult
}

func (s *semiJoinProbe) ResetProbe() {
	s.rowIter = nil
	s.baseJoinProbe.ResetProbe()
}

func (s *semiJoinProbe) IsCurrentChunkProbeDone() bool {
	return s.currentChunk == nil || (s.nextProcessProbeRowIdx >= s.chunkRows && len(s.processedProbeRowIdxSet) == 0)
}

func (s *semiJoinProbe) Probe(joinResult *hashjoinWorkerResult, sqlKiller *sqlkiller.SQLKiller) (ok bool, _ *hashjoinWorkerResult) {
	if joinResult.chk.IsFull() {
		return true, joinResult
	}

	joinedChk, remainCap, err := s.prepareForProbe(joinResult.chk)
	if err != nil {
		joinResult.err = err
		return false, joinResult
	}

	isInCompleteChunk := joinedChk.IsInCompleteChunk()
	// in case that virtual rows is not maintained correctly
	joinedChk.SetNumVirtualRows(joinedChk.NumRows())
	// always set in complete chunk during probe
	joinedChk.SetInCompleteChunk(true)
	defer joinedChk.SetInCompleteChunk(isInCompleteChunk)

	hasOtherCondition := s.ctx.hasOtherCondition()
	if s.isLeftSideBuild {
		if hasOtherCondition {
			err = s.probeForLeftSideBuildHasOtherCondition(joinedChk, sqlKiller)
		} else {
			err = s.probeForLeftSideBuildNoOtherCondition(sqlKiller)
		}
	} else {
		if hasOtherCondition {
			err = s.probeForRightSideBuildHasOtherCondition(joinResult.chk, joinedChk, sqlKiller)
		} else {
			err = s.probeForRightSideBuildNoOtherCondition(joinResult.chk, remainCap, sqlKiller)
		}
	}
	if err != nil {
		joinResult.err = err
		return false, joinResult
	}
	return true, joinResult
}

// One probe row may match multi build rows and generate multi result rows.
// In semi join, we only need one row when left table is probe side, so we need to truncate
// the `j.select` to meet the rule that one probe row outputs at most one result row.
func (s *semiJoinProbe) truncateSelect() {
	clear(s.skipRowIdxSet)

	// scannedGroupIdx refers to which group we are scanning now
	scannedGroupIdx := -1
	selectLen := len(s.selected)

	// Set it to true when we encounter true in a group
	encounterTrue := false

	for i := 0; i < selectLen; i++ {
		currentGroupIdx := s.groupMark[i]
		if scannedGroupIdx != currentGroupIdx {
			// Switch to a new group
			_, ok := s.skipRowIdxSet[currentGroupIdx]
			if ok {
				// When row index n is set to true in `j.selected`, it will be outputed as result.
				// However, in semi join, rows in left side should be outputed for only once.
				//
				// When one left side row has been set to true before, we should not output it again.
				// groupMark: | 0 | 0 | 0 | 0 | 1 | 1 | 2 | 2 | 2 | 0 | 0 | 1 | 2 |
				// selected:  | T | F | T | F | T | T | F | F | F | T | F | F | T |
				//              ▲                                   ▲
				//              └ output index 0 here               |
				//                                                  |
				//                       index 0 was true before, we should not output it again
				encounterTrue = true
				s.selected[i] = false
			} else {
				encounterTrue = s.selected[i]
				if encounterTrue {
					s.skipRowIdxSet[currentGroupIdx] = struct{}{}
				}
			}

			scannedGroupIdx = currentGroupIdx
			continue
		}

		if encounterTrue {
			// When we have encountered true in a group,
			// we need to set the rest of selected values to false.
			s.selected[i] = false
			continue
		}

		encounterTrue = s.selected[i]
		if encounterTrue {
			s.skipRowIdxSet[currentGroupIdx] = struct{}{}
		}
	}
}

func (s *semiJoinProbe) removeMatchedProbeRow() {
	for idx, selected := range s.selected {
		if selected {
			delete(s.processedProbeRowIdxSet, s.groupMark[idx])
		}
	}
}

func (s *semiJoinProbe) matchMultiBuildRows(joinedChk *chunk.Chunk, joinedChkRemainCap *int, isRightSideBuild bool) {
	tagHelper := s.ctx.hashTableContext.tagHelper
	meta := s.ctx.hashTableMeta
	for s.matchedRowsHeaders[s.currentProbeRow] != 0 && *joinedChkRemainCap > 0 && s.matchedRowsForCurrentProbeRow < maxMatchedRowNum {
		candidateRow := tagHelper.toUnsafePointer(s.matchedRowsHeaders[s.currentProbeRow])
		if isRightSideBuild {
			if isKeyMatched(meta.keyMode, s.serializedKeys[s.currentProbeRow], candidateRow, meta) {
				s.appendBuildRowToCachedBuildRowsV1(s.currentProbeRow, candidateRow, joinedChk, 0, true)
				s.matchedRowsForCurrentProbeRow++
				*joinedChkRemainCap--
				s.groupMark = append(s.groupMark, s.currentProbeRow)
			} else {
				s.probeCollision++
			}
		} else {
			if !meta.isCurrentRowUsedWithAtomic(candidateRow) {
				if isKeyMatched(meta.keyMode, s.serializedKeys[s.currentProbeRow], candidateRow, meta) {
					s.appendBuildRowToCachedBuildRowsV1(s.currentProbeRow, candidateRow, joinedChk, 0, true)
					s.matchedRowsForCurrentProbeRow++
					*joinedChkRemainCap--
				} else {
					s.probeCollision++
				}
			}
		}
		s.matchedRowsHeaders[s.currentProbeRow] = getNextRowAddress(candidateRow, tagHelper, s.matchedRowsHashValue[s.currentProbeRow])
	}

	s.finishLookupCurrentProbeRow()
}

func (s *semiJoinProbe) concatenateProbeAndBuildRows(joinedChk *chunk.Chunk, sqlKiller *sqlkiller.SQLKiller, isRightSideBuild bool) error {
	s.groupMark = s.groupMark[:0]
	joinedChkRemainCap := joinedChk.Capacity()

	for joinedChkRemainCap > 0 && (len(s.processedProbeRowIdxSet) > 0 || s.nextProcessProbeRowIdx < s.chunkRows) {
		for probeRowIdx := range s.processedProbeRowIdxSet {
			s.currentProbeRow = probeRowIdx
			s.matchMultiBuildRows(joinedChk, &joinedChkRemainCap, isRightSideBuild)

			if s.matchedRowsHeaders[probeRowIdx] == 0 {
				delete(s.processedProbeRowIdxSet, probeRowIdx)
			}

			if joinedChkRemainCap == 0 {
				break
			}
		}

		for joinedChkRemainCap > 0 && s.nextProcessProbeRowIdx < s.chunkRows {
			s.currentProbeRow = s.nextProcessProbeRowIdx
			s.matchMultiBuildRows(joinedChk, &joinedChkRemainCap, true)

			if s.matchedRowsHeaders[s.currentProbeRow] != 0 {
				s.processedProbeRowIdxSet[s.currentProbeRow] = struct{}{}
			}
			s.nextProcessProbeRowIdx++
		}
	}

	err := checkSQLKiller(sqlKiller, "killedDuringProbe")
	if err != nil {
		return err
	}

	s.finishCurrentLookupLoop(joinedChk)
	return nil
}

func (s *semiJoinProbe) probeForLeftSideBuildHasOtherCondition(joinedChk *chunk.Chunk, sqlKiller *sqlkiller.SQLKiller) (err error) {
	err = s.concatenateProbeAndBuildRows(joinedChk, sqlKiller, false)
	if err != nil {
		return err
	}

	// To avoid `Previous chunk is not probed yet` error
	s.currentProbeRow = s.nextProcessProbeRowIdx

	meta := s.ctx.hashTableMeta
	if joinedChk.NumRows() > 0 {
		s.selected, err = expression.VectorizedFilter(s.ctx.SessCtx.GetExprCtx().GetEvalCtx(), s.ctx.SessCtx.GetSessionVars().EnableVectorizedExpression, s.ctx.OtherCondition, chunk.NewIterator4Chunk(joinedChk), s.selected)
		if err != nil {
			return err
		}

		for index, result := range s.selected {
			if result {
				meta.setUsedFlag(*(*unsafe.Pointer)(unsafe.Pointer(&s.rowIndexInfos[index].buildRowStart)))
			}
		}
	}

	return
}

func (s *semiJoinProbe) probeForLeftSideBuildNoOtherCondition(sqlKiller *sqlkiller.SQLKiller) (err error) {
	meta := s.ctx.hashTableMeta
	tagHelper := s.ctx.hashTableContext.tagHelper

	loopCnt := 0

	for s.currentProbeRow < s.chunkRows {
		if s.matchedRowsHeaders[s.currentProbeRow] != 0 {
			candidateRow := tagHelper.toUnsafePointer(s.matchedRowsHeaders[s.currentProbeRow])
			if isKeyMatched(meta.keyMode, s.serializedKeys[s.currentProbeRow], candidateRow, meta) {
				meta.setUsedFlag(candidateRow)
			} else {
				s.probeCollision++
			}
			s.matchedRowsHeaders[s.currentProbeRow] = getNextRowAddress(candidateRow, tagHelper, s.matchedRowsHashValue[s.currentProbeRow])
		} else {
			s.currentProbeRow++
		}

		loopCnt++
		if loopCnt%2000 == 0 {
			err = checkSQLKiller(sqlKiller, "killedDuringProbe")
			if err != nil {
				return err
			}
		}
	}

	err = checkSQLKiller(sqlKiller, "killedDuringProbe")
	if err != nil {
		return err
	}

	// For the check by `IsCurrentChunkProbeDone` function
	s.nextProcessProbeRowIdx = s.currentProbeRow
	return
}

func (s *semiJoinProbe) probeForRightSideBuildHasOtherCondition(chk, joinedChk *chunk.Chunk, sqlKiller *sqlkiller.SQLKiller) (err error) {
	err = s.concatenateProbeAndBuildRows(joinedChk, sqlKiller, true)
	if err != nil {
		return err
	}

	// To avoid `Previous chunk is not probed yet` error
	s.currentProbeRow = s.nextProcessProbeRowIdx
	if joinedChk.NumRows() > 0 {
		s.selected = s.selected[:0]
		s.selected, err = expression.VectorizedFilter(s.ctx.SessCtx.GetExprCtx().GetEvalCtx(), s.ctx.SessCtx.GetSessionVars().EnableVectorizedExpression, s.ctx.OtherCondition, chunk.NewIterator4Chunk(joinedChk), s.selected)
		if err != nil {
			return err
		}

		s.truncateSelect()
		s.removeMatchedProbeRow()
		return s.buildResultAfterOtherCondition(chk, joinedChk)
	}
	return
}

func (s *semiJoinProbe) probeForRightSideBuildNoOtherCondition(chk *chunk.Chunk, remainCap int, sqlKiller *sqlkiller.SQLKiller) (err error) {
	meta := s.ctx.hashTableMeta
	tagHelper := s.ctx.hashTableContext.tagHelper

	for remainCap > 0 && s.currentProbeRow < s.chunkRows {
		if s.matchedRowsHeaders[s.currentProbeRow] != 0 {
			candidateRow := tagHelper.toUnsafePointer(s.matchedRowsHeaders[s.currentProbeRow])
			if isKeyMatched(meta.keyMode, s.serializedKeys[s.currentProbeRow], candidateRow, meta) {
				s.matchedRowsHeaders[s.currentProbeRow] = 0
				s.matchedRowsForCurrentProbeRow++
				remainCap--
			} else {
				s.probeCollision++
				s.matchedRowsHeaders[s.currentProbeRow] = getNextRowAddress(candidateRow, tagHelper, s.matchedRowsHashValue[s.currentProbeRow])
			}
		} else {
			s.finishLookupCurrentProbeRow()
			s.currentProbeRow++
		}
	}

	err = checkSQLKiller(sqlKiller, "killedDuringProbe")
	if err != nil {
		return err
	}

	s.finishCurrentLookupLoop(chk)

	// For the check by `IsCurrentChunkProbeDone` function
	s.nextProcessProbeRowIdx = s.currentProbeRow
	return
}
