// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tici.proto

package tici

import (
	"context"
	encoding_binary "encoding/binary"
	"fmt"
	"io"
	"math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ErrorCode int32

const (
	ErrorCode_SUCCESS              ErrorCode = 0
	ErrorCode_UNKNOWN_ERROR        ErrorCode = 1
	ErrorCode_INVALID_ARGUMENTS    ErrorCode = 2
	ErrorCode_SHARD_NOT_FOUND      ErrorCode = 11
	ErrorCode_INDEX_NOT_FOUND      ErrorCode = 12
	ErrorCode_WORKER_NOT_FOUND     ErrorCode = 13
	ErrorCode_SHARD_NOT_SCHEDULED  ErrorCode = 14
	ErrorCode_COMPACTION_NOT_FOUND ErrorCode = 15
)

var ErrorCode_name = map[int32]string{
	0:  "SUCCESS",
	1:  "UNKNOWN_ERROR",
	2:  "INVALID_ARGUMENTS",
	11: "SHARD_NOT_FOUND",
	12: "INDEX_NOT_FOUND",
	13: "WORKER_NOT_FOUND",
	14: "SHARD_NOT_SCHEDULED",
	15: "COMPACTION_NOT_FOUND",
}

var ErrorCode_value = map[string]int32{
	"SUCCESS":              0,
	"UNKNOWN_ERROR":        1,
	"INVALID_ARGUMENTS":    2,
	"SHARD_NOT_FOUND":      11,
	"INDEX_NOT_FOUND":      12,
	"WORKER_NOT_FOUND":     13,
	"SHARD_NOT_SCHEDULED":  14,
	"COMPACTION_NOT_FOUND": 15,
}

func (x ErrorCode) String() string {
	return proto.EnumName(ErrorCode_name, int32(x))
}

func (ErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{0}
}

type CompactType int32

const (
	CompactType_Delta CompactType = 0
	CompactType_Base  CompactType = 1
	CompactType_Full  CompactType = 2
)

var CompactType_name = map[int32]string{
	0: "Delta",
	1: "Base",
	2: "Full",
}

var CompactType_value = map[string]int32{
	"Delta": 0,
	"Base":  1,
	"Full":  2,
}

func (x CompactType) String() string {
	return proto.EnumName(CompactType_name, int32(x))
}

func (CompactType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{1}
}

// IndexType represents the type of index
type IndexType int32

const (
	// Default value must be 0 in proto3
	IndexType_UNKNOWN IndexType = 0
	// Full-text index type
	IndexType_FULL_TEXT IndexType = 1
	// Custom index type
	IndexType_CUSTOM IndexType = 2
)

var IndexType_name = map[int32]string{
	0: "UNKNOWN",
	1: "FULL_TEXT",
	2: "CUSTOM",
}

var IndexType_value = map[string]int32{
	"UNKNOWN":   0,
	"FULL_TEXT": 1,
	"CUSTOM":    2,
}

func (x IndexType) String() string {
	return proto.EnumName(IndexType_name, int32(x))
}

func (IndexType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{2}
}

// ParserType represents the type of parser
type ParserType int32

const (
	// Default value must be 0 in proto3
	ParserType_UNKNOWN_PARSER ParserType = 0
	// Default parser
	ParserType_DEFAULT_PARSER ParserType = 1
	// Other parser types
	ParserType_OTHER_PARSER ParserType = 2
)

var ParserType_name = map[int32]string{
	0: "UNKNOWN_PARSER",
	1: "DEFAULT_PARSER",
	2: "OTHER_PARSER",
}

var ParserType_value = map[string]int32{
	"UNKNOWN_PARSER": 0,
	"DEFAULT_PARSER": 1,
	"OTHER_PARSER":   2,
}

func (x ParserType) String() string {
	return proto.EnumName(ParserType_name, int32(x))
}

func (ParserType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{3}
}

type GetIndexProgressResponse_State int32

const (
	GetIndexProgressResponse_PENDING   GetIndexProgressResponse_State = 0
	GetIndexProgressResponse_RUNNING   GetIndexProgressResponse_State = 1
	GetIndexProgressResponse_COMPLETED GetIndexProgressResponse_State = 2
	GetIndexProgressResponse_FAILED    GetIndexProgressResponse_State = 3
	GetIndexProgressResponse_NOTFOUND  GetIndexProgressResponse_State = 4
	GetIndexProgressResponse_ERROR     GetIndexProgressResponse_State = 5
)

var GetIndexProgressResponse_State_name = map[int32]string{
	0: "PENDING",
	1: "RUNNING",
	2: "COMPLETED",
	3: "FAILED",
	4: "NOTFOUND",
	5: "ERROR",
}

var GetIndexProgressResponse_State_value = map[string]int32{
	"PENDING":   0,
	"RUNNING":   1,
	"COMPLETED": 2,
	"FAILED":    3,
	"NOTFOUND":  4,
	"ERROR":     5,
}

func (x GetIndexProgressResponse_State) String() string {
	return proto.EnumName(GetIndexProgressResponse_State_name, int32(x))
}

func (GetIndexProgressResponse_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{39, 0}
}

type WorkerNodeStatus struct {
	// TODO Need more metrics, such as disk usage, quotas, cache miss rates
	CpuUsage    float64 `protobuf:"fixed64,1,opt,name=cpu_usage,json=cpuUsage,proto3" json:"cpu_usage,omitempty"`
	MemoryUsage uint64  `protobuf:"varint,2,opt,name=memory_usage,json=memoryUsage,proto3" json:"memory_usage,omitempty"`
}

func (m *WorkerNodeStatus) Reset()         { *m = WorkerNodeStatus{} }
func (m *WorkerNodeStatus) String() string { return proto.CompactTextString(m) }
func (*WorkerNodeStatus) ProtoMessage()    {}
func (*WorkerNodeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{0}
}
func (m *WorkerNodeStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerNodeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerNodeStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerNodeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerNodeStatus.Merge(m, src)
}
func (m *WorkerNodeStatus) XXX_Size() int {
	return m.Size()
}
func (m *WorkerNodeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerNodeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerNodeStatus proto.InternalMessageInfo

func (m *WorkerNodeStatus) GetCpuUsage() float64 {
	if m != nil {
		return m.CpuUsage
	}
	return 0
}

func (m *WorkerNodeStatus) GetMemoryUsage() uint64 {
	if m != nil {
		return m.MemoryUsage
	}
	return 0
}

// Reader node status information
type ReaderNodeStatus struct {
	// CPU usage percentage (0.0 to 100.0)
	CpuUsage float64 `protobuf:"fixed64,1,opt,name=cpu_usage,json=cpuUsage,proto3" json:"cpu_usage,omitempty"`
	// Memory usage in bytes
	MemoryUsage uint64 `protobuf:"varint,2,opt,name=memory_usage,json=memoryUsage,proto3" json:"memory_usage,omitempty"`
	// Number of requests processed in current heartbeat cycle
	RequestsInCycle uint32 `protobuf:"varint,3,opt,name=requests_in_cycle,json=requestsInCycle,proto3" json:"requests_in_cycle,omitempty"`
	// Cache hit rate percentage (0.0 to 100.0)
	CacheHitRate float64 `protobuf:"fixed64,4,opt,name=cache_hit_rate,json=cacheHitRate,proto3" json:"cache_hit_rate,omitempty"`
}

func (m *ReaderNodeStatus) Reset()         { *m = ReaderNodeStatus{} }
func (m *ReaderNodeStatus) String() string { return proto.CompactTextString(m) }
func (*ReaderNodeStatus) ProtoMessage()    {}
func (*ReaderNodeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{1}
}
func (m *ReaderNodeStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReaderNodeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReaderNodeStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReaderNodeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReaderNodeStatus.Merge(m, src)
}
func (m *ReaderNodeStatus) XXX_Size() int {
	return m.Size()
}
func (m *ReaderNodeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ReaderNodeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ReaderNodeStatus proto.InternalMessageInfo

func (m *ReaderNodeStatus) GetCpuUsage() float64 {
	if m != nil {
		return m.CpuUsage
	}
	return 0
}

func (m *ReaderNodeStatus) GetMemoryUsage() uint64 {
	if m != nil {
		return m.MemoryUsage
	}
	return 0
}

func (m *ReaderNodeStatus) GetRequestsInCycle() uint32 {
	if m != nil {
		return m.RequestsInCycle
	}
	return 0
}

func (m *ReaderNodeStatus) GetCacheHitRate() float64 {
	if m != nil {
		return m.CacheHitRate
	}
	return 0
}

// Some fields may be duplicated with ShardManifestHeader,
// however, just leave them here.
type WorkerNodeShardStatus struct {
	StartKey []byte `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// TODO shard_id is unique across tables and indexes.
	// We still need them because in meta service we are not currently maintain
	// this correspondence.
	TableId int64  `protobuf:"varint,3,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId int64  `protobuf:"varint,4,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	ShardId uint64 `protobuf:"varint,5,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	Epoch   uint64 `protobuf:"varint,6,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Seq     uint64 `protobuf:"varint,7,opt,name=seq,proto3" json:"seq,omitempty"`
}

func (m *WorkerNodeShardStatus) Reset()         { *m = WorkerNodeShardStatus{} }
func (m *WorkerNodeShardStatus) String() string { return proto.CompactTextString(m) }
func (*WorkerNodeShardStatus) ProtoMessage()    {}
func (*WorkerNodeShardStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{2}
}
func (m *WorkerNodeShardStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerNodeShardStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerNodeShardStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerNodeShardStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerNodeShardStatus.Merge(m, src)
}
func (m *WorkerNodeShardStatus) XXX_Size() int {
	return m.Size()
}
func (m *WorkerNodeShardStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerNodeShardStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerNodeShardStatus proto.InternalMessageInfo

func (m *WorkerNodeShardStatus) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *WorkerNodeShardStatus) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *WorkerNodeShardStatus) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *WorkerNodeShardStatus) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *WorkerNodeShardStatus) GetShardId() uint64 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

func (m *WorkerNodeShardStatus) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *WorkerNodeShardStatus) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

type WorkerNodeCompactionStatus struct {
	Req *CompactFragRequest `protobuf:"bytes,1,opt,name=req,proto3" json:"req,omitempty"`
}

func (m *WorkerNodeCompactionStatus) Reset()         { *m = WorkerNodeCompactionStatus{} }
func (m *WorkerNodeCompactionStatus) String() string { return proto.CompactTextString(m) }
func (*WorkerNodeCompactionStatus) ProtoMessage()    {}
func (*WorkerNodeCompactionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{3}
}
func (m *WorkerNodeCompactionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerNodeCompactionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerNodeCompactionStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerNodeCompactionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerNodeCompactionStatus.Merge(m, src)
}
func (m *WorkerNodeCompactionStatus) XXX_Size() int {
	return m.Size()
}
func (m *WorkerNodeCompactionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerNodeCompactionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerNodeCompactionStatus proto.InternalMessageInfo

func (m *WorkerNodeCompactionStatus) GetReq() *CompactFragRequest {
	if m != nil {
		return m.Req
	}
	return nil
}

type ImportWriteStatus struct {
	TableId    int64  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId    int64  `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	FilePrefix string `protobuf:"bytes,4,opt,name=file_prefix,json=filePrefix,proto3" json:"file_prefix,omitempty"`
}

func (m *ImportWriteStatus) Reset()         { *m = ImportWriteStatus{} }
func (m *ImportWriteStatus) String() string { return proto.CompactTextString(m) }
func (*ImportWriteStatus) ProtoMessage()    {}
func (*ImportWriteStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{4}
}
func (m *ImportWriteStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportWriteStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImportWriteStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImportWriteStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportWriteStatus.Merge(m, src)
}
func (m *ImportWriteStatus) XXX_Size() int {
	return m.Size()
}
func (m *ImportWriteStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportWriteStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ImportWriteStatus proto.InternalMessageInfo

func (m *ImportWriteStatus) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *ImportWriteStatus) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *ImportWriteStatus) GetFilePrefix() string {
	if m != nil {
		return m.FilePrefix
	}
	return ""
}

type WorkerNodeHeartbeatRequest struct {
	Addr         string                        `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	Status       *WorkerNodeStatus             `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	Shards       []*WorkerNodeShardStatus      `protobuf:"bytes,3,rep,name=shards,proto3" json:"shards,omitempty"`
	Compactions  []*WorkerNodeCompactionStatus `protobuf:"bytes,4,rep,name=compactions,proto3" json:"compactions,omitempty"`
	ImportWrites []*ImportWriteStatus          `protobuf:"bytes,5,rep,name=import_writes,json=importWrites,proto3" json:"import_writes,omitempty"`
}

func (m *WorkerNodeHeartbeatRequest) Reset()         { *m = WorkerNodeHeartbeatRequest{} }
func (m *WorkerNodeHeartbeatRequest) String() string { return proto.CompactTextString(m) }
func (*WorkerNodeHeartbeatRequest) ProtoMessage()    {}
func (*WorkerNodeHeartbeatRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{5}
}
func (m *WorkerNodeHeartbeatRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerNodeHeartbeatRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerNodeHeartbeatRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerNodeHeartbeatRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerNodeHeartbeatRequest.Merge(m, src)
}
func (m *WorkerNodeHeartbeatRequest) XXX_Size() int {
	return m.Size()
}
func (m *WorkerNodeHeartbeatRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerNodeHeartbeatRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerNodeHeartbeatRequest proto.InternalMessageInfo

func (m *WorkerNodeHeartbeatRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *WorkerNodeHeartbeatRequest) GetStatus() *WorkerNodeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *WorkerNodeHeartbeatRequest) GetShards() []*WorkerNodeShardStatus {
	if m != nil {
		return m.Shards
	}
	return nil
}

func (m *WorkerNodeHeartbeatRequest) GetCompactions() []*WorkerNodeCompactionStatus {
	if m != nil {
		return m.Compactions
	}
	return nil
}

func (m *WorkerNodeHeartbeatRequest) GetImportWrites() []*ImportWriteStatus {
	if m != nil {
		return m.ImportWrites
	}
	return nil
}

type WorkerNodeHeartbeatResponse struct {
	Status      ErrorCode          `protobuf:"varint,1,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
	ToAddShards []*AddShardRequest `protobuf:"bytes,2,rep,name=to_add_shards,json=toAddShards,proto3" json:"to_add_shards,omitempty"`
	// We assume the `shard_id`s are unique across tables,
	// So using `shard_id` is enough here.
	ToRemoveShards []uint64 `protobuf:"varint,3,rep,packed,name=to_remove_shards,json=toRemoveShards,proto3" json:"to_remove_shards,omitempty"`
}

func (m *WorkerNodeHeartbeatResponse) Reset()         { *m = WorkerNodeHeartbeatResponse{} }
func (m *WorkerNodeHeartbeatResponse) String() string { return proto.CompactTextString(m) }
func (*WorkerNodeHeartbeatResponse) ProtoMessage()    {}
func (*WorkerNodeHeartbeatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{6}
}
func (m *WorkerNodeHeartbeatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerNodeHeartbeatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerNodeHeartbeatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerNodeHeartbeatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerNodeHeartbeatResponse.Merge(m, src)
}
func (m *WorkerNodeHeartbeatResponse) XXX_Size() int {
	return m.Size()
}
func (m *WorkerNodeHeartbeatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerNodeHeartbeatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerNodeHeartbeatResponse proto.InternalMessageInfo

func (m *WorkerNodeHeartbeatResponse) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

func (m *WorkerNodeHeartbeatResponse) GetToAddShards() []*AddShardRequest {
	if m != nil {
		return m.ToAddShards
	}
	return nil
}

func (m *WorkerNodeHeartbeatResponse) GetToRemoveShards() []uint64 {
	if m != nil {
		return m.ToRemoveShards
	}
	return nil
}

// Reader node heartbeat request
type ReaderNodeHeartbeatRequest struct {
	// Reader node address
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	// Reader node status
	Status *ReaderNodeStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// TiFlash server address
	TiflashServerAddr string `protobuf:"bytes,3,opt,name=tiflash_server_addr,json=tiflashServerAddr,proto3" json:"tiflash_server_addr,omitempty"`
	// List of cached shard IDs on this reader
	CachedShardIds []uint64 `protobuf:"varint,4,rep,packed,name=cached_shard_ids,json=cachedShardIds,proto3" json:"cached_shard_ids,omitempty"`
}

func (m *ReaderNodeHeartbeatRequest) Reset()         { *m = ReaderNodeHeartbeatRequest{} }
func (m *ReaderNodeHeartbeatRequest) String() string { return proto.CompactTextString(m) }
func (*ReaderNodeHeartbeatRequest) ProtoMessage()    {}
func (*ReaderNodeHeartbeatRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{7}
}
func (m *ReaderNodeHeartbeatRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReaderNodeHeartbeatRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReaderNodeHeartbeatRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReaderNodeHeartbeatRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReaderNodeHeartbeatRequest.Merge(m, src)
}
func (m *ReaderNodeHeartbeatRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReaderNodeHeartbeatRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReaderNodeHeartbeatRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReaderNodeHeartbeatRequest proto.InternalMessageInfo

func (m *ReaderNodeHeartbeatRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *ReaderNodeHeartbeatRequest) GetStatus() *ReaderNodeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *ReaderNodeHeartbeatRequest) GetTiflashServerAddr() string {
	if m != nil {
		return m.TiflashServerAddr
	}
	return ""
}

func (m *ReaderNodeHeartbeatRequest) GetCachedShardIds() []uint64 {
	if m != nil {
		return m.CachedShardIds
	}
	return nil
}

// Reader node heartbeat response
type ReaderNodeHeartbeatResponse struct {
	Status ErrorCode `protobuf:"varint,1,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
	// Error message, only valid when status is non-zero
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// List of shard headers that should be kept in cache
	ShardsToKeep []*ShardManifestHeader `protobuf:"bytes,3,rep,name=shards_to_keep,json=shardsToKeep,proto3" json:"shards_to_keep,omitempty"`
	// List of shard headers that should be removed from cache
	ShardsToRemove []*ShardManifestHeader `protobuf:"bytes,4,rep,name=shards_to_remove,json=shardsToRemove,proto3" json:"shards_to_remove,omitempty"`
}

func (m *ReaderNodeHeartbeatResponse) Reset()         { *m = ReaderNodeHeartbeatResponse{} }
func (m *ReaderNodeHeartbeatResponse) String() string { return proto.CompactTextString(m) }
func (*ReaderNodeHeartbeatResponse) ProtoMessage()    {}
func (*ReaderNodeHeartbeatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{8}
}
func (m *ReaderNodeHeartbeatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReaderNodeHeartbeatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReaderNodeHeartbeatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReaderNodeHeartbeatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReaderNodeHeartbeatResponse.Merge(m, src)
}
func (m *ReaderNodeHeartbeatResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReaderNodeHeartbeatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReaderNodeHeartbeatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReaderNodeHeartbeatResponse proto.InternalMessageInfo

func (m *ReaderNodeHeartbeatResponse) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

func (m *ReaderNodeHeartbeatResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *ReaderNodeHeartbeatResponse) GetShardsToKeep() []*ShardManifestHeader {
	if m != nil {
		return m.ShardsToKeep
	}
	return nil
}

func (m *ReaderNodeHeartbeatResponse) GetShardsToRemove() []*ShardManifestHeader {
	if m != nil {
		return m.ShardsToRemove
	}
	return nil
}

// Fragment metadata primarily stores all data files under a
// ​​fragment​​
type FragProperty struct {
	// Total file size of fragment.
	Size_ uint64 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	// Distinct handle count in fragment.
	Count     uint64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	MinHandle []byte `protobuf:"bytes,3,opt,name=min_handle,json=minHandle,proto3" json:"min_handle,omitempty"`
	MidHandle []byte `protobuf:"bytes,4,opt,name=mid_handle,json=midHandle,proto3" json:"mid_handle,omitempty"`
	MaxHandle []byte `protobuf:"bytes,5,opt,name=max_handle,json=maxHandle,proto3" json:"max_handle,omitempty"`
}

func (m *FragProperty) Reset()         { *m = FragProperty{} }
func (m *FragProperty) String() string { return proto.CompactTextString(m) }
func (*FragProperty) ProtoMessage()    {}
func (*FragProperty) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{9}
}
func (m *FragProperty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FragProperty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FragProperty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FragProperty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FragProperty.Merge(m, src)
}
func (m *FragProperty) XXX_Size() int {
	return m.Size()
}
func (m *FragProperty) XXX_DiscardUnknown() {
	xxx_messageInfo_FragProperty.DiscardUnknown(m)
}

var xxx_messageInfo_FragProperty proto.InternalMessageInfo

func (m *FragProperty) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *FragProperty) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *FragProperty) GetMinHandle() []byte {
	if m != nil {
		return m.MinHandle
	}
	return nil
}

func (m *FragProperty) GetMidHandle() []byte {
	if m != nil {
		return m.MidHandle
	}
	return nil
}

func (m *FragProperty) GetMaxHandle() []byte {
	if m != nil {
		return m.MaxHandle
	}
	return nil
}

type FragMeta struct {
	// Data format version​​, used for future iterative upgrades
	FormatVersion uint64 `protobuf:"varint,1,opt,name=format_version,json=formatVersion,proto3" json:"format_version,omitempty"`
	// Root path of the fragment​​
	FragPath      string                   `protobuf:"bytes,2,opt,name=frag_path,json=fragPath,proto3" json:"frag_path,omitempty"`
	HasDeletedSet bool                     `protobuf:"varint,3,opt,name=has_deleted_set,json=hasDeletedSet,proto3" json:"has_deleted_set,omitempty"`
	Segs          []*FragMeta_IndexSegment `protobuf:"bytes,4,rep,name=segs,proto3" json:"segs,omitempty"`
	Property      *FragProperty            `protobuf:"bytes,5,opt,name=property,proto3" json:"property,omitempty"`
}

func (m *FragMeta) Reset()         { *m = FragMeta{} }
func (m *FragMeta) String() string { return proto.CompactTextString(m) }
func (*FragMeta) ProtoMessage()    {}
func (*FragMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{10}
}
func (m *FragMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FragMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FragMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FragMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FragMeta.Merge(m, src)
}
func (m *FragMeta) XXX_Size() int {
	return m.Size()
}
func (m *FragMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_FragMeta.DiscardUnknown(m)
}

var xxx_messageInfo_FragMeta proto.InternalMessageInfo

func (m *FragMeta) GetFormatVersion() uint64 {
	if m != nil {
		return m.FormatVersion
	}
	return 0
}

func (m *FragMeta) GetFragPath() string {
	if m != nil {
		return m.FragPath
	}
	return ""
}

func (m *FragMeta) GetHasDeletedSet() bool {
	if m != nil {
		return m.HasDeletedSet
	}
	return false
}

func (m *FragMeta) GetSegs() []*FragMeta_IndexSegment {
	if m != nil {
		return m.Segs
	}
	return nil
}

func (m *FragMeta) GetProperty() *FragProperty {
	if m != nil {
		return m.Property
	}
	return nil
}

type FragMeta_IndexSegment struct {
	SegId     string `protobuf:"bytes,1,opt,name=seg_id,json=segId,proto3" json:"seg_id,omitempty"`
	DelSuffix string `protobuf:"bytes,2,opt,name=del_suffix,json=delSuffix,proto3" json:"del_suffix,omitempty"`
}

func (m *FragMeta_IndexSegment) Reset()         { *m = FragMeta_IndexSegment{} }
func (m *FragMeta_IndexSegment) String() string { return proto.CompactTextString(m) }
func (*FragMeta_IndexSegment) ProtoMessage()    {}
func (*FragMeta_IndexSegment) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{10, 0}
}
func (m *FragMeta_IndexSegment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FragMeta_IndexSegment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FragMeta_IndexSegment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FragMeta_IndexSegment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FragMeta_IndexSegment.Merge(m, src)
}
func (m *FragMeta_IndexSegment) XXX_Size() int {
	return m.Size()
}
func (m *FragMeta_IndexSegment) XXX_DiscardUnknown() {
	xxx_messageInfo_FragMeta_IndexSegment.DiscardUnknown(m)
}

var xxx_messageInfo_FragMeta_IndexSegment proto.InternalMessageInfo

func (m *FragMeta_IndexSegment) GetSegId() string {
	if m != nil {
		return m.SegId
	}
	return ""
}

func (m *FragMeta_IndexSegment) GetDelSuffix() string {
	if m != nil {
		return m.DelSuffix
	}
	return ""
}

type AppendDeltaFragMetaRequest struct {
	TableId        int64       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId        int64       `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	ShardId        uint64      `protobuf:"varint,3,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	WorkerNodeAddr string      `protobuf:"bytes,4,opt,name=worker_node_addr,json=workerNodeAddr,proto3" json:"worker_node_addr,omitempty"`
	FragMetas      []*FragMeta `protobuf:"bytes,5,rep,name=frag_metas,json=fragMetas,proto3" json:"frag_metas,omitempty"`
	LastCdcFile    string      `protobuf:"bytes,6,opt,name=last_cdc_file,json=lastCdcFile,proto3" json:"last_cdc_file,omitempty"`
}

func (m *AppendDeltaFragMetaRequest) Reset()         { *m = AppendDeltaFragMetaRequest{} }
func (m *AppendDeltaFragMetaRequest) String() string { return proto.CompactTextString(m) }
func (*AppendDeltaFragMetaRequest) ProtoMessage()    {}
func (*AppendDeltaFragMetaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{11}
}
func (m *AppendDeltaFragMetaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendDeltaFragMetaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendDeltaFragMetaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendDeltaFragMetaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendDeltaFragMetaRequest.Merge(m, src)
}
func (m *AppendDeltaFragMetaRequest) XXX_Size() int {
	return m.Size()
}
func (m *AppendDeltaFragMetaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendDeltaFragMetaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AppendDeltaFragMetaRequest proto.InternalMessageInfo

func (m *AppendDeltaFragMetaRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *AppendDeltaFragMetaRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *AppendDeltaFragMetaRequest) GetShardId() uint64 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

func (m *AppendDeltaFragMetaRequest) GetWorkerNodeAddr() string {
	if m != nil {
		return m.WorkerNodeAddr
	}
	return ""
}

func (m *AppendDeltaFragMetaRequest) GetFragMetas() []*FragMeta {
	if m != nil {
		return m.FragMetas
	}
	return nil
}

func (m *AppendDeltaFragMetaRequest) GetLastCdcFile() string {
	if m != nil {
		return m.LastCdcFile
	}
	return ""
}

type AppendFragMetaResponse struct {
	Status ErrorCode `protobuf:"varint,1,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
}

func (m *AppendFragMetaResponse) Reset()         { *m = AppendFragMetaResponse{} }
func (m *AppendFragMetaResponse) String() string { return proto.CompactTextString(m) }
func (*AppendFragMetaResponse) ProtoMessage()    {}
func (*AppendFragMetaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{12}
}
func (m *AppendFragMetaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendFragMetaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendFragMetaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendFragMetaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendFragMetaResponse.Merge(m, src)
}
func (m *AppendFragMetaResponse) XXX_Size() int {
	return m.Size()
}
func (m *AppendFragMetaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendFragMetaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AppendFragMetaResponse proto.InternalMessageInfo

func (m *AppendFragMetaResponse) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

type AppendBaseFragMetaRequest struct {
	TableId   int64       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId   int64       `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	FragMetas []*FragMeta `protobuf:"bytes,3,rep,name=frag_metas,json=fragMetas,proto3" json:"frag_metas,omitempty"`
}

func (m *AppendBaseFragMetaRequest) Reset()         { *m = AppendBaseFragMetaRequest{} }
func (m *AppendBaseFragMetaRequest) String() string { return proto.CompactTextString(m) }
func (*AppendBaseFragMetaRequest) ProtoMessage()    {}
func (*AppendBaseFragMetaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{13}
}
func (m *AppendBaseFragMetaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendBaseFragMetaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendBaseFragMetaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendBaseFragMetaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendBaseFragMetaRequest.Merge(m, src)
}
func (m *AppendBaseFragMetaRequest) XXX_Size() int {
	return m.Size()
}
func (m *AppendBaseFragMetaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendBaseFragMetaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AppendBaseFragMetaRequest proto.InternalMessageInfo

func (m *AppendBaseFragMetaRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *AppendBaseFragMetaRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *AppendBaseFragMetaRequest) GetFragMetas() []*FragMeta {
	if m != nil {
		return m.FragMetas
	}
	return nil
}

// Key range definition
type KeyRange struct {
	// Inclusive lower key bound
	StartKey []byte `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	// Exclusive upper key bound
	EndKey []byte `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
}

func (m *KeyRange) Reset()         { *m = KeyRange{} }
func (m *KeyRange) String() string { return proto.CompactTextString(m) }
func (*KeyRange) ProtoMessage()    {}
func (*KeyRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{14}
}
func (m *KeyRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyRange.Merge(m, src)
}
func (m *KeyRange) XXX_Size() int {
	return m.Size()
}
func (m *KeyRange) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyRange.DiscardUnknown(m)
}

var xxx_messageInfo_KeyRange proto.InternalMessageInfo

func (m *KeyRange) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *KeyRange) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

// Shard local cache information
type ShardLocalCacheInfo struct {
	Shard           *ShardManifestHeader `protobuf:"bytes,1,opt,name=shard,proto3" json:"shard,omitempty"`
	LocalCacheAddrs []string             `protobuf:"bytes,2,rep,name=local_cache_addrs,json=localCacheAddrs,proto3" json:"local_cache_addrs,omitempty"`
}

func (m *ShardLocalCacheInfo) Reset()         { *m = ShardLocalCacheInfo{} }
func (m *ShardLocalCacheInfo) String() string { return proto.CompactTextString(m) }
func (*ShardLocalCacheInfo) ProtoMessage()    {}
func (*ShardLocalCacheInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{15}
}
func (m *ShardLocalCacheInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardLocalCacheInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardLocalCacheInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardLocalCacheInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardLocalCacheInfo.Merge(m, src)
}
func (m *ShardLocalCacheInfo) XXX_Size() int {
	return m.Size()
}
func (m *ShardLocalCacheInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardLocalCacheInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ShardLocalCacheInfo proto.InternalMessageInfo

func (m *ShardLocalCacheInfo) GetShard() *ShardManifestHeader {
	if m != nil {
		return m.Shard
	}
	return nil
}

func (m *ShardLocalCacheInfo) GetLocalCacheAddrs() []string {
	if m != nil {
		return m.LocalCacheAddrs
	}
	return nil
}

// Request to get shard local cache information
type GetShardLocalCacheRequest struct {
	// Table ID to filter shards
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// Index ID to filter shards
	IndexId   int64       `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	KeyRanges []*KeyRange `protobuf:"bytes,3,rep,name=key_ranges,json=keyRanges,proto3" json:"key_ranges,omitempty"`
	// at most `limit` shards can be returned
	Limit int32 `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *GetShardLocalCacheRequest) Reset()         { *m = GetShardLocalCacheRequest{} }
func (m *GetShardLocalCacheRequest) String() string { return proto.CompactTextString(m) }
func (*GetShardLocalCacheRequest) ProtoMessage()    {}
func (*GetShardLocalCacheRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{16}
}
func (m *GetShardLocalCacheRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetShardLocalCacheRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetShardLocalCacheRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetShardLocalCacheRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetShardLocalCacheRequest.Merge(m, src)
}
func (m *GetShardLocalCacheRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetShardLocalCacheRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetShardLocalCacheRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetShardLocalCacheRequest proto.InternalMessageInfo

func (m *GetShardLocalCacheRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *GetShardLocalCacheRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *GetShardLocalCacheRequest) GetKeyRanges() []*KeyRange {
	if m != nil {
		return m.KeyRanges
	}
	return nil
}

func (m *GetShardLocalCacheRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// Response containing shard local cache information
type GetShardLocalCacheResponse struct {
	Status               int32                  `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	ShardLocalCacheInfos []*ShardLocalCacheInfo `protobuf:"bytes,2,rep,name=shard_local_cache_infos,json=shardLocalCacheInfos,proto3" json:"shard_local_cache_infos,omitempty"`
}

func (m *GetShardLocalCacheResponse) Reset()         { *m = GetShardLocalCacheResponse{} }
func (m *GetShardLocalCacheResponse) String() string { return proto.CompactTextString(m) }
func (*GetShardLocalCacheResponse) ProtoMessage()    {}
func (*GetShardLocalCacheResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{17}
}
func (m *GetShardLocalCacheResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetShardLocalCacheResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetShardLocalCacheResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetShardLocalCacheResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetShardLocalCacheResponse.Merge(m, src)
}
func (m *GetShardLocalCacheResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetShardLocalCacheResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetShardLocalCacheResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetShardLocalCacheResponse proto.InternalMessageInfo

func (m *GetShardLocalCacheResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *GetShardLocalCacheResponse) GetShardLocalCacheInfos() []*ShardLocalCacheInfo {
	if m != nil {
		return m.ShardLocalCacheInfos
	}
	return nil
}

type DebugGetShardManifestRequest struct {
	TableId  int64     `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId  int64     `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	KeyRange *KeyRange `protobuf:"bytes,3,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
}

func (m *DebugGetShardManifestRequest) Reset()         { *m = DebugGetShardManifestRequest{} }
func (m *DebugGetShardManifestRequest) String() string { return proto.CompactTextString(m) }
func (*DebugGetShardManifestRequest) ProtoMessage()    {}
func (*DebugGetShardManifestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{18}
}
func (m *DebugGetShardManifestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugGetShardManifestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugGetShardManifestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugGetShardManifestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugGetShardManifestRequest.Merge(m, src)
}
func (m *DebugGetShardManifestRequest) XXX_Size() int {
	return m.Size()
}
func (m *DebugGetShardManifestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugGetShardManifestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DebugGetShardManifestRequest proto.InternalMessageInfo

func (m *DebugGetShardManifestRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *DebugGetShardManifestRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *DebugGetShardManifestRequest) GetKeyRange() *KeyRange {
	if m != nil {
		return m.KeyRange
	}
	return nil
}

type DebugGetShardManifestResponse struct {
	Status    int32       `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	FragMetas []*FragMeta `protobuf:"bytes,2,rep,name=frag_metas,json=fragMetas,proto3" json:"frag_metas,omitempty"`
	ShardId   uint64      `protobuf:"varint,3,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
}

func (m *DebugGetShardManifestResponse) Reset()         { *m = DebugGetShardManifestResponse{} }
func (m *DebugGetShardManifestResponse) String() string { return proto.CompactTextString(m) }
func (*DebugGetShardManifestResponse) ProtoMessage()    {}
func (*DebugGetShardManifestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{19}
}
func (m *DebugGetShardManifestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugGetShardManifestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugGetShardManifestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugGetShardManifestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugGetShardManifestResponse.Merge(m, src)
}
func (m *DebugGetShardManifestResponse) XXX_Size() int {
	return m.Size()
}
func (m *DebugGetShardManifestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugGetShardManifestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DebugGetShardManifestResponse proto.InternalMessageInfo

func (m *DebugGetShardManifestResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *DebugGetShardManifestResponse) GetFragMetas() []*FragMeta {
	if m != nil {
		return m.FragMetas
	}
	return nil
}

func (m *DebugGetShardManifestResponse) GetShardId() uint64 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

type CompactFragRequest struct {
	Shard          *ShardManifestHeader `protobuf:"bytes,1,opt,name=shard,proto3" json:"shard,omitempty"`
	TableId        int64                `protobuf:"varint,2,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId        int64                `protobuf:"varint,3,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	Seq            uint64               `protobuf:"varint,4,opt,name=seq,proto3" json:"seq,omitempty"`
	Timestamp      uint64               `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	LeaderTerm     string               `protobuf:"bytes,6,opt,name=leader_term,json=leaderTerm,proto3" json:"leader_term,omitempty"`
	InputFrags     []*FragMeta          `protobuf:"bytes,7,rep,name=input_frags,json=inputFrags,proto3" json:"input_frags,omitempty"`
	UploadLocation *S3Location          `protobuf:"bytes,8,opt,name=upload_location,json=uploadLocation,proto3" json:"upload_location,omitempty"`
	CompactType    CompactType          `protobuf:"varint,9,opt,name=compact_type,json=compactType,proto3,enum=tici.CompactType" json:"compact_type,omitempty"`
	Worker         string               `protobuf:"bytes,10,opt,name=worker,proto3" json:"worker,omitempty"`
}

func (m *CompactFragRequest) Reset()         { *m = CompactFragRequest{} }
func (m *CompactFragRequest) String() string { return proto.CompactTextString(m) }
func (*CompactFragRequest) ProtoMessage()    {}
func (*CompactFragRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{20}
}
func (m *CompactFragRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactFragRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactFragRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactFragRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactFragRequest.Merge(m, src)
}
func (m *CompactFragRequest) XXX_Size() int {
	return m.Size()
}
func (m *CompactFragRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactFragRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CompactFragRequest proto.InternalMessageInfo

func (m *CompactFragRequest) GetShard() *ShardManifestHeader {
	if m != nil {
		return m.Shard
	}
	return nil
}

func (m *CompactFragRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *CompactFragRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *CompactFragRequest) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *CompactFragRequest) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *CompactFragRequest) GetLeaderTerm() string {
	if m != nil {
		return m.LeaderTerm
	}
	return ""
}

func (m *CompactFragRequest) GetInputFrags() []*FragMeta {
	if m != nil {
		return m.InputFrags
	}
	return nil
}

func (m *CompactFragRequest) GetUploadLocation() *S3Location {
	if m != nil {
		return m.UploadLocation
	}
	return nil
}

func (m *CompactFragRequest) GetCompactType() CompactType {
	if m != nil {
		return m.CompactType
	}
	return CompactType_Delta
}

func (m *CompactFragRequest) GetWorker() string {
	if m != nil {
		return m.Worker
	}
	return ""
}

type CompactFragResponse struct {
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *CompactFragResponse) Reset()         { *m = CompactFragResponse{} }
func (m *CompactFragResponse) String() string { return proto.CompactTextString(m) }
func (*CompactFragResponse) ProtoMessage()    {}
func (*CompactFragResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{21}
}
func (m *CompactFragResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactFragResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactFragResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactFragResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactFragResponse.Merge(m, src)
}
func (m *CompactFragResponse) XXX_Size() int {
	return m.Size()
}
func (m *CompactFragResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactFragResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CompactFragResponse proto.InternalMessageInfo

func (m *CompactFragResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type FinishCompactFragRequest struct {
	Addr        string               `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	Shard       *ShardManifestHeader `protobuf:"bytes,2,opt,name=shard,proto3" json:"shard,omitempty"`
	TableId     int64                `protobuf:"varint,3,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId     int64                `protobuf:"varint,4,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	Seq         uint64               `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
	Timestamp   uint64               `protobuf:"varint,6,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	LeaderTerm  string               `protobuf:"bytes,7,opt,name=leader_term,json=leaderTerm,proto3" json:"leader_term,omitempty"`
	InputFrags  []*FragMeta          `protobuf:"bytes,8,rep,name=input_frags,json=inputFrags,proto3" json:"input_frags,omitempty"`
	OutputFrags []*FragMeta          `protobuf:"bytes,9,rep,name=output_frags,json=outputFrags,proto3" json:"output_frags,omitempty"`
}

func (m *FinishCompactFragRequest) Reset()         { *m = FinishCompactFragRequest{} }
func (m *FinishCompactFragRequest) String() string { return proto.CompactTextString(m) }
func (*FinishCompactFragRequest) ProtoMessage()    {}
func (*FinishCompactFragRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{22}
}
func (m *FinishCompactFragRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinishCompactFragRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinishCompactFragRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinishCompactFragRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinishCompactFragRequest.Merge(m, src)
}
func (m *FinishCompactFragRequest) XXX_Size() int {
	return m.Size()
}
func (m *FinishCompactFragRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FinishCompactFragRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FinishCompactFragRequest proto.InternalMessageInfo

func (m *FinishCompactFragRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *FinishCompactFragRequest) GetShard() *ShardManifestHeader {
	if m != nil {
		return m.Shard
	}
	return nil
}

func (m *FinishCompactFragRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *FinishCompactFragRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *FinishCompactFragRequest) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *FinishCompactFragRequest) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *FinishCompactFragRequest) GetLeaderTerm() string {
	if m != nil {
		return m.LeaderTerm
	}
	return ""
}

func (m *FinishCompactFragRequest) GetInputFrags() []*FragMeta {
	if m != nil {
		return m.InputFrags
	}
	return nil
}

func (m *FinishCompactFragRequest) GetOutputFrags() []*FragMeta {
	if m != nil {
		return m.OutputFrags
	}
	return nil
}

type FinishCompactFragResponse struct {
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *FinishCompactFragResponse) Reset()         { *m = FinishCompactFragResponse{} }
func (m *FinishCompactFragResponse) String() string { return proto.CompactTextString(m) }
func (*FinishCompactFragResponse) ProtoMessage()    {}
func (*FinishCompactFragResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{23}
}
func (m *FinishCompactFragResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinishCompactFragResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinishCompactFragResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinishCompactFragResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinishCompactFragResponse.Merge(m, src)
}
func (m *FinishCompactFragResponse) XXX_Size() int {
	return m.Size()
}
func (m *FinishCompactFragResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FinishCompactFragResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FinishCompactFragResponse proto.InternalMessageInfo

func (m *FinishCompactFragResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type ImportWriteRequest struct {
	TaskId  uint64 `protobuf:"varint,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	TableId int64  `protobuf:"varint,2,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId int64  `protobuf:"varint,3,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	// The location of the file to be imported
	// For example, s3://bucket/prefix/filename
	FileLocation string `protobuf:"bytes,4,opt,name=file_location,json=fileLocation,proto3" json:"file_location,omitempty"`
	// The location of the fragment prefix
	// For example, s3://bucket/prefix/
	FragPrefix string `protobuf:"bytes,5,opt,name=frag_prefix,json=fragPrefix,proto3" json:"frag_prefix,omitempty"`
}

func (m *ImportWriteRequest) Reset()         { *m = ImportWriteRequest{} }
func (m *ImportWriteRequest) String() string { return proto.CompactTextString(m) }
func (*ImportWriteRequest) ProtoMessage()    {}
func (*ImportWriteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{24}
}
func (m *ImportWriteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportWriteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImportWriteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImportWriteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportWriteRequest.Merge(m, src)
}
func (m *ImportWriteRequest) XXX_Size() int {
	return m.Size()
}
func (m *ImportWriteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportWriteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ImportWriteRequest proto.InternalMessageInfo

func (m *ImportWriteRequest) GetTaskId() uint64 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *ImportWriteRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *ImportWriteRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *ImportWriteRequest) GetFileLocation() string {
	if m != nil {
		return m.FileLocation
	}
	return ""
}

func (m *ImportWriteRequest) GetFragPrefix() string {
	if m != nil {
		return m.FragPrefix
	}
	return ""
}

type ImportWriteResponse struct {
	// Operation result status code, 0 means success
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ImportWriteResponse) Reset()         { *m = ImportWriteResponse{} }
func (m *ImportWriteResponse) String() string { return proto.CompactTextString(m) }
func (*ImportWriteResponse) ProtoMessage()    {}
func (*ImportWriteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{25}
}
func (m *ImportWriteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportWriteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImportWriteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImportWriteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportWriteResponse.Merge(m, src)
}
func (m *ImportWriteResponse) XXX_Size() int {
	return m.Size()
}
func (m *ImportWriteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportWriteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ImportWriteResponse proto.InternalMessageInfo

func (m *ImportWriteResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type ShardManifestHeader struct {
	ShardId  uint64 `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	StartKey []byte `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	Epoch    uint64 `protobuf:"varint,4,opt,name=epoch,proto3" json:"epoch,omitempty"`
}

func (m *ShardManifestHeader) Reset()         { *m = ShardManifestHeader{} }
func (m *ShardManifestHeader) String() string { return proto.CompactTextString(m) }
func (*ShardManifestHeader) ProtoMessage()    {}
func (*ShardManifestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{26}
}
func (m *ShardManifestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardManifestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardManifestHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardManifestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardManifestHeader.Merge(m, src)
}
func (m *ShardManifestHeader) XXX_Size() int {
	return m.Size()
}
func (m *ShardManifestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardManifestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ShardManifestHeader proto.InternalMessageInfo

func (m *ShardManifestHeader) GetShardId() uint64 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

func (m *ShardManifestHeader) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *ShardManifestHeader) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *ShardManifestHeader) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

type S3Location struct {
	Bucket string `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Prefix string `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
}

func (m *S3Location) Reset()         { *m = S3Location{} }
func (m *S3Location) String() string { return proto.CompactTextString(m) }
func (*S3Location) ProtoMessage()    {}
func (*S3Location) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{27}
}
func (m *S3Location) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S3Location) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S3Location.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S3Location) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S3Location.Merge(m, src)
}
func (m *S3Location) XXX_Size() int {
	return m.Size()
}
func (m *S3Location) XXX_DiscardUnknown() {
	xxx_messageInfo_S3Location.DiscardUnknown(m)
}

var xxx_messageInfo_S3Location proto.InternalMessageInfo

func (m *S3Location) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *S3Location) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

// AddShardRequest is sent from meta service to worker node
type AddShardRequest struct {
	Shard *ShardManifestHeader `protobuf:"bytes,1,opt,name=shard,proto3" json:"shard,omitempty"`
	// Index information
	IndexInfo *IndexInfo `protobuf:"bytes,2,opt,name=index_info,json=indexInfo,proto3" json:"index_info,omitempty"`
	// Table information
	TableInfo *TableInfo `protobuf:"bytes,3,opt,name=table_info,json=tableInfo,proto3" json:"table_info,omitempty"`
	// If the shard is created from scratch, this field is empty
	CdcS3LastFile  string      `protobuf:"bytes,4,opt,name=cdc_s3_last_file,json=cdcS3LastFile,proto3" json:"cdc_s3_last_file,omitempty"`
	CdcLocation    *S3Location `protobuf:"bytes,5,opt,name=cdc_location,json=cdcLocation,proto3" json:"cdc_location,omitempty"`
	UploadLocation *S3Location `protobuf:"bytes,6,opt,name=upload_location,json=uploadLocation,proto3" json:"upload_location,omitempty"`
}

func (m *AddShardRequest) Reset()         { *m = AddShardRequest{} }
func (m *AddShardRequest) String() string { return proto.CompactTextString(m) }
func (*AddShardRequest) ProtoMessage()    {}
func (*AddShardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{28}
}
func (m *AddShardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddShardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddShardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddShardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddShardRequest.Merge(m, src)
}
func (m *AddShardRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddShardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddShardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddShardRequest proto.InternalMessageInfo

func (m *AddShardRequest) GetShard() *ShardManifestHeader {
	if m != nil {
		return m.Shard
	}
	return nil
}

func (m *AddShardRequest) GetIndexInfo() *IndexInfo {
	if m != nil {
		return m.IndexInfo
	}
	return nil
}

func (m *AddShardRequest) GetTableInfo() *TableInfo {
	if m != nil {
		return m.TableInfo
	}
	return nil
}

func (m *AddShardRequest) GetCdcS3LastFile() string {
	if m != nil {
		return m.CdcS3LastFile
	}
	return ""
}

func (m *AddShardRequest) GetCdcLocation() *S3Location {
	if m != nil {
		return m.CdcLocation
	}
	return nil
}

func (m *AddShardRequest) GetUploadLocation() *S3Location {
	if m != nil {
		return m.UploadLocation
	}
	return nil
}

// AddShardResponse
type AddShardResponse struct {
	// Operation result status code, 0 means success
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *AddShardResponse) Reset()         { *m = AddShardResponse{} }
func (m *AddShardResponse) String() string { return proto.CompactTextString(m) }
func (*AddShardResponse) ProtoMessage()    {}
func (*AddShardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{29}
}
func (m *AddShardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddShardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddShardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddShardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddShardResponse.Merge(m, src)
}
func (m *AddShardResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddShardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddShardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddShardResponse proto.InternalMessageInfo

func (m *AddShardResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// CreateIndexRequest is a request to create an index
type CreateIndexRequest struct {
	// Index information
	IndexInfo *IndexInfo `protobuf:"bytes,1,opt,name=index_info,json=indexInfo,proto3" json:"index_info,omitempty"`
	// Table information
	TableInfo *TableInfo `protobuf:"bytes,2,opt,name=table_info,json=tableInfo,proto3" json:"table_info,omitempty"`
}

func (m *CreateIndexRequest) Reset()         { *m = CreateIndexRequest{} }
func (m *CreateIndexRequest) String() string { return proto.CompactTextString(m) }
func (*CreateIndexRequest) ProtoMessage()    {}
func (*CreateIndexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{30}
}
func (m *CreateIndexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateIndexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateIndexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateIndexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateIndexRequest.Merge(m, src)
}
func (m *CreateIndexRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateIndexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateIndexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateIndexRequest proto.InternalMessageInfo

func (m *CreateIndexRequest) GetIndexInfo() *IndexInfo {
	if m != nil {
		return m.IndexInfo
	}
	return nil
}

func (m *CreateIndexRequest) GetTableInfo() *TableInfo {
	if m != nil {
		return m.TableInfo
	}
	return nil
}

// CreateIndexResponse is a response to the index creation request
type CreateIndexResponse struct {
	Status ErrorCode `protobuf:"varint,1,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
	// Error message, only valid when status is non-zero
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Created index ID
	IndexId string `protobuf:"bytes,3,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
}

func (m *CreateIndexResponse) Reset()         { *m = CreateIndexResponse{} }
func (m *CreateIndexResponse) String() string { return proto.CompactTextString(m) }
func (*CreateIndexResponse) ProtoMessage()    {}
func (*CreateIndexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{31}
}
func (m *CreateIndexResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateIndexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateIndexResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateIndexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateIndexResponse.Merge(m, src)
}
func (m *CreateIndexResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateIndexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateIndexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateIndexResponse proto.InternalMessageInfo

func (m *CreateIndexResponse) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

func (m *CreateIndexResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *CreateIndexResponse) GetIndexId() string {
	if m != nil {
		return m.IndexId
	}
	return ""
}

// DropIndexRequest is a request to drop an index
type DropIndexRequest struct {
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId int64 `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
}

func (m *DropIndexRequest) Reset()         { *m = DropIndexRequest{} }
func (m *DropIndexRequest) String() string { return proto.CompactTextString(m) }
func (*DropIndexRequest) ProtoMessage()    {}
func (*DropIndexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{32}
}
func (m *DropIndexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropIndexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropIndexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropIndexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropIndexRequest.Merge(m, src)
}
func (m *DropIndexRequest) XXX_Size() int {
	return m.Size()
}
func (m *DropIndexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DropIndexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DropIndexRequest proto.InternalMessageInfo

func (m *DropIndexRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *DropIndexRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

// DropIndexResponse is a response to the index drop request
type DropIndexResponse struct {
	Status ErrorCode `protobuf:"varint,1,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
	// Error message, only valid when status is non-zero
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *DropIndexResponse) Reset()         { *m = DropIndexResponse{} }
func (m *DropIndexResponse) String() string { return proto.CompactTextString(m) }
func (*DropIndexResponse) ProtoMessage()    {}
func (*DropIndexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{33}
}
func (m *DropIndexResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropIndexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropIndexResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropIndexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropIndexResponse.Merge(m, src)
}
func (m *DropIndexResponse) XXX_Size() int {
	return m.Size()
}
func (m *DropIndexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DropIndexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DropIndexResponse proto.InternalMessageInfo

func (m *DropIndexResponse) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

func (m *DropIndexResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// TableInfo represents table information
type TableInfo struct {
	// Table ID
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// Table name
	TableName string `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	// Database name
	DatabaseName string `protobuf:"bytes,3,opt,name=database_name,json=databaseName,proto3" json:"database_name,omitempty"`
	// Table version
	Version int64 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	// Column information
	Columns []*ColumnInfo `protobuf:"bytes,5,rep,name=columns,proto3" json:"columns,omitempty"`
	// Whether the table is clustered
	IsClustered bool `protobuf:"varint,6,opt,name=is_clustered,json=isClustered,proto3" json:"is_clustered,omitempty"`
}

func (m *TableInfo) Reset()         { *m = TableInfo{} }
func (m *TableInfo) String() string { return proto.CompactTextString(m) }
func (*TableInfo) ProtoMessage()    {}
func (*TableInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{34}
}
func (m *TableInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableInfo.Merge(m, src)
}
func (m *TableInfo) XXX_Size() int {
	return m.Size()
}
func (m *TableInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TableInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TableInfo proto.InternalMessageInfo

func (m *TableInfo) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *TableInfo) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *TableInfo) GetDatabaseName() string {
	if m != nil {
		return m.DatabaseName
	}
	return ""
}

func (m *TableInfo) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *TableInfo) GetColumns() []*ColumnInfo {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *TableInfo) GetIsClustered() bool {
	if m != nil {
		return m.IsClustered
	}
	return false
}

// ColumnInfo represents column information
type ColumnInfo struct {
	// Column ID
	ColumnId int64 `protobuf:"varint,1,opt,name=column_id,json=columnId,proto3" json:"column_id,omitempty"`
	// Column name
	ColumnName string `protobuf:"bytes,2,opt,name=column_name,json=columnName,proto3" json:"column_name,omitempty"`
	// MySQL type
	Type int32 `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	// Collation
	Collation int32 `protobuf:"varint,4,opt,name=collation,proto3" json:"collation,omitempty"`
	// Column length
	ColumnLength int32 `protobuf:"varint,5,opt,name=column_length,json=columnLength,proto3" json:"column_length,omitempty"`
	// Decimal places
	Decimal int32 `protobuf:"varint,6,opt,name=decimal,proto3" json:"decimal,omitempty"`
	// Flags
	Flag uint32 `protobuf:"varint,7,opt,name=flag,proto3" json:"flag,omitempty"`
	// Enum elements
	Elems []string `protobuf:"bytes,8,rep,name=elems,proto3" json:"elems,omitempty"`
	// Default value
	DefaultVal []byte `protobuf:"bytes,9,opt,name=default_val,json=defaultVal,proto3" json:"default_val,omitempty"`
	// Whether it's a primary key
	IsPrimaryKey bool `protobuf:"varint,10,opt,name=is_primary_key,json=isPrimaryKey,proto3" json:"is_primary_key,omitempty"`
	// Whether it's an array
	IsArray bool `protobuf:"varint,11,opt,name=is_array,json=isArray,proto3" json:"is_array,omitempty"`
}

func (m *ColumnInfo) Reset()         { *m = ColumnInfo{} }
func (m *ColumnInfo) String() string { return proto.CompactTextString(m) }
func (*ColumnInfo) ProtoMessage()    {}
func (*ColumnInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{35}
}
func (m *ColumnInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColumnInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnInfo.Merge(m, src)
}
func (m *ColumnInfo) XXX_Size() int {
	return m.Size()
}
func (m *ColumnInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnInfo proto.InternalMessageInfo

func (m *ColumnInfo) GetColumnId() int64 {
	if m != nil {
		return m.ColumnId
	}
	return 0
}

func (m *ColumnInfo) GetColumnName() string {
	if m != nil {
		return m.ColumnName
	}
	return ""
}

func (m *ColumnInfo) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ColumnInfo) GetCollation() int32 {
	if m != nil {
		return m.Collation
	}
	return 0
}

func (m *ColumnInfo) GetColumnLength() int32 {
	if m != nil {
		return m.ColumnLength
	}
	return 0
}

func (m *ColumnInfo) GetDecimal() int32 {
	if m != nil {
		return m.Decimal
	}
	return 0
}

func (m *ColumnInfo) GetFlag() uint32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

func (m *ColumnInfo) GetElems() []string {
	if m != nil {
		return m.Elems
	}
	return nil
}

func (m *ColumnInfo) GetDefaultVal() []byte {
	if m != nil {
		return m.DefaultVal
	}
	return nil
}

func (m *ColumnInfo) GetIsPrimaryKey() bool {
	if m != nil {
		return m.IsPrimaryKey
	}
	return false
}

func (m *ColumnInfo) GetIsArray() bool {
	if m != nil {
		return m.IsArray
	}
	return false
}

// IndexInfo represents index information
type IndexInfo struct {
	// Table ID
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// Index ID
	IndexId int64 `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	// Index name
	IndexName string `protobuf:"bytes,3,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty"`
	// Index type (fulltext, custom)
	IndexType IndexType `protobuf:"varint,4,opt,name=index_type,json=indexType,proto3,enum=tici.IndexType" json:"index_type,omitempty"`
	// Index columns
	Columns []*ColumnInfo `protobuf:"bytes,5,rep,name=columns,proto3" json:"columns,omitempty"`
	// Whether the index is unique
	IsUnique bool `protobuf:"varint,6,opt,name=is_unique,json=isUnique,proto3" json:"is_unique,omitempty"`
	// Parser information
	ParserInfo *ParserInfo `protobuf:"bytes,7,opt,name=parser_info,json=parserInfo,proto3" json:"parser_info,omitempty"`
	// Other index parameters
	OtherParams map[string]string `protobuf:"bytes,8,rep,name=other_params,json=otherParams,proto3" json:"other_params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *IndexInfo) Reset()         { *m = IndexInfo{} }
func (m *IndexInfo) String() string { return proto.CompactTextString(m) }
func (*IndexInfo) ProtoMessage()    {}
func (*IndexInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{36}
}
func (m *IndexInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexInfo.Merge(m, src)
}
func (m *IndexInfo) XXX_Size() int {
	return m.Size()
}
func (m *IndexInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IndexInfo proto.InternalMessageInfo

func (m *IndexInfo) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *IndexInfo) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *IndexInfo) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *IndexInfo) GetIndexType() IndexType {
	if m != nil {
		return m.IndexType
	}
	return IndexType_UNKNOWN
}

func (m *IndexInfo) GetColumns() []*ColumnInfo {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *IndexInfo) GetIsUnique() bool {
	if m != nil {
		return m.IsUnique
	}
	return false
}

func (m *IndexInfo) GetParserInfo() *ParserInfo {
	if m != nil {
		return m.ParserInfo
	}
	return nil
}

func (m *IndexInfo) GetOtherParams() map[string]string {
	if m != nil {
		return m.OtherParams
	}
	return nil
}

// ParserInfo represents parser information
type ParserInfo struct {
	// Parser type
	ParserType ParserType `protobuf:"varint,1,opt,name=parser_type,json=parserType,proto3,enum=tici.ParserType" json:"parser_type,omitempty"`
	// Parser parameters
	ParserParams map[string]string `protobuf:"bytes,2,rep,name=parser_params,json=parserParams,proto3" json:"parser_params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ParserInfo) Reset()         { *m = ParserInfo{} }
func (m *ParserInfo) String() string { return proto.CompactTextString(m) }
func (*ParserInfo) ProtoMessage()    {}
func (*ParserInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{37}
}
func (m *ParserInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParserInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParserInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParserInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParserInfo.Merge(m, src)
}
func (m *ParserInfo) XXX_Size() int {
	return m.Size()
}
func (m *ParserInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ParserInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ParserInfo proto.InternalMessageInfo

func (m *ParserInfo) GetParserType() ParserType {
	if m != nil {
		return m.ParserType
	}
	return ParserType_UNKNOWN_PARSER
}

func (m *ParserInfo) GetParserParams() map[string]string {
	if m != nil {
		return m.ParserParams
	}
	return nil
}

// GetIndexProgressRequest is a request to get the progress of an index build
type GetIndexProgressRequest struct {
	// Table ID
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// Index ID
	IndexId int64 `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
}

func (m *GetIndexProgressRequest) Reset()         { *m = GetIndexProgressRequest{} }
func (m *GetIndexProgressRequest) String() string { return proto.CompactTextString(m) }
func (*GetIndexProgressRequest) ProtoMessage()    {}
func (*GetIndexProgressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{38}
}
func (m *GetIndexProgressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetIndexProgressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetIndexProgressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetIndexProgressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetIndexProgressRequest.Merge(m, src)
}
func (m *GetIndexProgressRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetIndexProgressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetIndexProgressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetIndexProgressRequest proto.InternalMessageInfo

func (m *GetIndexProgressRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *GetIndexProgressRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

// GetIndexProgressResponse is a response containing index build progress
type GetIndexProgressResponse struct {
	Status ErrorCode `protobuf:"varint,1,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
	// Error message, only valid when status is non-zero
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Number of documents indexed so far
	DocumentCount uint64 `protobuf:"varint,3,opt,name=document_count,json=documentCount,proto3" json:"document_count,omitempty"`
	// Build task state (PENDING, RUNNING, COMPLETED, FAILED)
	State GetIndexProgressResponse_State `protobuf:"varint,4,opt,name=state,proto3,enum=tici.GetIndexProgressResponse_State" json:"state,omitempty"`
	// Whether index has been uploaded to S3
	IsUploaded bool `protobuf:"varint,5,opt,name=is_uploaded,json=isUploaded,proto3" json:"is_uploaded,omitempty"`
	// Last S3 upload time in RFC3339 format
	LastUploadTime string `protobuf:"bytes,6,opt,name=last_upload_time,json=lastUploadTime,proto3" json:"last_upload_time,omitempty"`
	// S3 path where the index is stored
	S3Path string `protobuf:"bytes,7,opt,name=s3_path,json=s3Path,proto3" json:"s3_path,omitempty"`
}

func (m *GetIndexProgressResponse) Reset()         { *m = GetIndexProgressResponse{} }
func (m *GetIndexProgressResponse) String() string { return proto.CompactTextString(m) }
func (*GetIndexProgressResponse) ProtoMessage()    {}
func (*GetIndexProgressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{39}
}
func (m *GetIndexProgressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetIndexProgressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetIndexProgressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetIndexProgressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetIndexProgressResponse.Merge(m, src)
}
func (m *GetIndexProgressResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetIndexProgressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetIndexProgressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetIndexProgressResponse proto.InternalMessageInfo

func (m *GetIndexProgressResponse) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

func (m *GetIndexProgressResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *GetIndexProgressResponse) GetDocumentCount() uint64 {
	if m != nil {
		return m.DocumentCount
	}
	return 0
}

func (m *GetIndexProgressResponse) GetState() GetIndexProgressResponse_State {
	if m != nil {
		return m.State
	}
	return GetIndexProgressResponse_PENDING
}

func (m *GetIndexProgressResponse) GetIsUploaded() bool {
	if m != nil {
		return m.IsUploaded
	}
	return false
}

func (m *GetIndexProgressResponse) GetLastUploadTime() string {
	if m != nil {
		return m.LastUploadTime
	}
	return ""
}

func (m *GetIndexProgressResponse) GetS3Path() string {
	if m != nil {
		return m.S3Path
	}
	return ""
}

type ImportIndexJobRequest struct {
	// Table ID of the target table.
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// Index ID of the target index.
	IndexId int64 `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	// Start TSO of the import job.
	StartTs uint64 `protobuf:"varint,3,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
}

func (m *ImportIndexJobRequest) Reset()         { *m = ImportIndexJobRequest{} }
func (m *ImportIndexJobRequest) String() string { return proto.CompactTextString(m) }
func (*ImportIndexJobRequest) ProtoMessage()    {}
func (*ImportIndexJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{40}
}
func (m *ImportIndexJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportIndexJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImportIndexJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImportIndexJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportIndexJobRequest.Merge(m, src)
}
func (m *ImportIndexJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *ImportIndexJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportIndexJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ImportIndexJobRequest proto.InternalMessageInfo

func (m *ImportIndexJobRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *ImportIndexJobRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *ImportIndexJobRequest) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

type ImportIndexJobResponse struct {
	Status ErrorCode `protobuf:"varint,1,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
	// Optional human‑readable diagnostics, only defined when status ≠ 0.
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// The import index job_id in TiCI
	JobId uint64 `protobuf:"varint,3,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// The cloud storage prefix where the import data should be written.
	// The format is "s3://bucket/prefix/".
	StorageUri string `protobuf:"bytes,4,opt,name=storage_uri,json=storageUri,proto3" json:"storage_uri,omitempty"`
}

func (m *ImportIndexJobResponse) Reset()         { *m = ImportIndexJobResponse{} }
func (m *ImportIndexJobResponse) String() string { return proto.CompactTextString(m) }
func (*ImportIndexJobResponse) ProtoMessage()    {}
func (*ImportIndexJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{41}
}
func (m *ImportIndexJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportIndexJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImportIndexJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImportIndexJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportIndexJobResponse.Merge(m, src)
}
func (m *ImportIndexJobResponse) XXX_Size() int {
	return m.Size()
}
func (m *ImportIndexJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportIndexJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ImportIndexJobResponse proto.InternalMessageInfo

func (m *ImportIndexJobResponse) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

func (m *ImportIndexJobResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *ImportIndexJobResponse) GetJobId() uint64 {
	if m != nil {
		return m.JobId
	}
	return 0
}

func (m *ImportIndexJobResponse) GetStorageUri() string {
	if m != nil {
		return m.StorageUri
	}
	return ""
}

type FinishImportPartitionUploadRequest struct {
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId int64 `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	// Key range for the partition uploaded.
	KeyRange *KeyRange `protobuf:"bytes,3,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
	S3Path   string    `protobuf:"bytes,4,opt,name=s3_path,json=s3Path,proto3" json:"s3_path,omitempty"`
}

func (m *FinishImportPartitionUploadRequest) Reset()         { *m = FinishImportPartitionUploadRequest{} }
func (m *FinishImportPartitionUploadRequest) String() string { return proto.CompactTextString(m) }
func (*FinishImportPartitionUploadRequest) ProtoMessage()    {}
func (*FinishImportPartitionUploadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{42}
}
func (m *FinishImportPartitionUploadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinishImportPartitionUploadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinishImportPartitionUploadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinishImportPartitionUploadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinishImportPartitionUploadRequest.Merge(m, src)
}
func (m *FinishImportPartitionUploadRequest) XXX_Size() int {
	return m.Size()
}
func (m *FinishImportPartitionUploadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FinishImportPartitionUploadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FinishImportPartitionUploadRequest proto.InternalMessageInfo

func (m *FinishImportPartitionUploadRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *FinishImportPartitionUploadRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *FinishImportPartitionUploadRequest) GetKeyRange() *KeyRange {
	if m != nil {
		return m.KeyRange
	}
	return nil
}

func (m *FinishImportPartitionUploadRequest) GetS3Path() string {
	if m != nil {
		return m.S3Path
	}
	return ""
}

//   - If the index is built successfully, the `status` field should be 0,
//     and the `frag_metas` field should contain the metadata of the uploaded
//     baseline fragments. MetaService is responsible for
//     1. Find the overlapped Shards for the given table_id, index_id and key_range
//     2. Append the frags to all the overlapped shards' baseline frags
//     3. Update the ImportTask with task_id status as finished
//   - If the index building meet unrecoverable errors, then MetaService should
//     update the ImportTask with task_id status as failed
type FinishImportPartitionBuildRequest struct {
	TableId int64     `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId int64     `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	TaskId  uint64    `protobuf:"varint,3,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	Status  ErrorCode `protobuf:"varint,4,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
	// The uploaded fragment metadata when status is 0.
	FragMetas []*FragMeta `protobuf:"bytes,5,rep,name=frag_metas,json=fragMetas,proto3" json:"frag_metas,omitempty"`
	// The error message if the status is not 0.
	ErrorMessage string `protobuf:"bytes,6,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *FinishImportPartitionBuildRequest) Reset()         { *m = FinishImportPartitionBuildRequest{} }
func (m *FinishImportPartitionBuildRequest) String() string { return proto.CompactTextString(m) }
func (*FinishImportPartitionBuildRequest) ProtoMessage()    {}
func (*FinishImportPartitionBuildRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{43}
}
func (m *FinishImportPartitionBuildRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinishImportPartitionBuildRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinishImportPartitionBuildRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinishImportPartitionBuildRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinishImportPartitionBuildRequest.Merge(m, src)
}
func (m *FinishImportPartitionBuildRequest) XXX_Size() int {
	return m.Size()
}
func (m *FinishImportPartitionBuildRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FinishImportPartitionBuildRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FinishImportPartitionBuildRequest proto.InternalMessageInfo

func (m *FinishImportPartitionBuildRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *FinishImportPartitionBuildRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *FinishImportPartitionBuildRequest) GetTaskId() uint64 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *FinishImportPartitionBuildRequest) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

func (m *FinishImportPartitionBuildRequest) GetFragMetas() []*FragMeta {
	if m != nil {
		return m.FragMetas
	}
	return nil
}

func (m *FinishImportPartitionBuildRequest) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

type FinishImportIndexUploadRequest struct {
	// Table ID of the target table.
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// Index ID of the target index.
	IndexId int64 `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
}

func (m *FinishImportIndexUploadRequest) Reset()         { *m = FinishImportIndexUploadRequest{} }
func (m *FinishImportIndexUploadRequest) String() string { return proto.CompactTextString(m) }
func (*FinishImportIndexUploadRequest) ProtoMessage()    {}
func (*FinishImportIndexUploadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{44}
}
func (m *FinishImportIndexUploadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinishImportIndexUploadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinishImportIndexUploadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinishImportIndexUploadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinishImportIndexUploadRequest.Merge(m, src)
}
func (m *FinishImportIndexUploadRequest) XXX_Size() int {
	return m.Size()
}
func (m *FinishImportIndexUploadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FinishImportIndexUploadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FinishImportIndexUploadRequest proto.InternalMessageInfo

func (m *FinishImportIndexUploadRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *FinishImportIndexUploadRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

type FinishImportResponse struct {
	Status ErrorCode `protobuf:"varint,1,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
	// Optional human‑readable diagnostics, only defined when status ≠ 0.
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *FinishImportResponse) Reset()         { *m = FinishImportResponse{} }
func (m *FinishImportResponse) String() string { return proto.CompactTextString(m) }
func (*FinishImportResponse) ProtoMessage()    {}
func (*FinishImportResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{45}
}
func (m *FinishImportResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinishImportResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinishImportResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinishImportResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinishImportResponse.Merge(m, src)
}
func (m *FinishImportResponse) XXX_Size() int {
	return m.Size()
}
func (m *FinishImportResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FinishImportResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FinishImportResponse proto.InternalMessageInfo

func (m *FinishImportResponse) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

func (m *FinishImportResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func init() {
	proto.RegisterEnum("tici.ErrorCode", ErrorCode_name, ErrorCode_value)
	proto.RegisterEnum("tici.CompactType", CompactType_name, CompactType_value)
	proto.RegisterEnum("tici.IndexType", IndexType_name, IndexType_value)
	proto.RegisterEnum("tici.ParserType", ParserType_name, ParserType_value)
	proto.RegisterEnum("tici.GetIndexProgressResponse_State", GetIndexProgressResponse_State_name, GetIndexProgressResponse_State_value)
	proto.RegisterType((*WorkerNodeStatus)(nil), "tici.WorkerNodeStatus")
	proto.RegisterType((*ReaderNodeStatus)(nil), "tici.ReaderNodeStatus")
	proto.RegisterType((*WorkerNodeShardStatus)(nil), "tici.WorkerNodeShardStatus")
	proto.RegisterType((*WorkerNodeCompactionStatus)(nil), "tici.WorkerNodeCompactionStatus")
	proto.RegisterType((*ImportWriteStatus)(nil), "tici.ImportWriteStatus")
	proto.RegisterType((*WorkerNodeHeartbeatRequest)(nil), "tici.WorkerNodeHeartbeatRequest")
	proto.RegisterType((*WorkerNodeHeartbeatResponse)(nil), "tici.WorkerNodeHeartbeatResponse")
	proto.RegisterType((*ReaderNodeHeartbeatRequest)(nil), "tici.ReaderNodeHeartbeatRequest")
	proto.RegisterType((*ReaderNodeHeartbeatResponse)(nil), "tici.ReaderNodeHeartbeatResponse")
	proto.RegisterType((*FragProperty)(nil), "tici.FragProperty")
	proto.RegisterType((*FragMeta)(nil), "tici.FragMeta")
	proto.RegisterType((*FragMeta_IndexSegment)(nil), "tici.FragMeta.IndexSegment")
	proto.RegisterType((*AppendDeltaFragMetaRequest)(nil), "tici.AppendDeltaFragMetaRequest")
	proto.RegisterType((*AppendFragMetaResponse)(nil), "tici.AppendFragMetaResponse")
	proto.RegisterType((*AppendBaseFragMetaRequest)(nil), "tici.AppendBaseFragMetaRequest")
	proto.RegisterType((*KeyRange)(nil), "tici.KeyRange")
	proto.RegisterType((*ShardLocalCacheInfo)(nil), "tici.ShardLocalCacheInfo")
	proto.RegisterType((*GetShardLocalCacheRequest)(nil), "tici.GetShardLocalCacheRequest")
	proto.RegisterType((*GetShardLocalCacheResponse)(nil), "tici.GetShardLocalCacheResponse")
	proto.RegisterType((*DebugGetShardManifestRequest)(nil), "tici.DebugGetShardManifestRequest")
	proto.RegisterType((*DebugGetShardManifestResponse)(nil), "tici.DebugGetShardManifestResponse")
	proto.RegisterType((*CompactFragRequest)(nil), "tici.CompactFragRequest")
	proto.RegisterType((*CompactFragResponse)(nil), "tici.CompactFragResponse")
	proto.RegisterType((*FinishCompactFragRequest)(nil), "tici.FinishCompactFragRequest")
	proto.RegisterType((*FinishCompactFragResponse)(nil), "tici.FinishCompactFragResponse")
	proto.RegisterType((*ImportWriteRequest)(nil), "tici.ImportWriteRequest")
	proto.RegisterType((*ImportWriteResponse)(nil), "tici.ImportWriteResponse")
	proto.RegisterType((*ShardManifestHeader)(nil), "tici.ShardManifestHeader")
	proto.RegisterType((*S3Location)(nil), "tici.S3Location")
	proto.RegisterType((*AddShardRequest)(nil), "tici.AddShardRequest")
	proto.RegisterType((*AddShardResponse)(nil), "tici.AddShardResponse")
	proto.RegisterType((*CreateIndexRequest)(nil), "tici.CreateIndexRequest")
	proto.RegisterType((*CreateIndexResponse)(nil), "tici.CreateIndexResponse")
	proto.RegisterType((*DropIndexRequest)(nil), "tici.DropIndexRequest")
	proto.RegisterType((*DropIndexResponse)(nil), "tici.DropIndexResponse")
	proto.RegisterType((*TableInfo)(nil), "tici.TableInfo")
	proto.RegisterType((*ColumnInfo)(nil), "tici.ColumnInfo")
	proto.RegisterType((*IndexInfo)(nil), "tici.IndexInfo")
	proto.RegisterMapType((map[string]string)(nil), "tici.IndexInfo.OtherParamsEntry")
	proto.RegisterType((*ParserInfo)(nil), "tici.ParserInfo")
	proto.RegisterMapType((map[string]string)(nil), "tici.ParserInfo.ParserParamsEntry")
	proto.RegisterType((*GetIndexProgressRequest)(nil), "tici.GetIndexProgressRequest")
	proto.RegisterType((*GetIndexProgressResponse)(nil), "tici.GetIndexProgressResponse")
	proto.RegisterType((*ImportIndexJobRequest)(nil), "tici.ImportIndexJobRequest")
	proto.RegisterType((*ImportIndexJobResponse)(nil), "tici.ImportIndexJobResponse")
	proto.RegisterType((*FinishImportPartitionUploadRequest)(nil), "tici.FinishImportPartitionUploadRequest")
	proto.RegisterType((*FinishImportPartitionBuildRequest)(nil), "tici.FinishImportPartitionBuildRequest")
	proto.RegisterType((*FinishImportIndexUploadRequest)(nil), "tici.FinishImportIndexUploadRequest")
	proto.RegisterType((*FinishImportResponse)(nil), "tici.FinishImportResponse")
}

func init() { proto.RegisterFile("tici.proto", fileDescriptor_80e84b3910d5cd39) }

var fileDescriptor_80e84b3910d5cd39 = []byte{
	// 3072 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x5a, 0xcd, 0x73, 0x1b, 0xc7,
	0xb1, 0xe7, 0xe2, 0x83, 0x04, 0x1a, 0x00, 0xb9, 0x1c, 0x4a, 0x22, 0x04, 0x59, 0x14, 0xb5, 0x96,
	0x9f, 0x59, 0x7c, 0xcf, 0x54, 0x59, 0x7c, 0x87, 0x67, 0x97, 0xeb, 0x39, 0x14, 0x08, 0x8a, 0x8c,
	0x28, 0x90, 0x19, 0x00, 0x92, 0x63, 0x1f, 0x36, 0x43, 0xec, 0x10, 0x58, 0x6b, 0x81, 0x85, 0x76,
	0x06, 0xb2, 0x98, 0x4a, 0xa5, 0x92, 0x8b, 0xcf, 0xc9, 0x21, 0x1f, 0x97, 0xa4, 0x72, 0xc8, 0x21,
	0xa9, 0x9c, 0x73, 0x49, 0xee, 0xf9, 0x3a, 0xb9, 0x2a, 0x87, 0xf8, 0x98, 0xb2, 0x6e, 0xb9, 0xa4,
	0xf2, 0x1f, 0xa4, 0xe6, 0x63, 0x17, 0x8b, 0x4f, 0x9a, 0x92, 0x95, 0xdb, 0x4e, 0x4f, 0xcf, 0x4c,
	0xf7, 0xaf, 0x7b, 0xba, 0x7b, 0x66, 0x16, 0x80, 0xbb, 0x4d, 0x77, 0xab, 0x17, 0xf8, 0xdc, 0x47,
	0x29, 0xf1, 0x5d, 0xba, 0xd4, 0xf2, 0x5b, 0xbe, 0x24, 0xdc, 0x16, 0x5f, 0xaa, 0xaf, 0xb4, 0x14,
	0xf4, 0x19, 0x97, 0x9f, 0x8a, 0x60, 0x61, 0x30, 0x1f, 0xf9, 0xc1, 0x63, 0x1a, 0x54, 0x7d, 0x87,
	0xd6, 0x38, 0xe1, 0x7d, 0x86, 0xae, 0x41, 0xb6, 0xd9, 0xeb, 0xdb, 0x7d, 0x46, 0x5a, 0xb4, 0x68,
	0xac, 0x1b, 0x1b, 0x06, 0xce, 0x34, 0x7b, 0xfd, 0x86, 0x68, 0xa3, 0x9b, 0x90, 0xef, 0xd0, 0x8e,
	0x1f, 0x9c, 0xe9, 0xfe, 0xc4, 0xba, 0xb1, 0x91, 0xc2, 0x39, 0x45, 0x93, 0x2c, 0xd6, 0x2f, 0x0d,
	0x30, 0x31, 0x25, 0xce, 0x57, 0x39, 0x29, 0xda, 0x84, 0xe5, 0x80, 0x3e, 0xe9, 0x53, 0xc6, 0x99,
	0xed, 0x76, 0xed, 0xe6, 0x59, 0xd3, 0xa3, 0xc5, 0xe4, 0xba, 0xb1, 0x51, 0xc0, 0x4b, 0x61, 0xc7,
	0x41, 0xb7, 0x2c, 0xc8, 0xe8, 0x16, 0x2c, 0x36, 0x49, 0xb3, 0x4d, 0xed, 0xb6, 0xcb, 0xed, 0x80,
	0x70, 0x5a, 0x4c, 0xc9, 0x05, 0xf3, 0x92, 0xba, 0xef, 0x72, 0x4c, 0x38, 0xb5, 0xfe, 0x60, 0xc0,
	0xe5, 0x98, 0xee, 0x6d, 0x12, 0x38, 0x03, 0x59, 0x19, 0x27, 0x01, 0xb7, 0x1f, 0xd3, 0x33, 0x29,
	0x6b, 0x1e, 0x67, 0x24, 0xe1, 0x3e, 0x3d, 0x43, 0xab, 0xb0, 0x40, 0xbb, 0x8e, 0xec, 0x4a, 0xc8,
	0xae, 0x79, 0xda, 0x75, 0x44, 0xc7, 0x55, 0xc8, 0x70, 0x72, 0xe2, 0x51, 0xdb, 0x75, 0xa4, 0x60,
	0x49, 0xbc, 0x20, 0xdb, 0x07, 0x8e, 0xe8, 0x72, 0xbb, 0x0e, 0x7d, 0x26, 0xba, 0x52, 0xaa, 0x4b,
	0xb6, 0x55, 0x17, 0x13, 0x4b, 0x8b, 0xae, 0xb4, 0x54, 0x7b, 0x41, 0xb6, 0x0f, 0x1c, 0x74, 0x09,
	0xd2, 0xb4, 0xe7, 0x37, 0xdb, 0xc5, 0x79, 0x49, 0x57, 0x0d, 0x64, 0x42, 0x92, 0xd1, 0x27, 0xc5,
	0x05, 0x49, 0x13, 0x9f, 0xd6, 0x3e, 0x94, 0x06, 0x7a, 0x94, 0xfd, 0x4e, 0x8f, 0x34, 0xb9, 0xeb,
	0x77, 0xb5, 0x32, 0x9b, 0x90, 0x0c, 0xe8, 0x13, 0xa9, 0x46, 0xee, 0x4e, 0x71, 0x4b, 0x3a, 0x8a,
	0x66, 0xda, 0x0b, 0x48, 0x0b, 0x2b, 0xec, 0xb0, 0x60, 0xb2, 0x3e, 0x86, 0xe5, 0x83, 0x4e, 0xcf,
	0x0f, 0xf8, 0xa3, 0xc0, 0xe5, 0xa1, 0xe5, 0xe2, 0x7a, 0x19, 0xd3, 0xf5, 0x4a, 0x0c, 0xeb, 0x75,
	0x03, 0x72, 0xa7, 0xae, 0x47, 0xed, 0x5e, 0x40, 0x4f, 0xdd, 0x67, 0x52, 0xeb, 0x2c, 0x06, 0x41,
	0x3a, 0x96, 0x14, 0xeb, 0x27, 0x89, 0xb8, 0xd8, 0xfb, 0x94, 0x04, 0xfc, 0x84, 0x12, 0xae, 0xe5,
	0x41, 0x08, 0x52, 0xc4, 0x71, 0x02, 0xb9, 0x62, 0x16, 0xcb, 0x6f, 0xb4, 0x05, 0xf3, 0x4c, 0xca,
	0x24, 0x17, 0xcb, 0xdd, 0xb9, 0xa2, 0xb4, 0x19, 0x75, 0x60, 0xac, 0xb9, 0xd0, 0x36, 0xcc, 0x4b,
	0x2c, 0x59, 0x31, 0xb9, 0x9e, 0xdc, 0xc8, 0xdd, 0xb9, 0x36, 0xc6, 0x3f, 0x30, 0x3a, 0xd6, 0xac,
	0xe8, 0x2e, 0xe4, 0x9a, 0x11, 0x86, 0xac, 0x98, 0x92, 0x23, 0xd7, 0x47, 0x47, 0x8e, 0xc2, 0x8c,
	0xe3, 0x83, 0xd0, 0x7b, 0x50, 0x70, 0x25, 0x8e, 0xf6, 0x27, 0x02, 0x48, 0x56, 0x4c, 0xcb, 0x59,
	0x56, 0xd5, 0x2c, 0x63, 0x10, 0xe3, 0xbc, 0x3b, 0x20, 0x31, 0xeb, 0x37, 0x06, 0x5c, 0x9b, 0x88,
	0x0c, 0xeb, 0xf9, 0x5d, 0x46, 0xd1, 0x9b, 0x11, 0x0c, 0x02, 0x9c, 0xc5, 0x3b, 0x4b, 0x6a, 0xda,
	0x4a, 0x10, 0xf8, 0x41, 0xd9, 0x77, 0x68, 0xa4, 0xff, 0x3b, 0x50, 0xe0, 0xbe, 0x4d, 0x1c, 0xc7,
	0xd6, 0x30, 0x24, 0xa4, 0x18, 0x97, 0x15, 0xff, 0x8e, 0xe3, 0x48, 0xfd, 0x43, 0x0f, 0xc8, 0x71,
	0x3f, 0x24, 0x31, 0xb4, 0x01, 0x26, 0xf7, 0xed, 0x80, 0x76, 0xfc, 0xa7, 0xd4, 0x8e, 0x81, 0x98,
	0xc2, 0x8b, 0xdc, 0xc7, 0x92, 0xac, 0x38, 0xad, 0xdf, 0x19, 0x50, 0x1a, 0xec, 0xf6, 0x97, 0xb1,
	0xe3, 0x68, 0xcc, 0x88, 0xf4, 0xd8, 0x82, 0x15, 0xee, 0x9e, 0x7a, 0x84, 0xb5, 0x6d, 0x46, 0x83,
	0xa7, 0x34, 0xb0, 0xe5, 0x94, 0x49, 0x39, 0xe5, 0xb2, 0xee, 0xaa, 0xc9, 0x9e, 0x1d, 0x31, 0xff,
	0x06, 0x98, 0x72, 0xa7, 0x6b, 0xbd, 0x6d, 0xd7, 0x51, 0x76, 0x4c, 0x61, 0x15, 0x17, 0x94, 0x92,
	0x07, 0x0e, 0xb3, 0xfe, 0x65, 0xc0, 0xb5, 0x89, 0xc2, 0x5f, 0x14, 0xea, 0xd7, 0xa1, 0x40, 0x05,
	0xd1, 0xee, 0x50, 0x16, 0x85, 0xb0, 0x2c, 0xce, 0x4b, 0xe2, 0x03, 0x45, 0x43, 0xef, 0xc3, 0xa2,
	0x82, 0xd2, 0xe6, 0xbe, 0xfd, 0x98, 0xd2, 0x9e, 0xf6, 0xcb, 0xab, 0x6a, 0x56, 0x29, 0xd5, 0x03,
	0xd2, 0x75, 0x4f, 0x29, 0xe3, 0xfb, 0x52, 0x2a, 0x9c, 0x57, 0x03, 0xea, 0xfe, 0x7d, 0x4a, 0x7b,
	0xa8, 0x0c, 0xe6, 0x60, 0x02, 0x65, 0x1c, 0xed, 0xa0, 0x33, 0xa6, 0x58, 0x0c, 0xa7, 0x50, 0x66,
	0xb3, 0x7e, 0x64, 0x40, 0x5e, 0xec, 0xfc, 0xe3, 0xc0, 0xef, 0xd1, 0x80, 0x9f, 0x09, 0x13, 0x31,
	0xf7, 0xdb, 0x2a, 0x2a, 0xa7, 0xb0, 0xfc, 0x16, 0xb1, 0xa7, 0xe9, 0xf7, 0xbb, 0x5c, 0x87, 0x62,
	0xd5, 0x40, 0xd7, 0x01, 0x3a, 0x6e, 0xd7, 0x6e, 0x93, 0xae, 0xa3, 0xa3, 0x6f, 0x1e, 0x67, 0x3b,
	0x6e, 0x77, 0x5f, 0x12, 0x54, 0xb7, 0x13, 0x76, 0xa7, 0xc2, 0x6e, 0x27, 0xd6, 0x4d, 0x9e, 0x85,
	0xdd, 0x69, 0xdd, 0x4d, 0x9e, 0xa9, 0x6e, 0xeb, 0x67, 0x09, 0xc8, 0x08, 0xb9, 0x1e, 0x50, 0x4e,
	0xd0, 0x1b, 0xb0, 0x78, 0xea, 0x07, 0x1d, 0xc2, 0xed, 0xa7, 0x34, 0x60, 0xae, 0xdf, 0xd5, 0xd2,
	0x15, 0x14, 0xf5, 0xa1, 0x22, 0x8a, 0x48, 0x7d, 0x1a, 0x90, 0x96, 0xdd, 0x23, 0xbc, 0xad, 0x21,
	0xcf, 0x08, 0xc2, 0x31, 0xe1, 0x6d, 0xf4, 0x5f, 0xb0, 0xd4, 0x26, 0xcc, 0x76, 0xa8, 0x47, 0xb9,
	0xf0, 0x05, 0xca, 0xa5, 0xc8, 0x19, 0x5c, 0x68, 0x13, 0xb6, 0xab, 0xa8, 0x35, 0xca, 0xd1, 0x6d,
	0x48, 0x31, 0xda, 0x0a, 0xb7, 0xba, 0x0e, 0x12, 0xa1, 0x24, 0x5b, 0x07, 0x22, 0xa0, 0xd5, 0x68,
	0xab, 0x43, 0xbb, 0x1c, 0x4b, 0x46, 0xb4, 0x05, 0x99, 0x9e, 0x06, 0x4f, 0xaa, 0x91, 0xbb, 0x83,
	0x06, 0x83, 0x42, 0x58, 0x71, 0xc4, 0x53, 0xda, 0x85, 0x7c, 0x7c, 0x16, 0x74, 0x19, 0xe6, 0x19,
	0x6d, 0x85, 0xf1, 0x34, 0x8b, 0xd3, 0x8c, 0xb6, 0x0e, 0x1c, 0x81, 0x8f, 0x43, 0x3d, 0x9b, 0xf5,
	0x4f, 0x45, 0xc4, 0x54, 0xda, 0x64, 0x1d, 0xea, 0xd5, 0x24, 0xc1, 0xfa, 0x87, 0x01, 0xa5, 0x9d,
	0x5e, 0x8f, 0x76, 0x9d, 0x5d, 0xea, 0x71, 0x12, 0x0a, 0x18, 0x6e, 0xb4, 0x17, 0x0b, 0xd3, 0xf1,
	0xf4, 0x93, 0x1c, 0x4e, 0x3f, 0x1b, 0x60, 0x7e, 0x22, 0xa3, 0x90, 0xdd, 0xf5, 0x1d, 0xaa, 0xb6,
	0x9c, 0x0a, 0xe3, 0x8b, 0x9f, 0x44, 0xd1, 0x49, 0xee, 0xb7, 0xb7, 0x00, 0xa4, 0x15, 0x3a, 0x94,
	0x93, 0x30, 0xd6, 0x2d, 0x0e, 0xc3, 0x88, 0xa5, 0x9d, 0xc4, 0x17, 0x43, 0x16, 0x14, 0x3c, 0xc2,
	0xb8, 0xdd, 0x74, 0x9a, 0xb6, 0x48, 0x08, 0x32, 0xbf, 0x65, 0x71, 0x4e, 0x10, 0xcb, 0x4e, 0x73,
	0xcf, 0xf5, 0xa8, 0xb5, 0x03, 0x57, 0x94, 0xae, 0x03, 0x35, 0x2f, 0xb8, 0x25, 0xad, 0xef, 0x19,
	0x70, 0x55, 0xcd, 0x71, 0x97, 0x30, 0xfa, 0xd5, 0xc0, 0x35, 0xac, 0x69, 0xf2, 0x1c, 0x4d, 0xad,
	0xaf, 0x41, 0xe6, 0x3e, 0x3d, 0xc3, 0xa4, 0xdb, 0xa2, 0x2f, 0x56, 0x54, 0x58, 0x01, 0xac, 0xc8,
	0x3d, 0x7d, 0xe8, 0x37, 0x89, 0x57, 0x16, 0xc1, 0xeb, 0xa0, 0x7b, 0xea, 0xa3, 0xdb, 0x90, 0x96,
	0x66, 0xd2, 0x69, 0x7d, 0xc6, 0xee, 0x57, 0x7c, 0xa2, 0x7c, 0xf2, 0xc4, 0x14, 0xb6, 0x2a, 0x8c,
	0x84, 0x31, 0x55, 0x3a, 0xc8, 0xe2, 0x25, 0x2f, 0x9a, 0x5b, 0x58, 0x93, 0x59, 0x3f, 0x36, 0xe0,
	0xea, 0x3d, 0xca, 0x47, 0xd6, 0x7d, 0x69, 0xe0, 0x1e, 0xd3, 0x33, 0x3b, 0x10, 0x50, 0x8c, 0x00,
	0x17, 0x22, 0x84, 0xb3, 0x8f, 0xf5, 0x17, 0x13, 0xe1, 0xc7, 0x73, 0x3b, 0x2e, 0x97, 0x0e, 0x97,
	0xc6, 0xaa, 0x61, 0x7d, 0x6a, 0x40, 0x69, 0x92, 0x60, 0xda, 0x33, 0xae, 0x0c, 0x79, 0x46, 0x3a,
	0x8a, 0xcd, 0xc7, 0xb0, 0xaa, 0x7c, 0x3c, 0x8e, 0x80, 0xdb, 0x3d, 0xf5, 0xc3, 0x84, 0x18, 0x87,
	0x6f, 0x18, 0x68, 0x7c, 0x89, 0x8d, 0x13, 0x99, 0xf5, 0x7d, 0x03, 0x5e, 0xdb, 0xa5, 0x27, 0xfd,
	0x56, 0x28, 0x4d, 0x08, 0xfa, 0xcb, 0x81, 0xf4, 0xdf, 0x90, 0x8d, 0x40, 0x92, 0xbb, 0x71, 0x1c,
	0xa3, 0x4c, 0x88, 0x91, 0x90, 0xe1, 0xfa, 0x14, 0x19, 0xce, 0xc1, 0x63, 0xd8, 0x89, 0x13, 0xe7,
	0x6d, 0xd7, 0xe9, 0x21, 0xc2, 0xfa, 0x34, 0x09, 0x68, 0xbc, 0x96, 0xbc, 0xb8, 0x77, 0xc6, 0xe1,
	0x4a, 0x4c, 0x87, 0x2b, 0x39, 0x0c, 0x97, 0xae, 0x84, 0x53, 0x51, 0x25, 0x8c, 0x5e, 0x83, 0x2c,
	0x77, 0x3b, 0x94, 0x71, 0xd2, 0xe9, 0xe9, 0x6a, 0x7a, 0x40, 0x10, 0x25, 0xa9, 0x27, 0x97, 0xb5,
	0x39, 0x0d, 0x3a, 0x3a, 0xea, 0x80, 0x22, 0xd5, 0x69, 0xd0, 0x41, 0xb7, 0x21, 0xe7, 0x76, 0x7b,
	0x7d, 0x6e, 0x0b, 0xe5, 0x59, 0x71, 0x61, 0x22, 0x32, 0x20, 0x59, 0x44, 0x53, 0x14, 0x58, 0x4b,
	0xfd, 0x9e, 0xe7, 0x13, 0xe5, 0x5a, 0xa2, 0xf6, 0x2b, 0x66, 0xa4, 0xca, 0xa6, 0x56, 0x79, 0xfb,
	0x50, 0xd3, 0xf1, 0xa2, 0x62, 0x0c, 0xdb, 0xe8, 0x7f, 0x21, 0xaf, 0x2b, 0x46, 0x9b, 0x9f, 0xf5,
	0x68, 0x31, 0x2b, 0x83, 0xd9, 0xf2, 0x50, 0x7d, 0x5e, 0x3f, 0xeb, 0xd1, 0xa8, 0xb0, 0x14, 0x0d,
	0x61, 0x52, 0x15, 0x7b, 0x8b, 0x20, 0xa5, 0xd7, 0x2d, 0xeb, 0x2d, 0x58, 0x19, 0xb2, 0xc3, 0x6c,
	0x0f, 0xb0, 0xfe, 0x92, 0x80, 0xe2, 0x9e, 0xdb, 0x75, 0x59, 0x7b, 0x82, 0xf5, 0x26, 0x55, 0x6c,
	0x91, 0x45, 0x13, 0x2f, 0x60, 0xd1, 0x2f, 0x7f, 0x18, 0xd2, 0x16, 0x4d, 0x4f, 0xb1, 0xe8, 0xfc,
	0x39, 0x16, 0x5d, 0x38, 0xcf, 0xa2, 0x99, 0x73, 0x2d, 0xfa, 0x36, 0xe4, 0xfd, 0x3e, 0x1f, 0x8c,
	0xc8, 0x4e, 0x1c, 0x91, 0x53, 0x3c, 0x72, 0x88, 0xb5, 0x0d, 0x57, 0x27, 0x60, 0x79, 0x8e, 0x05,
	0x7e, 0x6d, 0x00, 0x8a, 0x9d, 0x03, 0x42, 0xec, 0x57, 0x61, 0x81, 0x13, 0xf6, 0x38, 0x0c, 0x1b,
	0x29, 0x3c, 0x2f, 0x9a, 0x07, 0x2f, 0xba, 0x43, 0x5e, 0x87, 0x82, 0x3c, 0x84, 0x45, 0xde, 0xa9,
	0xf2, 0x77, 0x5e, 0x10, 0x23, 0x4f, 0x14, 0x27, 0x35, 0x59, 0x43, 0xa9, 0x93, 0x5a, 0x5a, 0x9f,
	0xd4, 0x64, 0x29, 0x23, 0x4f, 0x6a, 0x6f, 0xc1, 0xca, 0x90, 0xa8, 0xe7, 0xa8, 0xf6, 0x1d, 0x9d,
	0xb2, 0x86, 0x1d, 0x63, 0x28, 0x8c, 0x18, 0xc3, 0x95, 0xc6, 0x50, 0x6a, 0x4c, 0x4c, 0x4f, 0x8d,
	0xc9, 0xa1, 0xf3, 0x76, 0x74, 0x3c, 0x4e, 0xc5, 0x8e, 0xc7, 0xd6, 0x7b, 0x00, 0x83, 0x5d, 0x27,
	0x64, 0x3c, 0xe9, 0x37, 0x1f, 0x53, 0xae, 0xbd, 0x59, 0xb7, 0x04, 0x5d, 0xab, 0xab, 0xca, 0x2c,
	0xdd, 0xb2, 0x7e, 0x9f, 0x80, 0xa5, 0x91, 0x73, 0xd1, 0xc5, 0xa3, 0xd9, 0x16, 0x80, 0x36, 0x48,
	0xf7, 0xd4, 0xd7, 0x3b, 0x46, 0x57, 0x29, 0xb2, 0x0c, 0x94, 0x89, 0x25, 0xeb, 0x86, 0x9f, 0x82,
	0x5f, 0xdb, 0x56, 0xf0, 0x27, 0xe3, 0xfc, 0x75, 0x69, 0x63, 0xc9, 0xcf, 0xc3, 0x4f, 0xf4, 0x26,
	0x98, 0xa2, 0x74, 0x62, 0xdb, 0xb6, 0x2c, 0xa3, 0x64, 0x09, 0xa5, 0x0c, 0x5b, 0x68, 0x3a, 0xcd,
	0xda, 0xf6, 0x21, 0x61, 0x5c, 0x14, 0x51, 0x68, 0x1b, 0xf2, 0x82, 0x31, 0xb2, 0x7e, 0x7a, 0x4a,
	0x6c, 0xca, 0x35, 0x9d, 0x66, 0x04, 0xd9, 0x84, 0x98, 0x36, 0xff, 0xe5, 0x62, 0x9a, 0xb5, 0x09,
	0xe6, 0x00, 0xbc, 0x73, 0xbc, 0x84, 0x03, 0x2a, 0x07, 0x94, 0x70, 0x2a, 0x21, 0x09, 0xb1, 0x1e,
	0x86, 0xce, 0xb8, 0x20, 0x74, 0x89, 0xf3, 0xa0, 0xb3, 0xbe, 0x0b, 0x2b, 0x43, 0xab, 0xbe, 0x92,
	0x63, 0xde, 0xe8, 0x86, 0xcc, 0x46, 0x1b, 0xd2, 0xda, 0x07, 0x73, 0x37, 0xf0, 0x7b, 0x43, 0x3a,
	0xbf, 0x50, 0xad, 0x60, 0x11, 0x58, 0x8e, 0xcd, 0xf4, 0x2a, 0xf4, 0xb0, 0xfe, 0x6a, 0x40, 0x36,
	0x42, 0x71, 0x96, 0x98, 0xd7, 0x43, 0x2b, 0x74, 0x49, 0x27, 0x9c, 0x4a, 0x81, 0x5e, 0x25, 0x1d,
	0x2a, 0x16, 0x73, 0x08, 0x27, 0x27, 0x84, 0x69, 0x0e, 0x05, 0x4a, 0x3e, 0x24, 0x4a, 0xa6, 0x22,
	0x2c, 0x84, 0x27, 0x3d, 0x9d, 0x14, 0x74, 0x13, 0x6d, 0xc2, 0x42, 0xd3, 0xf7, 0xfa, 0x9d, 0x6e,
	0x78, 0xb4, 0x30, 0xc3, 0x24, 0x29, 0x88, 0xd2, 0xc2, 0x21, 0x03, 0xba, 0x09, 0x79, 0x97, 0xd9,
	0x4d, 0xaf, 0xcf, 0x38, 0x0d, 0xa8, 0x23, 0x3d, 0x37, 0x83, 0x73, 0x2e, 0x2b, 0x87, 0x24, 0xeb,
	0x8f, 0x09, 0x80, 0xc1, 0x50, 0x79, 0x2f, 0x29, 0x5b, 0x03, 0xbd, 0x32, 0x8a, 0xa0, 0x2e, 0xb1,
	0x74, 0x67, 0x4c, 0x33, 0x50, 0x24, 0x29, 0x35, 0x82, 0x94, 0xcc, 0xde, 0x49, 0xe9, 0xdb, 0xf2,
	0x5b, 0xa4, 0xac, 0xa6, 0xef, 0x79, 0x83, 0x80, 0x9b, 0xc6, 0x03, 0x82, 0x00, 0x43, 0x4f, 0xe9,
	0xd1, 0x6e, 0x8b, 0xb7, 0xe5, 0xa6, 0x4c, 0xe3, 0xbc, 0x22, 0x1e, 0x4a, 0x9a, 0x00, 0xc3, 0xa1,
	0x4d, 0xb7, 0x43, 0x3c, 0xa9, 0x41, 0x1a, 0x87, 0x4d, 0xb1, 0xe0, 0xa9, 0x47, 0x5a, 0x32, 0xd5,
	0x15, 0xb0, 0xfc, 0x96, 0x81, 0xd0, 0xa3, 0x1d, 0x95, 0xde, 0xb2, 0x58, 0x35, 0x84, 0xec, 0x0e,
	0x3d, 0x25, 0x7d, 0x8f, 0xdb, 0x4f, 0x89, 0x27, 0xeb, 0x8b, 0x3c, 0x06, 0x4d, 0x7a, 0x48, 0x3c,
	0x74, 0x0b, 0x16, 0x5d, 0x66, 0xf7, 0x02, 0xb7, 0x43, 0x82, 0x33, 0x19, 0x5f, 0x41, 0xa2, 0x95,
	0x77, 0xd9, 0xb1, 0x22, 0xea, 0x5b, 0x4d, 0x97, 0xd9, 0x24, 0x08, 0xc8, 0x59, 0x31, 0x27, 0xfb,
	0x17, 0x5c, 0xb6, 0x23, 0x9a, 0xd6, 0x0f, 0x93, 0x90, 0x8d, 0x76, 0xe5, 0x0b, 0x96, 0xbc, 0xd7,
	0xc3, 0x0d, 0x1f, 0x73, 0x0c, 0xb5, 0xbf, 0x25, 0xbe, 0x51, 0x3c, 0x90, 0x28, 0xa7, 0xe2, 0x4e,
	0x2d, 0x57, 0x96, 0x15, 0x92, 0xe2, 0x97, 0xf5, 0xd1, 0x45, 0x7c, 0xe5, 0x1a, 0x64, 0x5d, 0x66,
	0xf7, 0xbb, 0xee, 0x93, 0x3e, 0xd5, 0x8e, 0x92, 0x71, 0x59, 0x43, 0xb6, 0xd1, 0xdb, 0x90, 0xeb,
	0x91, 0x80, 0xd1, 0x40, 0x45, 0x96, 0x85, 0x78, 0x04, 0x3c, 0x96, 0x1d, 0x72, 0x32, 0xe8, 0x45,
	0xdf, 0xa8, 0x0c, 0x79, 0x9f, 0xb7, 0x69, 0x60, 0xf7, 0x48, 0x40, 0x3a, 0x61, 0xb1, 0xb1, 0x3e,
	0x12, 0xbd, 0xb6, 0x8e, 0x04, 0xcf, 0xb1, 0x64, 0xa9, 0x74, 0x79, 0x70, 0x86, 0x73, 0xfe, 0x80,
	0x52, 0xfa, 0x7f, 0x30, 0x47, 0x19, 0x44, 0x55, 0x14, 0x9e, 0x19, 0xb3, 0x58, 0x7c, 0x0a, 0x8b,
	0x3f, 0x25, 0x5e, 0x3f, 0xf4, 0x48, 0xd5, 0x78, 0x37, 0xf1, 0x7f, 0x86, 0xf5, 0x67, 0x03, 0x60,
	0x20, 0x5f, 0x4c, 0x0d, 0x09, 0xa0, 0x8a, 0x0a, 0x43, 0x6a, 0x48, 0x04, 0xb5, 0x1a, 0x12, 0xc2,
	0x7b, 0x50, 0xd0, 0x43, 0xb4, 0x1e, 0xea, 0x80, 0x60, 0x8d, 0xea, 0xae, 0x3f, 0xe3, 0x9a, 0xe4,
	0x7b, 0x31, 0x52, 0xe9, 0x7d, 0x58, 0x1e, 0x63, 0xb9, 0x90, 0x2e, 0x47, 0xb0, 0x7a, 0x8f, 0x72,
	0x89, 0xdc, 0x71, 0xe0, 0xb7, 0x02, 0xca, 0xd8, 0xcb, 0xc5, 0xcc, 0x4f, 0x93, 0x50, 0x1c, 0x9f,
	0xf1, 0x95, 0xe4, 0x80, 0x37, 0x60, 0xd1, 0xf1, 0x9b, 0xfd, 0x0e, 0xed, 0x72, 0x5b, 0x5d, 0xa4,
	0xa9, 0xa3, 0x53, 0x21, 0xa4, 0x96, 0xe5, 0x85, 0xda, 0xbb, 0x90, 0x16, 0xb3, 0x86, 0xae, 0x7d,
	0x4b, 0xad, 0x39, 0x4d, 0xc6, 0xad, 0x9a, 0xe0, 0xc5, 0x6a, 0x88, 0xd8, 0xe0, 0xc2, 0x7f, 0x65,
	0x0a, 0xa6, 0xea, 0xf1, 0x20, 0x83, 0xc1, 0x65, 0x0d, 0x4d, 0x41, 0x1b, 0x60, 0xca, 0x02, 0x41,
	0xa7, 0x73, 0x51, 0x36, 0xeb, 0x43, 0xcf, 0xa2, 0xa0, 0x2b, 0xbe, 0xba, 0xdb, 0xa1, 0xa2, 0xc6,
	0x62, 0xdb, 0xea, 0x12, 0x4d, 0xd5, 0xd0, 0xf3, 0x6c, 0xfb, 0x98, 0xf0, 0xb6, 0xd5, 0x80, 0xb4,
	0x5c, 0x13, 0xe5, 0x60, 0xe1, 0xb8, 0x52, 0xdd, 0x3d, 0xa8, 0xde, 0x33, 0xe7, 0x44, 0x03, 0x37,
	0xaa, 0x55, 0xd1, 0x30, 0x50, 0x01, 0xb2, 0xe5, 0xa3, 0x07, 0xc7, 0x87, 0x95, 0x7a, 0x65, 0xd7,
	0x4c, 0x20, 0x80, 0xf9, 0xbd, 0x9d, 0x83, 0xc3, 0xca, 0xae, 0x99, 0x44, 0x79, 0xc8, 0x54, 0x8f,
	0xea, 0x7b, 0x47, 0x8d, 0xea, 0xae, 0x99, 0x42, 0x59, 0x48, 0x57, 0x30, 0x3e, 0xc2, 0x66, 0xda,
	0x6a, 0xc3, 0x65, 0x55, 0x51, 0x4a, 0x35, 0xbf, 0xee, 0x9f, 0xbc, 0xfc, 0x25, 0x96, 0xac, 0x1f,
	0x39, 0x8b, 0x4e, 0xa8, 0xa2, 0x5d, 0x67, 0xd6, 0xcf, 0x0d, 0xb8, 0x32, 0xba, 0xd4, 0x2b, 0x31,
	0xf8, 0x65, 0x98, 0xff, 0xd8, 0x3f, 0x19, 0x9c, 0x91, 0xd3, 0x1f, 0xfb, 0x27, 0x2a, 0x83, 0x30,
	0xee, 0x07, 0xa4, 0x45, 0xed, 0x7e, 0xe0, 0x86, 0xcf, 0x20, 0x9a, 0xd4, 0x08, 0x5c, 0xeb, 0x17,
	0x06, 0x58, 0xea, 0xf8, 0xa0, 0xc4, 0x3c, 0x26, 0x01, 0x77, 0x45, 0xa6, 0x50, 0xe6, 0xf9, 0xcf,
	0x5d, 0x28, 0xc4, 0x9d, 0x20, 0x35, 0xe4, 0x04, 0xff, 0x34, 0xe0, 0xe6, 0x44, 0x11, 0xef, 0xf6,
	0x5d, 0xef, 0x25, 0x25, 0x8c, 0x1d, 0x78, 0x92, 0x43, 0x07, 0x9e, 0x81, 0x75, 0x52, 0xb3, 0xad,
	0x73, 0xc1, 0xcb, 0xc7, 0x31, 0x63, 0xce, 0x4f, 0xa8, 0x7c, 0x1e, 0xc2, 0x5a, 0x5c, 0x61, 0xe9,
	0x3a, 0x5f, 0x81, 0x3d, 0x2c, 0x07, 0x2e, 0xc5, 0xe7, 0x7d, 0x35, 0xae, 0xb8, 0xf9, 0x5b, 0x03,
	0xb2, 0xd1, 0x50, 0xb1, 0x59, 0x6b, 0x8d, 0x72, 0xb9, 0x52, 0xab, 0x99, 0x73, 0x68, 0x19, 0x0a,
	0x8d, 0xea, 0xfd, 0xea, 0xd1, 0xa3, 0xaa, 0xad, 0xf6, 0xa2, 0x81, 0x2e, 0xc3, 0xf2, 0x41, 0xf5,
	0xe1, 0xce, 0xe1, 0xc1, 0xae, 0xbd, 0x83, 0xef, 0x35, 0x1e, 0x54, 0xaa, 0xf5, 0x9a, 0x99, 0x40,
	0x2b, 0xb0, 0x54, 0xdb, 0xdf, 0xc1, 0xbb, 0x76, 0xf5, 0xa8, 0x6e, 0xab, 0x2d, 0x9c, 0x13, 0xc4,
	0x83, 0xea, 0x6e, 0xe5, 0x83, 0x18, 0x31, 0x8f, 0x2e, 0x81, 0xf9, 0xe8, 0x08, 0xdf, 0xaf, 0xe0,
	0x18, 0xb5, 0x80, 0x56, 0x61, 0x65, 0x30, 0xbe, 0x56, 0xde, 0xaf, 0xec, 0x36, 0x44, 0x50, 0x58,
	0x44, 0x45, 0xb8, 0x24, 0xe2, 0xc5, 0x4e, 0xb9, 0x7e, 0x70, 0x54, 0x8d, 0x0d, 0x59, 0xda, 0xfc,
	0x1f, 0xc8, 0xc5, 0x2e, 0x3e, 0x44, 0xbc, 0x90, 0x17, 0xdd, 0xe6, 0x1c, 0xca, 0x40, 0xea, 0x2e,
	0x61, 0xd4, 0x34, 0xc4, 0xd7, 0x5e, 0xdf, 0xf3, 0xcc, 0xc4, 0xe6, 0xb6, 0x2e, 0x3e, 0x24, 0x6f,
	0x0e, 0x16, 0xb4, 0x5e, 0xe6, 0x9c, 0x88, 0x48, 0x7b, 0x8d, 0xc3, 0x43, 0xbb, 0x5e, 0xf9, 0xa0,
	0x6e, 0x1a, 0x22, 0x22, 0x95, 0x1b, 0xb5, 0xfa, 0xd1, 0x03, 0x33, 0xb1, 0xb9, 0x17, 0x66, 0x47,
	0x39, 0x0a, 0xc1, 0x62, 0x88, 0xc6, 0xf1, 0x0e, 0xae, 0x55, 0xb0, 0x39, 0x27, 0x68, 0xbb, 0x95,
	0xbd, 0x9d, 0xc6, 0x61, 0x3d, 0xa4, 0x19, 0xc8, 0x84, 0xfc, 0x51, 0x7d, 0xbf, 0x82, 0x43, 0x4a,
	0xe2, 0xce, 0xe7, 0x59, 0xc8, 0x09, 0x7f, 0xaa, 0xd1, 0xe0, 0xa9, 0xdb, 0xa4, 0xe8, 0x43, 0x58,
	0x99, 0xf0, 0x62, 0x87, 0xc6, 0x9e, 0x0d, 0x47, 0x9f, 0xc7, 0x4a, 0x37, 0x67, 0x70, 0x68, 0xe7,
	0xf8, 0x10, 0x56, 0x26, 0x3c, 0x51, 0x85, 0x73, 0x4f, 0x7f, 0x7a, 0x0b, 0xe7, 0x9e, 0xf5, 0xbe,
	0x75, 0x17, 0x72, 0xb1, 0xf3, 0x10, 0x0a, 0x9f, 0x87, 0xc7, 0x0e, 0x66, 0xa5, 0xab, 0x13, 0x7a,
	0xf4, 0x1c, 0xef, 0x41, 0x36, 0x3a, 0x89, 0x20, 0xfd, 0x94, 0x37, 0x7a, 0xc8, 0x29, 0xad, 0x8e,
	0xd1, 0xf5, 0xe8, 0x6f, 0x80, 0x39, 0x9a, 0xee, 0xd0, 0xf5, 0x69, 0x69, 0x50, 0xcd, 0xb5, 0x36,
	0x3b, 0x4b, 0xa2, 0x06, 0xac, 0x4c, 0x78, 0x27, 0x09, 0x01, 0x9b, 0xfe, 0x84, 0x52, 0x7a, 0x2d,
	0xce, 0x31, 0xf6, 0xf0, 0x50, 0x03, 0x34, 0xfe, 0x9c, 0x80, 0x6e, 0xc4, 0xc7, 0x4c, 0x78, 0x68,
	0x38, 0x67, 0xd2, 0x8f, 0xe0, 0xca, 0xf8, 0x8d, 0xb6, 0x2c, 0xdd, 0x6e, 0x44, 0x5a, 0x4e, 0xbe,
	0x88, 0x2f, 0xad, 0x4f, 0x67, 0xd0, 0x93, 0x7f, 0x0b, 0x2e, 0x4f, 0xbc, 0x21, 0x46, 0xba, 0x98,
	0x9b, 0x75, 0x85, 0x5d, 0x7a, 0x7d, 0x26, 0x8f, 0x5e, 0xe1, 0x9b, 0x70, 0x65, 0xec, 0xee, 0x4b,
	0x54, 0x37, 0x0c, 0x69, 0x23, 0x4d, 0xbb, 0x65, 0x2c, 0xdd, 0x98, 0xda, 0x1f, 0x39, 0xc6, 0xa5,
	0x5a, 0xff, 0xa4, 0xe3, 0xf2, 0xe1, 0xf4, 0x8d, 0xae, 0xc5, 0x1f, 0xd1, 0x47, 0xea, 0x87, 0x10,
	0xec, 0x29, 0x19, 0xbf, 0x09, 0xd7, 0x66, 0xa4, 0x5a, 0xb4, 0x11, 0x17, 0x69, 0x56, 0x36, 0x2e,
	0x95, 0xc6, 0x39, 0xa3, 0x45, 0x08, 0x94, 0xa6, 0x27, 0x4b, 0xf4, 0xe6, 0x8c, 0x35, 0xe2, 0xe9,
	0x74, 0xe6, 0x12, 0x1f, 0xc1, 0xea, 0x94, 0xf4, 0x84, 0x6e, 0x8d, 0x0f, 0x1b, 0xcf, 0x5e, 0xb3,
	0x26, 0xbf, 0xf3, 0x37, 0x03, 0x0a, 0x2a, 0x1c, 0x85, 0xc1, 0xed, 0x1d, 0xc8, 0x84, 0xd7, 0x3a,
	0x68, 0xf2, 0xbf, 0x03, 0xa5, 0x2b, 0xa3, 0x64, 0x2d, 0xe9, 0x3d, 0x30, 0xc7, 0x3c, 0x63, 0xea,
	0x3f, 0x28, 0x51, 0x90, 0x99, 0xe0, 0x0d, 0x77, 0x21, 0x17, 0xbb, 0x83, 0x0c, 0xe7, 0x18, 0xbf,
	0x41, 0x0d, 0xe7, 0x98, 0x70, 0x61, 0x79, 0x77, 0xfd, 0xf3, 0x5f, 0x65, 0x8c, 0x3f, 0x7d, 0xb1,
	0x66, 0x7c, 0xf6, 0xc5, 0x9a, 0xf1, 0xf7, 0x2f, 0xd6, 0x8c, 0x1f, 0x3c, 0x5f, 0x9b, 0xfb, 0xe9,
	0xf3, 0xb5, 0xb9, 0xcf, 0x9e, 0xaf, 0xcd, 0x7d, 0xfe, 0x7c, 0x6d, 0xee, 0x64, 0x5e, 0xfe, 0x14,
	0xb5, 0xfd, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd9, 0x5a, 0x30, 0x0c, 0x4f, 0x25, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MetaServiceClient is the client API for MetaService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MetaServiceClient interface {
	// Maintains heartbeat from worker nodes(such as writers, compactors) to meta
	// service.
	WorkerNodeHeartbeat(ctx context.Context, in *WorkerNodeHeartbeatRequest, opts ...grpc.CallOption) (*WorkerNodeHeartbeatResponse, error)
	// Maintains heartbeat from reader nodes to meta service.
	ReaderNodeHeartbeat(ctx context.Context, in *ReaderNodeHeartbeatRequest, opts ...grpc.CallOption) (*ReaderNodeHeartbeatResponse, error)
	// CreateIndex creates a new index
	CreateIndex(ctx context.Context, in *CreateIndexRequest, opts ...grpc.CallOption) (*CreateIndexResponse, error)
	// DropIndex removes an existing index
	DropIndex(ctx context.Context, in *DropIndexRequest, opts ...grpc.CallOption) (*DropIndexResponse, error)
	// GetIndexProgress retrieves the current progress of an index build
	GetIndexProgress(ctx context.Context, in *GetIndexProgressRequest, opts ...grpc.CallOption) (*GetIndexProgressResponse, error)
	AppendDeltaFragMeta(ctx context.Context, in *AppendDeltaFragMetaRequest, opts ...grpc.CallOption) (*AppendFragMetaResponse, error)
	// TODO: this method should be replace by `FinishPartitionBuild`
	// / Append base fragment metadata, used for baseline shards
	// / MetaService is responsible for
	// / 1. Find the overlapped Shards for the given table_id, index_id and
	// / key_range
	// / 2. Append the frags to all the overlapped shards' baseline frags
	AppendBaseFragMeta(ctx context.Context, in *AppendBaseFragMetaRequest, opts ...grpc.CallOption) (*AppendFragMetaResponse, error)
	// Get shard local cache information
	GetShardLocalCacheInfo(ctx context.Context, in *GetShardLocalCacheRequest, opts ...grpc.CallOption) (*GetShardLocalCacheResponse, error)
	// Debug usage: get shard manifest from meta service writer
	DebugGetShardManifest(ctx context.Context, in *DebugGetShardManifestRequest, opts ...grpc.CallOption) (*DebugGetShardManifestResponse, error)
	FinishCompactFragments(ctx context.Context, in *FinishCompactFragRequest, opts ...grpc.CallOption) (*FinishCompactFragResponse, error)
	// Submit a new import index job to TiCI.
	// This will create a new import job with a unique job_id and a storage
	// backend prefix for the import data. The caller should generate files under
	// the storage backend prefix and call `FinishImportPartitionUpload` after
	// uploading each partition. If there is an existing running import job for
	// the same table_id and index_id, it will return the existing job_id.
	SubmitImportIndexJob(ctx context.Context, in *ImportIndexJobRequest, opts ...grpc.CallOption) (*ImportIndexJobResponse, error)
	// Called by Import DXF to notify Meta Service after a partition for
	// the given index are uploaded.
	FinishImportPartitionUpload(ctx context.Context, in *FinishImportPartitionUploadRequest, opts ...grpc.CallOption) (*FinishImportResponse, error)
	// Called by TiCI worker to notify Meta Service after a partition for
	// the given index is built.
	FinishImportPartitionBuild(ctx context.Context, in *FinishImportPartitionBuildRequest, opts ...grpc.CallOption) (*FinishImportResponse, error)
	// Called to notify Meta Service that the whole table/index upload is
	// finished.
	FinishImportIndexUpload(ctx context.Context, in *FinishImportIndexUploadRequest, opts ...grpc.CallOption) (*FinishImportResponse, error)
}

type metaServiceClient struct {
	cc *grpc.ClientConn
}

func NewMetaServiceClient(cc *grpc.ClientConn) MetaServiceClient {
	return &metaServiceClient{cc}
}

func (c *metaServiceClient) WorkerNodeHeartbeat(ctx context.Context, in *WorkerNodeHeartbeatRequest, opts ...grpc.CallOption) (*WorkerNodeHeartbeatResponse, error) {
	out := new(WorkerNodeHeartbeatResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/WorkerNodeHeartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) ReaderNodeHeartbeat(ctx context.Context, in *ReaderNodeHeartbeatRequest, opts ...grpc.CallOption) (*ReaderNodeHeartbeatResponse, error) {
	out := new(ReaderNodeHeartbeatResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/ReaderNodeHeartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) CreateIndex(ctx context.Context, in *CreateIndexRequest, opts ...grpc.CallOption) (*CreateIndexResponse, error) {
	out := new(CreateIndexResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/CreateIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) DropIndex(ctx context.Context, in *DropIndexRequest, opts ...grpc.CallOption) (*DropIndexResponse, error) {
	out := new(DropIndexResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/DropIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) GetIndexProgress(ctx context.Context, in *GetIndexProgressRequest, opts ...grpc.CallOption) (*GetIndexProgressResponse, error) {
	out := new(GetIndexProgressResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/GetIndexProgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) AppendDeltaFragMeta(ctx context.Context, in *AppendDeltaFragMetaRequest, opts ...grpc.CallOption) (*AppendFragMetaResponse, error) {
	out := new(AppendFragMetaResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/AppendDeltaFragMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) AppendBaseFragMeta(ctx context.Context, in *AppendBaseFragMetaRequest, opts ...grpc.CallOption) (*AppendFragMetaResponse, error) {
	out := new(AppendFragMetaResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/AppendBaseFragMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) GetShardLocalCacheInfo(ctx context.Context, in *GetShardLocalCacheRequest, opts ...grpc.CallOption) (*GetShardLocalCacheResponse, error) {
	out := new(GetShardLocalCacheResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/GetShardLocalCacheInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) DebugGetShardManifest(ctx context.Context, in *DebugGetShardManifestRequest, opts ...grpc.CallOption) (*DebugGetShardManifestResponse, error) {
	out := new(DebugGetShardManifestResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/DebugGetShardManifest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) FinishCompactFragments(ctx context.Context, in *FinishCompactFragRequest, opts ...grpc.CallOption) (*FinishCompactFragResponse, error) {
	out := new(FinishCompactFragResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/FinishCompactFragments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) SubmitImportIndexJob(ctx context.Context, in *ImportIndexJobRequest, opts ...grpc.CallOption) (*ImportIndexJobResponse, error) {
	out := new(ImportIndexJobResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/SubmitImportIndexJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) FinishImportPartitionUpload(ctx context.Context, in *FinishImportPartitionUploadRequest, opts ...grpc.CallOption) (*FinishImportResponse, error) {
	out := new(FinishImportResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/FinishImportPartitionUpload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) FinishImportPartitionBuild(ctx context.Context, in *FinishImportPartitionBuildRequest, opts ...grpc.CallOption) (*FinishImportResponse, error) {
	out := new(FinishImportResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/FinishImportPartitionBuild", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) FinishImportIndexUpload(ctx context.Context, in *FinishImportIndexUploadRequest, opts ...grpc.CallOption) (*FinishImportResponse, error) {
	out := new(FinishImportResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/FinishImportIndexUpload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetaServiceServer is the server API for MetaService service.
type MetaServiceServer interface {
	// Maintains heartbeat from worker nodes(such as writers, compactors) to meta
	// service.
	WorkerNodeHeartbeat(context.Context, *WorkerNodeHeartbeatRequest) (*WorkerNodeHeartbeatResponse, error)
	// Maintains heartbeat from reader nodes to meta service.
	ReaderNodeHeartbeat(context.Context, *ReaderNodeHeartbeatRequest) (*ReaderNodeHeartbeatResponse, error)
	// CreateIndex creates a new index
	CreateIndex(context.Context, *CreateIndexRequest) (*CreateIndexResponse, error)
	// DropIndex removes an existing index
	DropIndex(context.Context, *DropIndexRequest) (*DropIndexResponse, error)
	// GetIndexProgress retrieves the current progress of an index build
	GetIndexProgress(context.Context, *GetIndexProgressRequest) (*GetIndexProgressResponse, error)
	AppendDeltaFragMeta(context.Context, *AppendDeltaFragMetaRequest) (*AppendFragMetaResponse, error)
	// TODO: this method should be replace by `FinishPartitionBuild`
	// / Append base fragment metadata, used for baseline shards
	// / MetaService is responsible for
	// / 1. Find the overlapped Shards for the given table_id, index_id and
	// / key_range
	// / 2. Append the frags to all the overlapped shards' baseline frags
	AppendBaseFragMeta(context.Context, *AppendBaseFragMetaRequest) (*AppendFragMetaResponse, error)
	// Get shard local cache information
	GetShardLocalCacheInfo(context.Context, *GetShardLocalCacheRequest) (*GetShardLocalCacheResponse, error)
	// Debug usage: get shard manifest from meta service writer
	DebugGetShardManifest(context.Context, *DebugGetShardManifestRequest) (*DebugGetShardManifestResponse, error)
	FinishCompactFragments(context.Context, *FinishCompactFragRequest) (*FinishCompactFragResponse, error)
	// Submit a new import index job to TiCI.
	// This will create a new import job with a unique job_id and a storage
	// backend prefix for the import data. The caller should generate files under
	// the storage backend prefix and call `FinishImportPartitionUpload` after
	// uploading each partition. If there is an existing running import job for
	// the same table_id and index_id, it will return the existing job_id.
	SubmitImportIndexJob(context.Context, *ImportIndexJobRequest) (*ImportIndexJobResponse, error)
	// Called by Import DXF to notify Meta Service after a partition for
	// the given index are uploaded.
	FinishImportPartitionUpload(context.Context, *FinishImportPartitionUploadRequest) (*FinishImportResponse, error)
	// Called by TiCI worker to notify Meta Service after a partition for
	// the given index is built.
	FinishImportPartitionBuild(context.Context, *FinishImportPartitionBuildRequest) (*FinishImportResponse, error)
	// Called to notify Meta Service that the whole table/index upload is
	// finished.
	FinishImportIndexUpload(context.Context, *FinishImportIndexUploadRequest) (*FinishImportResponse, error)
}

// UnimplementedMetaServiceServer can be embedded to have forward compatible implementations.
type UnimplementedMetaServiceServer struct {
}

func (*UnimplementedMetaServiceServer) WorkerNodeHeartbeat(ctx context.Context, req *WorkerNodeHeartbeatRequest) (*WorkerNodeHeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WorkerNodeHeartbeat not implemented")
}
func (*UnimplementedMetaServiceServer) ReaderNodeHeartbeat(ctx context.Context, req *ReaderNodeHeartbeatRequest) (*ReaderNodeHeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReaderNodeHeartbeat not implemented")
}
func (*UnimplementedMetaServiceServer) CreateIndex(ctx context.Context, req *CreateIndexRequest) (*CreateIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateIndex not implemented")
}
func (*UnimplementedMetaServiceServer) DropIndex(ctx context.Context, req *DropIndexRequest) (*DropIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropIndex not implemented")
}
func (*UnimplementedMetaServiceServer) GetIndexProgress(ctx context.Context, req *GetIndexProgressRequest) (*GetIndexProgressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIndexProgress not implemented")
}
func (*UnimplementedMetaServiceServer) AppendDeltaFragMeta(ctx context.Context, req *AppendDeltaFragMetaRequest) (*AppendFragMetaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppendDeltaFragMeta not implemented")
}
func (*UnimplementedMetaServiceServer) AppendBaseFragMeta(ctx context.Context, req *AppendBaseFragMetaRequest) (*AppendFragMetaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppendBaseFragMeta not implemented")
}
func (*UnimplementedMetaServiceServer) GetShardLocalCacheInfo(ctx context.Context, req *GetShardLocalCacheRequest) (*GetShardLocalCacheResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetShardLocalCacheInfo not implemented")
}
func (*UnimplementedMetaServiceServer) DebugGetShardManifest(ctx context.Context, req *DebugGetShardManifestRequest) (*DebugGetShardManifestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DebugGetShardManifest not implemented")
}
func (*UnimplementedMetaServiceServer) FinishCompactFragments(ctx context.Context, req *FinishCompactFragRequest) (*FinishCompactFragResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishCompactFragments not implemented")
}
func (*UnimplementedMetaServiceServer) SubmitImportIndexJob(ctx context.Context, req *ImportIndexJobRequest) (*ImportIndexJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitImportIndexJob not implemented")
}
func (*UnimplementedMetaServiceServer) FinishImportPartitionUpload(ctx context.Context, req *FinishImportPartitionUploadRequest) (*FinishImportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishImportPartitionUpload not implemented")
}
func (*UnimplementedMetaServiceServer) FinishImportPartitionBuild(ctx context.Context, req *FinishImportPartitionBuildRequest) (*FinishImportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishImportPartitionBuild not implemented")
}
func (*UnimplementedMetaServiceServer) FinishImportIndexUpload(ctx context.Context, req *FinishImportIndexUploadRequest) (*FinishImportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishImportIndexUpload not implemented")
}

func RegisterMetaServiceServer(s *grpc.Server, srv MetaServiceServer) {
	s.RegisterService(&_MetaService_serviceDesc, srv)
}

func _MetaService_WorkerNodeHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkerNodeHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).WorkerNodeHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/WorkerNodeHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).WorkerNodeHeartbeat(ctx, req.(*WorkerNodeHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_ReaderNodeHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReaderNodeHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).ReaderNodeHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/ReaderNodeHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).ReaderNodeHeartbeat(ctx, req.(*ReaderNodeHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_CreateIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).CreateIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/CreateIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).CreateIndex(ctx, req.(*CreateIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_DropIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).DropIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/DropIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).DropIndex(ctx, req.(*DropIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_GetIndexProgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIndexProgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).GetIndexProgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/GetIndexProgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).GetIndexProgress(ctx, req.(*GetIndexProgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_AppendDeltaFragMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendDeltaFragMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).AppendDeltaFragMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/AppendDeltaFragMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).AppendDeltaFragMeta(ctx, req.(*AppendDeltaFragMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_AppendBaseFragMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendBaseFragMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).AppendBaseFragMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/AppendBaseFragMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).AppendBaseFragMeta(ctx, req.(*AppendBaseFragMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_GetShardLocalCacheInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetShardLocalCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).GetShardLocalCacheInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/GetShardLocalCacheInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).GetShardLocalCacheInfo(ctx, req.(*GetShardLocalCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_DebugGetShardManifest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DebugGetShardManifestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).DebugGetShardManifest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/DebugGetShardManifest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).DebugGetShardManifest(ctx, req.(*DebugGetShardManifestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_FinishCompactFragments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishCompactFragRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).FinishCompactFragments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/FinishCompactFragments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).FinishCompactFragments(ctx, req.(*FinishCompactFragRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_SubmitImportIndexJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportIndexJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).SubmitImportIndexJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/SubmitImportIndexJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).SubmitImportIndexJob(ctx, req.(*ImportIndexJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_FinishImportPartitionUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishImportPartitionUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).FinishImportPartitionUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/FinishImportPartitionUpload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).FinishImportPartitionUpload(ctx, req.(*FinishImportPartitionUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_FinishImportPartitionBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishImportPartitionBuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).FinishImportPartitionBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/FinishImportPartitionBuild",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).FinishImportPartitionBuild(ctx, req.(*FinishImportPartitionBuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_FinishImportIndexUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishImportIndexUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).FinishImportIndexUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/FinishImportIndexUpload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).FinishImportIndexUpload(ctx, req.(*FinishImportIndexUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MetaService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tici.MetaService",
	HandlerType: (*MetaServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WorkerNodeHeartbeat",
			Handler:    _MetaService_WorkerNodeHeartbeat_Handler,
		},
		{
			MethodName: "ReaderNodeHeartbeat",
			Handler:    _MetaService_ReaderNodeHeartbeat_Handler,
		},
		{
			MethodName: "CreateIndex",
			Handler:    _MetaService_CreateIndex_Handler,
		},
		{
			MethodName: "DropIndex",
			Handler:    _MetaService_DropIndex_Handler,
		},
		{
			MethodName: "GetIndexProgress",
			Handler:    _MetaService_GetIndexProgress_Handler,
		},
		{
			MethodName: "AppendDeltaFragMeta",
			Handler:    _MetaService_AppendDeltaFragMeta_Handler,
		},
		{
			MethodName: "AppendBaseFragMeta",
			Handler:    _MetaService_AppendBaseFragMeta_Handler,
		},
		{
			MethodName: "GetShardLocalCacheInfo",
			Handler:    _MetaService_GetShardLocalCacheInfo_Handler,
		},
		{
			MethodName: "DebugGetShardManifest",
			Handler:    _MetaService_DebugGetShardManifest_Handler,
		},
		{
			MethodName: "FinishCompactFragments",
			Handler:    _MetaService_FinishCompactFragments_Handler,
		},
		{
			MethodName: "SubmitImportIndexJob",
			Handler:    _MetaService_SubmitImportIndexJob_Handler,
		},
		{
			MethodName: "FinishImportPartitionUpload",
			Handler:    _MetaService_FinishImportPartitionUpload_Handler,
		},
		{
			MethodName: "FinishImportPartitionBuild",
			Handler:    _MetaService_FinishImportPartitionBuild_Handler,
		},
		{
			MethodName: "FinishImportIndexUpload",
			Handler:    _MetaService_FinishImportIndexUpload_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tici.proto",
}

// WorkerServiceClient is the client API for WorkerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WorkerServiceClient interface {
	// Add shard for an index
	AddShard(ctx context.Context, in *AddShardRequest, opts ...grpc.CallOption) (*AddShardResponse, error)
	// Compact a shard
	CompactFragments(ctx context.Context, in *CompactFragRequest, opts ...grpc.CallOption) (*CompactFragResponse, error)
	// Write import data to a shard
	ImportWrite(ctx context.Context, in *ImportWriteRequest, opts ...grpc.CallOption) (*ImportWriteResponse, error)
}

type workerServiceClient struct {
	cc *grpc.ClientConn
}

func NewWorkerServiceClient(cc *grpc.ClientConn) WorkerServiceClient {
	return &workerServiceClient{cc}
}

func (c *workerServiceClient) AddShard(ctx context.Context, in *AddShardRequest, opts ...grpc.CallOption) (*AddShardResponse, error) {
	out := new(AddShardResponse)
	err := c.cc.Invoke(ctx, "/tici.WorkerService/AddShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerServiceClient) CompactFragments(ctx context.Context, in *CompactFragRequest, opts ...grpc.CallOption) (*CompactFragResponse, error) {
	out := new(CompactFragResponse)
	err := c.cc.Invoke(ctx, "/tici.WorkerService/CompactFragments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerServiceClient) ImportWrite(ctx context.Context, in *ImportWriteRequest, opts ...grpc.CallOption) (*ImportWriteResponse, error) {
	out := new(ImportWriteResponse)
	err := c.cc.Invoke(ctx, "/tici.WorkerService/ImportWrite", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkerServiceServer is the server API for WorkerService service.
type WorkerServiceServer interface {
	// Add shard for an index
	AddShard(context.Context, *AddShardRequest) (*AddShardResponse, error)
	// Compact a shard
	CompactFragments(context.Context, *CompactFragRequest) (*CompactFragResponse, error)
	// Write import data to a shard
	ImportWrite(context.Context, *ImportWriteRequest) (*ImportWriteResponse, error)
}

// UnimplementedWorkerServiceServer can be embedded to have forward compatible implementations.
type UnimplementedWorkerServiceServer struct {
}

func (*UnimplementedWorkerServiceServer) AddShard(ctx context.Context, req *AddShardRequest) (*AddShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddShard not implemented")
}
func (*UnimplementedWorkerServiceServer) CompactFragments(ctx context.Context, req *CompactFragRequest) (*CompactFragResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompactFragments not implemented")
}
func (*UnimplementedWorkerServiceServer) ImportWrite(ctx context.Context, req *ImportWriteRequest) (*ImportWriteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportWrite not implemented")
}

func RegisterWorkerServiceServer(s *grpc.Server, srv WorkerServiceServer) {
	s.RegisterService(&_WorkerService_serviceDesc, srv)
}

func _WorkerService_AddShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServiceServer).AddShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.WorkerService/AddShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServiceServer).AddShard(ctx, req.(*AddShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerService_CompactFragments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompactFragRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServiceServer).CompactFragments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.WorkerService/CompactFragments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServiceServer).CompactFragments(ctx, req.(*CompactFragRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerService_ImportWrite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportWriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServiceServer).ImportWrite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.WorkerService/ImportWrite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServiceServer).ImportWrite(ctx, req.(*ImportWriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _WorkerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tici.WorkerService",
	HandlerType: (*WorkerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddShard",
			Handler:    _WorkerService_AddShard_Handler,
		},
		{
			MethodName: "CompactFragments",
			Handler:    _WorkerService_CompactFragments_Handler,
		},
		{
			MethodName: "ImportWrite",
			Handler:    _WorkerService_ImportWrite_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tici.proto",
}

func (m *WorkerNodeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerNodeStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerNodeStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MemoryUsage != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.MemoryUsage))
		i--
		dAtA[i] = 0x10
	}
	if m.CpuUsage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuUsage))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *ReaderNodeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReaderNodeStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReaderNodeStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CacheHitRate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CacheHitRate))))
		i--
		dAtA[i] = 0x21
	}
	if m.RequestsInCycle != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.RequestsInCycle))
		i--
		dAtA[i] = 0x18
	}
	if m.MemoryUsage != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.MemoryUsage))
		i--
		dAtA[i] = 0x10
	}
	if m.CpuUsage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuUsage))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *WorkerNodeShardStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerNodeShardStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerNodeShardStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x38
	}
	if m.Epoch != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x30
	}
	if m.ShardId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x28
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x20
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintTici(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintTici(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkerNodeCompactionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerNodeCompactionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerNodeCompactionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Req != nil {
		{
			size, err := m.Req.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ImportWriteStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportWriteStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImportWriteStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FilePrefix) > 0 {
		i -= len(m.FilePrefix)
		copy(dAtA[i:], m.FilePrefix)
		i = encodeVarintTici(dAtA, i, uint64(len(m.FilePrefix)))
		i--
		dAtA[i] = 0x22
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WorkerNodeHeartbeatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerNodeHeartbeatRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerNodeHeartbeatRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ImportWrites) > 0 {
		for iNdEx := len(m.ImportWrites) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ImportWrites[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Compactions) > 0 {
		for iNdEx := len(m.Compactions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Compactions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Shards) > 0 {
		for iNdEx := len(m.Shards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Shards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintTici(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkerNodeHeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerNodeHeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerNodeHeartbeatResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ToRemoveShards) > 0 {
		dAtA4 := make([]byte, len(m.ToRemoveShards)*10)
		var j3 int
		for _, num := range m.ToRemoveShards {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintTici(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ToAddShards) > 0 {
		for iNdEx := len(m.ToAddShards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ToAddShards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReaderNodeHeartbeatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReaderNodeHeartbeatRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReaderNodeHeartbeatRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CachedShardIds) > 0 {
		dAtA6 := make([]byte, len(m.CachedShardIds)*10)
		var j5 int
		for _, num := range m.CachedShardIds {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintTici(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TiflashServerAddr) > 0 {
		i -= len(m.TiflashServerAddr)
		copy(dAtA[i:], m.TiflashServerAddr)
		i = encodeVarintTici(dAtA, i, uint64(len(m.TiflashServerAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintTici(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReaderNodeHeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReaderNodeHeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReaderNodeHeartbeatResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ShardsToRemove) > 0 {
		for iNdEx := len(m.ShardsToRemove) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShardsToRemove[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ShardsToKeep) > 0 {
		for iNdEx := len(m.ShardsToKeep) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShardsToKeep[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FragProperty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FragProperty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FragProperty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaxHandle) > 0 {
		i -= len(m.MaxHandle)
		copy(dAtA[i:], m.MaxHandle)
		i = encodeVarintTici(dAtA, i, uint64(len(m.MaxHandle)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MidHandle) > 0 {
		i -= len(m.MidHandle)
		copy(dAtA[i:], m.MidHandle)
		i = encodeVarintTici(dAtA, i, uint64(len(m.MidHandle)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MinHandle) > 0 {
		i -= len(m.MinHandle)
		copy(dAtA[i:], m.MinHandle)
		i = encodeVarintTici(dAtA, i, uint64(len(m.MinHandle)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Count != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Size_ != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FragMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FragMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FragMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Property != nil {
		{
			size, err := m.Property.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Segs) > 0 {
		for iNdEx := len(m.Segs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Segs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.HasDeletedSet {
		i--
		if m.HasDeletedSet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.FragPath) > 0 {
		i -= len(m.FragPath)
		copy(dAtA[i:], m.FragPath)
		i = encodeVarintTici(dAtA, i, uint64(len(m.FragPath)))
		i--
		dAtA[i] = 0x12
	}
	if m.FormatVersion != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.FormatVersion))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FragMeta_IndexSegment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FragMeta_IndexSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FragMeta_IndexSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DelSuffix) > 0 {
		i -= len(m.DelSuffix)
		copy(dAtA[i:], m.DelSuffix)
		i = encodeVarintTici(dAtA, i, uint64(len(m.DelSuffix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SegId) > 0 {
		i -= len(m.SegId)
		copy(dAtA[i:], m.SegId)
		i = encodeVarintTici(dAtA, i, uint64(len(m.SegId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppendDeltaFragMetaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendDeltaFragMetaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendDeltaFragMetaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LastCdcFile) > 0 {
		i -= len(m.LastCdcFile)
		copy(dAtA[i:], m.LastCdcFile)
		i = encodeVarintTici(dAtA, i, uint64(len(m.LastCdcFile)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.FragMetas) > 0 {
		for iNdEx := len(m.FragMetas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FragMetas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.WorkerNodeAddr) > 0 {
		i -= len(m.WorkerNodeAddr)
		copy(dAtA[i:], m.WorkerNodeAddr)
		i = encodeVarintTici(dAtA, i, uint64(len(m.WorkerNodeAddr)))
		i--
		dAtA[i] = 0x22
	}
	if m.ShardId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x18
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppendFragMetaResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendFragMetaResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendFragMetaResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppendBaseFragMetaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendBaseFragMetaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendBaseFragMetaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FragMetas) > 0 {
		for iNdEx := len(m.FragMetas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FragMetas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KeyRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintTici(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintTici(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardLocalCacheInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardLocalCacheInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardLocalCacheInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LocalCacheAddrs) > 0 {
		for iNdEx := len(m.LocalCacheAddrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LocalCacheAddrs[iNdEx])
			copy(dAtA[i:], m.LocalCacheAddrs[iNdEx])
			i = encodeVarintTici(dAtA, i, uint64(len(m.LocalCacheAddrs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Shard != nil {
		{
			size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetShardLocalCacheRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetShardLocalCacheRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetShardLocalCacheRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if len(m.KeyRanges) > 0 {
		for iNdEx := len(m.KeyRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.KeyRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetShardLocalCacheResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetShardLocalCacheResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetShardLocalCacheResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ShardLocalCacheInfos) > 0 {
		for iNdEx := len(m.ShardLocalCacheInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShardLocalCacheInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DebugGetShardManifestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugGetShardManifestRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugGetShardManifestRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.KeyRange != nil {
		{
			size, err := m.KeyRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DebugGetShardManifestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugGetShardManifestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugGetShardManifestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.FragMetas) > 0 {
		for iNdEx := len(m.FragMetas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FragMetas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompactFragRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactFragRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactFragRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Worker) > 0 {
		i -= len(m.Worker)
		copy(dAtA[i:], m.Worker)
		i = encodeVarintTici(dAtA, i, uint64(len(m.Worker)))
		i--
		dAtA[i] = 0x52
	}
	if m.CompactType != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.CompactType))
		i--
		dAtA[i] = 0x48
	}
	if m.UploadLocation != nil {
		{
			size, err := m.UploadLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.InputFrags) > 0 {
		for iNdEx := len(m.InputFrags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputFrags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.LeaderTerm) > 0 {
		i -= len(m.LeaderTerm)
		copy(dAtA[i:], m.LeaderTerm)
		i = encodeVarintTici(dAtA, i, uint64(len(m.LeaderTerm)))
		i--
		dAtA[i] = 0x32
	}
	if m.Timestamp != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x28
	}
	if m.Seq != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x20
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x18
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x10
	}
	if m.Shard != nil {
		{
			size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CompactFragResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactFragResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactFragResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FinishCompactFragRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinishCompactFragRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinishCompactFragRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OutputFrags) > 0 {
		for iNdEx := len(m.OutputFrags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutputFrags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.InputFrags) > 0 {
		for iNdEx := len(m.InputFrags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputFrags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.LeaderTerm) > 0 {
		i -= len(m.LeaderTerm)
		copy(dAtA[i:], m.LeaderTerm)
		i = encodeVarintTici(dAtA, i, uint64(len(m.LeaderTerm)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Timestamp != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x30
	}
	if m.Seq != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x28
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x20
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x18
	}
	if m.Shard != nil {
		{
			size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintTici(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FinishCompactFragResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinishCompactFragResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinishCompactFragResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImportWriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportWriteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImportWriteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FragPrefix) > 0 {
		i -= len(m.FragPrefix)
		copy(dAtA[i:], m.FragPrefix)
		i = encodeVarintTici(dAtA, i, uint64(len(m.FragPrefix)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FileLocation) > 0 {
		i -= len(m.FileLocation)
		copy(dAtA[i:], m.FileLocation)
		i = encodeVarintTici(dAtA, i, uint64(len(m.FileLocation)))
		i--
		dAtA[i] = 0x22
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x18
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x10
	}
	if m.TaskId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TaskId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImportWriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportWriteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImportWriteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShardManifestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardManifestHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardManifestHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x20
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintTici(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintTici(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.ShardId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S3Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S3Location) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S3Location) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintTici(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Bucket) > 0 {
		i -= len(m.Bucket)
		copy(dAtA[i:], m.Bucket)
		i = encodeVarintTici(dAtA, i, uint64(len(m.Bucket)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddShardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddShardRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddShardRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UploadLocation != nil {
		{
			size, err := m.UploadLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.CdcLocation != nil {
		{
			size, err := m.CdcLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CdcS3LastFile) > 0 {
		i -= len(m.CdcS3LastFile)
		copy(dAtA[i:], m.CdcS3LastFile)
		i = encodeVarintTici(dAtA, i, uint64(len(m.CdcS3LastFile)))
		i--
		dAtA[i] = 0x22
	}
	if m.TableInfo != nil {
		{
			size, err := m.TableInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexInfo != nil {
		{
			size, err := m.IndexInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Shard != nil {
		{
			size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddShardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddShardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddShardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateIndexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateIndexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateIndexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableInfo != nil {
		{
			size, err := m.TableInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.IndexInfo != nil {
		{
			size, err := m.IndexInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateIndexResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateIndexResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateIndexResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IndexId) > 0 {
		i -= len(m.IndexId)
		copy(dAtA[i:], m.IndexId)
		i = encodeVarintTici(dAtA, i, uint64(len(m.IndexId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropIndexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropIndexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropIndexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropIndexResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropIndexResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropIndexResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsClustered {
		i--
		if m.IsClustered {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Version != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DatabaseName) > 0 {
		i -= len(m.DatabaseName)
		copy(dAtA[i:], m.DatabaseName)
		i = encodeVarintTici(dAtA, i, uint64(len(m.DatabaseName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintTici(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsArray {
		i--
		if m.IsArray {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IsPrimaryKey {
		i--
		if m.IsPrimaryKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.DefaultVal) > 0 {
		i -= len(m.DefaultVal)
		copy(dAtA[i:], m.DefaultVal)
		i = encodeVarintTici(dAtA, i, uint64(len(m.DefaultVal)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Elems) > 0 {
		for iNdEx := len(m.Elems) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Elems[iNdEx])
			copy(dAtA[i:], m.Elems[iNdEx])
			i = encodeVarintTici(dAtA, i, uint64(len(m.Elems[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Flag != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Flag))
		i--
		dAtA[i] = 0x38
	}
	if m.Decimal != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Decimal))
		i--
		dAtA[i] = 0x30
	}
	if m.ColumnLength != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.ColumnLength))
		i--
		dAtA[i] = 0x28
	}
	if m.Collation != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Collation))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ColumnName) > 0 {
		i -= len(m.ColumnName)
		copy(dAtA[i:], m.ColumnName)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ColumnName)))
		i--
		dAtA[i] = 0x12
	}
	if m.ColumnId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.ColumnId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OtherParams) > 0 {
		for k := range m.OtherParams {
			v := m.OtherParams[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTici(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTici(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTici(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.ParserInfo != nil {
		{
			size, err := m.ParserInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.IsUnique {
		i--
		if m.IsUnique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.IndexType != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintTici(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ParserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParserInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParserInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParserParams) > 0 {
		for k := range m.ParserParams {
			v := m.ParserParams[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTici(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTici(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTici(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ParserType != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.ParserType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetIndexProgressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetIndexProgressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetIndexProgressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetIndexProgressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetIndexProgressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetIndexProgressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.S3Path) > 0 {
		i -= len(m.S3Path)
		copy(dAtA[i:], m.S3Path)
		i = encodeVarintTici(dAtA, i, uint64(len(m.S3Path)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.LastUploadTime) > 0 {
		i -= len(m.LastUploadTime)
		copy(dAtA[i:], m.LastUploadTime)
		i = encodeVarintTici(dAtA, i, uint64(len(m.LastUploadTime)))
		i--
		dAtA[i] = 0x32
	}
	if m.IsUploaded {
		i--
		if m.IsUploaded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.State != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.DocumentCount != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.DocumentCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImportIndexJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportIndexJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImportIndexJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StartTs != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.StartTs))
		i--
		dAtA[i] = 0x18
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImportIndexJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportIndexJobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImportIndexJobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StorageUri) > 0 {
		i -= len(m.StorageUri)
		copy(dAtA[i:], m.StorageUri)
		i = encodeVarintTici(dAtA, i, uint64(len(m.StorageUri)))
		i--
		dAtA[i] = 0x22
	}
	if m.JobId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.JobId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FinishImportPartitionUploadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinishImportPartitionUploadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinishImportPartitionUploadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.S3Path) > 0 {
		i -= len(m.S3Path)
		copy(dAtA[i:], m.S3Path)
		i = encodeVarintTici(dAtA, i, uint64(len(m.S3Path)))
		i--
		dAtA[i] = 0x22
	}
	if m.KeyRange != nil {
		{
			size, err := m.KeyRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FinishImportPartitionBuildRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinishImportPartitionBuildRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinishImportPartitionBuildRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.FragMetas) > 0 {
		for iNdEx := len(m.FragMetas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FragMetas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.TaskId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TaskId))
		i--
		dAtA[i] = 0x18
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FinishImportIndexUploadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinishImportIndexUploadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinishImportIndexUploadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FinishImportResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinishImportResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinishImportResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTici(dAtA []byte, offset int, v uint64) int {
	offset -= sovTici(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WorkerNodeStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuUsage != 0 {
		n += 9
	}
	if m.MemoryUsage != 0 {
		n += 1 + sovTici(uint64(m.MemoryUsage))
	}
	return n
}

func (m *ReaderNodeStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuUsage != 0 {
		n += 9
	}
	if m.MemoryUsage != 0 {
		n += 1 + sovTici(uint64(m.MemoryUsage))
	}
	if m.RequestsInCycle != 0 {
		n += 1 + sovTici(uint64(m.RequestsInCycle))
	}
	if m.CacheHitRate != 0 {
		n += 9
	}
	return n
}

func (m *WorkerNodeShardStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if m.ShardId != 0 {
		n += 1 + sovTici(uint64(m.ShardId))
	}
	if m.Epoch != 0 {
		n += 1 + sovTici(uint64(m.Epoch))
	}
	if m.Seq != 0 {
		n += 1 + sovTici(uint64(m.Seq))
	}
	return n
}

func (m *WorkerNodeCompactionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Req != nil {
		l = m.Req.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *ImportWriteStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	l = len(m.FilePrefix)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *WorkerNodeHeartbeatRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if len(m.Shards) > 0 {
		for _, e := range m.Shards {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if len(m.Compactions) > 0 {
		for _, e := range m.Compactions {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if len(m.ImportWrites) > 0 {
		for _, e := range m.ImportWrites {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	return n
}

func (m *WorkerNodeHeartbeatResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	if len(m.ToAddShards) > 0 {
		for _, e := range m.ToAddShards {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if len(m.ToRemoveShards) > 0 {
		l = 0
		for _, e := range m.ToRemoveShards {
			l += sovTici(uint64(e))
		}
		n += 1 + sovTici(uint64(l)) + l
	}
	return n
}

func (m *ReaderNodeHeartbeatRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.TiflashServerAddr)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if len(m.CachedShardIds) > 0 {
		l = 0
		for _, e := range m.CachedShardIds {
			l += sovTici(uint64(e))
		}
		n += 1 + sovTici(uint64(l)) + l
	}
	return n
}

func (m *ReaderNodeHeartbeatResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if len(m.ShardsToKeep) > 0 {
		for _, e := range m.ShardsToKeep {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if len(m.ShardsToRemove) > 0 {
		for _, e := range m.ShardsToRemove {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	return n
}

func (m *FragProperty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != 0 {
		n += 1 + sovTici(uint64(m.Size_))
	}
	if m.Count != 0 {
		n += 1 + sovTici(uint64(m.Count))
	}
	l = len(m.MinHandle)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.MidHandle)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.MaxHandle)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *FragMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FormatVersion != 0 {
		n += 1 + sovTici(uint64(m.FormatVersion))
	}
	l = len(m.FragPath)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.HasDeletedSet {
		n += 2
	}
	if len(m.Segs) > 0 {
		for _, e := range m.Segs {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if m.Property != nil {
		l = m.Property.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *FragMeta_IndexSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SegId)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.DelSuffix)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *AppendDeltaFragMetaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if m.ShardId != 0 {
		n += 1 + sovTici(uint64(m.ShardId))
	}
	l = len(m.WorkerNodeAddr)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if len(m.FragMetas) > 0 {
		for _, e := range m.FragMetas {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	l = len(m.LastCdcFile)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *AppendFragMetaResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	return n
}

func (m *AppendBaseFragMetaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if len(m.FragMetas) > 0 {
		for _, e := range m.FragMetas {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	return n
}

func (m *KeyRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *ShardLocalCacheInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Shard != nil {
		l = m.Shard.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if len(m.LocalCacheAddrs) > 0 {
		for _, s := range m.LocalCacheAddrs {
			l = len(s)
			n += 1 + l + sovTici(uint64(l))
		}
	}
	return n
}

func (m *GetShardLocalCacheRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if len(m.KeyRanges) > 0 {
		for _, e := range m.KeyRanges {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if m.Limit != 0 {
		n += 1 + sovTici(uint64(m.Limit))
	}
	return n
}

func (m *GetShardLocalCacheResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	if len(m.ShardLocalCacheInfos) > 0 {
		for _, e := range m.ShardLocalCacheInfos {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	return n
}

func (m *DebugGetShardManifestRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if m.KeyRange != nil {
		l = m.KeyRange.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *DebugGetShardManifestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	if len(m.FragMetas) > 0 {
		for _, e := range m.FragMetas {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if m.ShardId != 0 {
		n += 1 + sovTici(uint64(m.ShardId))
	}
	return n
}

func (m *CompactFragRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Shard != nil {
		l = m.Shard.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if m.Seq != 0 {
		n += 1 + sovTici(uint64(m.Seq))
	}
	if m.Timestamp != 0 {
		n += 1 + sovTici(uint64(m.Timestamp))
	}
	l = len(m.LeaderTerm)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if len(m.InputFrags) > 0 {
		for _, e := range m.InputFrags {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if m.UploadLocation != nil {
		l = m.UploadLocation.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if m.CompactType != 0 {
		n += 1 + sovTici(uint64(m.CompactType))
	}
	l = len(m.Worker)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *CompactFragResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	return n
}

func (m *FinishCompactFragRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.Shard != nil {
		l = m.Shard.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if m.Seq != 0 {
		n += 1 + sovTici(uint64(m.Seq))
	}
	if m.Timestamp != 0 {
		n += 1 + sovTici(uint64(m.Timestamp))
	}
	l = len(m.LeaderTerm)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if len(m.InputFrags) > 0 {
		for _, e := range m.InputFrags {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if len(m.OutputFrags) > 0 {
		for _, e := range m.OutputFrags {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	return n
}

func (m *FinishCompactFragResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	return n
}

func (m *ImportWriteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovTici(uint64(m.TaskId))
	}
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	l = len(m.FileLocation)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.FragPrefix)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *ImportWriteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	return n
}

func (m *ShardManifestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardId != 0 {
		n += 1 + sovTici(uint64(m.ShardId))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovTici(uint64(m.Epoch))
	}
	return n
}

func (m *S3Location) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bucket)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *AddShardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Shard != nil {
		l = m.Shard.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if m.IndexInfo != nil {
		l = m.IndexInfo.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if m.TableInfo != nil {
		l = m.TableInfo.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.CdcS3LastFile)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.CdcLocation != nil {
		l = m.CdcLocation.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if m.UploadLocation != nil {
		l = m.UploadLocation.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *AddShardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	return n
}

func (m *CreateIndexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexInfo != nil {
		l = m.IndexInfo.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if m.TableInfo != nil {
		l = m.TableInfo.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *CreateIndexResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.IndexId)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *DropIndexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	return n
}

func (m *DropIndexResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *TableInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.DatabaseName)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovTici(uint64(m.Version))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if m.IsClustered {
		n += 2
	}
	return n
}

func (m *ColumnInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnId != 0 {
		n += 1 + sovTici(uint64(m.ColumnId))
	}
	l = len(m.ColumnName)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTici(uint64(m.Type))
	}
	if m.Collation != 0 {
		n += 1 + sovTici(uint64(m.Collation))
	}
	if m.ColumnLength != 0 {
		n += 1 + sovTici(uint64(m.ColumnLength))
	}
	if m.Decimal != 0 {
		n += 1 + sovTici(uint64(m.Decimal))
	}
	if m.Flag != 0 {
		n += 1 + sovTici(uint64(m.Flag))
	}
	if len(m.Elems) > 0 {
		for _, s := range m.Elems {
			l = len(s)
			n += 1 + l + sovTici(uint64(l))
		}
	}
	l = len(m.DefaultVal)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.IsPrimaryKey {
		n += 2
	}
	if m.IsArray {
		n += 2
	}
	return n
}

func (m *IndexInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.IndexType != 0 {
		n += 1 + sovTici(uint64(m.IndexType))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if m.IsUnique {
		n += 2
	}
	if m.ParserInfo != nil {
		l = m.ParserInfo.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if len(m.OtherParams) > 0 {
		for k, v := range m.OtherParams {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTici(uint64(len(k))) + 1 + len(v) + sovTici(uint64(len(v)))
			n += mapEntrySize + 1 + sovTici(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ParserInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParserType != 0 {
		n += 1 + sovTici(uint64(m.ParserType))
	}
	if len(m.ParserParams) > 0 {
		for k, v := range m.ParserParams {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTici(uint64(len(k))) + 1 + len(v) + sovTici(uint64(len(v)))
			n += mapEntrySize + 1 + sovTici(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GetIndexProgressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	return n
}

func (m *GetIndexProgressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.DocumentCount != 0 {
		n += 1 + sovTici(uint64(m.DocumentCount))
	}
	if m.State != 0 {
		n += 1 + sovTici(uint64(m.State))
	}
	if m.IsUploaded {
		n += 2
	}
	l = len(m.LastUploadTime)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.S3Path)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *ImportIndexJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if m.StartTs != 0 {
		n += 1 + sovTici(uint64(m.StartTs))
	}
	return n
}

func (m *ImportIndexJobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.JobId != 0 {
		n += 1 + sovTici(uint64(m.JobId))
	}
	l = len(m.StorageUri)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *FinishImportPartitionUploadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if m.KeyRange != nil {
		l = m.KeyRange.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.S3Path)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *FinishImportPartitionBuildRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if m.TaskId != 0 {
		n += 1 + sovTici(uint64(m.TaskId))
	}
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	if len(m.FragMetas) > 0 {
		for _, e := range m.FragMetas {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *FinishImportIndexUploadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	return n
}

func (m *FinishImportResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func sovTici(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTici(x uint64) (n int) {
	return sovTici(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *WorkerNodeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerNodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerNodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUsage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuUsage = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryUsage", wireType)
			}
			m.MemoryUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryUsage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReaderNodeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReaderNodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReaderNodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUsage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuUsage = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryUsage", wireType)
			}
			m.MemoryUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryUsage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestsInCycle", wireType)
			}
			m.RequestsInCycle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestsInCycle |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheHitRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CacheHitRate = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerNodeShardStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerNodeShardStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerNodeShardStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerNodeCompactionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerNodeCompactionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerNodeCompactionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Req == nil {
				m.Req = &CompactFragRequest{}
			}
			if err := m.Req.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportWriteStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportWriteStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportWriteStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerNodeHeartbeatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerNodeHeartbeatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerNodeHeartbeatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &WorkerNodeStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, &WorkerNodeShardStatus{})
			if err := m.Shards[len(m.Shards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Compactions = append(m.Compactions, &WorkerNodeCompactionStatus{})
			if err := m.Compactions[len(m.Compactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImportWrites = append(m.ImportWrites, &ImportWriteStatus{})
			if err := m.ImportWrites[len(m.ImportWrites)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerNodeHeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerNodeHeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerNodeHeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddShards = append(m.ToAddShards, &AddShardRequest{})
			if err := m.ToAddShards[len(m.ToAddShards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTici
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ToRemoveShards = append(m.ToRemoveShards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTici
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTici
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTici
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ToRemoveShards) == 0 {
					m.ToRemoveShards = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTici
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ToRemoveShards = append(m.ToRemoveShards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ToRemoveShards", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReaderNodeHeartbeatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReaderNodeHeartbeatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReaderNodeHeartbeatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ReaderNodeStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TiflashServerAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TiflashServerAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTici
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CachedShardIds = append(m.CachedShardIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTici
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTici
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTici
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CachedShardIds) == 0 {
					m.CachedShardIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTici
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CachedShardIds = append(m.CachedShardIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedShardIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReaderNodeHeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReaderNodeHeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReaderNodeHeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardsToKeep", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardsToKeep = append(m.ShardsToKeep, &ShardManifestHeader{})
			if err := m.ShardsToKeep[len(m.ShardsToKeep)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardsToRemove", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardsToRemove = append(m.ShardsToRemove, &ShardManifestHeader{})
			if err := m.ShardsToRemove[len(m.ShardsToRemove)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FragProperty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FragProperty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FragProperty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinHandle", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinHandle = append(m.MinHandle[:0], dAtA[iNdEx:postIndex]...)
			if m.MinHandle == nil {
				m.MinHandle = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MidHandle", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MidHandle = append(m.MidHandle[:0], dAtA[iNdEx:postIndex]...)
			if m.MidHandle == nil {
				m.MidHandle = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxHandle", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxHandle = append(m.MaxHandle[:0], dAtA[iNdEx:postIndex]...)
			if m.MaxHandle == nil {
				m.MaxHandle = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FragMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FragMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FragMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FormatVersion", wireType)
			}
			m.FormatVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FormatVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FragPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasDeletedSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasDeletedSet = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Segs = append(m.Segs, &FragMeta_IndexSegment{})
			if err := m.Segs[len(m.Segs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Property", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Property == nil {
				m.Property = &FragProperty{}
			}
			if err := m.Property.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FragMeta_IndexSegment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexSegment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexSegment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SegId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelSuffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelSuffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendDeltaFragMetaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendDeltaFragMetaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendDeltaFragMetaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerNodeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerNodeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragMetas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FragMetas = append(m.FragMetas, &FragMeta{})
			if err := m.FragMetas[len(m.FragMetas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCdcFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastCdcFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendFragMetaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendFragMetaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendFragMetaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendBaseFragMetaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendBaseFragMetaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendBaseFragMetaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragMetas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FragMetas = append(m.FragMetas, &FragMeta{})
			if err := m.FragMetas[len(m.FragMetas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardLocalCacheInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardLocalCacheInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardLocalCacheInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shard == nil {
				m.Shard = &ShardManifestHeader{}
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalCacheAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalCacheAddrs = append(m.LocalCacheAddrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetShardLocalCacheRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetShardLocalCacheRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetShardLocalCacheRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyRanges = append(m.KeyRanges, &KeyRange{})
			if err := m.KeyRanges[len(m.KeyRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetShardLocalCacheResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetShardLocalCacheResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetShardLocalCacheResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardLocalCacheInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardLocalCacheInfos = append(m.ShardLocalCacheInfos, &ShardLocalCacheInfo{})
			if err := m.ShardLocalCacheInfos[len(m.ShardLocalCacheInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugGetShardManifestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugGetShardManifestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugGetShardManifestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &KeyRange{}
			}
			if err := m.KeyRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugGetShardManifestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugGetShardManifestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugGetShardManifestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragMetas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FragMetas = append(m.FragMetas, &FragMeta{})
			if err := m.FragMetas[len(m.FragMetas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactFragRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactFragRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactFragRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shard == nil {
				m.Shard = &ShardManifestHeader{}
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderTerm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaderTerm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputFrags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputFrags = append(m.InputFrags, &FragMeta{})
			if err := m.InputFrags[len(m.InputFrags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadLocation == nil {
				m.UploadLocation = &S3Location{}
			}
			if err := m.UploadLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactType", wireType)
			}
			m.CompactType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactType |= CompactType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Worker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Worker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactFragResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactFragResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactFragResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinishCompactFragRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinishCompactFragRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinishCompactFragRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shard == nil {
				m.Shard = &ShardManifestHeader{}
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderTerm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaderTerm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputFrags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputFrags = append(m.InputFrags, &FragMeta{})
			if err := m.InputFrags[len(m.InputFrags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputFrags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputFrags = append(m.OutputFrags, &FragMeta{})
			if err := m.OutputFrags[len(m.OutputFrags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinishCompactFragResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinishCompactFragResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinishCompactFragResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportWriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportWriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportWriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FragPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportWriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportWriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportWriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardManifestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardManifestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardManifestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S3Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S3Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S3Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddShardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddShardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddShardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shard == nil {
				m.Shard = &ShardManifestHeader{}
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexInfo == nil {
				m.IndexInfo = &IndexInfo{}
			}
			if err := m.IndexInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableInfo == nil {
				m.TableInfo = &TableInfo{}
			}
			if err := m.TableInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdcS3LastFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CdcS3LastFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdcLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CdcLocation == nil {
				m.CdcLocation = &S3Location{}
			}
			if err := m.CdcLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadLocation == nil {
				m.UploadLocation = &S3Location{}
			}
			if err := m.UploadLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddShardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddShardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddShardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateIndexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateIndexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateIndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexInfo == nil {
				m.IndexInfo = &IndexInfo{}
			}
			if err := m.IndexInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableInfo == nil {
				m.TableInfo = &TableInfo{}
			}
			if err := m.TableInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateIndexResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateIndexResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateIndexResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropIndexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropIndexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropIndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropIndexResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropIndexResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropIndexResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ColumnInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClustered", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClustered = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnId", wireType)
			}
			m.ColumnId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collation", wireType)
			}
			m.Collation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Collation |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnLength", wireType)
			}
			m.ColumnLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal", wireType)
			}
			m.Decimal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elems", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Elems = append(m.Elems, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultVal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultVal = append(m.DefaultVal[:0], dAtA[iNdEx:postIndex]...)
			if m.DefaultVal == nil {
				m.DefaultVal = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimaryKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrimaryKey = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArray", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsArray = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexType", wireType)
			}
			m.IndexType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexType |= IndexType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ColumnInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUnique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUnique = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParserInfo == nil {
				m.ParserInfo = &ParserInfo{}
			}
			if err := m.ParserInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OtherParams == nil {
				m.OtherParams = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTici
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTici
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTici
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTici
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTici
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTici
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTici
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTici(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTici
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.OtherParams[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParserInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParserType", wireType)
			}
			m.ParserType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParserType |= ParserType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParserParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParserParams == nil {
				m.ParserParams = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTici
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTici
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTici
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTici
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTici
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTici
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTici
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTici(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTici
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ParserParams[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetIndexProgressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetIndexProgressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetIndexProgressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetIndexProgressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetIndexProgressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetIndexProgressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentCount", wireType)
			}
			m.DocumentCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DocumentCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= GetIndexProgressResponse_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUploaded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUploaded = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUploadTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastUploadTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S3Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportIndexJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportIndexJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportIndexJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportIndexJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportIndexJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportIndexJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			m.JobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinishImportPartitionUploadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinishImportPartitionUploadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinishImportPartitionUploadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &KeyRange{}
			}
			if err := m.KeyRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S3Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinishImportPartitionBuildRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinishImportPartitionBuildRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinishImportPartitionBuildRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragMetas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FragMetas = append(m.FragMetas, &FragMeta{})
			if err := m.FragMetas[len(m.FragMetas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinishImportIndexUploadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinishImportIndexUploadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinishImportIndexUploadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinishImportResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinishImportResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinishImportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTici(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTici
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTici
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTici
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTici
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTici
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTici
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTici        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTici          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTici = fmt.Errorf("proto: unexpected end of group")
)
