syntax = "proto3";

package tici;

option go_package = ".";

message WorkerNodeStatus {
  // TODO Need more metrics, such as disk usage, quotas, cache miss rates
  double cpu_usage = 1;
  uint64 memory_usage = 2;
}

// Reader node status information
message ReaderNodeStatus {
  // CPU usage percentage (0.0 to 100.0)
  double cpu_usage = 1;
  // Memory usage in bytes
  uint64 memory_usage = 2;
  // Number of requests processed in current heartbeat cycle
  uint32 requests_in_cycle = 3;
  // Cache hit rate percentage (0.0 to 100.0)
  double cache_hit_rate = 4;
}

// Some fields may be duplicated with ShardManifestHeader,
// however, just leave them here.
message WorkerNodeShardStatus {
  bytes start_key = 1;
  bytes end_key = 2;
  // TODO shard_id is unique across tables and indexes.
  // We still need them because in meta service we are not currently maintain
  // this correspondence.
  int64 table_id = 3;
  int64 index_id = 4;
  uint64 shard_id = 5;
  uint64 epoch = 6;
  uint64 seq = 7;
}

message WorkerNodeCompactionStatus {}

message WorkerNodeHeartbeatRequest {
  string addr = 1;
  WorkerNodeStatus status = 2;
  repeated WorkerNodeShardStatus shards = 3;
  repeated WorkerNodeCompactionStatus compactions = 4;
}

message WorkerNodeHeartbeatResponse {
  // Operation result status code, 0 means success
  int32 status = 1;
  repeated AddShardRequest to_add_shards = 2;
  // We assume the `shard_id`s are unique across tables,
  // So using `shard_id` is enough here.
  repeated uint64 to_remove_shards = 3;
}

// Reader node heartbeat request
message ReaderNodeHeartbeatRequest {
  // Reader node address
  string addr = 1;
  // Reader node status
  ReaderNodeStatus status = 2;
  // TiFlash server address
  string tiflash_server_addr = 3;
  // List of cached shard IDs on this reader
  repeated uint64 cached_shard_ids = 4;
}

// Reader node heartbeat response
message ReaderNodeHeartbeatResponse {
  // Operation result status code, 0 means success
  int32 status = 1;
  // Error message, only valid when status is non-zero
  string error_message = 2;
}

// Fragment metadata primarily stores all data files under a
// ​​fragment​​
message FragProperty {
  // Total file size of fragment.
  uint64 size = 1;
  // Distinct handle count in fragment.
  uint64 count = 2;
  bytes min_handle = 3;
  bytes mid_handle = 4;
  bytes max_handle = 5;
}

message FragMeta {
  // Data format version​​, used for future iterative upgrades
  uint64 format_version = 1;
  // Root path of the fragment​​
  string frag_path = 2;

  bool has_deleted_set = 3;

  message IndexSegment {
    string seg_id = 1;
    string del_suffix = 2;
  }
  repeated IndexSegment segs = 4;

  FragProperty property = 5;
}

message AppendFragMetaRequest {
  int64 table_id = 1;
  int64 index_id = 2;
  uint64 shard_id = 3;
  string last_cdc_file = 4;
  string worker_node_addr = 5;
  repeated FragMeta frag_metas = 6;
}

message AppendFragMetaResponse {
  // 0 - success
  // ... other error codes
  int32 status = 1;
}

// Key range definition
message KeyRange {
  // Inclusive lower key bound
  bytes start_key = 1;
  // Exclusive upper key bound
  bytes end_key = 2;
}

// Shard local cache information
message ShardLocalCacheInfo {
  ShardManifestHeader shard = 1;
  repeated string local_cache_addrs = 2;
}

// Request to get shard local cache information
message GetShardLocalCacheRequest {
  // Table ID to filter shards
  int64 table_id = 1;
  // Index ID to filter shards
  int64 index_id = 2;
  repeated KeyRange key_ranges = 3;
  // at most `limit` shards can be returned
  int32 limit = 4;
}

// Response containing shard local cache information
message GetShardLocalCacheResponse {
  // Operation result status code, 0 means success
  int32 status = 1;
  repeated ShardLocalCacheInfo shard_local_cache_infos = 2;
}

message DebugGetShardManifestRequest {
  int64 table_id = 1;
  int64 index_id = 2;
  KeyRange key_range = 3;
}

message DebugGetShardManifestResponse { repeated FragMeta frag_metas = 1; }

service MetaService {
  // Maintains heartbeat from worker nodes(such as writers, compactors) to meta
  // service.
  rpc WorkerNodeHeartbeat(WorkerNodeHeartbeatRequest)
      returns (WorkerNodeHeartbeatResponse);

  // Maintains heartbeat from reader nodes to meta service.
  rpc ReaderNodeHeartbeat(ReaderNodeHeartbeatRequest)
      returns (ReaderNodeHeartbeatResponse);

  // -----------------------------------------------------------------------------
  // APIs for create indexes

  // CreateIndex creates a new index
  rpc CreateIndex(CreateIndexRequest) returns (CreateIndexResponse);

  // DropIndex removes an existing index
  rpc DropIndex(DropIndexRequest) returns (DropIndexResponse);

  // GetIndexProgress retrieves the current progress of an index build
  rpc GetIndexProgress(GetIndexProgressRequest)
      returns (GetIndexProgressResponse);

  // -----------------------------------------------------------------------------

  rpc AppendFragMeta(AppendFragMetaRequest) returns (AppendFragMetaResponse);

  // Get shard local cache information
  rpc GetShardLocalCacheInfo(GetShardLocalCacheRequest)
      returns (GetShardLocalCacheResponse);

  // Debug usage: get shard manifest from meta service writer
  rpc DebugGetShardManifest(DebugGetShardManifestRequest)
      returns (DebugGetShardManifestResponse);

  rpc FinishCompactFragments(FinishCompactFragRequest) returns (FinishCompactFragResponse);

  // -----------------------------------------------------------------------------
  // APIs for importing data

  // Returns the cloud storage path where TiDB should upload a baseline shard
  // for the specified [table_info, index_info, key_range].
  rpc GetImportStoragePath(GetImportStoragePathRequest)
      returns (GetImportStoragePathResponse);

  // Called by Import DXF to notify Meta Service after a partitions for
  // the given index are uploaded.
  rpc MarkPartitionUploadFinished(MarkPartitionUploadFinishedRequest)
      returns (MarkPartitionUploadFinishedResponse);

  // Called to notify Meta Service that the whole table/index upload is
  // finished.
  rpc MarkTableUploadFinished(MarkTableUploadFinishedRequest)
      returns (MarkTableUploadFinishedResponse);

  // -----------------------------------------------------------------------------
}

enum CompactType {
  Delta = 0;
  Base = 1;
  Full = 2;
}

message CompactFragRequest {
  ShardManifestHeader shard = 1;
  int64 table_id = 2;
  int64 index_id = 3;
  string compaction_key = 4;
  uint64 seq = 5;
  uint64 timestamp = 6;
  string leader_term = 7;
  repeated FragMeta input_frags = 8;
  S3Location upload_location = 9;
  CompactType compact_type = 10;
}

message CompactFragResponse {
  int32 status = 1;
}

message FinishCompactFragRequest {
  string addr = 1;
  ShardManifestHeader shard = 2;
  int64 table_id = 3;
  int64 index_id = 4;
  string compaction_key = 5;
  uint64 seq = 6;
  uint64 timestamp = 7;
  string leader_term = 8;
  repeated FragMeta output_frags = 9;
}

message FinishCompactFragResponse {
  int32 status = 1;
}

// WorkerService provides index creation and deletion functionality
service WorkerService {
  // Add shard for an index
  rpc AddShard(AddShardRequest) returns (AddShardResponse);
  // Compact a shard
  rpc CompactFragments(CompactFragRequest) returns (CompactFragResponse);
}

// IndexType represents the type of index
enum IndexType {
  // Default value must be 0 in proto3
  UNKNOWN = 0;
  // Full-text index type
  FULL_TEXT = 1;
  // Custom index type
  CUSTOM = 2;
}

// ParserType represents the type of parser
enum ParserType {
  // Default value must be 0 in proto3
  UNKNOWN_PARSER = 0;
  // Default parser
  DEFAULT_PARSER = 1;
  // Other parser types
  OTHER_PARSER = 2;
}

message ShardManifestHeader {
  uint64 shard_id = 1;
  bytes start_key = 2;
  bytes end_key = 3;
  uint64 epoch = 4;
}

message S3Location {
  string bucket = 1;
  string prefix = 2;
}

// AddShardRequest is sent from meta service to worker node
message AddShardRequest {
  ShardManifestHeader shard = 1;
  // Index information
  IndexInfo index_info = 2;
  // Table information
  TableInfo table_info = 3;
  // If the shard is created from scratch, this field is empty
  string cdc_s3_last_file = 4;
  S3Location cdc_location = 5;
  S3Location upload_location = 6;
}

// AddShardResponse
message AddShardResponse {
  // Operation result status code, 0 means success
  int32 status = 1;
}

// CreateIndexRequest is a request to create an index
message CreateIndexRequest {
  // Index information
  IndexInfo index_info = 1;
  // Table information
  TableInfo table_info = 2;
}

// CreateIndexResponse is a response to the index creation request
message CreateIndexResponse {
  // Operation result status code, 0 means success
  int32 status = 1;
  // Error message, only valid when status is non-zero
  string error_message = 2;
  // Created index ID
  string index_id = 3;
}

// DropIndexRequest is a request to drop an index
message DropIndexRequest {
  int64 table_id = 1;
  int64 index_id = 2;
}

// DropIndexResponse is a response to the index drop request
message DropIndexResponse {
  // Operation result status code, 0 means success
  int32 status = 1;
  // Error message, only valid when status is non-zero
  string error_message = 2;
}

// TableInfo represents table information
message TableInfo {
  // Table ID
  int64 table_id = 1;
  // Table name
  string table_name = 2;
  // Database name
  string database_name = 3;
  // Table version
  int64 version = 4;
  // Column information
  repeated ColumnInfo columns = 5;
}

// ColumnInfo represents column information
message ColumnInfo {
  // Column ID
  int64 column_id = 1;
  // Column name
  string column_name = 2;
  // MySQL type
  int32 type = 3;
  // Collation
  int32 collation = 4;
  // Column length
  int32 column_length = 5;
  // Decimal places
  int32 decimal = 6;
  // Flags
  int32 flag = 7;
  // Enum elements
  repeated string elems = 8;
  // Default value
  bytes default_val = 9;
  // Whether it's a primary key
  bool is_primary_key = 10;
  // Whether it's an array
  bool is_array = 11;
}

// IndexInfo represents index information
message IndexInfo {
  // Table ID
  int64 table_id = 1;
  // Index ID
  int64 index_id = 2;
  // Index name
  string index_name = 3;
  // Index type (fulltext, custom)
  IndexType index_type = 4;
  // Index columns
  repeated ColumnInfo columns = 5;
  // Whether the index is unique
  bool is_unique = 6;
  // Parser information
  ParserInfo parser_info = 7;
  // Other index parameters
  map<string, string> other_params = 8;
}

// ParserInfo represents parser information
message ParserInfo {
  // Parser type
  ParserType parser_type = 1;
  // Parser parameters
  map<string, string> parser_params = 2;
}

// GetIndexProgressRequest is a request to get the progress of an index build
message GetIndexProgressRequest {
  // Table ID
  int64 table_id = 1;
  // Index ID
  int64 index_id = 2;
}

// GetIndexProgressResponse is a response containing index build progress
message GetIndexProgressResponse {
  enum State {
    PENDING = 0;
    RUNNING = 1;
    COMPLETED = 2;
    FAILED = 3;
    NOTFOUND = 4;
    ERROR = 5;
  }
  // Operation result status code, 0 means success
  int32 status = 1;
  // Error message, only valid when status is non-zero
  string error_message = 2;
  // Number of documents indexed so far
  uint64 document_count = 3;
  // Build task state (PENDING, RUNNING, COMPLETED, FAILED)
  State state = 4;
  // Whether index has been uploaded to S3
  bool is_uploaded = 5;
  // Last S3 upload time in RFC3339 format
  string last_upload_time = 6;
  // S3 path where the index is stored
  string s3_path = 7;
}

// -----------------------------------------------------------------------------
// TiCI Full-text index data import workflow during Import Into (with DXF):
// -----------------------------------------------------------------------------
// 1. TiDB requests a cloud storage object path ("file") from the TiCI Meta
//    Service. It provides the table info, index info, and key range for the
//    specific data shard. TiDB import code path expects a unique file path
//    for each shard to write its key-value pairs. Currently, only S3 is
//    supported as the cloud storage backend.
//
// 2. After import DXF has uploaded one partition data belonging to a baseline
//    full text index, it calls `MarkPartitionUploadFinished`. This allows
//    TiCI to mark the partition as complete and make it available to downstream
//    consumers.
//
// 3. After import DXF has uploaded all partitions data belonging to a baseline
//    full text index on a table, it calls `MarkTableUploadFinishedRequest`.
//    This allows TiCI to mark the table as complete and make it available to
//    GC data after consumed by downstream consumers.
// -----------------------------------------------------------------------------

message GetImportStoragePathRequest {
  // Detailed schema of the fts being built.
  IndexInfo index_info = 1;
  // Parent table metadata.
  TableInfo table_info = 2;
  // Inclusive lower key bound (encoded handle/rowID), non-empty.
  bytes lower_bound = 3;
  // Exclusive upper key bound, non-empty.
  bytes upper_bound = 4;
  // TODO: Use KeyRange instead of `lower_bound` `upper_bound`.
  // Key range for the partition being uploaded.
  // KeyRange key_range = 3;
}

message GetImportStoragePathResponse {
  // 0 - success
  // ... other error codes
  int32 status = 1;
  // Optional human‑readable diagnostics, only defined when status ≠ 0.
  string error_message = 2;
  // Object key inside the bucket that TiDB Import should write to.
  // The format is "s3://bucket/prefix/filename".
  string s3_path = 3;
}

message MarkPartitionUploadFinishedRequest {
  // The same S3 path previously returned by GetCloudStoragePath.
  // We assume the path is unique for each partition so it can be used to
  // identify the partition.
  string s3_path = 1;
}

// DXF receives this in-band result so callers can
// inspect the status and customized results.
message MarkPartitionUploadFinishedResponse {
  // 0 - success
  // ... other error codes
  int32 status = 1;
  // Optional human‑readable diagnostics, only defined when status ≠ 0.
  string error_message = 2;
}

message MarkTableUploadFinishedRequest {
  // Table ID of the target table.
  int64 table_id = 1;
  // Index ID of the target index.
  int64 index_id = 2;
}

message MarkTableUploadFinishedResponse {
  // 0 - success
  // ... other error codes
  int32 status = 1;
  // Optional human‑readable diagnostics, only defined when status ≠ 0.
  string error_message = 2;
}

// -----------------------------------------------------------------------------
