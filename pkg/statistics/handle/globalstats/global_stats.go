// Copyright 2023 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package globalstats

import (
	"github.com/pingcap/errors"
	"github.com/pingcap/tidb/pkg/infoschema"
	"github.com/pingcap/tidb/pkg/parser/ast"
	"github.com/pingcap/tidb/pkg/parser/model"
	"github.com/pingcap/tidb/pkg/sessionctx"
	"github.com/pingcap/tidb/pkg/sessiontxn"
	"github.com/pingcap/tidb/pkg/statistics"
	"github.com/pingcap/tidb/pkg/statistics/handle/util"
	"github.com/pingcap/tidb/pkg/table"
	"github.com/pingcap/tidb/pkg/util/logutil"
	"github.com/tiancaiamao/gp"
	"go.uber.org/zap"
)

const (
	// MaxPartitionMergeBatchSize indicates the max batch size for a worker to merge partition stats
	MaxPartitionMergeBatchSize = 256
)

// GlobalStats is used to store the statistics contained in the global-level stats
// which is generated by the merge of partition-level stats.
// It will both store the column stats and index stats.
// In the column statistics, the variable `num` is equal to the number of columns in the partition table.
// In the index statistics, the variable `num` is always equal to one.
type GlobalStats struct {
	Hg                    []*statistics.Histogram
	Cms                   []*statistics.CMSketch
	TopN                  []*statistics.TopN
	Fms                   []*statistics.FMSketch
	MissingPartitionStats []string
	Num                   int
	Count                 int64
	ModifyCount           int64
}

func newGlobalStats(histCount int) *GlobalStats {
	globalStats := new(GlobalStats)
	globalStats.Num = histCount
	globalStats.Count = 0
	globalStats.Hg = make([]*statistics.Histogram, globalStats.Num)
	globalStats.Cms = make([]*statistics.CMSketch, globalStats.Num)
	globalStats.TopN = make([]*statistics.TopN, globalStats.Num)
	globalStats.Fms = make([]*statistics.FMSketch, globalStats.Num)

	return globalStats
}

type (
	getTableByPhysicalIDFunc  func(is infoschema.InfoSchema, tableID int64) (table.Table, bool)
	callWithSCtxFunc          func(f func(sctx sessionctx.Context) error, flags ...int) error
	saveStatsToStorageFunc    func(tableID int64, count, modifyCount int64, isIndex int, hg *statistics.Histogram, cms *statistics.CMSketch, topN *statistics.TopN, statsVersion int, isAnalyzed int64, updateAnalyzeTime bool, source string) (err error)
	tableStatsFromStorageFunc func(tableInfo *model.TableInfo, physicalID int64, loadAll bool, snapshot uint64) (*statistics.Table, error)
)

// MergePartitionStats2GlobalStats merge the partition-level stats to global-level stats based on the tableInfo.
func MergePartitionStats2GlobalStats(
	sc sessionctx.Context,
	gpool *gp.Pool,
	opts map[ast.AnalyzeOptionType]uint64,
	is infoschema.InfoSchema,
	globalTableInfo *model.TableInfo,
	isIndex bool,
	histIDs []int64,
	getTableByPhysicalIDFn getTableByPhysicalIDFunc,
	callWithSCtxFunc callWithSCtxFunc,
) (globalStats *GlobalStats, err error) {
	worker, err := NewAsyncMergePartitionStats2GlobalStats(gpool, globalTableInfo, histIDs, is, getTableByPhysicalIDFn, callWithSCtxFunc)
	if err != nil {
		return nil, errors.Trace(err)
	}
	err = worker.MergePartitionStats2GlobalStats(sc, opts, isIndex)
	if err != nil {
		return nil, errors.Trace(err)
	}
	return worker.Result(), nil
}

// MergePartitionStats2GlobalStatsByTableID merge the partition-level stats to global-level stats based on the tableID.
func MergePartitionStats2GlobalStatsByTableID(
	sc sessionctx.Context,
	gpool *gp.Pool,
	opts map[ast.AnalyzeOptionType]uint64,
	is infoschema.InfoSchema,
	tableID int64,
	isIndex bool,
	histIDs []int64,
	getTableByPhysicalIDFn getTableByPhysicalIDFunc,
	callWithSCtxFunc callWithSCtxFunc,
) (globalStats *GlobalStats, err error) {
	// Get the partition table IDs.
	globalTable, ok := getTableByPhysicalIDFn(is, tableID)
	if !ok {
		err = errors.Errorf("unknown physical ID %d in stats meta table, maybe it has been dropped", tableID)
		return
	}

	globalTableInfo := globalTable.Meta()

	worker, err := NewAsyncMergePartitionStats2GlobalStats(gpool, globalTableInfo, histIDs, is, getTableByPhysicalIDFn, callWithSCtxFunc)
	if err != nil {
		return nil, errors.Trace(err)
	}
	err = worker.MergePartitionStats2GlobalStats(sc, opts, isIndex)
	if err != nil {
		return nil, errors.Trace(err)
	}
	globalStats = worker.Result()
	if len(globalStats.MissingPartitionStats) > 0 {
		var item string
		if !isIndex {
			item = "columns"
		} else {
			item = "index"
			if len(histIDs) > 0 {
				item += " " + globalTableInfo.FindIndexNameByID(histIDs[0])
			}
		}

		logutil.BgLogger().Warn("missing partition stats when merging global stats", zap.String("table", globalTableInfo.Name.L),
			zap.String("item", item), zap.Strings("missing", globalStats.MissingPartitionStats))
	}
	return
}

// analyzeOptionDefault saves the default values of NumBuckets and NumTopN.
// These values will be used in dynamic mode when we drop table partition and then need to merge global-stats.
// These values originally came from the analyzeOptionDefault structure in the planner/core/planbuilder.go file.
var analyzeOptionDefault = map[ast.AnalyzeOptionType]uint64{
	ast.AnalyzeOptNumBuckets: 256,
	ast.AnalyzeOptNumTopN:    20,
}

// UpdateGlobalStats update the global-level stats based on the partition-level stats.
func UpdateGlobalStats(
	sctx sessionctx.Context,
	tblInfo *model.TableInfo,
	gpool *gp.Pool,
	tableStatsFromStorage tableStatsFromStorageFunc,
	getTableByPhysicalIDFn getTableByPhysicalIDFunc,
	callWithSCtxFunc callWithSCtxFunc,
	saveStatsToStorage saveStatsToStorageFunc) error {
	tableID := tblInfo.ID
	is := sessiontxn.GetTxnManager(sctx).GetTxnInfoSchema()
	globalStats, err := tableStatsFromStorage(tblInfo, tableID, true, 0)
	if err != nil {
		return err
	}
	// If we do not currently have global-stats, no new global-stats will be generated.
	if globalStats == nil {
		return nil
	}
	opts := make(map[ast.AnalyzeOptionType]uint64, len(analyzeOptionDefault))
	for key, val := range analyzeOptionDefault {
		opts[key] = val
	}
	// Use current global-stats related information to construct the opts for `MergePartitionStats2GlobalStats` function.
	globalColStatsTopNNum, globalColStatsBucketNum := 0, 0
	for colID := range globalStats.Columns {
		globalColStatsTopN := globalStats.Columns[colID].TopN
		if globalColStatsTopN != nil && len(globalColStatsTopN.TopN) > globalColStatsTopNNum {
			globalColStatsTopNNum = len(globalColStatsTopN.TopN)
		}
		globalColStats := globalStats.Columns[colID]
		if globalColStats != nil && len(globalColStats.Buckets) > globalColStatsBucketNum {
			globalColStatsBucketNum = len(globalColStats.Buckets)
		}
	}
	if globalColStatsTopNNum != 0 {
		opts[ast.AnalyzeOptNumTopN] = uint64(globalColStatsTopNNum)
	}
	if globalColStatsBucketNum != 0 {
		opts[ast.AnalyzeOptNumBuckets] = uint64(globalColStatsBucketNum)
	}
	// Generate the new column global-stats
	newColGlobalStats, err := MergePartitionStats2GlobalStats(sctx, gpool, opts, is, tblInfo, false, nil, getTableByPhysicalIDFn, callWithSCtxFunc)
	if err != nil {
		return err
	}
	if len(newColGlobalStats.MissingPartitionStats) > 0 {
		logutil.BgLogger().Warn("missing partition stats when merging global stats", zap.String("table", tblInfo.Name.L),
			zap.String("item", "columns"), zap.Strings("missing", newColGlobalStats.MissingPartitionStats))
	}
	for i := 0; i < newColGlobalStats.Num; i++ {
		hg, cms, topN := newColGlobalStats.Hg[i], newColGlobalStats.Cms[i], newColGlobalStats.TopN[i]
		if hg == nil {
			// All partitions have no stats so global stats are not created.
			continue
		}
		// fms for global stats doesn't need to dump to kv.
		err = saveStatsToStorage(tableID, newColGlobalStats.Count, newColGlobalStats.ModifyCount,
			0, hg, cms, topN, 2, 1, false, util.StatsMetaHistorySourceSchemaChange)
		if err != nil {
			return err
		}
	}

	// Generate the new index global-stats
	globalIdxStatsTopNNum, globalIdxStatsBucketNum := 0, 0
	for _, idx := range tblInfo.Indices {
		globalIdxStatsTopN := globalStats.Indices[idx.ID].TopN
		if globalIdxStatsTopN != nil && len(globalIdxStatsTopN.TopN) > globalIdxStatsTopNNum {
			globalIdxStatsTopNNum = len(globalIdxStatsTopN.TopN)
		}
		globalIdxStats := globalStats.Indices[idx.ID]
		if globalIdxStats != nil && len(globalIdxStats.Buckets) > globalIdxStatsBucketNum {
			globalIdxStatsBucketNum = len(globalIdxStats.Buckets)
		}
		if globalIdxStatsTopNNum != 0 {
			opts[ast.AnalyzeOptNumTopN] = uint64(globalIdxStatsTopNNum)
		}
		if globalIdxStatsBucketNum != 0 {
			opts[ast.AnalyzeOptNumBuckets] = uint64(globalIdxStatsBucketNum)
		}
		newIndexGlobalStats, err := MergePartitionStats2GlobalStats(sctx, gpool, opts, is, tblInfo, true, []int64{idx.ID}, getTableByPhysicalIDFn, callWithSCtxFunc)
		if err != nil {
			return err
		}
		if len(newIndexGlobalStats.MissingPartitionStats) > 0 {
			logutil.BgLogger().Warn("missing partition stats when merging global stats", zap.String("table", tblInfo.Name.L),
				zap.String("item", "index "+idx.Name.L), zap.Strings("missing", newIndexGlobalStats.MissingPartitionStats))
		}
		for i := 0; i < newIndexGlobalStats.Num; i++ {
			hg, cms, topN := newIndexGlobalStats.Hg[i], newIndexGlobalStats.Cms[i], newIndexGlobalStats.TopN[i]
			if hg == nil {
				// All partitions have no stats so global stats are not created.
				continue
			}
			// fms for global stats doesn't need to dump to kv.
			err = saveStatsToStorage(tableID, newIndexGlobalStats.Count, newIndexGlobalStats.ModifyCount, 1, hg, cms, topN, 2, 1, false, util.StatsMetaHistorySourceSchemaChange)
			if err != nil {
				return err
			}
		}
	}
	return nil
}
