// Copyright 2025 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bindinfo

import (
	"container/list"
	"fmt"
	"sort"
	"strings"

	"github.com/pingcap/tidb/pkg/parser"
	"github.com/pingcap/tidb/pkg/parser/ast"
	"github.com/pingcap/tidb/pkg/planner/util/fixcontrol"
	"github.com/pingcap/tidb/pkg/sessionctx"
	"github.com/pingcap/tidb/pkg/sessionctx/vardef"
	"github.com/pingcap/tidb/pkg/util"
	"github.com/pingcap/tidb/pkg/util/hint"
)

// PlanGenerator is used to generate new Plan Candidates for this specified query.
type PlanGenerator interface {
	Generate(defaultSchema, sql, charset, collation string) (plans []*BindingPlanInfo, err error)
}

// planGenerator implements PlanGenerator.
// It generates new plans via adjusting the optimizer variables and fixes.
type planGenerator struct {
	sPool util.DestroyableSessionPool
}

// Generate generates new plans for the given SQL statement.
func (g *planGenerator) Generate(defaultSchema, sql, charset, collation string) (plans []*BindingPlanInfo, err error) {
	// TODO: only support SQL starting with SELECT for now, support other types of SQLs later.
	// TODO: make this check more strict.
	sql = strings.TrimSpace(sql)
	prefix := "SELECT"
	if len(sql) < len(prefix) || strings.ToUpper(sql[:len(prefix)]) != prefix {
		return nil, nil // not a SELECT statement
	}

	err = callWithSCtx(g.sPool, false, func(sctx sessionctx.Context) error {
		genedPlans, err := generatePlanWithSCtx(sctx, defaultSchema, sql, charset, collation)
		if err != nil {
			return err
		}
		plans = make([]*BindingPlanInfo, 0, len(genedPlans))

		for _, genedPlan := range genedPlans {
			// TODO: construct bindingSQL in a more strict way.
			bindingSQL := sql[:len(prefix)] + " /*+ " + genedPlan.planHints + " */ " + sql[len(prefix):]
			binding := &Binding{
				OriginalSQL: sql,
				BindSQL:     bindingSQL,
				Db:          defaultSchema,
				Source:      "generated",
				PlanDigest:  genedPlan.planDigest,
			}
			if err := prepareHints(sctx, binding); err != nil {
				return err
			}
			plan := &BindingPlanInfo{
				Binding: binding,
				Plan:    genedPlan.PlanText(),
			}
			plans = append(plans, plan)
		}
		return nil
	})
	return
}

type tableName struct {
	schema string
	name   string
	alias  string
}

func (t *tableName) HintName() string {
	if t.alias != "" {
		return t.alias
	}
	return t.name
}

func (t *tableName) String() string {
	return fmt.Sprintf("%s.%s", t.schema, t.HintName())
}

type indexHint struct {
	table *tableName
	index string
}

func (h *indexHint) String() string {
	return fmt.Sprintf("%s:%s", h.table.String(), h.index)
}

// genedPlan represents a plan generated by planGenerator.
type genedPlan struct {
	planDigest string     // digest of this plan
	planHints  string     // a set of hints to reproduce this plan
	planText   [][]string // human-readable plan text
}

func (gp *genedPlan) PlanText() string {
	sb := new(strings.Builder)
	for i, row := range gp.planText {
		if i > 0 {
			sb.WriteString("\n")
		}
		for j, col := range row {
			if j > 0 {
				sb.WriteString("\t")
			}
			sb.WriteString(col)
		}
	}
	return sb.String()
}

// state represents a state of the optimizer variables and fixes.
type state struct {
	leading2   [2]*tableName // leading-2 table names
	indexHints []*indexHint  // optional index hints per table
	varNames   []string      // relevant variables and their values to generate a certain plan
	varValues  []any
	fixIDs     []uint64 // relevant fixes and their values to generate a certain plan
	fixValues  []string
}

// Encode encodes the state into a string.
func (s *state) Encode() string {
	sb := new(strings.Builder)
	for _, t := range s.leading2 {
		if t == nil {
			continue
		}
		if sb.Len() > 0 {
			sb.WriteString(",")
		}
		sb.WriteString(t.String())
	}
	for _, indexHint := range s.indexHints {
		if indexHint == nil {
			continue
		}
		if sb.Len() > 0 {
			sb.WriteString(",")
		}
		sb.WriteString(indexHint.String())
	}
	for _, v := range s.varValues {
		if sb.Len() > 0 {
			sb.WriteString(",")
		}
		if _, isFloat := v.(float64); isFloat {
			// only consider 4 decimal digits, which should be enough for optimizer tuning.
			fmt.Fprintf(sb, "%.4f", v)
			continue
		}
		fmt.Fprintf(sb, "%v", v)
	}
	for _, v := range s.fixValues {
		if sb.Len() > 0 {
			sb.WriteString(",")
		}
		sb.WriteString(v)
	}
	return sb.String()
}

func newStateWithLeading2(old *state, leading2 [2]*tableName) *state {
	newState := &state{
		leading2:   leading2,
		indexHints: append([]*indexHint(nil), old.indexHints...),
		varNames:   old.varNames,
		varValues:  old.varValues,
		fixIDs:     old.fixIDs,
		fixValues:  old.fixValues,
	}
	return newState
}

func newStateWithIndexHint(old *state, tableIdx int, hint *indexHint) *state {
	newHints := append([]*indexHint(nil), old.indexHints...)
	if tableIdx >= 0 && tableIdx < len(newHints) {
		newHints[tableIdx] = hint
	}
	return &state{
		leading2:   old.leading2,
		indexHints: newHints,
		varNames:   old.varNames,
		varValues:  old.varValues,
		fixIDs:     old.fixIDs,
		fixValues:  old.fixValues,
	}
}

func newStateWithNewVar(old *state, varName string, varVal any) *state {
	newState := &state{
		leading2:   old.leading2,
		indexHints: append([]*indexHint(nil), old.indexHints...),
		varNames:   old.varNames,
		varValues:  make([]any, len(old.varValues)),
		fixIDs:     old.fixIDs,
		fixValues:  old.fixValues,
	}
	copy(newState.varValues, old.varValues)
	for i := range newState.varNames {
		if newState.varNames[i] == varName {
			newState.varValues[i] = varVal
			break
		}
	}
	return newState
}

func newStateWithNewFix(old *state, fixID uint64, fixVal string) *state {
	newState := &state{
		leading2:   old.leading2,
		indexHints: append([]*indexHint(nil), old.indexHints...),
		varNames:   old.varNames,
		varValues:  old.varValues,
		fixIDs:     old.fixIDs,
		fixValues:  make([]string, len(old.fixValues)),
	}
	copy(newState.fixValues, old.fixValues)
	for i := range newState.fixIDs {
		if newState.fixIDs[i] == fixID {
			newState.fixValues[i] = fixVal
			break
		}
	}
	return newState
}

func generatePlanWithSCtx(sctx sessionctx.Context, defaultSchema, sql, charset, collation string) (plans []*genedPlan, err error) {
	p := parser.New()
	stmt, err := p.ParseOneStmt(sql, charset, collation)
	if err != nil {
		return nil, err
	}
	sctx.GetSessionVars().CurrentDB = defaultSchema
	sctx.GetSessionVars().CostModelVersion = 2 // cost factor only works on cost-model v2
	vars, fixes, err := RecordRelevantOptVarsAndFixes(sctx, stmt)
	if err != nil {
		return nil, err
	}
	tableNames := extractSelectTableNames(defaultSchema, stmt)
	possibleLeading2 := make([][2]*tableName, 0, 8) // enumerate all possible leading-2 table pairs
	for i := range tableNames {
		for j := range tableNames {
			if i == j {
				continue
			}
			possibleLeading2 = append(possibleLeading2, [2]*tableName{tableNames[i], tableNames[j]})
		}
	}
	indexHintOptions := extractSelectIndexHints(sctx, defaultSchema, stmt)
	return breadthFirstPlanSearch(sctx, stmt, vars, fixes, possibleLeading2, indexHintOptions)
}

func breadthFirstPlanSearch(sctx sessionctx.Context, stmt ast.StmtNode,
	vars []string, fixes []uint64, possibleLeading2 [][2]*tableName, indexHintOptions [][]*indexHint) (plans []*genedPlan, err error) {
	// init BFS structures
	visitedStates := make(map[string]struct{})  // map[encodedState]struct{}, all visited states
	visitedPlans := make(map[string]*genedPlan) // map[planDigest]plan, all visited plans
	stateList := list.New()                     // states in queue to explore

	// init the start state and push it into the BFS list
	// start state: no specified leading hint + default values of all variables and fix-controls
	startState, err := getStartState(vars, fixes, len(indexHintOptions))
	if err != nil {
		return nil, err
	}
	visitedStates[startState.Encode()] = struct{}{}
	stateList.PushBack(startState)

	maxPlans, maxExploreState := 30, 10000
	for len(visitedPlans) < maxPlans && len(visitedStates) < maxExploreState && stateList.Len() > 0 {
		currState := stateList.Remove(stateList.Front()).(*state)
		plan, err := genPlanUnderState(sctx, stmt, currState)
		if err != nil {
			return nil, err
		}
		visitedPlans[plan.planDigest] = plan

		// in each step, adjust one variable or fix or join-order
		for _, leading2 := range possibleLeading2 {
			newState := newStateWithLeading2(currState, leading2)
			if _, ok := visitedStates[newState.Encode()]; !ok {
				visitedStates[newState.Encode()] = struct{}{}
				stateList.PushBack(newState)
			}
		}
		for tableIdx := range indexHintOptions {
			for _, indexHint := range indexHintOptions[tableIdx] {
				newState := newStateWithIndexHint(currState, tableIdx, indexHint)
				if _, ok := visitedStates[newState.Encode()]; !ok {
					visitedStates[newState.Encode()] = struct{}{}
					stateList.PushBack(newState)
				}
			}
		}
		for i := range vars {
			varName, varVal := vars[i], currState.varValues[i]
			newVarVal, err := adjustVar(varName, varVal)
			if err != nil {
				return nil, err
			}
			newState := newStateWithNewVar(currState, varName, newVarVal)
			if _, ok := visitedStates[newState.Encode()]; !ok {
				visitedStates[newState.Encode()] = struct{}{}
				stateList.PushBack(newState)
			}
		}
		for i := range fixes {
			fixID, fixVal := fixes[i], currState.fixValues[i]
			newFixVal, err := adjustFix(fixID, fixVal)
			if err != nil {
				return nil, err
			}
			newState := newStateWithNewFix(currState, fixID, newFixVal)
			if _, ok := visitedStates[newState.Encode()]; !ok {
				visitedStates[newState.Encode()] = struct{}{}
				stateList.PushBack(newState)
			}
		}
	}

	plans = make([]*genedPlan, 0, len(visitedPlans))
	for _, plan := range visitedPlans {
		plans = append(plans, plan)
	}
	sort.Slice(plans, func(i, j int) bool { // to make the result stable
		return plans[i].planDigest < plans[j].planDigest
	})
	return plans, nil
}

// genPlanUnderState returns a plan generated under the given state (vars and fix-controls).
func genPlanUnderState(sctx sessionctx.Context, stmt ast.StmtNode, state *state) (plan *genedPlan, err error) {
	for i, varName := range state.varNames {
		switch varName {
		case vardef.TiDBOptIndexScanCostFactor:
			sctx.GetSessionVars().IndexScanCostFactor = state.varValues[i].(float64)
		case vardef.TiDBOptIndexReaderCostFactor:
			sctx.GetSessionVars().IndexReaderCostFactor = state.varValues[i].(float64)
		case vardef.TiDBOptTableReaderCostFactor:
			sctx.GetSessionVars().TableReaderCostFactor = state.varValues[i].(float64)
		case vardef.TiDBOptTableFullScanCostFactor:
			sctx.GetSessionVars().TableFullScanCostFactor = state.varValues[i].(float64)
		case vardef.TiDBOptTableRangeScanCostFactor:
			sctx.GetSessionVars().TableRangeScanCostFactor = state.varValues[i].(float64)
		case vardef.TiDBOptTableRowIDScanCostFactor:
			sctx.GetSessionVars().TableRowIDScanCostFactor = state.varValues[i].(float64)
		case vardef.TiDBOptTableTiFlashScanCostFactor:
			sctx.GetSessionVars().TableTiFlashScanCostFactor = state.varValues[i].(float64)
		case vardef.TiDBOptIndexLookupCostFactor:
			sctx.GetSessionVars().IndexLookupCostFactor = state.varValues[i].(float64)
		case vardef.TiDBOptIndexMergeCostFactor:
			sctx.GetSessionVars().IndexMergeCostFactor = state.varValues[i].(float64)
		case vardef.TiDBOptSortCostFactor:
			sctx.GetSessionVars().SortCostFactor = state.varValues[i].(float64)
		case vardef.TiDBOptTopNCostFactor:
			sctx.GetSessionVars().TopNCostFactor = state.varValues[i].(float64)
		case vardef.TiDBOptLimitCostFactor:
			sctx.GetSessionVars().LimitCostFactor = state.varValues[i].(float64)
		case vardef.TiDBOptStreamAggCostFactor:
			sctx.GetSessionVars().StreamAggCostFactor = state.varValues[i].(float64)
		case vardef.TiDBOptHashAggCostFactor:
			sctx.GetSessionVars().HashAggCostFactor = state.varValues[i].(float64)
		case vardef.TiDBOptMergeJoinCostFactor:
			sctx.GetSessionVars().MergeJoinCostFactor = state.varValues[i].(float64)
		case vardef.TiDBOptHashJoinCostFactor:
			sctx.GetSessionVars().HashJoinCostFactor = state.varValues[i].(float64)
		case vardef.TiDBOptIndexJoinCostFactor:
			sctx.GetSessionVars().IndexJoinCostFactor = state.varValues[i].(float64)
		case vardef.TiDBOptOrderingIdxSelRatio:
			sctx.GetSessionVars().OptOrderingIdxSelRatio = state.varValues[i].(float64)
		case vardef.TiDBOptRiskEqSkewRatio:
			sctx.GetSessionVars().RiskEqSkewRatio = state.varValues[i].(float64)
		case vardef.TiDBOptRiskGroupNDVSkewRatio:
			sctx.GetSessionVars().RiskGroupNDVSkewRatio = state.varValues[i].(float64)
		case vardef.TiDBOptRiskRangeSkewRatio:
			sctx.GetSessionVars().RiskRangeSkewRatio = state.varValues[i].(float64)
		case vardef.TiDBOptPreferRangeScan:
			sctx.GetSessionVars().SetAllowPreferRangeScan(state.varValues[i].(bool))
		case vardef.TiDBOptEnableNoDecorrelateInSelect:
			sctx.GetSessionVars().EnableNoDecorrelateInSelect = state.varValues[i].(bool)
		case vardef.TiDBOptEnableSemiJoinRewrite:
			sctx.GetSessionVars().EnableSemiJoinRewrite = state.varValues[i].(bool)
		case vardef.TiDBOptSelectivityFactor:
			sctx.GetSessionVars().SelectivityFactor = state.varValues[i].(float64)
		default:
			return nil, fmt.Errorf("unsupported variable %s in plan generation", varName)
		}
	}

	fixControlStrBuilder := strings.Builder{}
	for i, fixID := range state.fixIDs {
		if i > 0 {
			fixControlStrBuilder.WriteString(",")
		}
		fixControlStrBuilder.WriteString(fmt.Sprintf("%v:%v", fixID, state.fixValues[i]))
	}
	fixControlMap, _, err := fixcontrol.ParseToMap(fixControlStrBuilder.String())
	if err != nil {
		return nil, err
	}
	sctx.GetSessionVars().OptimizerFixControl = fixControlMap

	if sel, isSel := stmt.(*ast.SelectStmt); isSel {
		hasIndexHint := false
		for _, indexHint := range state.indexHints {
			if indexHint != nil {
				hasIndexHint = true
				break
			}
		}
		if (state.leading2[0] != nil && state.leading2[1] != nil) || hasIndexHint {
			originalHintsLen := len(sel.TableHints)
			defer func() {
				sel.TableHints = sel.TableHints[:originalHintsLen]
			}()
			if state.leading2[0] != nil && state.leading2[1] != nil {
				leadingHint := &ast.TableOptimizerHint{
					HintName: ast.NewCIStr(hint.HintLeading),
					Tables: []ast.HintTable{
						{
							DBName:    ast.NewCIStr(state.leading2[0].schema),
							TableName: ast.NewCIStr(state.leading2[0].HintName()),
						},
						{
							DBName:    ast.NewCIStr(state.leading2[1].schema),
							TableName: ast.NewCIStr(state.leading2[1].HintName()),
						},
					},
				}
				sel.TableHints = append(sel.TableHints, leadingHint)
			}
			for _, indexHint := range state.indexHints {
				if indexHint == nil {
					continue
				}
				hintNode := &ast.TableOptimizerHint{
					HintName: ast.NewCIStr(hint.HintUseIndex),
					Tables: []ast.HintTable{
						{
							DBName:    ast.NewCIStr(indexHint.table.schema),
							TableName: ast.NewCIStr(indexHint.table.HintName()),
						},
					},
					Indexes: []ast.CIStr{ast.NewCIStr(indexHint.index)},
				}
				sel.TableHints = append(sel.TableHints, hintNode)
			}
		}
	}

	planDigest, planHints, planText, err := GenBriefPlanWithSCtx(sctx, stmt)
	if err != nil {
		return nil, err
	}
	return &genedPlan{
		planDigest: planDigest,
		planText:   planText,
		planHints:  planHints,
	}, nil
}

