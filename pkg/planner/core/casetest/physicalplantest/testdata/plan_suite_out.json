[
  {
    "Name": "TestMPPHints",
    "Cases": [
      {
        "SQL": "select /*+ MPP_1PHASE_AGG() */ a, sum(b) from t group by a, c",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, Column",
          "    └─Projection mpp[tiflash]  Column, test.t.a",
          "      └─HashAgg mpp[tiflash]  group by:Column, Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.t.a",
          "        └─Projection mpp[tiflash]  cast(test.t.b, decimal(10,0) BINARY)->Column, test.t.a->Column, test.t.c->Column",
          "          └─ExchangeReceiver mpp[tiflash]  ",
          "            └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary], [name: test.t.c, collate: binary]",
          "              └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ MPP_2PHASE_AGG() */ a, sum(b) from t group by a, c",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, Column",
          "    └─Projection mpp[tiflash]  Column, test.t.a",
          "      └─HashAgg mpp[tiflash]  group by:test.t.a, test.t.c, funcs:sum(Column)->Column, funcs:firstrow(test.t.a)->test.t.a",
          "        └─ExchangeReceiver mpp[tiflash]  ",
          "          └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary], [name: test.t.c, collate: binary]",
          "            └─HashAgg mpp[tiflash]  group by:Column, Column, funcs:sum(Column)->Column",
          "              └─Projection mpp[tiflash]  cast(test.t.b, decimal(10,0) BINARY)->Column, test.t.a->Column, test.t.c->Column",
          "                └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ shuffle_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "        └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "          └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ broadcast_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "      └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t]), MPP_1PHASE_AGG() */ a, sum(b) from t group by a, c",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, Column",
          "    └─Projection mpp[tiflash]  Column, test.t.a",
          "      └─HashAgg mpp[tiflash]  group by:Column, Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.t.a",
          "        └─Projection mpp[tiflash]  cast(test.t.b, decimal(10,0) BINARY)->Column, test.t.a->Column, test.t.c->Column",
          "          └─ExchangeReceiver mpp[tiflash]  ",
          "            └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary], [name: test.t.c, collate: binary]",
          "              └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t]), MPP_2PHASE_AGG() */ a, sum(b) from t group by a, c",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, Column",
          "    └─Projection mpp[tiflash]  Column, test.t.a",
          "      └─HashAgg mpp[tiflash]  group by:test.t.a, test.t.c, funcs:sum(Column)->Column, funcs:firstrow(test.t.a)->test.t.a",
          "        └─ExchangeReceiver mpp[tiflash]  ",
          "          └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary], [name: test.t.c, collate: binary]",
          "            └─HashAgg mpp[tiflash]  group by:Column, Column, funcs:sum(Column)->Column",
          "              └─Projection mpp[tiflash]  cast(test.t.b, decimal(10,0) BINARY)->Column, test.t.a->Column, test.t.c->Column",
          "                └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), shuffle_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "        └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "          └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), broadcast_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "      └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), shuffle_join(t1, t2), hash_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "        └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "          └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), broadcast_join(t1, t2), hash_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "      └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), shuffle_join(t1, t2), hash_join_build(t1) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "        └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "          └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), broadcast_join(t1, t2), hash_join_build(t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "      └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), broadcast_join(t1, t2), hash_join_build(t1) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "      └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), shuffle_join(t1, t2), hash_join_probe(t1) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "        └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "          └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), broadcast_join(t1, t2), hash_join_probe(t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "      └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), broadcast_join(t1, t2), hash_join_probe(t1) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "      └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), shuffle_join(t1, t2), merge_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "      └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]The MPP join hints are in conflict, and you can only specify join method hints that are currently supported by MPP mode now"
        ]
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), broadcast_join(t1, t2), merge_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "      └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]The MPP join hints are in conflict, and you can only specify join method hints that are currently supported by MPP mode now"
        ]
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), shuffle_join(t1, t2), INL_JOIN(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "      └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]The MPP join hints are in conflict, and you can only specify join method hints that are currently supported by MPP mode now"
        ]
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), broadcast_join(t1, t2), INL_JOIN(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "      └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]The MPP join hints are in conflict, and you can only specify join method hints that are currently supported by MPP mode now"
        ]
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t]), MPP_1PHASE_AGG(), hash_agg() */ a, sum(b) from t group by a, c",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, Column",
          "    └─Projection mpp[tiflash]  Column, test.t.a",
          "      └─HashAgg mpp[tiflash]  group by:Column, Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.t.a",
          "        └─Projection mpp[tiflash]  cast(test.t.b, decimal(10,0) BINARY)->Column, test.t.a->Column, test.t.c->Column",
          "          └─ExchangeReceiver mpp[tiflash]  ",
          "            └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary], [name: test.t.c, collate: binary]",
          "              └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t]), MPP_2PHASE_AGG(), stream_agg() */ a, sum(b) from t group by a, c",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, Column",
          "    └─Projection mpp[tiflash]  Column, test.t.a",
          "      └─HashAgg mpp[tiflash]  group by:test.t.a, test.t.c, funcs:sum(Column)->Column, funcs:firstrow(test.t.a)->test.t.a",
          "        └─ExchangeReceiver mpp[tiflash]  ",
          "          └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary], [name: test.t.c, collate: binary]",
          "            └─HashAgg mpp[tiflash]  group by:Column, Column, funcs:sum(Column)->Column",
          "              └─Projection mpp[tiflash]  cast(test.t.b, decimal(10,0) BINARY)->Column, test.t.a->Column, test.t.c->Column",
          "                └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t]), MPP_1PHASE_AGG(), use_index(t, idx_a) */ a, sum(b) from t where a > 1 group by a, c",
        "Plan": [
          "Projection root  test.t.a, Column",
          "└─HashAgg root  group by:test.t.a, test.t.c, funcs:sum(Column)->Column, funcs:firstrow(test.t.a)->test.t.a",
          "  └─IndexLookUp root  ",
          "    ├─IndexRangeScan(Build) cop[tikv] table:t, index:idx_a(a) range:(1,+inf], keep order:false, stats:pseudo",
          "    └─HashAgg(Probe) cop[tikv]  group by:test.t.a, test.t.c, funcs:sum(test.t.b)->Column",
          "      └─TableRowIDScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]No available path for table test.t with the store type tiflash of the hint /*+ read_from_storage */, please check the status of the table replica and variable value of tidb_isolation_read_engines(map[0:{} 1:{} 2:{}])"
        ]
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t]), MPP_1PHASE_AGG(), ignore_index(t, idx_a) */ a, sum(b) from t where a > 1 group by a, c",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, Column",
          "    └─Projection mpp[tiflash]  Column, test.t.a",
          "      └─HashAgg mpp[tiflash]  group by:Column, Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.t.a",
          "        └─Projection mpp[tiflash]  cast(test.t.b, decimal(10,0) BINARY)->Column, test.t.a->Column, test.t.c->Column",
          "          └─ExchangeReceiver mpp[tiflash]  ",
          "            └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary], [name: test.t.c, collate: binary]",
          "              └─Selection mpp[tiflash]  gt(test.t.a, 1)",
          "                └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t]), MPP_2PHASE_AGG(), force_index(t, idx_b) */ a, sum(b) from t where b < 2 group by a, c",
        "Plan": [
          "Projection root  test.t.a, Column",
          "└─HashAgg root  group by:test.t.a, test.t.c, funcs:sum(Column)->Column, funcs:firstrow(test.t.a)->test.t.a",
          "  └─IndexLookUp root  ",
          "    ├─IndexRangeScan(Build) cop[tikv] table:t, index:idx_b(b) range:[-inf,2), keep order:false, stats:pseudo",
          "    └─HashAgg(Probe) cop[tikv]  group by:test.t.a, test.t.c, funcs:sum(test.t.b)->Column",
          "      └─TableRowIDScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]No available path for table test.t with the store type tiflash of the hint /*+ read_from_storage */, please check the status of the table replica and variable value of tidb_isolation_read_engines(map[0:{} 1:{} 2:{}])"
        ]
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t]), MPP_2PHASE_AGG(), index_merge(t, idx_b, idx_a) */ a, sum(b) from t where b < 2 or a > 2 group by a, c",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, Column",
          "    └─Projection mpp[tiflash]  Column, test.t.a",
          "      └─HashAgg mpp[tiflash]  group by:test.t.a, test.t.c, funcs:sum(Column)->Column, funcs:firstrow(test.t.a)->test.t.a",
          "        └─ExchangeReceiver mpp[tiflash]  ",
          "          └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary], [name: test.t.c, collate: binary]",
          "            └─HashAgg mpp[tiflash]  group by:Column, Column, funcs:sum(Column)->Column",
          "              └─Projection mpp[tiflash]  cast(test.t.b, decimal(10,0) BINARY)->Column, test.t.a->Column, test.t.c->Column",
          "                └─Selection mpp[tiflash]  or(lt(test.t.b, 2), gt(test.t.a, 2))",
          "                  └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[parser:8061]Optimizer hint index_merge is not supported by TiDB and is ignored"
        ]
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2, t3]), shuffle_join(t1, t2, t3), straight_join() */ * from t t1, t t2, t t3 where t1.a=t2.a and t2.b=t3.b",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.b, test.t.b)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.b, collate: binary]",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.b))",
          "    │     └─TableFullScan mpp[tiflash] table:t3 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.b, collate: binary]",
          "        └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "          ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "          │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "          │   └─Selection mpp[tiflash]  not(isnull(test.t.a)), not(isnull(test.t.b))",
          "          │     └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "          └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "            └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "              └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "                └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2, t3]), shuffle_join(t1, t2, t3), leading(t3, t1) */ * from t t1, t t2, t t3 where t1.a=t2.a and t2.b=t3.b",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, test.t.b, test.t.c, test.t.a, test.t.b, test.t.c, test.t.a, test.t.b, test.t.c",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a) eq(test.t.b, test.t.b)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary], [name: test.t.b, collate: binary]",
          "      │   └─Selection mpp[tiflash]  not(isnull(test.t.a)), not(isnull(test.t.b))",
          "      │     └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "      └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "        └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary], [name: test.t.b, collate: binary]",
          "          └─HashJoin mpp[tiflash]  CARTESIAN inner join",
          "            ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "            │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "            │   └─Selection mpp[tiflash]  not(isnull(test.t.b))",
          "            │     └─TableFullScan mpp[tiflash] table:t3 keep order:false, stats:pseudo",
          "            └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "              └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]The join can not push down to the MPP side, the shuffle_join() hint is invalid"
        ]
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2, t3]), broadcast_join(t1, t2, t3), straight_join() */ * from t t2, t t1, t t3 where t1.a=t2.a and t2.b=t3.b",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.b, test.t.b)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.b))",
          "    │     └─TableFullScan mpp[tiflash] table:t3 keep order:false, stats:pseudo",
          "    └─HashJoin(Probe) mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─Selection mpp[tiflash]  not(isnull(test.t.a)), not(isnull(test.t.b))",
          "      │     └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "      └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "        └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2, t3]), broadcast_join(t1, t2, t3), leading(t2, t3) */ * from t t1, t t2, t t3 where t1.a=t2.a and t2.b=t3.b",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, test.t.b, test.t.c, test.t.a, test.t.b, test.t.c, test.t.a, test.t.b, test.t.c",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "      │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "      └─HashJoin(Probe) mpp[tiflash]  inner join, equal:[eq(test.t.b, test.t.b)]",
          "        ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "        │   └─Selection mpp[tiflash]  not(isnull(test.t.a)), not(isnull(test.t.b))",
          "        │     └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "        └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.b))",
          "          └─TableFullScan mpp[tiflash] table:t3 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ qb_name(qb, v), MPP_1PHASE_AGG(@qb) */ * from v",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, Column",
          "    └─Projection mpp[tiflash]  Column, test.t.a",
          "      └─HashAgg mpp[tiflash]  group by:Column, Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.t.a",
          "        └─Projection mpp[tiflash]  cast(test.t.b, decimal(10,0) BINARY)->Column, test.t.a->Column, test.t.c->Column",
          "          └─ExchangeReceiver mpp[tiflash]  ",
          "            └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary], [name: test.t.c, collate: binary]",
          "              └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ qb_name(qb, v), MPP_2PHASE_AGG(@qb) */ * from v",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, Column",
          "    └─Projection mpp[tiflash]  Column, test.t.a",
          "      └─HashAgg mpp[tiflash]  group by:test.t.a, test.t.c, funcs:sum(Column)->Column, funcs:firstrow(test.t.a)->test.t.a",
          "        └─ExchangeReceiver mpp[tiflash]  ",
          "          └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary], [name: test.t.c, collate: binary]",
          "            └─HashAgg mpp[tiflash]  group by:Column, Column, funcs:sum(Column)->Column",
          "              └─Projection mpp[tiflash]  cast(test.t.b, decimal(10,0) BINARY)->Column, test.t.a->Column, test.t.c->Column",
          "                └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ qb_name(qb, v1), shuffle_join(t1@qb, t2@qb) */ * from v1",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "      │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "      │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "      └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "        └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "          └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "            └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ qb_name(qb, v1), broadcast_join(t1@qb, t2@qb) */ * from v1",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "      │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "      └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "        └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "SELECT /*+ shuffle_join(t) */ * FROM t WHERE EXISTS (SELECT /*+ SEMI_JOIN_REWRITE() */ 1 FROM t t1 WHERE t1.b = t.b);",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, test.t.b, test.t.c",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.b, test.t.b)]",
          "      ├─Projection(Build) mpp[tiflash]  test.t.b",
          "      │ └─HashAgg mpp[tiflash]  group by:test.t.b, funcs:firstrow(test.t.b)->test.t.b",
          "      │   └─ExchangeReceiver mpp[tiflash]  ",
          "      │     └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.b, collate: binary]",
          "      │       └─HashAgg mpp[tiflash]  group by:test.t.b, ",
          "      │         └─Selection mpp[tiflash]  not(isnull(test.t.b))",
          "      │           └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "      └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "        └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.b, collate: binary]",
          "          └─Selection mpp[tiflash]  not(isnull(test.t.b))",
          "            └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "SELECT /*+ broadcast_join(t) */ * FROM t WHERE EXISTS (SELECT /*+ SEMI_JOIN_REWRITE() */ 1 FROM t t1 WHERE t1.b = t.b);",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, test.t.b, test.t.c",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.b, test.t.b)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─Projection mpp[tiflash]  test.t.b",
          "      │     └─HashAgg mpp[tiflash]  group by:test.t.b, funcs:firstrow(test.t.b)->test.t.b",
          "      │       └─ExchangeReceiver mpp[tiflash]  ",
          "      │         └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.b, collate: binary]",
          "      │           └─HashAgg mpp[tiflash]  group by:test.t.b, ",
          "      │             └─Selection mpp[tiflash]  not(isnull(test.t.b))",
          "      │               └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "      └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.b))",
          "        └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select * from t t1 where t1.a < (select /*+ MPP_1PHASE_AGG() */ sum(t2.a) from t t2 where t2.b = t1.b);",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, test.t.b, test.t.c",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.b, test.t.b)], other cond:lt(cast(test.t.a, decimal(10,0) BINARY), Column)",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─Projection mpp[tiflash]  Column, test.t.b",
          "      │     └─HashAgg mpp[tiflash]  group by:Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.t.b",
          "      │       └─Projection mpp[tiflash]  cast(test.t.a, decimal(10,0) BINARY)->Column, test.t.b->Column",
          "      │         └─ExchangeReceiver mpp[tiflash]  ",
          "      │           └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.b, collate: binary]",
          "      │             └─Selection mpp[tiflash]  not(isnull(test.t.b))",
          "      │               └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "      └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.b))",
          "        └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select * from t t1 where t1.a < (select /*+ MPP_2PHASE_AGG() */ sum(t2.a) from t t2 where t2.b = t1.b);",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, test.t.b, test.t.c",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.b, test.t.b)], other cond:lt(cast(test.t.a, decimal(10,0) BINARY), Column)",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─Projection mpp[tiflash]  Column, test.t.b",
          "      │     └─HashAgg mpp[tiflash]  group by:test.t.b, funcs:sum(Column)->Column, funcs:firstrow(test.t.b)->test.t.b",
          "      │       └─ExchangeReceiver mpp[tiflash]  ",
          "      │         └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.b, collate: binary]",
          "      │           └─HashAgg mpp[tiflash]  group by:Column, funcs:sum(Column)->Column",
          "      │             └─Projection mpp[tiflash]  cast(test.t.a, decimal(10,0) BINARY)->Column, test.t.b->Column",
          "      │               └─Selection mpp[tiflash]  not(isnull(test.t.b))",
          "      │                 └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "      └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.b))",
          "        └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "WITH CTE AS (SELECT /*+ MPP_1PHASE_AGG() */ count(*) as a, b FROM t WHERE t.a < 60 group by b) SELECT * FROM CTE WHERE CTE.a <18 union select * from cte where cte.b > 1;",
        "Plan": [
          "HashAgg root  group by:Column, Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column",
          "└─Union root  ",
          "  ├─Selection root  lt(Column, 18)",
          "  │ └─CTEFullScan root CTE:cte data:CTE_0",
          "  └─Selection root  gt(test.t.b, 1)",
          "    └─CTEFullScan root CTE:cte data:CTE_0",
          "CTE_0 root  Non-Recursive CTE",
          "└─TableReader(Seed Part) root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─Selection mpp[tiflash]  or(lt(Column, 18), gt(test.t.b, 1))",
          "      └─Projection mpp[tiflash]  Column, test.t.b",
          "        └─HashAgg mpp[tiflash]  group by:test.t.b, funcs:count(1)->Column, funcs:firstrow(test.t.b)->test.t.b",
          "          └─ExchangeReceiver mpp[tiflash]  ",
          "            └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.b, collate: binary]",
          "              └─Selection mpp[tiflash]  lt(test.t.a, 60)",
          "                └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "WITH CTE AS (SELECT /*+ MPP_2PHASE_AGG() */ count(*) as a, b FROM t WHERE t.a < 60 group by b) SELECT * FROM CTE WHERE CTE.a <18 union select * from cte where cte.b > 1;",
        "Plan": [
          "HashAgg root  group by:Column, Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column",
          "└─Union root  ",
          "  ├─Selection root  lt(Column, 18)",
          "  │ └─CTEFullScan root CTE:cte data:CTE_0",
          "  └─Selection root  gt(test.t.b, 1)",
          "    └─CTEFullScan root CTE:cte data:CTE_0",
          "CTE_0 root  Non-Recursive CTE",
          "└─TableReader(Seed Part) root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─Selection mpp[tiflash]  or(lt(Column, 18), gt(test.t.b, 1))",
          "      └─Projection mpp[tiflash]  Column, test.t.b",
          "        └─HashAgg mpp[tiflash]  group by:test.t.b, funcs:sum(Column)->Column, funcs:firstrow(test.t.b)->test.t.b",
          "          └─ExchangeReceiver mpp[tiflash]  ",
          "            └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.b, collate: binary]",
          "              └─HashAgg mpp[tiflash]  group by:test.t.b, funcs:count(1)->Column",
          "                └─Selection mpp[tiflash]  lt(test.t.a, 60)",
          "                  └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "WITH CTE AS (SELECT /*+ shuffle_join(t1, t) */ t.a, t.b FROM t join t t1 where t.a = t1.a) SELECT * FROM CTE WHERE CTE.a <18 union select * from cte where cte.b > 1;",
        "Plan": [
          "HashAgg root  group by:Column, Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column",
          "└─Union root  ",
          "  ├─Selection root  lt(test.t.a, 18)",
          "  │ └─CTEFullScan root CTE:cte data:CTE_0",
          "  └─Selection root  gt(test.t.b, 1)",
          "    └─CTEFullScan root CTE:cte data:CTE_0",
          "CTE_0 root  Non-Recursive CTE",
          "└─TableReader(Seed Part) root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─Projection mpp[tiflash]  test.t.a, test.t.b",
          "      └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "        ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "        │   └─Selection mpp[tiflash]  not(isnull(test.t.a)), or(lt(test.t.a, 18), gt(test.t.b, 1))",
          "        │     └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "        └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "          └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "            └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "              └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "WITH CTE AS (SELECT /*+ broadcast_join(t1, t) */ t.a, t.b FROM t join t t1 where t.a = t1.a) SELECT * FROM CTE WHERE CTE.a <18 union select * from cte where cte.b > 1;",
        "Plan": [
          "HashAgg root  group by:Column, Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column",
          "└─Union root  ",
          "  ├─Selection root  lt(test.t.a, 18)",
          "  │ └─CTEFullScan root CTE:cte data:CTE_0",
          "  └─Selection root  gt(test.t.b, 1)",
          "    └─CTEFullScan root CTE:cte data:CTE_0",
          "CTE_0 root  Non-Recursive CTE",
          "└─TableReader(Seed Part) root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─Projection mpp[tiflash]  test.t.a, test.t.b",
          "      └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "        ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "        │   └─Selection mpp[tiflash]  not(isnull(test.t.a)), or(lt(test.t.a, 18), gt(test.t.b, 1))",
          "        │     └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "        └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "          └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "WITH CTE AS (SELECT /*+ MERGE(), MPP_1PHASE_AGG() */ count(*) as a, b FROM t WHERE t.a < 60 group by b) SELECT * FROM CTE WHERE CTE.a <18 union select * from cte where cte.b > 1;",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  Column, Column",
          "    └─HashAgg mpp[tiflash]  group by:Column, Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column",
          "      └─ExchangeReceiver mpp[tiflash]  ",
          "        └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary], [name: Column, collate: binary]",
          "          └─Union mpp[tiflash]  ",
          "            ├─Selection mpp[tiflash]  lt(Column, 18)",
          "            │ └─Projection mpp[tiflash]  Column, test.t.b",
          "            │   └─HashAgg mpp[tiflash]  group by:test.t.b, funcs:count(1)->Column, funcs:firstrow(test.t.b)->test.t.b",
          "            │     └─ExchangeReceiver mpp[tiflash]  ",
          "            │       └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.b, collate: binary]",
          "            │         └─Selection mpp[tiflash]  lt(test.t.a, 60)",
          "            │           └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "            └─Projection mpp[tiflash]  Column->Column, test.t.b->Column",
          "              └─HashAgg mpp[tiflash]  group by:test.t.b, funcs:count(1)->Column, funcs:firstrow(test.t.b)->test.t.b",
          "                └─ExchangeReceiver mpp[tiflash]  ",
          "                  └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.b, collate: binary]",
          "                    └─Selection mpp[tiflash]  gt(test.t.b, 1), lt(test.t.a, 60)",
          "                      └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "WITH CTE AS (SELECT /*+ MERGE(), MPP_2PHASE_AGG() */ count(*) as a, b FROM t WHERE t.a < 60 group by b) SELECT * FROM CTE WHERE CTE.a <18 union select * from cte where cte.b > 1;",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  Column, Column",
          "    └─HashAgg mpp[tiflash]  group by:Column, Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column",
          "      └─ExchangeReceiver mpp[tiflash]  ",
          "        └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary], [name: Column, collate: binary]",
          "          └─Union mpp[tiflash]  ",
          "            ├─Selection mpp[tiflash]  lt(Column, 18)",
          "            │ └─Projection mpp[tiflash]  Column, test.t.b",
          "            │   └─HashAgg mpp[tiflash]  group by:test.t.b, funcs:sum(Column)->Column, funcs:firstrow(test.t.b)->test.t.b",
          "            │     └─ExchangeReceiver mpp[tiflash]  ",
          "            │       └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.b, collate: binary]",
          "            │         └─HashAgg mpp[tiflash]  group by:test.t.b, funcs:count(1)->Column",
          "            │           └─Selection mpp[tiflash]  lt(test.t.a, 60)",
          "            │             └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "            └─Projection mpp[tiflash]  Column->Column, test.t.b->Column",
          "              └─HashAgg mpp[tiflash]  group by:test.t.b, funcs:sum(Column)->Column, funcs:firstrow(test.t.b)->test.t.b",
          "                └─ExchangeReceiver mpp[tiflash]  ",
          "                  └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.b, collate: binary]",
          "                    └─HashAgg mpp[tiflash]  group by:test.t.b, funcs:count(1)->Column",
          "                      └─Selection mpp[tiflash]  gt(test.t.b, 1), lt(test.t.a, 60)",
          "                        └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "WITH CTE AS (SELECT /*+ MERGE(), shuffle_join(t1, t) */ t.a, t.b FROM t join t t1 where t.a = t1.a) SELECT * FROM CTE WHERE CTE.a <18 union select * from cte where cte.b > 1;",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  Column, Column",
          "    └─HashAgg mpp[tiflash]  group by:Column, Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column",
          "      └─ExchangeReceiver mpp[tiflash]  ",
          "        └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary], [name: Column, collate: binary]",
          "          └─HashAgg mpp[tiflash]  group by:Column, Column, ",
          "            └─Union mpp[tiflash]  ",
          "              ├─Projection mpp[tiflash]  test.t.a->Column, test.t.b->Column",
          "              │ └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "              │   ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "              │   │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "              │   │   └─Selection mpp[tiflash]  lt(test.t.a, 18), not(isnull(test.t.a))",
          "              │   │     └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "              │   └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "              │     └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "              │       └─Selection mpp[tiflash]  lt(test.t.a, 18), not(isnull(test.t.a))",
          "              │         └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "              └─Projection mpp[tiflash]  test.t.a->Column, test.t.b->Column",
          "                └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "                  ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "                  │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "                  │   └─Selection mpp[tiflash]  gt(test.t.b, 1), not(isnull(test.t.a))",
          "                  │     └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "                  └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "                    └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "                      └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "                        └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "WITH CTE AS (SELECT /*+ MERGE(), broadcast_join(t1, t) */ t.a, t.b FROM t join t t1 where t.a = t1.a) SELECT * FROM CTE WHERE CTE.a <18 union select * from cte where cte.b > 1;",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  Column, Column",
          "    └─HashAgg mpp[tiflash]  group by:Column, Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column",
          "      └─ExchangeReceiver mpp[tiflash]  ",
          "        └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary], [name: Column, collate: binary]",
          "          └─HashAgg mpp[tiflash]  group by:Column, Column, ",
          "            └─Union mpp[tiflash]  ",
          "              ├─Projection mpp[tiflash]  test.t.a->Column, test.t.b->Column",
          "              │ └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "              │   ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "              │   │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "              │   │   └─Selection mpp[tiflash]  lt(test.t.a, 18), not(isnull(test.t.a))",
          "              │   │     └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "              │   └─Selection(Probe) mpp[tiflash]  lt(test.t.a, 18), not(isnull(test.t.a))",
          "              │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "              └─Projection mpp[tiflash]  test.t.a->Column, test.t.b->Column",
          "                └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "                  ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "                  │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "                  │   └─Selection mpp[tiflash]  gt(test.t.b, 1), not(isnull(test.t.a))",
          "                  │     └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "                  └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "                    └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), broadcast_join(t1, t2), hash_join_build(t2) */ * from t t1 left join t t2 on t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  left outer join, left side:TableFullScan, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "    └─TableFullScan(Probe) mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), broadcast_join(t1, t2), hash_join_build(t2), hash_join_probe(t2) */ * from t t1 left join t t2 on t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  left outer join, left side:TableFullScan, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "    └─TableFullScan(Probe) mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]Join hints are conflict, you can only specify one type of join"
        ]
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), broadcast_join(t1, t2), hash_join_build(t1) */ * from t t1 right join t t2 on t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  right outer join, left side:ExchangeReceiver, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─TableFullScan(Probe) mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), broadcast_join(t1, t2), hash_join_probe(t2) */ * from t t1 left join t t2 on t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  left outer join, left side:TableFullScan, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "    └─TableFullScan(Probe) mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]Some HASH_JOIN_BUILD and HASH_JOIN_PROBE hints cannot be utilized for MPP joins, please check the hints",
          "[planner:1815]Some HASH_JOIN_BUILD and HASH_JOIN_PROBE hints cannot be utilized for MPP joins, please check the hints"
        ]
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), broadcast_join(t1, t2), hash_join_probe(t1) */ * from t t1 right join t t2 on t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  right outer join, left side:ExchangeReceiver, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─TableFullScan(Probe) mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]Some HASH_JOIN_BUILD and HASH_JOIN_PROBE hints cannot be utilized for MPP joins, please check the hints",
          "[planner:1815]Some HASH_JOIN_BUILD and HASH_JOIN_PROBE hints cannot be utilized for MPP joins, please check the hints"
        ]
      },
      {
        "SQL": "set @@session.tidb_opt_mpp_outer_join_fixed_build_side = 1",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), shuffle_join(t1, t2), hash_join_build(t2) */ * from t t1 left join t t2 on t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  left outer join, left side:ExchangeReceiver, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "        └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), shuffle_join(t1, t2), hash_join_build(t1) */ * from t t1 right join t t2 on t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  right outer join, left side:ExchangeReceiver, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "        └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), shuffle_join(t1, t2), hash_join_probe(t2) */ * from t t1 left join t t2 on t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  left outer join, left side:ExchangeReceiver, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "    │   └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "        └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "          └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), shuffle_join(t1, t2), hash_join_probe(t1) */ * from t t1 right join t t2 on t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  right outer join, left side:ExchangeReceiver, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "    │   └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "        └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "          └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "set @@session.tidb_opt_mpp_outer_join_fixed_build_side = 0",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), shuffle_join(t1, t2), hash_join_build(t2) */ * from t t1 left join t t2 on t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  left outer join, left side:ExchangeReceiver, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "        └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), shuffle_join(t1, t2), hash_join_build(t1) */ * from t t1 right join t t2 on t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  right outer join, left side:ExchangeReceiver, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "        └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), shuffle_join(t1, t2), hash_join_probe(t2) */ * from t t1 left join t t2 on t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  left outer join, left side:ExchangeReceiver, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "    │   └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "        └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "          └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]Some HASH_JOIN_BUILD and HASH_JOIN_PROBE hints cannot be utilized for MPP joins, please check the hints",
          "[planner:1815]Some HASH_JOIN_BUILD and HASH_JOIN_PROBE hints cannot be utilized for MPP joins, please check the hints"
        ]
      },
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1, t2]), shuffle_join(t1, t2), hash_join_probe(t1) */ * from t t1 right join t t2 on t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  right outer join, left side:ExchangeReceiver, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "    │   └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "        └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "          └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]Some HASH_JOIN_BUILD and HASH_JOIN_PROBE hints cannot be utilized for MPP joins, please check the hints",
          "[planner:1815]Some HASH_JOIN_BUILD and HASH_JOIN_PROBE hints cannot be utilized for MPP joins, please check the hints"
        ]
      },
      {
        "SQL": "select /*+ shuffle_join(t1, t2@sel_2), hash_join_build(t2@sel_2) */ a from t t1 where t1.a>1 or t1.a in (select a from t t2);",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a",
          "    └─Selection mpp[tiflash]  or(gt(test.t.a, 1), Column)",
          "      └─HashJoin mpp[tiflash]  CARTESIAN left outer semi join, left side:TableFullScan, other cond:eq(test.t.a, test.t.a)",
          "        ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "        │   └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "        └─TableFullScan(Probe) mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]HASH_JOIN_BUILD and HASH_JOIN_PROBE hints are not supported for left outer semi join because the build side is fixed. Please remove these hints",
          "[planner:1815]The join can not push down to the MPP side, the shuffle_join() hint is invalid"
        ]
      },
      {
        "SQL": "select /*+ shuffle_join(t1, t2@sel_2), hash_join_build(t1) */ a from t t1 where t1.a>1 or t1.a not in (select a from t t2);",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a",
          "    └─Selection mpp[tiflash]  or(gt(test.t.a, 1), Column)",
          "      └─HashJoin mpp[tiflash]  Null-aware anti left outer semi join, left side:TableFullScan, equal:[eq(test.t.a, test.t.a)]",
          "        ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "        │   └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "        └─TableFullScan(Probe) mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]Some HASH_JOIN_BUILD and HASH_JOIN_PROBE hints cannot be utilized for MPP joins, please check the hints",
          "[planner:1815]HASH_JOIN_BUILD and HASH_JOIN_PROBE hints are not supported for anti left outer semi join because the build side is fixed. Please remove these hints",
          "[planner:1815]Some HASH_JOIN_BUILD and HASH_JOIN_PROBE hints cannot be utilized for MPP joins, please check the hints",
          "[planner:1815]The join can not push down to the MPP side, the shuffle_join() hint is invalid"
        ]
      },
      {
        "SQL": "select /*+ shuffle_join(t1, t2@sel_2), hash_join_probe(t2@sel_2) */ a from t t1 where t1.a>1 or t1.a in (select a from t t2);",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a",
          "    └─Selection mpp[tiflash]  or(gt(test.t.a, 1), Column)",
          "      └─HashJoin mpp[tiflash]  CARTESIAN left outer semi join, left side:TableFullScan, other cond:eq(test.t.a, test.t.a)",
          "        ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "        │   └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "        └─TableFullScan(Probe) mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]Some HASH_JOIN_BUILD and HASH_JOIN_PROBE hints cannot be utilized for MPP joins, please check the hints",
          "[planner:1815]HASH_JOIN_BUILD and HASH_JOIN_PROBE hints are not supported for left outer semi join because the build side is fixed. Please remove these hints",
          "[planner:1815]Some HASH_JOIN_BUILD and HASH_JOIN_PROBE hints cannot be utilized for MPP joins, please check the hints",
          "[planner:1815]The join can not push down to the MPP side, the shuffle_join() hint is invalid"
        ]
      },
      {
        "SQL": "select /*+ shuffle_join(t1, t2@sel_2), hash_join_probe(t1) */ a from t t1 where t1.a>1 or t1.a not in (select a from t t2);",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a",
          "    └─Selection mpp[tiflash]  or(gt(test.t.a, 1), Column)",
          "      └─HashJoin mpp[tiflash]  Null-aware anti left outer semi join, left side:TableFullScan, equal:[eq(test.t.a, test.t.a)]",
          "        ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "        │   └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "        └─TableFullScan(Probe) mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]HASH_JOIN_BUILD and HASH_JOIN_PROBE hints are not supported for anti left outer semi join because the build side is fixed. Please remove these hints",
          "[planner:1815]The join can not push down to the MPP side, the shuffle_join() hint is invalid"
        ]
      }
    ]
  },
  {
    "Name": "TestMPPHintsScope",
    "Cases": [
      {
        "SQL": "set @@session.tidb_allow_mpp=true",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ MPP_1PHASE_AGG() */ a, sum(b) from t group by a, c",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, Column",
          "    └─Projection mpp[tiflash]  Column, test.t.a",
          "      └─HashAgg mpp[tiflash]  group by:Column, Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.t.a",
          "        └─Projection mpp[tiflash]  cast(test.t.b, decimal(10,0) BINARY)->Column, test.t.a->Column, test.t.c->Column",
          "          └─ExchangeReceiver mpp[tiflash]  ",
          "            └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary], [name: test.t.c, collate: binary]",
          "              └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ MPP_2PHASE_AGG() */ a, sum(b) from t group by a, c",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, Column",
          "    └─Projection mpp[tiflash]  Column, test.t.a",
          "      └─HashAgg mpp[tiflash]  group by:test.t.a, test.t.c, funcs:sum(Column)->Column, funcs:firstrow(test.t.a)->test.t.a",
          "        └─ExchangeReceiver mpp[tiflash]  ",
          "          └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary], [name: test.t.c, collate: binary]",
          "            └─HashAgg mpp[tiflash]  group by:Column, Column, funcs:sum(Column)->Column",
          "              └─Projection mpp[tiflash]  cast(test.t.b, decimal(10,0) BINARY)->Column, test.t.a->Column, test.t.c->Column",
          "                └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ shuffle_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "        └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "          └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ broadcast_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "      └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "set @@session.tidb_enforce_mpp=true",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ hash_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "      └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ merge_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "MergeJoin root  inner join, left key:test.t.a, right key:test.t.a",
          "├─Sort(Build) root  test.t.a",
          "│ └─TableReader root  MppVersion: 3, data:ExchangeSender",
          "│   └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "│     └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "│       └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "└─Sort(Probe) root  test.t.a",
          "  └─TableReader root  MppVersion: 3, data:ExchangeSender",
          "    └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "      └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "        └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "MPP mode may be blocked because you have used hint to specify a join algorithm which is not supported by mpp now.",
          "MPP mode may be blocked because you have used hint to specify a join algorithm which is not supported by mpp now."
        ]
      },
      {
        "SQL": "set @@session.tidb_enforce_mpp=false",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ hash_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "      └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ merge_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "MergeJoin root  inner join, left key:test.t.a, right key:test.t.a",
          "├─Sort(Build) root  test.t.a",
          "│ └─TableReader root  MppVersion: 3, data:ExchangeSender",
          "│   └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "│     └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "│       └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "└─Sort(Probe) root  test.t.a",
          "  └─TableReader root  MppVersion: 3, data:ExchangeSender",
          "    └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "      └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "        └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tiflash[t1, t2]) hash_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "      └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tiflash[t1, t2]) merge_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "MergeJoin root  inner join, left key:test.t.a, right key:test.t.a",
          "├─Sort(Build) root  test.t.a",
          "│ └─TableReader root  MppVersion: 3, data:ExchangeSender",
          "│   └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "│     └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "│       └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "└─Sort(Probe) root  test.t.a",
          "  └─TableReader root  MppVersion: 3, data:ExchangeSender",
          "    └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "      └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "        └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "set @@session.tidb_allow_mpp=false",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ MPP_1PHASE_AGG() */ a, sum(b) from t group by a, c",
        "Plan": [
          "Projection root  test.t.a, Column",
          "└─HashAgg root  group by:test.t.a, test.t.c, funcs:sum(Column)->Column, funcs:firstrow(test.t.a)->test.t.a",
          "  └─TableReader root  data:HashAgg",
          "    └─HashAgg cop[tikv]  group by:test.t.a, test.t.c, funcs:sum(test.t.b)->Column",
          "      └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]The agg can not push down to the MPP side, the MPP_1PHASE_AGG() hint is invalid"
        ]
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ MPP_2PHASE_AGG() */ a, sum(b) from t group by a, c",
        "Plan": [
          "Projection root  test.t.a, Column",
          "└─HashAgg root  group by:test.t.a, test.t.c, funcs:sum(Column)->Column, funcs:firstrow(test.t.a)->test.t.a",
          "  └─TableReader root  data:HashAgg",
          "    └─HashAgg cop[tikv]  group by:test.t.a, test.t.c, funcs:sum(test.t.b)->Column",
          "      └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]The agg can not push down to the MPP side, the MPP_2PHASE_AGG() hint is invalid"
        ]
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ shuffle_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, test.t.a)]",
          "├─TableReader(Build) root  data:Selection",
          "│ └─Selection cop[tikv]  not(isnull(test.t.a))",
          "│   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  data:Selection",
          "  └─Selection cop[tikv]  not(isnull(test.t.a))",
          "    └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]The join can not push down to the MPP side, the shuffle_join() hint is invalid",
          "[planner:1815]The join can not push down to the MPP side, the shuffle_join() hint is invalid"
        ]
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ broadcast_join(t1, t2) */ * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, test.t.a)]",
          "├─TableReader(Build) root  data:Selection",
          "│ └─Selection cop[tikv]  not(isnull(test.t.a))",
          "│   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  data:Selection",
          "  └─Selection cop[tikv]  not(isnull(test.t.a))",
          "    └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]The join can not push down to the MPP side, the broadcast_join() hint is invalid",
          "[planner:1815]The join can not push down to the MPP side, the broadcast_join() hint is invalid"
        ]
      }
    ]
  },
  {
    "Name": "TestMPPBCJModel",
    "Cases": [
      {
        "SQL": "set @@session.tidb_allow_mpp=true",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "set @@session.tidb_prefer_broadcast_join_by_exchange_data_size=0",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "      └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "set @@session.tidb_prefer_broadcast_join_by_exchange_data_size=1",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "        └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "          └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      }
    ]
  },
  {
    "Name": "TestMPPPreferBCJ",
    "Cases": [
      {
        "SQL": "explain format = 'plan_tree' select * from t1, t2 where t1.a=t2.b",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t1.a, test.t2.b)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t1.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t2.b))",
          "      └─TableFullScan mpp[tiflash] table:t2 keep order:false"
        ],
        "Warn": null
      },
      {
        "SQL": "set @@session.tidb_prefer_broadcast_join_by_exchange_data_size=1",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select * from t1, t2 where t1.a=t2.b",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t1.a, test.t2.b)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t1.a, collate: binary]",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t1.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t2.b, collate: binary]",
          "        └─Selection mpp[tiflash]  not(isnull(test.t2.b))",
          "          └─TableFullScan mpp[tiflash] table:t2 keep order:false"
        ],
        "Warn": null
      },
      {
        "SQL": "insert into t2 values (9); analyze table t2;",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select * from t1, t2 where t1.a=t2.b",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t1.a, test.t2.b)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t1.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t2.b))",
          "      └─TableFullScan mpp[tiflash] table:t2 keep order:false"
        ],
        "Warn": null
      }
    ]
  },
  {
    "Name": "TestMPPBCJModelOneTiFlash",
    "Cases": [
      {
        "SQL": "set @@session.tidb_allow_mpp=true",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "set @@session.tidb_prefer_broadcast_join_by_exchange_data_size=0",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "        └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "          └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "set @@session.tidb_prefer_broadcast_join_by_exchange_data_size=1",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select * from t t1, t t2 where t1.a=t2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t.a))",
          "      └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      }
    ]
  },
  {
    "Name": "TestMPPRightSemiJoin",
    "Cases": [
      {
        "SQL": "set @@session.tidb_allow_mpp=true",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select * from t1 where exists (select * from t2 where t1.a=t2.b)",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  semi join, left side:Selection, equal:[eq(test.t1.a, test.t2.b)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t2.b))",
          "    │     └─TableFullScan mpp[tiflash] table:t2 keep order:false",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.t1.a))",
          "      └─TableFullScan mpp[tiflash] table:t1 keep order:false"
        ],
        "Warn": null
      },
      {
        "SQL": "set @@session.tidb_prefer_broadcast_join_by_exchange_data_size=0",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "set @@session.tidb_broadcast_join_threshold_size=0",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "set @@session.tidb_broadcast_join_threshold_count=0",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select * from t1 where exists (select * from t2 where t1.a=t2.b)",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  semi join, left side:ExchangeReceiver, equal:[eq(test.t1.a, test.t2.b)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t1.a, collate: binary]",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t1.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t2.b, collate: binary]",
          "        └─Selection mpp[tiflash]  not(isnull(test.t2.b))",
          "          └─TableFullScan mpp[tiflash] table:t2 keep order:false"
        ],
        "Warn": null
      }
    ]
  },
  {
    "Name": "TestMPPRightOuterJoin",
    "Cases": [
      {
        "SQL": "set @@session.tidb_allow_mpp=true",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select * from t1 right join t2 on t1.a=t2.b and t1.c < t2.d",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  right outer join, left side:ExchangeReceiver, equal:[eq(test.t1.a, test.t2.b)], other cond:lt(test.t1.c, test.t2.d)",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t1.a)), not(isnull(test.t1.c))",
          "    │     └─TableFullScan mpp[tiflash] table:t1 keep order:false",
          "    └─TableFullScan(Probe) mpp[tiflash] table:t2 keep order:false"
        ],
        "Warn": null
      },
      {
        "SQL": "set @@session.tidb_prefer_broadcast_join_by_exchange_data_size=0",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "set @@session.tidb_broadcast_join_threshold_size=0",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "set @@session.tidb_broadcast_join_threshold_count=0",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select * from t1 right join t2 on t1.a=t2.b and t1.c < t2.d",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  right outer join, left side:ExchangeReceiver, equal:[eq(test.t1.a, test.t2.b)], other cond:lt(test.t1.c, test.t2.d)",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t2.b, collate: binary]",
          "    │   └─TableFullScan mpp[tiflash] table:t2 keep order:false",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t1.a, collate: binary]",
          "        └─Selection mpp[tiflash]  not(isnull(test.t1.a)), not(isnull(test.t1.c))",
          "          └─TableFullScan mpp[tiflash] table:t1 keep order:false"
        ],
        "Warn": null
      }
    ]
  },
  {
    "Name": "TestIssue37520",
    "Cases": [
      {
        "SQL": "select /*+ inl_join(t1@sel_2) */ a, (select b from t1 where t1.a = t2.b) from t2;",
        "Plan": [
          "IndexJoin root  left outer join, inner:TableReader, left side:TableReader, outer key:test.t2.b, inner key:test.t1.a, equal cond:eq(test.t2.b, test.t1.a)",
          "├─TableReader(Build) root  data:TableFullScan",
          "│ └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  data:TableRangeScan",
          "  └─TableRangeScan cop[tikv] table:t1 range: decided by [test.t2.b], keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ inl_join(t2) */ a, (select b from t1 where t1.a = t2.b) from t2;",
        "Plan": [
          "HashJoin root  left outer join, left side:TableReader, equal:[eq(test.t2.b, test.t1.a)]",
          "├─TableReader(Build) root  data:TableFullScan",
          "│ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  data:TableFullScan",
          "  └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]Optimizer Hint /*+ INL_JOIN(t2) */ or /*+ TIDB_INLJ(t2) */ is inapplicable"
        ]
      },
      {
        "SQL": "select /*+ inl_join(t2@sel_2) */ * from t1 where exists ( select /*+ semi_join_rewrite() */ * from t2 where t1.a = t2.a);",
        "Plan": [
          "IndexJoin root  inner join, inner:StreamAgg, outer key:test.t1.a, inner key:test.t2.a, equal cond:eq(test.t1.a, test.t2.a)",
          "├─TableReader(Build) root  data:TableFullScan",
          "│ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "└─StreamAgg(Probe) root  group by:test.t2.a, funcs:firstrow(test.t2.a)->test.t2.a",
          "  └─IndexReader root  index:Selection",
          "    └─Selection cop[tikv]  not(isnull(test.t2.a))",
          "      └─IndexRangeScan cop[tikv] table:t2, index:ia(a) range: decided by [eq(test.t2.a, test.t1.a)], keep order:true, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ inl_join(t1) */ * from t1 where exists ( select /*+ semi_join_rewrite() */ * from t2 where t1.a = t2.a);",
        "Plan": [
          "IndexJoin root  inner join, inner:TableReader, outer key:test.t2.a, inner key:test.t1.a, equal cond:eq(test.t2.a, test.t1.a)",
          "├─StreamAgg(Build) root  group by:test.t2.a, funcs:firstrow(test.t2.a)->test.t2.a",
          "│ └─IndexReader root  index:StreamAgg",
          "│   └─StreamAgg cop[tikv]  group by:test.t2.a, ",
          "│     └─IndexFullScan cop[tikv] table:t2, index:ia(a) keep order:true, stats:pseudo",
          "└─TableReader(Probe) root  data:TableRangeScan",
          "  └─TableRangeScan cop[tikv] table:t1 range: decided by [test.t2.a], keep order:false, stats:pseudo"
        ],
        "Warn": null
      }
    ]
  },
  {
    "Name": "TestHintScope",
    "Cases": [
      {
        "SQL": "select /*+ MERGE_JOIN(t1) */ t1.a, t1.b from t t1, (select /*+ INL_JOIN(t3) */ t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Best": "MergeInnerJoin{TableReader(Table(t))->IndexJoin{TableReader(Table(t))->IndexReader(Index(t.c_d_e)[[NULL,NULL]])}(test.t.a,test.t.c)}(test.t.a,test.t.a)"
      },
      {
        "SQL": "select /*+ MERGE_JOIN(test.t1) */ t1.a, t1.b from t t1, (select /*+ INL_JOIN(test.t3) */ t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Best": "MergeInnerJoin{TableReader(Table(t))->IndexJoin{TableReader(Table(t))->IndexReader(Index(t.c_d_e)[[NULL,NULL]])}(test.t.a,test.t.c)}(test.t.a,test.t.a)"
      },
      {
        "SQL": "select /*+ MERGE_JOIN(t1) */ t1.a, t1.b from t t1, (select /*+ HASH_JOIN(t2) */ t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Best": "MergeInnerJoin{TableReader(Table(t))->LeftHashJoin{IndexReader(Index(t.f)[[NULL,+inf]])->IndexReader(Index(t.c_d_e)[[NULL,+inf]])}(test.t.a,test.t.c)->Sort}(test.t.a,test.t.a)"
      },
      {
        "SQL": "select /*+ INL_JOIN(t1) */ t1.a, t1.b from t t1, (select /*+ HASH_JOIN(t2) */ t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Best": "IndexJoin{TableReader(Table(t))->LeftHashJoin{IndexReader(Index(t.f)[[NULL,+inf]])->IndexReader(Index(t.c_d_e)[[NULL,+inf]])}(test.t.a,test.t.c)}(test.t.a,test.t.a)"
      },
      {
        "SQL": "select /*+ INL_JOIN(test.t1) */ t1.a, t1.b from t t1, (select /*+ HASH_JOIN(test.t2) */ t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Best": "IndexJoin{TableReader(Table(t))->LeftHashJoin{IndexReader(Index(t.f)[[NULL,+inf]])->IndexReader(Index(t.c_d_e)[[NULL,+inf]])}(test.t.a,test.t.c)}(test.t.a,test.t.a)"
      },
      {
        "SQL": "select /*+ INL_JOIN(t1) */ t1.a, t1.b from t t1, (select /*+ MERGE_JOIN(t2) */ t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Best": "IndexJoin{TableReader(Table(t))->MergeInnerJoin{TableReader(Table(t))->IndexReader(Index(t.c_d_e)[[NULL,+inf]])}(test.t.a,test.t.c)}(test.t.a,test.t.a)"
      },
      {
        "SQL": "select /*+ HASH_JOIN(t1) */ t1.a, t1.b from t t1, (select /*+ MERGE_JOIN(t2) */ t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Best": "RightHashJoin{TableReader(Table(t))->MergeInnerJoin{TableReader(Table(t))->IndexReader(Index(t.c_d_e)[[NULL,+inf]])}(test.t.a,test.t.c)}(test.t.a,test.t.a)"
      },
      {
        "SQL": "select /*+ HASH_JOIN(test.t1) */ t1.a, t1.b from t t1, (select /*+ MERGE_JOIN(test.t2) */ t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Best": "RightHashJoin{TableReader(Table(t))->MergeInnerJoin{TableReader(Table(t))->IndexReader(Index(t.c_d_e)[[NULL,+inf]])}(test.t.a,test.t.c)}(test.t.a,test.t.a)"
      },
      {
        "SQL": "select /*+ HASH_JOIN(t1) */ t1.a, t1.b from t t1, (select /*+ INL_JOIN(t2) */ t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Best": "RightHashJoin{TableReader(Table(t))->IndexJoin{TableReader(Table(t))->IndexReader(Index(t.c_d_e)[[NULL,+inf]])}(test.t.c,test.t.a)}(test.t.a,test.t.a)"
      },
      {
        "SQL": "select /*+ MERGE_JOIN(t1) */ t1.a, t1.b from t t1, (select t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Best": "MergeInnerJoin{TableReader(Table(t))->MergeInnerJoin{TableReader(Table(t))->IndexReader(Index(t.c_d_e)[[NULL,+inf]])}(test.t.a,test.t.c)}(test.t.a,test.t.a)"
      },
      {
        "SQL": "select /*+ INL_JOIN(t1) */ t1.a, t1.b from t t1, (select t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Best": "IndexJoin{TableReader(Table(t))->MergeInnerJoin{TableReader(Table(t))->IndexReader(Index(t.c_d_e)[[NULL,+inf]])}(test.t.a,test.t.c)}(test.t.a,test.t.a)"
      },
      {
        "SQL": "select /*+ HASH_JOIN(t1) */ t1.a, t1.b from t t1, (select t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Best": "RightHashJoin{TableReader(Table(t))->MergeInnerJoin{TableReader(Table(t))->IndexReader(Index(t.c_d_e)[[NULL,+inf]])}(test.t.a,test.t.c)}(test.t.a,test.t.a)"
      },
      {
        "SQL": "select /*+ HASH_JOIN(@sel_2 t1@sel_2, t2@sel_2), MERGE_JOIN(@sel_1 t1@sel_1, t2@sel_1) */ * from (select t1.a, t1.b from t t1, t t2 where t1.a = t2.a) t1, t t2 where t1.b = t2.b",
        "Best": "MergeInnerJoin{LeftHashJoin{TableReader(Table(t))->IndexReader(Index(t.f)[[NULL,+inf]])}(test.t.a,test.t.a)->Sort->TableReader(Table(t))->Sort}(test.t.b,test.t.b)"
      },
      {
        "SQL": "select /*+ STREAM_AGG() */ s, count(s) from (select /*+ HASH_AGG() */ sum(t1.a) as s from t t1, t t2 where t1.a = t2.b group by t1.a) p group by s",
        "Best": "LeftHashJoin{IndexReader(Index(t.f)[[NULL,+inf]])->TableReader(Table(t))}(test.t.a,test.t.b)->Projection->HashAgg->Sort->StreamAgg->Projection"
      },
      {
        "SQL": "select /*+ HASH_AGG() */ s, count(s) from (select /*+ STREAM_AGG() */ sum(t1.a) as s from t t1, t t2 where t1.a = t2.b group by t1.a) p group by s",
        "Best": "LeftHashJoin{IndexReader(Index(t.f)[[NULL,+inf]])->TableReader(Table(t))}(test.t.a,test.t.b)->Sort->Projection->StreamAgg->HashAgg->Projection"
      },
      {
        "SQL": "select /*+ HASH_AGG() */ s, count(s) from (select sum(t1.a) as s from t t1, t t2 where t1.a = t2.b group by t1.a) p group by s",
        "Best": "LeftHashJoin{IndexReader(Index(t.f)[[NULL,+inf]])->TableReader(Table(t))}(test.t.a,test.t.b)->Projection->HashAgg->HashAgg->Projection"
      },
      {
        "SQL": "select /*+ STREAM_AGG() */ s, count(s) from (select sum(t1.a) as s from t t1, t t2 where t1.a = t2.b group by t1.a) p group by s",
        "Best": "LeftHashJoin{IndexReader(Index(t.f)[[NULL,+inf]])->TableReader(Table(t))}(test.t.a,test.t.b)->Projection->HashAgg->Sort->StreamAgg->Projection"
      }
    ]
  },
  {
    "Name": "TestIndexHint",
    "Cases": [
      {
        "SQL": "select /*+ USE_INDEX(t, c_d_e) */ * from t",
        "Best": "IndexLookUp(Index(t.c_d_e)[[NULL,+inf]], Table(t))",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` `c_d_e`), no_order_index(@`sel_1` `test`.`t` `c_d_e`)"
      },
      {
        "SQL": "select /*+ USE_INDEX(test.t, c_d_e) */ * from t",
        "Best": "IndexLookUp(Index(t.c_d_e)[[NULL,+inf]], Table(t))",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` `c_d_e`), no_order_index(@`sel_1` `test`.`t` `c_d_e`)"
      },
      {
        "SQL": "select /*+ IGNORE_INDEX(t, c_d_e) */ c from t order by c",
        "Best": "TableReader(Table(t))->Sort",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` ), no_order_index(@`sel_1` `test`.`t` `primary`)"
      },
      {
        "SQL": "select /*+ IGNORE_INDEX(test.t, c_d_e) */ c from t order by c",
        "Best": "TableReader(Table(t))->Sort",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` ), no_order_index(@`sel_1` `test`.`t` `primary`)"
      },
      {
        "SQL": "select /*+ FORCE_INDEX(t, c_d_e) */ * from t",
        "Best": "IndexLookUp(Index(t.c_d_e)[[NULL,+inf]], Table(t))",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` `c_d_e`), no_order_index(@`sel_1` `test`.`t` `c_d_e`)"
      },
      {
        "SQL": "select /*+ FORCE_INDEX(test.t, c_d_e) */ * from t",
        "Best": "IndexLookUp(Index(t.c_d_e)[[NULL,+inf]], Table(t))",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` `c_d_e`), no_order_index(@`sel_1` `test`.`t` `c_d_e`)"
      },
      {
        "SQL": "select /*+ USE_INDEX(t, c_d_e) */ * from t t1",
        "Best": "TableReader(Table(t))",
        "HasWarn": true,
        "Hints": "use_index(@`sel_1` `test`.`t1` ), no_order_index(@`sel_1` `test`.`t1` `primary`)"
      },
      {
        "SQL": "select /*+ IGNORE_INDEX(t, c_d_e) */ t1.c from t t1 order by t1.c",
        "Best": "IndexReader(Index(t.c_d_e)[[NULL,+inf]])",
        "HasWarn": true,
        "Hints": "use_index(@`sel_1` `test`.`t1` `c_d_e`), order_index(@`sel_1` `test`.`t1` `c_d_e`)"
      },
      {
        "SQL": "select /*+ FORCE_INDEX(t, c_d_e) */ * from t t1",
        "Best": "TableReader(Table(t))",
        "HasWarn": true,
        "Hints": "use_index(@`sel_1` `test`.`t1` ), no_order_index(@`sel_1` `test`.`t1` `primary`)"
      },
      {
        "SQL": "select /*+ USE_INDEX(t1, c_d_e) */ * from t t1",
        "Best": "IndexLookUp(Index(t.c_d_e)[[NULL,+inf]], Table(t))",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t1` `c_d_e`), no_order_index(@`sel_1` `test`.`t1` `c_d_e`)"
      },
      {
        "SQL": "select /*+ IGNORE_INDEX(t1, c_d_e) */ t1.c from t t1 order by t1.c",
        "Best": "TableReader(Table(t))->Sort",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t1` ), no_order_index(@`sel_1` `test`.`t1` `primary`)"
      },
      {
        "SQL": "select /*+ FORCE_INDEX(t1, c_d_e) */ * from t t1",
        "Best": "IndexLookUp(Index(t.c_d_e)[[NULL,+inf]], Table(t))",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t1` `c_d_e`), no_order_index(@`sel_1` `test`.`t1` `c_d_e`)"
      },
      {
        "SQL": "select /*+ USE_INDEX(t1, c_d_e), USE_INDEX(t2, f) */ * from t t1, t t2 where t1.a = t2.b",
        "Best": "LeftHashJoin{IndexLookUp(Index(t.c_d_e)[[NULL,+inf]], Table(t))->IndexLookUp(Index(t.f)[[NULL,+inf]], Table(t))}(test.t.a,test.t.b)",
        "HasWarn": false,
        "Hints": "hash_join_build(`test`.`t2`), use_index(@`sel_1` `test`.`t1` `c_d_e`), no_order_index(@`sel_1` `test`.`t1` `c_d_e`), use_index(@`sel_1` `test`.`t2` `f`), no_order_index(@`sel_1` `test`.`t2` `f`)"
      },
      {
        "SQL": "select /*+ IGNORE_INDEX(t1, c_d_e), IGNORE_INDEX(t2, f), HASH_JOIN(t1) */ * from t t1, t t2 where t1.a = t2.b",
        "Best": "LeftHashJoin{TableReader(Table(t))->TableReader(Table(t))}(test.t.a,test.t.b)",
        "HasWarn": false,
        "Hints": "hash_join_build(`test`.`t2`), use_index(@`sel_1` `test`.`t1` ), no_order_index(@`sel_1` `test`.`t1` `primary`), use_index(@`sel_1` `test`.`t2` ), no_order_index(@`sel_1` `test`.`t2` `primary`)"
      },
      {
        "SQL": "select /*+ FORCE_INDEX(t1, c_d_e), FORCE_INDEX(t2, f) */ * from t t1, t t2 where t1.a = t2.b",
        "Best": "LeftHashJoin{IndexLookUp(Index(t.c_d_e)[[NULL,+inf]], Table(t))->IndexLookUp(Index(t.f)[[NULL,+inf]], Table(t))}(test.t.a,test.t.b)",
        "HasWarn": false,
        "Hints": "hash_join_build(`test`.`t2`), use_index(@`sel_1` `test`.`t1` `c_d_e`), no_order_index(@`sel_1` `test`.`t1` `c_d_e`), use_index(@`sel_1` `test`.`t2` `f`), no_order_index(@`sel_1` `test`.`t2` `f`)"
      },
      {
        "SQL": "select /*+ USE_INDEX(t, c_d_e, f, g) */ * from t order by f",
        "Best": "IndexLookUp(Index(t.f)[[NULL,+inf]], Table(t))",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` `f`), order_index(@`sel_1` `test`.`t` `f`)"
      },
      {
        "SQL": "select /*+ FORCE_INDEX(t, c_d_e, f, g) */ * from t order by f",
        "Best": "IndexLookUp(Index(t.f)[[NULL,+inf]], Table(t))",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` `f`), order_index(@`sel_1` `test`.`t` `f`)"
      },
      {
        "SQL": "select /*+ USE_INDEX(t) */ f from t where f > 10",
        "Best": "TableReader(Table(t)->Sel([gt(test.t.f, 10)]))",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` ), no_order_index(@`sel_1` `test`.`t` `primary`)"
      },
      {
        "SQL": "select /*+ FORCE_INDEX(t) */ f from t where f > 10",
        "Best": "TableReader(Table(t)->Sel([gt(test.t.f, 10)]))",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` ), no_order_index(@`sel_1` `test`.`t` `primary`)"
      },
      {
        "SQL": "select /*+ USE_INDEX(t, no_such_index) */ * from t",
        "Best": "TableReader(Table(t))",
        "HasWarn": true,
        "Hints": "use_index(@`sel_1` `test`.`t` ), no_order_index(@`sel_1` `test`.`t` `primary`)"
      },
      {
        "SQL": "select /*+ IGNORE_INDEX(t, no_such_index) */ * from t",
        "Best": "TableReader(Table(t))",
        "HasWarn": true,
        "Hints": "use_index(@`sel_1` `test`.`t` ), no_order_index(@`sel_1` `test`.`t` `primary`)"
      },
      {
        "SQL": "select /*+ FORCE_INDEX(t, no_such_index) */ * from t",
        "Best": "TableReader(Table(t))",
        "HasWarn": true,
        "Hints": "use_index(@`sel_1` `test`.`t` ), no_order_index(@`sel_1` `test`.`t` `primary`)"
      },
      {
        "SQL": "select /*+ USE_INDEX(t, c_d_e), IGNORE_INDEX(t, f) */ c from t order by c",
        "Best": "IndexReader(Index(t.c_d_e)[[NULL,+inf]])",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` `c_d_e`), order_index(@`sel_1` `test`.`t` `c_d_e`)"
      },
      {
        "SQL": "select /*+ USE_INDEX(t, f), IGNORE_INDEX(t, f) */ c from t order by c",
        "Best": "TableReader(Table(t))->Sort",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` ), no_order_index(@`sel_1` `test`.`t` `primary`)"
      },
      {
        "SQL": "select /*+ USE_INDEX(t, c_d_e), IGNORE_INDEX(t, c_d_e) */ c from t order by c",
        "Best": "TableReader(Table(t))->Sort",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` ), no_order_index(@`sel_1` `test`.`t` `primary`)"
      },
      {
        "SQL": "select /*+ USE_INDEX(t, c_d_e, f), IGNORE_INDEX(t, c_d_e) */ c from t order by c",
        "Best": "IndexLookUp(Index(t.f)[[NULL,+inf]], Table(t))->Sort",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` `f`), no_order_index(@`sel_1` `test`.`t` `f`)"
      },
      {
        "SQL": "select /*+ FORCE_INDEX(t, c_d_e), IGNORE_INDEX(t, f) */ c from t order by c",
        "Best": "IndexReader(Index(t.c_d_e)[[NULL,+inf]])",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` `c_d_e`), order_index(@`sel_1` `test`.`t` `c_d_e`)"
      },
      {
        "SQL": "select /*+ FORCE_INDEX(t, f), IGNORE_INDEX(t, f) */ c from t order by c",
        "Best": "TableReader(Table(t))->Sort",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` ), no_order_index(@`sel_1` `test`.`t` `primary`)"
      },
      {
        "SQL": "select /*+ FORCE_INDEX(t, c_d_e), IGNORE_INDEX(t, c_d_e) */ c from t order by c",
        "Best": "TableReader(Table(t))->Sort",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` ), no_order_index(@`sel_1` `test`.`t` `primary`)"
      },
      {
        "SQL": "select /*+ FORCE_INDEX(t, c_d_e, f), IGNORE_INDEX(t, c_d_e) */ c from t order by c",
        "Best": "IndexLookUp(Index(t.f)[[NULL,+inf]], Table(t))->Sort",
        "HasWarn": false,
        "Hints": "use_index(@`sel_1` `test`.`t` `f`), no_order_index(@`sel_1` `test`.`t` `f`)"
      }
    ]
  },
  {
    "Name": "TestIndexMergeHint",
    "Cases": [
      {
        "SQL": "select /*+ USE_INDEX_MERGE(t, c_d_e, f_g) */ * from t where c < 1 or f > 2",
        "Best": "IndexMergeReader(PartialPlans->[Index(t.c_d_e)[[-inf,1)], Index(t.f_g)[(2,+inf]]], TablePlan->Table(t))",
        "HasWarn": false,
        "Hints": "use_index_merge(@`sel_1` `t` `c_d_e`, `f_g`)"
      },
      {
        "SQL": "select /*+ USE_INDEX_MERGE(t, primary, f_g) */ * from t where a < 1 or f > 2",
        "Best": "IndexMergeReader(PartialPlans->[Table(t), Index(t.f_g)[(2,+inf]]], TablePlan->Table(t))",
        "HasWarn": false,
        "Hints": "use_index_merge(@`sel_1` `t` `primary`, `f_g`)"
      },
      {
        "SQL": "select /*+ USE_INDEX_MERGE(t, primary, f_g, c_d_e) */ * from t where a < 1 or f > 2",
        "Best": "IndexMergeReader(PartialPlans->[Table(t), Index(t.f_g)[(2,+inf]]], TablePlan->Table(t))",
        "HasWarn": false,
        "Hints": "use_index_merge(@`sel_1` `t` `primary`, `f_g`)"
      },
      {
        "SQL": "select /*+ NO_INDEX_MERGE(), USE_INDEX_MERGE(t, primary, f_g, c_d_e) */ * from t where a < 1 or f > 2",
        "Best": "TableReader(Table(t)->Sel([or(lt(test.t.a, 1), gt(test.t.f, 2))]))",
        "HasWarn": true,
        "Hints": "use_index(@`sel_1` `test`.`t` ), no_order_index(@`sel_1` `test`.`t` `primary`)"
      },
      {
        "SQL": "select /*+ USE_INDEX_MERGE(t1, c_d_e, f_g) */ * from t where c < 1 or f > 2",
        "Best": "IndexMergeReader(PartialPlans->[Index(t.c_d_e)[[-inf,1)], Index(t.f)[(2,+inf]]], TablePlan->Table(t))",
        "HasWarn": true,
        "Hints": "use_index_merge(@`sel_1` `t` `c_d_e`, `f`)"
      },
      {
        "SQL": "select /*+ NO_INDEX_MERGE(), USE_INDEX_MERGE(t, primary, f_g, c_d_e) */ * from t where a < 1 or f > 2",
        "Best": "TableReader(Table(t)->Sel([or(lt(test.t.a, 1), gt(test.t.f, 2))]))",
        "HasWarn": true,
        "Hints": "use_index(@`sel_1` `test`.`t` ), no_order_index(@`sel_1` `test`.`t` `primary`)"
      },
      {
        "SQL": "select /*+ USE_INDEX_MERGE(t) USE_INDEX_MERGE(t) */ * from t where c < 1 or f > 2",
        "Best": "IndexMergeReader(PartialPlans->[Index(t.c_d_e)[[-inf,1)], Index(t.f)[(2,+inf]]], TablePlan->Table(t))",
        "HasWarn": false,
        "Hints": "use_index_merge(@`sel_1` `t` `c_d_e`, `f`)"
      },
      {
        "SQL": "select /*+ USE_INDEX_MERGE(db2.t) */ * from t where c < 1 or f > 2",
        "Best": "IndexMergeReader(PartialPlans->[Index(t.c_d_e)[[-inf,1)], Index(t.f)[(2,+inf]]], TablePlan->Table(t))",
        "HasWarn": true,
        "Hints": "use_index_merge(@`sel_1` `t` `c_d_e`, `f`)"
      },
      {
        "SQL": "select /*+ USE_INDEX_MERGE(db2.t, c_d_e, f_g) */ * from t where c < 1 or f > 2",
        "Best": "IndexMergeReader(PartialPlans->[Index(t.c_d_e)[[-inf,1)], Index(t.f)[(2,+inf]]], TablePlan->Table(t))",
        "HasWarn": true,
        "Hints": "use_index_merge(@`sel_1` `t` `c_d_e`, `f`)"
      }
    ]
  },
  {
    "Name": "TestRefine",
    "Cases": [
      {
        "SQL": "select a from t where c is not null",
        "Best": "IndexReader(Index(t.f)[[NULL,+inf]])"
      },
      {
        "SQL": "select a from t where c >= 4",
        "Best": "IndexReader(Index(t.c_d_e)[[4,+inf]]->Projection)"
      },
      {
        "SQL": "select a from t where c <= 4",
        "Best": "IndexReader(Index(t.c_d_e)[[-inf,4]]->Projection)"
      },
      {
        "SQL": "select a from t where c = 4 and d = 5 and e = 6",
        "Best": "PointGet(Index(t.c_d_e)[KindInt64 4 KindInt64 5 KindInt64 6])->Projection"
      },
      {
        "SQL": "select a from t where d = 4 and c = 5",
        "Best": "IndexReader(Index(t.c_d_e)[[5 4,5 4]]->Projection)"
      },
      {
        "SQL": "select a from t where c = 4 and e < 5",
        "Best": "IndexReader(Index(t.c_d_e)[[4,4]]->Sel([lt(test.t.e, 5)])->Projection)"
      },
      {
        "SQL": "select a from t where c = 4 and d <= 5 and d > 3",
        "Best": "IndexReader(Index(t.c_d_e)[(4 3,4 5]]->Projection)"
      },
      {
        "SQL": "select a from t where d <= 5 and d > 3",
        "Best": "IndexReader(Index(t.c_d_e)[[NULL,+inf]]->Sel([le(test.t.d, 5) gt(test.t.d, 3)])->Projection)"
      },
      {
        "SQL": "select a from t where c between 1 and 2",
        "Best": "IndexReader(Index(t.c_d_e)[[1,2]]->Projection)"
      },
      {
        "SQL": "select a from t where c not between 1 and 2",
        "Best": "IndexReader(Index(t.c_d_e)[[-inf,1) (2,+inf]]->Projection)"
      },
      {
        "SQL": "select a from t where c <= 5 and c >= 3 and d = 1",
        "Best": "IndexReader(Index(t.c_d_e)[[3,5]]->Sel([eq(test.t.d, 1)])->Projection)"
      },
      {
        "SQL": "select a from t where c = 1 or c = 2 or c = 3",
        "Best": "IndexReader(Index(t.c_d_e)[[1,3]]->Projection)"
      },
      {
        "SQL": "select b from t where c = 1 or c = 2 or c = 3 or c = 4 or c = 5",
        "Best": "IndexLookUp(Index(t.c_d_e)[[1,5]], Table(t))->Projection"
      },
      {
        "SQL": "select a from t where c = 5",
        "Best": "IndexReader(Index(t.c_d_e)[[5,5]]->Projection)"
      },
      {
        "SQL": "select a from t where c = 5 and b = 1",
        "Best": "IndexLookUp(Index(t.c_d_e)[[5,5]], Table(t)->Sel([eq(test.t.b, 1)]))->Projection"
      },
      {
        "SQL": "select a from t where not a",
        "Best": "PointGet(Handle(t.a)0)"
      },
      {
        "SQL": "select a from t where c in (1)",
        "Best": "IndexReader(Index(t.c_d_e)[[1,1]]->Projection)"
      },
      {
        "SQL": "select a from t where c in ('1')",
        "Best": "IndexReader(Index(t.c_d_e)[[1,1]]->Projection)"
      },
      {
        "SQL": "select a from t where c = 1.0",
        "Best": "IndexReader(Index(t.c_d_e)[[1,1]]->Projection)"
      },
      {
        "SQL": "select a from t where c in (1) and d > 3",
        "Best": "IndexReader(Index(t.c_d_e)[(1 3,1 +inf]]->Projection)"
      },
      {
        "SQL": "select a from t where c in (1, 2, 3) and (d > 3 and d < 4 or d > 5 and d < 6)",
        "Best": "Dual->Projection"
      },
      {
        "SQL": "select a from t where c in (1, 2, 3) and (d > 2 and d < 4 or d > 5 and d < 7)",
        "Best": "IndexReader(Index(t.c_d_e)[[1 3,1 3] [1 6,1 6] [2 3,2 3] [2 6,2 6] [3 3,3 3] [3 6,3 6]]->Projection)"
      },
      {
        "SQL": "select a from t where c in (1, 2, 3)",
        "Best": "IndexReader(Index(t.c_d_e)[[1,1] [2,2] [3,3]]->Projection)"
      },
      {
        "SQL": "select a from t where c in (1, 2, 3) and d in (1,2) and e = 1",
        "Best": "BatchPointGet(Index(t.c_d_e)[[KindInt64 1 KindInt64 1 KindInt64 1] [KindInt64 1 KindInt64 2 KindInt64 1] [KindInt64 2 KindInt64 1 KindInt64 1] [KindInt64 2 KindInt64 2 KindInt64 1] [KindInt64 3 KindInt64 1 KindInt64 1] [KindInt64 3 KindInt64 2 KindInt64 1]])->Projection"
      },
      {
        "SQL": "select a from t where d in (1, 2, 3)",
        "Best": "IndexReader(Index(t.c_d_e)[[NULL,+inf]]->Sel([in(test.t.d, 1, 2, 3)])->Projection)"
      },
      {
        "SQL": "select a from t where c not in (1)",
        "Best": "IndexReader(Index(t.c_d_e)[[-inf,1) (1,+inf]]->Projection)"
      },
      {
        "SQL": "select a from t use index(c_d_e) where c != 1",
        "Best": "IndexReader(Index(t.c_d_e)[[-inf,1) (1,+inf]]->Projection)"
      },
      {
        "SQL": "select a from t where c_str like ''",
        "Best": "IndexReader(Index(t.c_d_e_str)[[\"\",\"\"]]->Sel([like(test.t.c_str, , 92)])->Projection)"
      },
      {
        "SQL": "select a from t where c_str like 'abc'",
        "Best": "IndexReader(Index(t.c_d_e_str)[[\"abc\",\"abc\"]]->Sel([like(test.t.c_str, abc, 92)])->Projection)"
      },
      {
        "SQL": "select a from t where c_str not like 'abc'",
        "Best": "IndexReader(Index(t.c_d_e_str)[[NULL,+inf]]->Sel([not(like(test.t.c_str, abc, 92))])->Projection)"
      },
      {
        "SQL": "select a from t where not (c_str like 'abc' or c_str like 'abd')",
        "Best": "IndexReader(Index(t.c_d_e_str)[[NULL,+inf]]->Sel([not(like(test.t.c_str, abc, 92)) not(like(test.t.c_str, abd, 92))])->Projection)"
      },
      {
        "SQL": "select a from t where c_str like '_abc'",
        "Best": "IndexReader(Index(t.c_d_e_str)[[NULL,+inf]]->Sel([like(test.t.c_str, _abc, 92)])->Projection)"
      },
      {
        "SQL": "select a from t where c_str like 'abc%'",
        "Best": "IndexReader(Index(t.c_d_e_str)[[\"abc\",\"abd\")]->Sel([like(test.t.c_str, abc%, 92)])->Projection)"
      },
      {
        "SQL": "select a from t where c_str like 'abc_'",
        "Best": "IndexReader(Index(t.c_d_e_str)[[\"abc\",\"abd\")]->Sel([like(test.t.c_str, abc_, 92)])->Projection)"
      },
      {
        "SQL": "select a from t where c_str like 'abc%af'",
        "Best": "IndexReader(Index(t.c_d_e_str)[[\"abc\",\"abd\")]->Sel([like(test.t.c_str, abc%af, 92)])->Projection)"
      },
      {
        "SQL": "select a from t where c_str like 'abc\\_' escape ''",
        "Best": "IndexReader(Index(t.c_d_e_str)[[\"abc_\",\"abc_\"]]->Sel([like(test.t.c_str, abc\\_, 92)])->Projection)"
      },
      {
        "SQL": "select a from t where c_str like 'abc\\_'",
        "Best": "IndexReader(Index(t.c_d_e_str)[[\"abc_\",\"abc_\"]]->Sel([like(test.t.c_str, abc\\_, 92)])->Projection)"
      },
      {
        "SQL": "select a from t where c_str like 'abc\\\\_'",
        "Best": "IndexReader(Index(t.c_d_e_str)[[\"abc_\",\"abc_\"]]->Sel([like(test.t.c_str, abc\\_, 92)])->Projection)"
      },
      {
        "SQL": "select a from t where c_str like 'abc\\_%'",
        "Best": "IndexReader(Index(t.c_d_e_str)[[\"abc_\",\"abc`\")]->Sel([like(test.t.c_str, abc\\_%, 92)])->Projection)"
      },
      {
        "SQL": "select a from t where c_str like 'abc=_%' escape '='",
        "Best": "IndexReader(Index(t.c_d_e_str)[[\"abc_\",\"abc`\")]->Sel([like(test.t.c_str, abc=_%, 61)])->Projection)"
      },
      {
        "SQL": "select a from t where c_str like 'abc\\__'",
        "Best": "IndexReader(Index(t.c_d_e_str)[[\"abc_\",\"abc`\")]->Sel([like(test.t.c_str, abc\\__, 92)])->Projection)"
      },
      {
        "SQL": "select a from t where c_str like 123",
        "Best": "IndexReader(Index(t.c_d_e_str)[[\"123\",\"123\"]]->Sel([like(test.t.c_str, 123, 92)])->Projection)"
      },
      {
        "SQL": "select a from t where c = 1.9 and d > 3",
        "Best": "Dual"
      },
      {
        "SQL": "select a from t where c < 1.1",
        "Best": "IndexReader(Index(t.c_d_e)[[-inf,2)]->Projection)"
      },
      {
        "SQL": "select a from t where c <= 1.9",
        "Best": "IndexReader(Index(t.c_d_e)[[-inf,1]]->Projection)"
      },
      {
        "SQL": "select a from t where c >= 1.1",
        "Best": "IndexReader(Index(t.c_d_e)[[2,+inf]]->Projection)"
      },
      {
        "SQL": "select a from t where c > 1.9",
        "Best": "IndexReader(Index(t.c_d_e)[(1,+inf]]->Projection)"
      },
      {
        "SQL": "select a from t where c = 123456789098765432101234",
        "Best": "Dual"
      },
      {
        "SQL": "select a from t where c = 'hanfei'",
        "Best": "IndexReader(Index(t.c_d_e)[[NULL,+inf]]->Sel([eq(cast(test.t.c, double BINARY), cast(hanfei, double BINARY))])->Projection)"
      }
    ]
  },
  {
    "Name": "TestAggEliminator",
    "Cases": [
      {
        "SQL": "select max(a) from t;",
        "Best": "TableReader(Table(t)->Limit)->Limit->StreamAgg"
      },
      {
        "SQL": "select min(a) from t;",
        "Best": "TableReader(Table(t)->Limit)->Limit->StreamAgg"
      },
      {
        "SQL": "select min(c_str) from t;",
        "Best": "IndexReader(Index(t.c_d_e_str)[[-inf,+inf]]->Limit)->Limit->StreamAgg"
      },
      {
        "SQL": "select max(a), b from t;",
        "Best": "TableReader(Table(t)->HashAgg)->HashAgg"
      },
      {
        "SQL": "select max(a+1) from t;",
        "Best": "IndexReader(Index(t.f)[[NULL,+inf]]->TopN([plus(test.t.a, 1) true],0,1))->Projection->TopN([Column#40 true],0,1)->Projection->Projection->StreamAgg"
      },
      {
        "SQL": "select max(a), min(a) from t;",
        "Best": "LeftHashJoin{TableReader(Table(t)->Limit)->Limit->StreamAgg->TableReader(Table(t)->Limit)->Limit->StreamAgg}"
      },
      {
        "SQL": "select max(a), min(a) from t where a > 10",
        "Best": "LeftHashJoin{TableReader(Table(t)->Limit)->Limit->StreamAgg->TableReader(Table(t)->Limit)->Limit->StreamAgg}"
      },
      {
        "SQL": "select max(d), min(d) from t where c = 1 and d > 10",
        "Best": "LeftHashJoin{IndexReader(Index(t.c_d_e)[(1 10,1 +inf]]->Limit)->Limit->StreamAgg->IndexReader(Index(t.c_d_e)[(1 10,1 +inf]]->Limit)->Limit->StreamAgg}"
      },
      {
        "SQL": "select max(a), max(c), min(f) from t",
        "Best": "LeftHashJoin{LeftHashJoin{TableReader(Table(t)->Limit)->Limit->StreamAgg->IndexReader(Index(t.c_d_e)[[NULL,+inf]]->Limit)->Limit->StreamAgg}->IndexReader(Index(t.f)[[NULL,+inf]]->Limit)->Limit->StreamAgg}"
      },
      {
        "SQL": "select max(a), max(b) from t",
        "Best": "TableReader(Table(t)->HashAgg)->HashAgg"
      },
      {
        "SQL": "select max(a), max(c) from t where c > 10",
        "Best": "IndexReader(Index(t.c_d_e)[(10,+inf]]->HashAgg)->HashAgg"
      },
      {
        "SQL": "select max(a), min(a) from t where a * 3 + 10 < 100",
        "Best": "IndexReader(Index(t.f)[[NULL,+inf]]->Sel([lt(plus(mul(test.t.a, 3), 10), 100)])->HashAgg)->HashAgg"
      },
      {
        "SQL": "select max(a) from t group by b;",
        "Best": "TableReader(Table(t)->HashAgg)->HashAgg"
      },
      {
        "SQL": "select max(a) from (select t1.a from t t1 join t t2 on t1.a=t2.a) t",
        "Best": "MergeInnerJoin{TableReader(Table(t))->TableReader(Table(t))}(test.t.a,test.t.a)->Limit->StreamAgg"
      }
    ]
  },
  {
    "Name": "TestRuleColumnPruningLogicalApply",
    "Cases": [
      {
        "SQL": "SELECT COUNT(*) FROM (SELECT a, (SELECT t2.b FROM t t2, t t3 WHERE t2.a = t3.a AND t1.a = t2.a LIMIT 1) t FROM t t1) t",
        "Best": "IndexReader(Index(t.f)[[NULL,+inf]]->HashAgg)->HashAgg",
        "Plan": [
          "HashAgg root  funcs:count(Column)->Column",
          "└─IndexReader root  index:HashAgg",
          "  └─HashAgg cop[tikv]  funcs:count(1)->Column",
          "    └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "SELECT COUNT(a) FROM (SELECT a, (SELECT t2.b FROM t t2, t t3 WHERE t2.a = t3.a AND t1.a = t2.a LIMIT 1) t FROM t t1) t",
        "Best": "IndexReader(Index(t.f)[[NULL,+inf]]->HashAgg)->HashAgg",
        "Plan": [
          "HashAgg root  funcs:count(Column)->Column",
          "└─IndexReader root  index:HashAgg",
          "  └─HashAgg cop[tikv]  funcs:count(test.t.a)->Column",
          "    └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "SELECT COUNT(t) FROM (SELECT a, (SELECT t2.b FROM t t2, t t3 WHERE t2.a = t3.a AND t1.a = t2.a LIMIT 1) t FROM t t1) t",
        "Best": "Apply{IndexReader(Index(t.f)[[NULL,+inf]])->IndexJoin{TableReader(Table(t)->Sel([eq(test.t.a, test.t.a)]))->TableReader(Table(t))}(test.t.a,test.t.a)->Limit}->HashAgg",
        "Plan": [
          "HashAgg root  funcs:count(test.t.b)->Column",
          "└─Apply root  CARTESIAN left outer join, left side:IndexReader",
          "  ├─IndexReader(Build) root  index:IndexFullScan",
          "  │ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo",
          "  └─Limit(Probe) root  offset:0, count:1",
          "    └─IndexHashJoin root  inner join, inner:IndexLookUp, outer key:test.t.a, inner key:test.t.a, equal cond:eq(test.t.a, test.t.a)",
          "      ├─IndexReader(Build) root  index:Selection",
          "      │ └─Selection cop[tikv]  eq(test.t.a, test.t.a)",
          "      │   └─IndexFullScan cop[tikv] table:t3, index:idx_a(a) keep order:false, stats:pseudo",
          "      └─IndexLookUp(Probe) root  ",
          "        ├─Selection(Build) cop[tikv]  eq(test.t.a, test.t.a), not(isnull(test.t.a))",
          "        │ └─IndexRangeScan cop[tikv] table:t2, index:idx_a(a) range: decided by [eq(test.t.a, test.t.a)], keep order:false, stats:pseudo",
          "        └─TableRowIDScan(Probe) cop[tikv] table:t2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "SELECT COUNT(a) FROM t t1 WHERE t1.a IN (SELECT t2.a FROM t t2, t t3 WHERE t2.b = t3.b)",
        "Best": "LeftHashJoin{IndexReader(Index(t.f)[[NULL,+inf]])->LeftHashJoin{TableReader(Table(t))->TableReader(Table(t))}(test.t.b,test.t.b)->HashAgg}(test.t.a,test.t.a)->HashAgg",
        "Plan": [
          "HashAgg root  funcs:count(test.t.a)->Column",
          "└─HashJoin root  inner join, equal:[eq(test.t.a, test.t.a)]",
          "  ├─HashAgg(Build) root  group by:test.t.a, funcs:firstrow(test.t.a)->test.t.a",
          "  │ └─HashJoin root  inner join, equal:[eq(test.t.b, test.t.b)]",
          "  │   ├─TableReader(Build) root  data:Selection",
          "  │   │ └─Selection cop[tikv]  not(isnull(test.t.b))",
          "  │   │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "  │   └─TableReader(Probe) root  data:Selection",
          "  │     └─Selection cop[tikv]  not(isnull(test.t.a)), not(isnull(test.t.b))",
          "  │       └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "  └─IndexReader(Probe) root  index:IndexFullScan",
          "    └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "SELECT a FROM (SELECT a, (SELECT t2.b FROM t t2, t t3 WHERE t2.a = t3.a AND t1.a = t2.a LIMIT 1) t FROM t t1) t",
        "Best": "IndexReader(Index(t.f)[[NULL,+inf]])",
        "Plan": [
          "IndexReader root  index:IndexFullScan",
          "└─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "SELECT a FROM t WHERE b IN (SELECT t2.b FROM t t2, t t3 WHERE t2.a = t3.a)",
        "Best": "LeftHashJoin{TableReader(Table(t))->MergeInnerJoin{TableReader(Table(t))->TableReader(Table(t))}(test.t.a,test.t.a)->HashAgg}(test.t.b,test.t.b)",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.b, test.t.b)]",
          "├─HashAgg(Build) root  group by:test.t.b, funcs:firstrow(test.t.b)->test.t.b",
          "│ └─HashJoin root  inner join, equal:[eq(test.t.a, test.t.a)]",
          "│   ├─IndexReader(Build) root  index:IndexFullScan",
          "│   │ └─IndexFullScan cop[tikv] table:t3, index:idx_a(a) keep order:false, stats:pseudo",
          "│   └─TableReader(Probe) root  data:Selection",
          "│     └─Selection cop[tikv]  not(isnull(test.t.a)), not(isnull(test.t.b))",
          "│       └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  data:Selection",
          "  └─Selection cop[tikv]  not(isnull(test.t.b))",
          "    └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "SELECT a FROM t WHERE EXISTS (SELECT t2.b FROM t t2, t t3 WHERE t2.a = t3.a AND t2.b=t.b)",
        "Best": "LeftHashJoin{TableReader(Table(t))->MergeInnerJoin{TableReader(Table(t))->TableReader(Table(t))}(test.t.a,test.t.a)}(test.t.b,test.t.b)",
        "Plan": [
          "HashJoin root  semi join, left side:TableReader, equal:[eq(test.t.b, test.t.b)]",
          "├─TableReader(Build) root  data:Selection",
          "│ └─Selection cop[tikv]  not(isnull(test.t.b))",
          "│   └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo",
          "└─HashJoin(Probe) root  inner join, equal:[eq(test.t.a, test.t.a)]",
          "  ├─IndexReader(Build) root  index:IndexFullScan",
          "  │ └─IndexFullScan cop[tikv] table:t3, index:idx_a(a) keep order:false, stats:pseudo",
          "  └─TableReader(Probe) root  data:Selection",
          "    └─Selection cop[tikv]  not(isnull(test.t.a)), not(isnull(test.t.b))",
          "      └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "SELECT a FROM t WHERE NOT EXISTS (SELECT t2.b FROM t t2, t t3 WHERE t2.a = t3.a AND t2.b=t.b)",
        "Best": "LeftHashJoin{TableReader(Table(t))->MergeInnerJoin{TableReader(Table(t))->TableReader(Table(t))}(test.t.a,test.t.a)}(test.t.b,test.t.b)",
        "Plan": [
          "HashJoin root  anti semi join, left side:TableReader, equal:[eq(test.t.b, test.t.b)]",
          "├─TableReader(Build) root  data:TableFullScan",
          "│ └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo",
          "└─HashJoin(Probe) root  inner join, equal:[eq(test.t.a, test.t.a)]",
          "  ├─IndexReader(Build) root  index:IndexFullScan",
          "  │ └─IndexFullScan cop[tikv] table:t3, index:idx_a(a) keep order:false, stats:pseudo",
          "  └─TableReader(Probe) root  data:Selection",
          "    └─Selection cop[tikv]  not(isnull(test.t.a))",
          "      └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "SELECT a FROM t WHERE b IN (SELECT b FROM t WHERE b = 1 AND a IN (SELECT a FROM t WHERE a > 0))",
        "Best": "RightHashJoin{IndexJoin{TableReader(Table(t)->Sel([eq(test.t.b, 1)]))->TableReader(Table(t)->Sel([gt(test.t.a, 0)]))}(test.t.a,test.t.a)->HashAgg->TableReader(Table(t))}(test.t.b,test.t.b)",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.b, test.t.b)]",
          "├─HashAgg(Build) root  group by:test.t.b, funcs:firstrow(test.t.b)->test.t.b",
          "│ └─IndexJoin root  inner join, inner:StreamAgg, outer key:test.t.a, inner key:test.t.a, equal cond:eq(test.t.a, test.t.a)",
          "│   ├─TableReader(Build) root  data:Selection",
          "│   │ └─Selection cop[tikv]  eq(test.t.b, 1), not(isnull(test.t.a))",
          "│   │   └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo",
          "│   └─StreamAgg(Probe) root  group by:test.t.a, funcs:firstrow(test.t.a)->test.t.a",
          "│     └─IndexReader root  index:Selection",
          "│       └─Selection cop[tikv]  gt(test.t.a, 0), not(isnull(test.t.a))",
          "│         └─IndexRangeScan cop[tikv] table:t, index:idx_a(a) range: decided by [eq(test.t.a, test.t.a)], keep order:true, stats:pseudo",
          "└─TableReader(Probe) root  data:Selection",
          "  └─Selection cop[tikv]  not(isnull(test.t.b))",
          "    └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "SELECT a FROM t WHERE b IN (SELECT b FROM t WHERE b = 1 AND a IN (SELECT t2.a FROM (SELECT t1.a, (SELECT t2.b FROM t t2, t t3 WHERE t2.a = t3.a AND t1.a = t2.a LIMIT 1) t FROM t t1) t2))",
        "Best": "LeftHashJoin{TableReader(Table(t))->IndexJoin{TableReader(Table(t)->Sel([eq(test.t.b, 1)]))->TableReader(Table(t))}(test.t.a,test.t.a)->HashAgg}(test.t.b,test.t.b)",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.b, test.t.b)]",
          "├─HashAgg(Build) root  group by:test.t.b, funcs:firstrow(test.t.b)->test.t.b",
          "│ └─IndexJoin root  inner join, inner:StreamAgg, outer key:test.t.a, inner key:test.t.a, equal cond:eq(test.t.a, test.t.a)",
          "│   ├─TableReader(Build) root  data:Selection",
          "│   │ └─Selection cop[tikv]  eq(test.t.b, 1), not(isnull(test.t.a))",
          "│   │   └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo",
          "│   └─StreamAgg(Probe) root  group by:test.t.a, funcs:firstrow(test.t.a)->test.t.a",
          "│     └─IndexReader root  index:Selection",
          "│       └─Selection cop[tikv]  not(isnull(test.t.a))",
          "│         └─IndexRangeScan cop[tikv] table:t1, index:idx_a(a) range: decided by [eq(test.t.a, test.t.a)], keep order:true, stats:pseudo",
          "└─TableReader(Probe) root  data:Selection",
          "  └─Selection cop[tikv]  not(isnull(test.t.b))",
          "    └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ]
      }
    ]
  },
  {
    "Name": "TestUnmatchedTableInHint",
    "Cases": [
      {
        "SQL": "SELECT /*+ TIDB_SMJ(t3, t4) */ * from t t1, t t2 where t1.a = t2.a",
        "Warning": "[planner:1815]There are no matching table names for (t3, t4) in optimizer hint /*+ MERGE_JOIN(t3, t4) */ or /*+ TIDB_SMJ(t3, t4) */. Maybe you can use the table alias name"
      },
      {
        "SQL": "SELECT /*+ TIDB_HJ(t3, t4) */ * from t t1, t t2 where t1.a = t2.a",
        "Warning": "[planner:1815]There are no matching table names for (t3, t4) in optimizer hint /*+ HASH_JOIN(t3, t4) */ or /*+ TIDB_HJ(t3, t4) */. Maybe you can use the table alias name"
      },
      {
        "SQL": "SELECT /*+ TIDB_INLJ(t3, t4) */ * from t t1, t t2 where t1.a = t2.a",
        "Warning": "[planner:1815]There are no matching table names for (t3, t4) in optimizer hint /*+ INL_JOIN(t3, t4) */ or /*+ TIDB_INLJ(t3, t4) */. Maybe you can use the table alias name"
      },
      {
        "SQL": "SELECT /*+ TIDB_SMJ(t1, t2) */ * from t t1, t t2 where t1.a = t2.a",
        "Warning": ""
      },
      {
        "SQL": "SELECT /*+ TIDB_SMJ(t3, t4) */ * from t t1, t t2, t t3 where t1.a = t2.a and t2.a = t3.a",
        "Warning": "[planner:1815]There are no matching table names for (t4) in optimizer hint /*+ MERGE_JOIN(t3, t4) */ or /*+ TIDB_SMJ(t3, t4) */. Maybe you can use the table alias name"
      }
    ]
  },
  {
    "Name": "TestJoinHints",
    "Cases": [
      {
        "SQL": "select /*+ TIDB_INLJ(t1) */ t1.a, t2.a, t3.a from t t1, t t2, t t3 where t1.a = t2.a and t2.a = t3.a;",
        "Best": "MergeInnerJoin{IndexJoin{TableReader(Table(t))->TableReader(Table(t))}(test.t.a,test.t.a)->TableReader(Table(t))}(test.t.a,test.t.a)",
        "Warning": "",
        "Hints": "merge_join(`test`.`t3`), leading(`test`.`t1`, `test`.`t2`, `test`.`t3`), inl_join(`test`.`t1`), use_index(@`sel_1` `test`.`t1` ), no_order_index(@`sel_1` `test`.`t1` `primary`), use_index(@`sel_1` `test`.`t2` ), order_index(@`sel_1` `test`.`t2` `primary`), use_index(@`sel_1` `test`.`t3` ), order_index(@`sel_1` `test`.`t3` `primary`)"
      },
      {
        "SQL": "select /*+ TIDB_INLJ(test.t1) */ t1.a, t2.a, t3.a from t t1, t t2, t t3 where t1.a = t2.a and t2.a = t3.a;",
        "Best": "MergeInnerJoin{IndexJoin{TableReader(Table(t))->TableReader(Table(t))}(test.t.a,test.t.a)->TableReader(Table(t))}(test.t.a,test.t.a)",
        "Warning": "",
        "Hints": "merge_join(`test`.`t3`), leading(`test`.`t1`, `test`.`t2`, `test`.`t3`), inl_join(`test`.`t1`), use_index(@`sel_1` `test`.`t1` ), no_order_index(@`sel_1` `test`.`t1` `primary`), use_index(@`sel_1` `test`.`t2` ), order_index(@`sel_1` `test`.`t2` `primary`), use_index(@`sel_1` `test`.`t3` ), order_index(@`sel_1` `test`.`t3` `primary`)"
      },
      {
        "SQL": "select /*+ TIDB_INLJ(t1) */ t1.b, t2.a from t t1, t t2 where t1.b = t2.a;",
        "Best": "LeftHashJoin{TableReader(Table(t))->IndexReader(Index(t.f)[[NULL,+inf]])}(test.t.b,test.t.a)",
        "Warning": "[planner:1815]Optimizer Hint /*+ INL_JOIN(t1) */ or /*+ TIDB_INLJ(t1) */ is inapplicable",
        "Hints": "hash_join_build(`test`.`t2`), use_index(@`sel_1` `test`.`t1` ), no_order_index(@`sel_1` `test`.`t1` `primary`), use_index(@`sel_1` `test`.`t2` `f`), no_order_index(@`sel_1` `test`.`t2` `f`)"
      },
      {
        "SQL": "select /*+ TIDB_INLJ(t2) */ t1.b, t2.a from t2 t1, t2 t2 where t1.b=t2.b and t2.c=-1;",
        "Best": "IndexJoin{IndexReader(Index(t2.b_c)[[NULL,+inf]]->Sel([eq(test.t2.c, -1)]))->IndexReader(Index(t2.b)[[NULL,NULL]])}(test.t2.b,test.t2.b)->Projection",
        "Warning": "[planner:1815]Optimizer Hint /*+ INL_JOIN(t2) */ or /*+ TIDB_INLJ(t2) */ is inapplicable",
        "Hints": "inl_join(`test`.`t1`), use_index(@`sel_1` `test`.`t2` `b_c`), no_order_index(@`sel_1` `test`.`t2` `b_c`), use_index(@`sel_1` `test`.`t1` `b`), no_order_index(@`sel_1` `test`.`t1` `b`)"
      }
    ]
  },
  {
    "Name": "TestAggregationHints",
    "Cases": [
      {
        "SQL": "select count(*) from t t1, t t2 where t1.a = t2.b",
        "Best": "LeftHashJoin{IndexReader(Index(t.f)[[NULL,+inf]])->TableReader(Table(t))}(test.t.a,test.t.b)->StreamAgg",
        "Warning": ""
      },
      {
        "SQL": "select count(t1.a) from t t1, t t2 where t1.a = t2.a*2 group by t1.a",
        "Best": "LeftHashJoin{IndexReader(Index(t.f)[[NULL,+inf]])->IndexReader(Index(t.f)[[NULL,+inf]])->Projection}(test.t.a,Column#26)->HashAgg",
        "Warning": ""
      },
      {
        "SQL": "select /*+ HASH_AGG() */ count(*) from t t1, t t2 where t1.a = t2.b",
        "Best": "LeftHashJoin{IndexReader(Index(t.f)[[NULL,+inf]])->TableReader(Table(t))}(test.t.a,test.t.b)->HashAgg",
        "Warning": ""
      },
      {
        "SQL": "select /*+ STREAM_AGG() */ count(t1.a) from t t1, t t2 where t1.a = t2.a*2 group by t1.a",
        "Best": "LeftHashJoin{IndexReader(Index(t.f)[[NULL,+inf]])->IndexReader(Index(t.f)[[NULL,+inf]])->Projection}(test.t.a,Column#26)->Sort->StreamAgg",
        "Warning": ""
      },
      {
        "SQL": "select /*+ HASH_AGG() STREAM_AGG() */ count(*) from t t1, t t2 where t1.a = t2.b",
        "Best": "LeftHashJoin{IndexReader(Index(t.f)[[NULL,+inf]])->TableReader(Table(t))}(test.t.a,test.t.b)->StreamAgg",
        "Warning": "[planner:1815]Optimizer aggregation hints are conflicted"
      },
      {
        "SQL": "select /*+ STREAM_AGG() */ distinct a from t",
        "Best": "IndexReader(Index(t.f)[[NULL,+inf]])",
        "Warning": ""
      },
      {
        "SQL": "select /*+ HASH_AGG() */ t1.a from t t1 where t1.a < any(select t2.b from t t2)",
        "Best": "LeftHashJoin{IndexReader(Index(t.f)[[NULL,+inf]])->TableReader(Table(t)->HashAgg)->HashAgg->Sel([ne(Column#27, 0)])}",
        "Warning": ""
      },
      {
        "SQL": "select /*+ hash_agg() */ t1.a from t t1 where t1.a != any(select t2.b from t t2)",
        "Best": "LeftHashJoin{IndexReader(Index(t.f)[[NULL,+inf]])->TableReader(Table(t))->HashAgg->Sel([ne(Column#28, 0)])}",
        "Warning": ""
      },
      {
        "SQL": "select /*+ hash_agg() */ t1.a from t t1 where t1.a = all(select t2.b from t t2)",
        "Best": "LeftHashJoin{IndexReader(Index(t.f)[[NULL,+inf]])->TableReader(Table(t))->HashAgg->Sel([or(and(le(Column#26, 1), if(ne(Column#27, 0), <nil>, 1)), eq(Column#28, 0))])}",
        "Warning": ""
      },
      {
        "SQL": "select /*+ STREAM_AGG() */ sum(t1.a) from t t1 join t t2 on t1.b = t2.b group by t1.b",
        "Best": "LeftHashJoin{TableReader(Table(t))->TableReader(Table(t))->Sort->Projection->StreamAgg}(test.t.b,test.t.b)->HashAgg",
        "Warning": ""
      },
      {
        "SQL": "select /*+ STREAM_AGG() */ e, sum(b) from t group by e",
        "Best": "TableReader(Table(t))->Sort->Projection->StreamAgg->Projection",
        "Warning": ""
      }
    ]
  },
  {
    "Name": "TestQueryBlockHint",
    "Cases": [
      {
        "SQL": "select /*+ MERGE_JOIN(@sel_1 t1), INL_JOIN(@sel_2 t3) */ t1.a, t1.b from t t1, (select t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Plan": "IndexJoin{MergeInnerJoin{TableReader(Table(t))->TableReader(Table(t))}(test.t.a,test.t.a)->IndexReader(Index(t.c_d_e)[[NULL,NULL]])}(test.t.a,test.t.c)",
        "Hints": "use_index(@`sel_1` `test`.`t1` ), order_index(@`sel_1` `test`.`t1` `primary`), use_index(@`sel_2` `test`.`t2` ), order_index(@`sel_2` `test`.`t2` `primary`), use_index(@`sel_2` `test`.`t3` `c_d_e`), no_order_index(@`sel_2` `test`.`t3` `c_d_e`)"
      },
      {
        "SQL": "select /*+ MERGE_JOIN(@sel_1 t1), INL_JOIN(@qb t3) */ t1.a, t1.b from t t1, (select /*+ QB_NAME(qb) */ t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Plan": "IndexJoin{MergeInnerJoin{TableReader(Table(t))->TableReader(Table(t))}(test.t.a,test.t.a)->IndexReader(Index(t.c_d_e)[[NULL,NULL]])}(test.t.a,test.t.c)",
        "Hints": "use_index(@`sel_1` `test`.`t1` ), order_index(@`sel_1` `test`.`t1` `primary`), use_index(@`sel_2` `test`.`t2` ), order_index(@`sel_2` `test`.`t2` `primary`), use_index(@`sel_2` `test`.`t3` `c_d_e`), no_order_index(@`sel_2` `test`.`t3` `c_d_e`)"
      },
      {
        "SQL": "select /*+ HASH_JOIN(@sel_1 t1), MERGE_JOIN(@sel_2 t2) */ t1.a, t1.b from t t1, (select t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Plan": "MergeInnerJoin{MergeInnerJoin{TableReader(Table(t))->TableReader(Table(t))}(test.t.a,test.t.a)->IndexReader(Index(t.c_d_e)[[NULL,+inf]])}(test.t.a,test.t.c)",
        "Hints": "use_index(@`sel_1` `test`.`t1` ), order_index(@`sel_1` `test`.`t1` `primary`), use_index(@`sel_2` `test`.`t2` ), order_index(@`sel_2` `test`.`t2` `primary`), use_index(@`sel_2` `test`.`t3` `c_d_e`), order_index(@`sel_2` `test`.`t3` `c_d_e`)"
      },
      {
        "SQL": "select /*+ HASH_JOIN(@sel_1 t1), MERGE_JOIN(@qb t2) */ t1.a, t1.b from t t1, (select /*+ QB_NAME(qb) */ t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Plan": "MergeInnerJoin{MergeInnerJoin{TableReader(Table(t))->TableReader(Table(t))}(test.t.a,test.t.a)->IndexReader(Index(t.c_d_e)[[NULL,+inf]])}(test.t.a,test.t.c)",
        "Hints": "use_index(@`sel_1` `test`.`t1` ), order_index(@`sel_1` `test`.`t1` `primary`), use_index(@`sel_2` `test`.`t2` ), order_index(@`sel_2` `test`.`t2` `primary`), use_index(@`sel_2` `test`.`t3` `c_d_e`), order_index(@`sel_2` `test`.`t3` `c_d_e`)"
      },
      {
        "SQL": "select /*+ INL_JOIN(@sel_1 t1), HASH_JOIN(@sel_2 t2) */ t1.a, t1.b from t t1, (select t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Plan": "MergeInnerJoin{MergeInnerJoin{TableReader(Table(t))->TableReader(Table(t))}(test.t.a,test.t.a)->IndexReader(Index(t.c_d_e)[[NULL,+inf]])}(test.t.a,test.t.c)",
        "Hints": "use_index(@`sel_1` `test`.`t1` ), order_index(@`sel_1` `test`.`t1` `primary`), use_index(@`sel_2` `test`.`t2` ), order_index(@`sel_2` `test`.`t2` `primary`), use_index(@`sel_2` `test`.`t3` `c_d_e`), order_index(@`sel_2` `test`.`t3` `c_d_e`)"
      },
      {
        "SQL": "select /*+ INL_JOIN(@sel_1 t1), HASH_JOIN(@qb t2) */ t1.a, t1.b from t t1, (select /*+ QB_NAME(qb) */ t2.a from t t2, t t3 where t2.a = t3.c) s where t1.a=s.a",
        "Plan": "MergeInnerJoin{MergeInnerJoin{TableReader(Table(t))->TableReader(Table(t))}(test.t.a,test.t.a)->IndexReader(Index(t.c_d_e)[[NULL,+inf]])}(test.t.a,test.t.c)",
        "Hints": "use_index(@`sel_1` `test`.`t1` ), order_index(@`sel_1` `test`.`t1` `primary`), use_index(@`sel_2` `test`.`t2` ), order_index(@`sel_2` `test`.`t2` `primary`), use_index(@`sel_2` `test`.`t3` `c_d_e`), order_index(@`sel_2` `test`.`t3` `c_d_e`)"
      },
      {
        "SQL": "select /*+ HASH_AGG(@sel_1), STREAM_AGG(@sel_2) */ count(*) from t t1 where t1.a < (select count(*) from t t2 where t1.a > t2.a)",
        "Plan": "Apply{IndexReader(Index(t.f)[[NULL,+inf]])->IndexReader(Index(t.f)[[NULL,+inf]]->Sel([gt(test.t.a, test.t.a)])->StreamAgg)->StreamAgg}->HashAgg",
        "Hints": "hash_agg(@`sel_1`), use_index(@`sel_1` `test`.`t1` `f`), no_order_index(@`sel_1` `test`.`t1` `f`), stream_agg(@`sel_2`), use_index(@`sel_2` `test`.`t2` `f`), no_order_index(@`sel_2` `test`.`t2` `f`), agg_to_cop(@`sel_2`)"
      },
      {
        "SQL": "select /*+ STREAM_AGG(@sel_1), HASH_AGG(@qb) */ count(*) from t t1 where t1.a < (select /*+ QB_NAME(qb) */ count(*) from t t2 where t1.a > t2.a)",
        "Plan": "Apply{IndexReader(Index(t.f)[[NULL,+inf]])->IndexReader(Index(t.f)[[NULL,+inf]]->Sel([gt(test.t.a, test.t.a)])->HashAgg)->HashAgg}->StreamAgg",
        "Hints": "stream_agg(@`sel_1`), use_index(@`sel_1` `test`.`t1` `f`), no_order_index(@`sel_1` `test`.`t1` `f`), hash_agg(@`sel_2`), use_index(@`sel_2` `test`.`t2` `f`), no_order_index(@`sel_2` `test`.`t2` `f`), agg_to_cop(@`sel_2`)"
      },
      {
        "SQL": "select /*+ HASH_AGG(@sel_2) */ a, (select count(*) from t t1 where t1.b > t.a) from t where b > (select b from t t2 where t2.b = t.a limit 1)",
        "Plan": "Apply{Apply{TableReader(Table(t))->TableReader(Table(t)->Sel([eq(test.t.b, test.t.a)])->Limit)->Limit}->TableReader(Table(t)->Sel([gt(test.t.b, test.t.a)])->HashAgg)->HashAgg}->Projection",
        "Hints": "use_index(@`sel_1` `test`.`t` ), no_order_index(@`sel_1` `test`.`t` `primary`), use_index(@`sel_3` `test`.`t2` ), no_order_index(@`sel_3` `test`.`t2` `primary`), limit_to_cop(@`sel_3`), hash_agg(@`sel_2`), use_index(@`sel_2` `test`.`t1` ), no_order_index(@`sel_2` `test`.`t1` `primary`), agg_to_cop(@`sel_2`)"
      },
      {
        "SQL": "select /*+ HASH_JOIN(@sel_1 t1), HASH_JOIN(@sel_2 t1) */ t1.b, t2.a, t2.aa from t t1, (select t1.a as a, t2.a as aa from t t1, t t2) t2 where t1.a = t2.aa;",
        "Plan": "LeftHashJoin{LeftHashJoin{TableReader(Table(t))->IndexReader(Index(t.f)[[NULL,+inf]])}(test.t.a,test.t.a)->IndexReader(Index(t.f)[[NULL,+inf]])}->Projection",
        "Hints": "use_index(@`sel_1` `test`.`t1` ), no_order_index(@`sel_1` `test`.`t1` `primary`), use_index(@`sel_2` `test`.`t2` `f`), no_order_index(@`sel_2` `test`.`t2` `f`), use_index(@`sel_2` `test`.`t1` `f`), no_order_index(@`sel_2` `test`.`t1` `f`)"
      },
      {
        "SQL": "select /*+ HASH_JOIN(@sel_2 t1@sel_2, t2@sel_2), MERGE_JOIN(@sel_1 t1@sel_1, t2@sel_1) */ * from (select t1.a, t1.b from t t1, t t2 where t1.a = t2.a) t1, t t2 where t1.b = t2.b",
        "Plan": "MergeInnerJoin{TableReader(Table(t))->Sort->LeftHashJoin{TableReader(Table(t))->IndexReader(Index(t.f)[[NULL,+inf]])}(test.t.a,test.t.a)->Sort}(test.t.b,test.t.b)->Projection",
        "Hints": "use_index(@`sel_1` `test`.`t2` ), no_order_index(@`sel_1` `test`.`t2` `primary`), hash_join_build(@`sel_2` `test`.`t2`@`sel_2`), use_index(@`sel_2` `test`.`t1` ), no_order_index(@`sel_2` `test`.`t1` `primary`), use_index(@`sel_2` `test`.`t2` `f`), no_order_index(@`sel_2` `test`.`t2` `f`)"
      }
    ]
  },
  {
    "Name": "TestSemiJoinToInner",
    "Cases": [
      {
        "SQL": "select t1.a, (select count(t2.a) from t t2 where t2.g in (select t3.d from t t3 where t3.c = t1.a)) as agg_col from t t1;",
        "Best": "Apply{IndexReader(Index(t.f)[[NULL,+inf]])->IndexHashJoin{IndexReader(Index(t.c_d_e)[[NULL,+inf]]->HashAgg)->HashAgg->IndexReader(Index(t.g)[[NULL,NULL]])}(test.t.d,test.t.g)}->HashAgg"
      }
    ]
  },
  {
    "Name": "TestIndexJoinHint",
    "Cases": [
      {
        "SQL": "select /*+ INL_JOIN(t1) */ * from t1 join t2 on t1.a = t2.a;",
        "Plan": "IndexJoin{IndexLookUp(Index(t1.idx_a)[[NULL,NULL]]->Sel([not(isnull(test.t1.a))]), Table(t1))->TableReader(Table(t2)->Sel([not(isnull(test.t2.a))]))}(test.t2.a,test.t1.a)",
        "Warns": null
      },
      {
        "SQL": "select /*+ INL_HASH_JOIN(t1) */ * from t1 join t2 on t1.a = t2.a;",
        "Plan": "IndexHashJoin{IndexLookUp(Index(t1.idx_a)[[NULL,NULL]]->Sel([not(isnull(test.t1.a))]), Table(t1))->TableReader(Table(t2)->Sel([not(isnull(test.t2.a))]))}(test.t2.a,test.t1.a)",
        "Warns": null
      },
      {
        "SQL": "select /*+ INL_MERGE_JOIN(t1) */ * from t1 join t2 on t1.a = t2.a;",
        "Plan": "LeftHashJoin{TableReader(Table(t1)->Sel([not(isnull(test.t1.a))]))->TableReader(Table(t2)->Sel([not(isnull(test.t2.a))]))}(test.t1.a,test.t2.a)",
        "Warns": [
          "[planner:1815]The INDEX MERGE JOIN hint is deprecated for usage, try other hints."
        ]
      },
      {
        "SQL": "select /*+ inl_merge_join(t2) */ t1.a, t2.a from t t1 left join t t2 use index(g_2) on t1.g=t2.g",
        "Plan": "MergeLeftOuterJoin{IndexReader(Index(t.g_2)[[NULL,+inf]])->IndexReader(Index(t.g_2)[[-inf,+inf]])}(test.t.g,test.t.g)",
        "Warns": [
          "[planner:1815]The INDEX MERGE JOIN hint is deprecated for usage, try other hints."
        ]
      },
      {
        "SQL": "select /*+inl_merge_join(t2)*/ t1.a, t2.a from t t1 left join t t2 use index(g_2) on t1.g=t2.g order by t1.a",
        "Plan": "IndexHashJoin{TableReader(Table(t))->IndexReader(Index(t.g_2)[[NULL,NULL]]->Sel([not(isnull(test.t.g))]))}(test.t.g,test.t.g)",
        "Warns": [
          "[planner:1815]The INDEX MERGE JOIN hint is deprecated for usage, try other hints."
        ]
      }
    ]
  },
  {
    "Name": "TestAggToCopHint",
    "Cases": [
      {
        "SQL": "select /*+ AGG_TO_COP(), HASH_AGG(), USE_INDEX(t) */ sum(a) from ta group by a",
        "Best": "IndexReader(Index(ta.a)[[NULL,+inf]]->HashAgg)->HashAgg",
        "Warning": "[planner:1815]use_index(test.t) is inapplicable, check whether the table(test.t) exists"
      },
      {
        "SQL": "select /*+ AGG_TO_COP(), USE_INDEX(t) */ sum(b) from ta group by b",
        "Best": "TableReader(Table(ta)->HashAgg)->HashAgg",
        "Warning": "[planner:1815]use_index(test.t) is inapplicable, check whether the table(test.t) exists"
      },
      {
        "SQL": "select /*+ AGG_TO_COP(), HASH_AGG(), USE_INDEX(t) */ distinct a from ta group by a",
        "Best": "IndexReader(Index(ta.a)[[NULL,+inf]]->HashAgg)->HashAgg",
        "Warning": "[planner:1815]use_index(test.t) is inapplicable, check whether the table(test.t) exists"
      },
      {
        "SQL": "select /*+ AGG_TO_COP(), HASH_AGG(), HASH_JOIN(t1), USE_INDEX(t1), USE_INDEX(t2) */ sum(t1.a) from ta t1, ta t2 where t1.a = t2.b group by t1.a",
        "Best": "LeftHashJoin{TableReader(Table(ta)->Sel([not(isnull(test.ta.a))]))->TableReader(Table(ta)->Sel([not(isnull(test.ta.b))]))}(test.ta.a,test.ta.b)->Projection->HashAgg",
        "Warning": "[planner:1815]Optimizer Hint AGG_TO_COP is inapplicable"
      }
    ]
  },
  {
    "Name": "TestGroupConcatOrderby",
    "Cases": [
      {
        "SQL": "select /*+ agg_to_cop */ group_concat(name ORDER BY name desc SEPARATOR '++'), group_concat(id ORDER BY name desc, id asc SEPARATOR '--') from test;",
        "Plan": [
          "HashAgg root  funcs:group_concat(Column order by Column desc separator \"++\")->Column, funcs:group_concat(Column order by Column desc, Column separator \"--\")->Column",
          "└─Projection root  cast(test.test.name, var_string(20))->Column, test.test.name->Column, cast(test.test.id, var_string(20))->Column, test.test.id->Column",
          "  └─TableReader root  data:TableFullScan",
          "    └─TableFullScan cop[tikv] table:test keep order:false, stats:pseudo"
        ],
        "Result": [
          "500++200++30++20++20++10 3--3--1--1--2--1"
        ]
      },
      {
        "SQL": "select /*+ agg_to_cop */ group_concat(name ORDER BY name desc SEPARATOR '++'), group_concat(id ORDER BY name desc, id asc SEPARATOR '--') from ptest;",
        "Plan": [
          "HashAgg root  funcs:group_concat(Column order by Column desc separator \"++\")->Column, funcs:group_concat(Column order by Column desc, Column separator \"--\")->Column",
          "└─Projection root  cast(test.ptest.name, var_string(20))->Column, test.ptest.name->Column, cast(test.ptest.id, var_string(20))->Column, test.ptest.id->Column",
          "  └─TableReader root partition:all data:TableFullScan",
          "    └─TableFullScan cop[tikv] table:ptest keep order:false, stats:pseudo"
        ],
        "Result": [
          "500++200++30++20++20++10 3--3--1--1--2--1"
        ]
      },
      {
        "SQL": "select /*+ agg_to_cop */ group_concat(distinct name order by name desc) from test;",
        "Plan": [
          "HashAgg root  funcs:group_concat(distinct Column order by Column desc separator \",\")->Column",
          "└─Projection root  cast(test.test.name, var_string(20))->Column, test.test.name->Column",
          "  └─TableReader root  data:TableFullScan",
          "    └─TableFullScan cop[tikv] table:test keep order:false, stats:pseudo"
        ],
        "Result": [
          "500,200,30,20,10"
        ]
      },
      {
        "SQL": "select /*+ agg_to_cop */ group_concat(distinct name order by name desc) from ptest;",
        "Plan": [
          "HashAgg root  funcs:group_concat(distinct Column order by Column desc separator \",\")->Column",
          "└─Projection root  cast(test.ptest.name, var_string(20))->Column, test.ptest.name->Column",
          "  └─TableReader root partition:all data:TableFullScan",
          "    └─TableFullScan cop[tikv] table:ptest keep order:false, stats:pseudo"
        ],
        "Result": [
          "500,200,30,20,10"
        ]
      }
    ]
  },
  {
    "Name": "TestInlineProjection",
    "Cases": [
      {
        "SQL": "select /*+ HASH_JOIN(t1) */ t1.b, t2.b from t1, t2 where t1.a = t2.a;",
        "Plan": "LeftHashJoin{TableReader(Table(t1)->Sel([not(isnull(test.t1.a))]))->TableReader(Table(t2)->Sel([not(isnull(test.t2.a))]))}(test.t1.a,test.t2.a)",
        "Hints": "hash_join_build(`test`.`t2`), use_index(@`sel_1` `test`.`t1` ), use_index(@`sel_1` `test`.`t2` )"
      },
      {
        "SQL": "select /*+ HASH_JOIN(t1) */ t1.b, t2.b from t1 inner join t2 on t1.a = t2.a;",
        "Plan": "LeftHashJoin{TableReader(Table(t1)->Sel([not(isnull(test.t1.a))]))->TableReader(Table(t2)->Sel([not(isnull(test.t2.a))]))}(test.t1.a,test.t2.a)",
        "Hints": "hash_join_build(`test`.`t2`), use_index(@`sel_1` `test`.`t1` ), use_index(@`sel_1` `test`.`t2` )"
      },
      {
        "SQL": "select /*+ HASH_JOIN(t1) */ t1.b, t2.b from t1 left outer join t2 on t1.a = t2.a;",
        "Plan": "LeftHashJoin{TableReader(Table(t1))->TableReader(Table(t2)->Sel([not(isnull(test.t2.a))]))}(test.t1.a,test.t2.a)",
        "Hints": "hash_join_build(`test`.`t2`), use_index(@`sel_1` `test`.`t1` ), use_index(@`sel_1` `test`.`t2` )"
      },
      {
        "SQL": "select /*+ HASH_JOIN(t1) */ t1.b, t2.b from t1 right outer join t2 on t1.a = t2.a;",
        "Plan": "RightHashJoin{TableReader(Table(t1)->Sel([not(isnull(test.t1.a))]))->TableReader(Table(t2))}(test.t1.a,test.t2.a)",
        "Hints": "hash_join_build(`test`.`t1`), use_index(@`sel_1` `test`.`t1` ), use_index(@`sel_1` `test`.`t2` )"
      },
      {
        "SQL": "select 1 from (select /*+ HASH_JOIN(t1) */ t1.a in (select t2.a from t2) from t1) x;",
        "Plan": "LeftHashJoin{IndexReader(Index(t1.idx_a)[[NULL,+inf]])->IndexReader(Index(t2.idx_a)[[NULL,+inf]])}->Projection",
        "Hints": "hash_join(@`sel_2` `test`.`t1`@`sel_2`), use_index(@`sel_2` `test`.`t1` `idx_a`), no_order_index(@`sel_2` `test`.`t1` `idx_a`), use_index(@`sel_3` `test`.`t2` `idx_a`), no_order_index(@`sel_3` `test`.`t2` `idx_a`)"
      },
      {
        "SQL": "select 1 from (select /*+ HASH_JOIN(t1) */ t1.a not in (select t2.a from t2) from t1) x;",
        "Plan": "LeftHashJoin{IndexReader(Index(t1.idx_a)[[NULL,+inf]])->IndexReader(Index(t2.idx_a)[[NULL,+inf]])}->Projection",
        "Hints": "hash_join(@`sel_2` `test`.`t1`@`sel_2`), use_index(@`sel_2` `test`.`t1` `idx_a`), no_order_index(@`sel_2` `test`.`t1` `idx_a`), use_index(@`sel_3` `test`.`t2` `idx_a`), no_order_index(@`sel_3` `test`.`t2` `idx_a`)"
      },
      {
        "SQL": "select /*+ INL_JOIN(t1) */ t1.b, t2.b from t1 inner join t2 on t1.a = t2.a;",
        "Plan": "IndexJoin{IndexLookUp(Index(t1.idx_a)[[NULL,NULL]]->Sel([not(isnull(test.t1.a))]), Table(t1))->TableReader(Table(t2)->Sel([not(isnull(test.t2.a))]))}(test.t2.a,test.t1.a)",
        "Hints": "inl_join(`test`.`t1`), use_index(@`sel_1` `test`.`t1` `idx_a`), no_order_index(@`sel_1` `test`.`t1` `idx_a`), use_index(@`sel_1` `test`.`t2` )"
      },
      {
        "SQL": "select /*+ INL_HASH_JOIN(t1) */ t1.b, t2.b from t1 inner join t2 on t1.a = t2.a;",
        "Plan": "IndexHashJoin{IndexLookUp(Index(t1.idx_a)[[NULL,NULL]]->Sel([not(isnull(test.t1.a))]), Table(t1))->TableReader(Table(t2)->Sel([not(isnull(test.t2.a))]))}(test.t2.a,test.t1.a)",
        "Hints": "inl_hash_join(`test`.`t1`), use_index(@`sel_1` `test`.`t1` `idx_a`), no_order_index(@`sel_1` `test`.`t1` `idx_a`), use_index(@`sel_1` `test`.`t2` )"
      },
      {
        "SQL": "select /*+ INL_MERGE_JOIN(t1) */ t1.b, t2.b from t1 inner join t2 on t1.a = t2.a;",
        "Plan": "LeftHashJoin{TableReader(Table(t1)->Sel([not(isnull(test.t1.a))]))->TableReader(Table(t2)->Sel([not(isnull(test.t2.a))]))}(test.t1.a,test.t2.a)",
        "Hints": "hash_join_build(`test`.`t2`), use_index(@`sel_1` `test`.`t1` ), use_index(@`sel_1` `test`.`t2` )"
      },
      {
        "SQL": "select /*+ MERGE_JOIN(t1) */ t1.b, t2.b from t1 inner join t2 on t1.a = t2.a;",
        "Plan": "MergeInnerJoin{TableReader(Table(t1)->Sel([not(isnull(test.t1.a))]))->Sort->TableReader(Table(t2)->Sel([not(isnull(test.t2.a))]))->Sort}(test.t1.a,test.t2.a)",
        "Hints": "merge_join(`test`.`t1`), use_index(@`sel_1` `test`.`t1` ), use_index(@`sel_1` `test`.`t2` )"
      }
    ]
  },
  {
    "Name": "TestHintFromDiffDatabase",
    "Cases": [
      {
        "SQL": "select /*+ inl_hash_join(test.t1) */ * from test.t2 join test.t1 on test.t2.a = test.t1.a",
        "Plan": "IndexHashJoin{IndexReader(Index(t2.idx_a)[[-inf,+inf]])->IndexReader(Index(t1.idx_a)[[NULL,NULL]]->Sel([not(isnull(test.t1.a))]))}(test.t2.a,test.t1.a)"
      }
    ]
  },
  {
    "Name": "TestMPPSinglePartitionType",
    "Cases": [
      {
        "SQL": "select * from employee where deptid>1",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Selection mpp[tiflash]  gt(test.employee.deptid, 1)",
          "    └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select deptid+5, empid*10  from employee where deptid>1",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  plus(test.employee.deptid, 5)->Column, mul(test.employee.empid, 10)->Column",
          "    └─Selection mpp[tiflash]  gt(test.employee.deptid, 1)",
          "      └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select count(*) from employee group by deptid+1",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  Column",
          "    └─HashAgg mpp[tiflash]  group by:Column, funcs:sum(Column)->Column",
          "      └─ExchangeReceiver mpp[tiflash]  ",
          "        └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary]",
          "          └─HashAgg mpp[tiflash]  group by:Column, funcs:count(1)->Column",
          "            └─Projection mpp[tiflash]  plus(test.employee.deptid, 1)->Column",
          "              └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select count(distinct deptid) a from employee",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  Column",
          "    └─HashAgg mpp[tiflash]  funcs:sum(Column)->Column",
          "      └─ExchangeReceiver mpp[tiflash]  ",
          "        └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough, Compression: FAST",
          "          └─HashAgg mpp[tiflash]  funcs:count(distinct test.employee.deptid)->Column",
          "            └─ExchangeReceiver mpp[tiflash]  ",
          "              └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.employee.deptid, collate: binary]",
          "                └─HashAgg mpp[tiflash]  group by:test.employee.deptid, ",
          "                  └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select * from employee join employee e1 using(deptid)",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.employee.deptid, test.employee.empid, test.employee.salary, test.employee.empid, test.employee.salary",
          "    └─Projection mpp[tiflash]  test.employee.empid, test.employee.deptid, test.employee.salary, test.employee.empid, test.employee.salary",
          "      └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.employee.deptid, test.employee.deptid)]",
          "        ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "        │   └─Selection mpp[tiflash]  not(isnull(test.employee.deptid))",
          "        │     └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo",
          "        └─Selection(Probe) mpp[tiflash]  not(isnull(test.employee.deptid))",
          "          └─TableFullScan mpp[tiflash] table:e1 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select count(distinct a) from (select count(distinct deptid) a from employee) x",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  Column",
          "    └─HashAgg mpp[tiflash]  funcs:count(distinct Column)->Column",
          "      └─Projection mpp[tiflash]  Column",
          "        └─HashAgg mpp[tiflash]  funcs:sum(Column)->Column",
          "          └─ExchangeReceiver mpp[tiflash]  ",
          "            └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough, Compression: FAST",
          "              └─HashAgg mpp[tiflash]  funcs:count(distinct test.employee.deptid)->Column",
          "                └─ExchangeReceiver mpp[tiflash]  ",
          "                  └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.employee.deptid, collate: binary]",
          "                    └─HashAgg mpp[tiflash]  group by:test.employee.deptid, ",
          "                      └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select count(a) from (select count(distinct deptid) a, count(distinct empid) b from employee) x group by b+1",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  Column",
          "    └─HashAgg mpp[tiflash]  group by:Column, funcs:sum(Column)->Column",
          "      └─ExchangeReceiver mpp[tiflash]  ",
          "        └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary]",
          "          └─HashAgg mpp[tiflash]  group by:Column, funcs:count(Column)->Column",
          "            └─Projection mpp[tiflash]  Column->Column, plus(Column, 1)->Column",
          "              └─Projection mpp[tiflash]  Column, Column",
          "                └─HashAgg mpp[tiflash]  funcs:count(distinct test.employee.deptid)->Column, funcs:count(distinct test.employee.empid)->Column",
          "                  └─ExchangeReceiver mpp[tiflash]  ",
          "                    └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough, Compression: FAST",
          "                      └─HashAgg mpp[tiflash]  group by:test.employee.deptid, test.employee.empid, ",
          "                        └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select count(a) from (select count(distinct deptid) a, count(distinct empid) b from employee) x group by b",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  Column",
          "    └─HashAgg mpp[tiflash]  group by:Column, funcs:count(Column)->Column",
          "      └─Projection mpp[tiflash]  Column, Column",
          "        └─HashAgg mpp[tiflash]  funcs:count(distinct test.employee.deptid)->Column, funcs:count(distinct test.employee.empid)->Column",
          "          └─ExchangeReceiver mpp[tiflash]  ",
          "            └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough, Compression: FAST",
          "              └─HashAgg mpp[tiflash]  group by:test.employee.deptid, test.employee.empid, ",
          "                └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select * from employee join (select count(distinct deptid) a, count(distinct empid) b from employee) e1",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  CARTESIAN inner join",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Projection mpp[tiflash]  Column, Column",
          "    │     └─HashAgg mpp[tiflash]  funcs:count(distinct test.employee.deptid)->Column, funcs:count(distinct test.employee.empid)->Column",
          "    │       └─ExchangeReceiver mpp[tiflash]  ",
          "    │         └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough, Compression: FAST",
          "    │           └─HashAgg mpp[tiflash]  group by:test.employee.deptid, test.employee.empid, ",
          "    │             └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo",
          "    └─TableFullScan(Probe) mpp[tiflash] table:employee keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select * from employee e1 join (select count(distinct deptid) a from employee) e2 on e1.deptid = e2.a",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.employee.deptid, Column)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Projection mpp[tiflash]  Column",
          "    │     └─HashAgg mpp[tiflash]  funcs:sum(Column)->Column",
          "    │       └─ExchangeReceiver mpp[tiflash]  ",
          "    │         └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough, Compression: FAST",
          "    │           └─HashAgg mpp[tiflash]  funcs:count(distinct test.employee.deptid)->Column",
          "    │             └─ExchangeReceiver mpp[tiflash]  ",
          "    │               └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.employee.deptid, collate: binary]",
          "    │                 └─HashAgg mpp[tiflash]  group by:test.employee.deptid, ",
          "    │                   └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.employee.deptid))",
          "      └─TableFullScan mpp[tiflash] table:e1 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select * from (select count(distinct deptid) a from employee) e1 join employee e2 on e1.a = e2.deptid",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  Column, test.employee.empid, test.employee.deptid, test.employee.salary",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.employee.deptid, Column)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─Projection mpp[tiflash]  Column",
          "      │     └─HashAgg mpp[tiflash]  funcs:sum(Column)->Column",
          "      │       └─ExchangeReceiver mpp[tiflash]  ",
          "      │         └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough, Compression: FAST",
          "      │           └─HashAgg mpp[tiflash]  funcs:count(distinct test.employee.deptid)->Column",
          "      │             └─ExchangeReceiver mpp[tiflash]  ",
          "      │               └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.employee.deptid, collate: binary]",
          "      │                 └─HashAgg mpp[tiflash]  group by:test.employee.deptid, ",
          "      │                   └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo",
          "      └─Selection(Probe) mpp[tiflash]  not(isnull(test.employee.deptid))",
          "        └─TableFullScan mpp[tiflash] table:e2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select * from (select count(distinct deptid) a from employee) e1 join (select count(distinct deptid) b from employee) e2 on e1.a=e2.b",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(Column, Column)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Projection mpp[tiflash]  Column",
          "    │     └─HashAgg mpp[tiflash]  funcs:sum(Column)->Column",
          "    │       └─ExchangeReceiver mpp[tiflash]  ",
          "    │         └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough, Compression: FAST",
          "    │           └─HashAgg mpp[tiflash]  funcs:count(distinct test.employee.deptid)->Column",
          "    │             └─ExchangeReceiver mpp[tiflash]  ",
          "    │               └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.employee.deptid, collate: binary]",
          "    │                 └─HashAgg mpp[tiflash]  group by:test.employee.deptid, ",
          "    │                   └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo",
          "    └─Projection(Probe) mpp[tiflash]  Column",
          "      └─HashAgg mpp[tiflash]  funcs:sum(Column)->Column",
          "        └─ExchangeReceiver mpp[tiflash]  ",
          "          └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough, Compression: FAST",
          "            └─HashAgg mpp[tiflash]  funcs:count(distinct test.employee.deptid)->Column",
          "              └─ExchangeReceiver mpp[tiflash]  ",
          "                └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.employee.deptid, collate: binary]",
          "                  └─HashAgg mpp[tiflash]  group by:test.employee.deptid, ",
          "                    └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select * from employee e1 join employee e2 on e1.deptid = e2.deptid",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.employee.deptid, test.employee.deptid)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.employee.deptid))",
          "    │     └─TableFullScan mpp[tiflash] table:e1 keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.employee.deptid))",
          "      └─TableFullScan mpp[tiflash] table:e2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select * from (select deptid+1 d, count(empid) a from employee group by d) e1 join employee e2 on e1.d = e2.deptid",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  Column, Column, test.employee.empid, test.employee.deptid, test.employee.salary",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.employee.deptid, Column)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─Projection mpp[tiflash]  plus(test.employee.deptid, 1)->Column, Column",
          "      │     └─Projection mpp[tiflash]  Column, test.employee.deptid",
          "      │       └─HashAgg mpp[tiflash]  group by:Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.employee.deptid",
          "      │         └─ExchangeReceiver mpp[tiflash]  ",
          "      │           └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary]",
          "      │             └─HashAgg mpp[tiflash]  group by:Column, funcs:count(Column)->Column, funcs:firstrow(Column)->Column",
          "      │               └─Projection mpp[tiflash]  test.employee.empid->Column, test.employee.deptid->Column, plus(test.employee.deptid, 1)->Column",
          "      │                 └─Selection mpp[tiflash]  not(isnull(plus(test.employee.deptid, 1)))",
          "      │                   └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo",
          "      └─Selection(Probe) mpp[tiflash]  not(isnull(test.employee.deptid))",
          "        └─TableFullScan mpp[tiflash] table:e2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select * from employee e1 join (select deptid+1 d, count(empid) a from employee group by d) e2 on e1.deptid = e2.d",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.employee.deptid, Column)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Projection mpp[tiflash]  plus(test.employee.deptid, 1)->Column, Column",
          "    │     └─Projection mpp[tiflash]  Column, test.employee.deptid",
          "    │       └─HashAgg mpp[tiflash]  group by:Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.employee.deptid",
          "    │         └─ExchangeReceiver mpp[tiflash]  ",
          "    │           └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary]",
          "    │             └─HashAgg mpp[tiflash]  group by:Column, funcs:count(Column)->Column, funcs:firstrow(Column)->Column",
          "    │               └─Projection mpp[tiflash]  test.employee.empid->Column, test.employee.deptid->Column, plus(test.employee.deptid, 1)->Column",
          "    │                 └─Selection mpp[tiflash]  not(isnull(plus(test.employee.deptid, 1)))",
          "    │                   └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo",
          "    └─Selection(Probe) mpp[tiflash]  not(isnull(test.employee.deptid))",
          "      └─TableFullScan mpp[tiflash] table:e1 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select * from (select deptid+1 d, count(empid) a from employee group by d) e1 join (select deptid+1 d, count(empid) a from employee group by d) e2 on e1.d = e2.d",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(Column, Column)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "    │   └─Projection mpp[tiflash]  plus(test.employee.deptid, 1)->Column, Column",
          "    │     └─Projection mpp[tiflash]  Column, test.employee.deptid",
          "    │       └─HashAgg mpp[tiflash]  group by:Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.employee.deptid",
          "    │         └─ExchangeReceiver mpp[tiflash]  ",
          "    │           └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary]",
          "    │             └─HashAgg mpp[tiflash]  group by:Column, funcs:count(Column)->Column, funcs:firstrow(Column)->Column",
          "    │               └─Projection mpp[tiflash]  test.employee.empid->Column, test.employee.deptid->Column, plus(test.employee.deptid, 1)->Column",
          "    │                 └─Selection mpp[tiflash]  not(isnull(plus(test.employee.deptid, 1)))",
          "    │                   └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo",
          "    └─Projection(Probe) mpp[tiflash]  plus(test.employee.deptid, 1)->Column, Column",
          "      └─Projection mpp[tiflash]  Column, test.employee.deptid",
          "        └─HashAgg mpp[tiflash]  group by:Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.employee.deptid",
          "          └─ExchangeReceiver mpp[tiflash]  ",
          "            └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary]",
          "              └─HashAgg mpp[tiflash]  group by:Column, funcs:count(Column)->Column, funcs:firstrow(Column)->Column",
          "                └─Projection mpp[tiflash]  test.employee.empid->Column, test.employee.deptid->Column, plus(test.employee.deptid, 1)->Column",
          "                  └─Selection mpp[tiflash]  not(isnull(plus(test.employee.deptid, 1)))",
          "                    └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "set tidb_broadcast_join_threshold_count=1",
        "Plan": null
      },
      {
        "SQL": "set tidb_broadcast_join_threshold_size=1",
        "Plan": null
      },
      {
        "SQL": "select * from (select count(distinct deptid) a from employee) e1 join employee e2 on e1.a = e2.deptid",
        "Plan": [
          "Projection root  Column, test.employee.empid, test.employee.deptid, test.employee.salary",
          "└─HashJoin root  inner join, equal:[eq(test.employee.deptid, Column)]",
          "  ├─TableReader(Build) root  MppVersion: 3, data:ExchangeSender",
          "  │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  │   └─Projection mpp[tiflash]  Column",
          "  │     └─HashAgg mpp[tiflash]  funcs:sum(Column)->Column",
          "  │       └─ExchangeReceiver mpp[tiflash]  ",
          "  │         └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough, Compression: FAST",
          "  │           └─HashAgg mpp[tiflash]  funcs:count(distinct test.employee.deptid)->Column",
          "  │             └─ExchangeReceiver mpp[tiflash]  ",
          "  │               └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.employee.deptid, collate: binary]",
          "  │                 └─HashAgg mpp[tiflash]  group by:test.employee.deptid, ",
          "  │                   └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo",
          "  └─TableReader(Probe) root  MppVersion: 3, data:ExchangeSender",
          "    └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "      └─Selection mpp[tiflash]  not(isnull(test.employee.deptid))",
          "        └─TableFullScan mpp[tiflash] table:e2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select * from (select count(distinct deptid) a from employee) e1 join (select count(distinct deptid) b from employee) e2 on e1.a=e2.b",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(Column, Column)]",
          "├─TableReader(Build) root  MppVersion: 3, data:ExchangeSender",
          "│ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "│   └─Projection mpp[tiflash]  Column",
          "│     └─HashAgg mpp[tiflash]  funcs:sum(Column)->Column",
          "│       └─ExchangeReceiver mpp[tiflash]  ",
          "│         └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough, Compression: FAST",
          "│           └─HashAgg mpp[tiflash]  funcs:count(distinct test.employee.deptid)->Column",
          "│             └─ExchangeReceiver mpp[tiflash]  ",
          "│               └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.employee.deptid, collate: binary]",
          "│                 └─HashAgg mpp[tiflash]  group by:test.employee.deptid, ",
          "│                   └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─Projection mpp[tiflash]  Column",
          "      └─HashAgg mpp[tiflash]  funcs:sum(Column)->Column",
          "        └─ExchangeReceiver mpp[tiflash]  ",
          "          └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough, Compression: FAST",
          "            └─HashAgg mpp[tiflash]  funcs:count(distinct test.employee.deptid)->Column",
          "              └─ExchangeReceiver mpp[tiflash]  ",
          "                └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.employee.deptid, collate: binary]",
          "                  └─HashAgg mpp[tiflash]  group by:test.employee.deptid, ",
          "                    └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select * from employee e1 join employee e2 on e1.deptid = e2.deptid",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.employee.deptid, test.employee.deptid)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.employee.deptid, collate: binary]",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.employee.deptid))",
          "    │     └─TableFullScan mpp[tiflash] table:e1 keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.employee.deptid, collate: binary]",
          "        └─Selection mpp[tiflash]  not(isnull(test.employee.deptid))",
          "          └─TableFullScan mpp[tiflash] table:e2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select * from (select deptid+1 d, count(empid) a from employee group by d) e1 join employee e2 on e1.d = e2.deptid",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  Column, Column, test.employee.empid, test.employee.deptid, test.employee.salary",
          "    └─Projection mpp[tiflash]  test.employee.empid, test.employee.deptid, test.employee.salary, Column, Column, Column",
          "      └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.employee.deptid, Column)]",
          "        ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary]",
          "        │   └─Projection mpp[tiflash]  plus(test.employee.deptid, 1)->Column, Column",
          "        │     └─Projection mpp[tiflash]  Column, test.employee.deptid",
          "        │       └─HashAgg mpp[tiflash]  group by:Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.employee.deptid",
          "        │         └─ExchangeReceiver mpp[tiflash]  ",
          "        │           └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary]",
          "        │             └─HashAgg mpp[tiflash]  group by:Column, funcs:count(Column)->Column, funcs:firstrow(Column)->Column",
          "        │               └─Projection mpp[tiflash]  test.employee.empid->Column, test.employee.deptid->Column, plus(test.employee.deptid, 1)->Column",
          "        │                 └─Selection mpp[tiflash]  not(isnull(plus(test.employee.deptid, 1)))",
          "        │                   └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo",
          "        └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "          └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary]",
          "            └─Projection mpp[tiflash]  test.employee.empid, test.employee.deptid, test.employee.salary, cast(test.employee.deptid, bigint(20))->Column",
          "              └─Selection mpp[tiflash]  not(isnull(test.employee.deptid))",
          "                └─TableFullScan mpp[tiflash] table:e2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select * from employee e1 join (select deptid+1 d, count(empid) a from employee group by d) e2 on e1.deptid = e2.d",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.employee.empid, test.employee.deptid, test.employee.salary, Column, Column",
          "    └─Projection mpp[tiflash]  test.employee.empid, test.employee.deptid, test.employee.salary, Column, Column, Column",
          "      └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.employee.deptid, Column)]",
          "        ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary]",
          "        │   └─Projection mpp[tiflash]  plus(test.employee.deptid, 1)->Column, Column",
          "        │     └─Projection mpp[tiflash]  Column, test.employee.deptid",
          "        │       └─HashAgg mpp[tiflash]  group by:Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.employee.deptid",
          "        │         └─ExchangeReceiver mpp[tiflash]  ",
          "        │           └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary]",
          "        │             └─HashAgg mpp[tiflash]  group by:Column, funcs:count(Column)->Column, funcs:firstrow(Column)->Column",
          "        │               └─Projection mpp[tiflash]  test.employee.empid->Column, test.employee.deptid->Column, plus(test.employee.deptid, 1)->Column",
          "        │                 └─Selection mpp[tiflash]  not(isnull(plus(test.employee.deptid, 1)))",
          "        │                   └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo",
          "        └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "          └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary]",
          "            └─Projection mpp[tiflash]  test.employee.empid, test.employee.deptid, test.employee.salary, cast(test.employee.deptid, bigint(20))->Column",
          "              └─Selection mpp[tiflash]  not(isnull(test.employee.deptid))",
          "                └─TableFullScan mpp[tiflash] table:e1 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "select * from (select deptid+1 d, count(empid) a from employee group by d) e1 join (select deptid+1 d, count(empid) a from employee group by d) e2 on e1.d = e2.d",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─HashJoin mpp[tiflash]  inner join, equal:[eq(Column, Column)]",
          "    ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary]",
          "    │   └─Projection mpp[tiflash]  plus(test.employee.deptid, 1)->Column, Column",
          "    │     └─Projection mpp[tiflash]  Column, test.employee.deptid",
          "    │       └─HashAgg mpp[tiflash]  group by:Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.employee.deptid",
          "    │         └─ExchangeReceiver mpp[tiflash]  ",
          "    │           └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary]",
          "    │             └─HashAgg mpp[tiflash]  group by:Column, funcs:count(Column)->Column, funcs:firstrow(Column)->Column",
          "    │               └─Projection mpp[tiflash]  test.employee.empid->Column, test.employee.deptid->Column, plus(test.employee.deptid, 1)->Column",
          "    │                 └─Selection mpp[tiflash]  not(isnull(plus(test.employee.deptid, 1)))",
          "    │                   └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo",
          "    └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary]",
          "        └─Projection mpp[tiflash]  plus(test.employee.deptid, 1)->Column, Column",
          "          └─Projection mpp[tiflash]  Column, test.employee.deptid",
          "            └─HashAgg mpp[tiflash]  group by:Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.employee.deptid",
          "              └─ExchangeReceiver mpp[tiflash]  ",
          "                └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary]",
          "                  └─HashAgg mpp[tiflash]  group by:Column, funcs:count(Column)->Column, funcs:firstrow(Column)->Column",
          "                    └─Projection mpp[tiflash]  test.employee.empid->Column, test.employee.deptid->Column, plus(test.employee.deptid, 1)->Column",
          "                      └─Selection mpp[tiflash]  not(isnull(plus(test.employee.deptid, 1)))",
          "                        └─TableFullScan mpp[tiflash] table:employee keep order:false, stats:pseudo"
        ]
      }
    ]
  },
  {
    "Name": "TestSemiJoinRewriteHints",
    "Cases": [
      {
        "SQL": "select /*+ SEMI_JOIN_REWRITE() */ * from t",
        "Plan": [
          "TableReader root  data:TableFullScan",
          "└─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warning": "[planner:1815]The SEMI_JOIN_REWRITE hint is not used correctly, maybe it's not in a subquery or the subquery is not IN/EXISTS clause."
      },
      {
        "SQL": "select * from t where a > (select /*+ SEMI_JOIN_REWRITE() */ min(b) from t t1 where t1.c = t.c)",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.c, test.t.c)], other cond:gt(test.t.a, Column)",
          "├─Selection(Build) root  not(isnull(Column))",
          "│ └─HashAgg root  group by:test.t.c, funcs:min(Column)->Column, funcs:firstrow(test.t.c)->test.t.c",
          "│   └─TableReader root  data:HashAgg",
          "│     └─HashAgg cop[tikv]  group by:test.t.c, funcs:min(test.t.b)->Column",
          "│       └─Selection cop[tikv]  not(isnull(test.t.c))",
          "│         └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  data:Selection",
          "  └─Selection cop[tikv]  not(isnull(test.t.a)), not(isnull(test.t.c))",
          "    └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warning": "[planner:1815]The SEMI_JOIN_REWRITE hint is not used correctly, maybe it's not in a subquery or the subquery is not IN/EXISTS clause."
      },
      {
        "SQL": "select * from t where exists (select /*+ SEMI_JOIN_REWRITE() */ 1 from t t1 where t1.a=t.a)",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, test.t.a)]",
          "├─HashAgg(Build) root  group by:test.t.a, funcs:firstrow(test.t.a)->test.t.a",
          "│ └─TableReader root  data:HashAgg",
          "│   └─HashAgg cop[tikv]  group by:test.t.a, ",
          "│     └─Selection cop[tikv]  not(isnull(test.t.a))",
          "│       └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  data:Selection",
          "  └─Selection cop[tikv]  not(isnull(test.t.a))",
          "    └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warning": ""
      },
      {
        "SQL": "select * from t where exists (select /*+ SEMI_JOIN_REWRITE() */ t.b from t t1 where t1.a=t.a)",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, test.t.a)]",
          "├─HashAgg(Build) root  group by:test.t.a, funcs:firstrow(test.t.a)->test.t.a",
          "│ └─TableReader root  data:HashAgg",
          "│   └─HashAgg cop[tikv]  group by:test.t.a, ",
          "│     └─Selection cop[tikv]  not(isnull(test.t.a))",
          "│       └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  data:Selection",
          "  └─Selection cop[tikv]  not(isnull(test.t.a))",
          "    └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warning": ""
      },
      {
        "SQL": "select exists(select /*+ SEMI_JOIN_REWRITE() */ * from t t1 where t1.a=t.a) from t",
        "Plan": [
          "HashJoin root  left outer semi join, left side:TableReader, equal:[eq(test.t.a, test.t.a)]",
          "├─TableReader(Build) root  data:TableFullScan",
          "│ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  data:TableFullScan",
          "  └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warning": "[planner:1815]SEMI_JOIN_REWRITE() is inapplicable for LeftOuterSemiJoin."
      },
      {
        "SQL": "select * from t where exists (select /*+ SEMI_JOIN_REWRITE() */ 1 from t t1 where t1.a > t.a)",
        "Plan": [
          "HashJoin root  CARTESIAN semi join, left side:TableReader, other cond:gt(test.t.a, test.t.a)",
          "├─TableReader(Build) root  data:Selection",
          "│ └─Selection cop[tikv]  not(isnull(test.t.a))",
          "│   └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  data:Selection",
          "  └─Selection cop[tikv]  not(isnull(test.t.a))",
          "    └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warning": "[planner:1815]SEMI_JOIN_REWRITE() is inapplicable for SemiJoin with left conditions or other conditions."
      }
    ]
  },
  {
    "Name": "TestHJBuildAndProbeHint4DynamicPartitionTable",
    "Cases": [
      {
        "SQL": "select /*+ hash_join_build(t2) */ t1.a, t2.a from t1 join t2 on t1.a=t2.a and t1.b=t2.b",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t1.a, test.t2.a) eq(test.t1.b, test.t2.b)]",
          "├─TableReader(Build) root partition:all data:Selection",
          "│ └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "│   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root partition:all data:Selection",
          "  └─Selection cop[tikv]  not(isnull(test.t1.a)), not(isnull(test.t1.b))",
          "    └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Result": [
          "1 1"
        ],
        "Warning": null
      },
      {
        "SQL": "select /*+ hash_join_probe(t2) */ t1.a, t2.a from t1 join t2 on t1.a=t2.a and t1.b=t2.b",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t1.a, test.t2.a) eq(test.t1.b, test.t2.b)]",
          "├─TableReader(Build) root partition:all data:Selection",
          "│ └─Selection cop[tikv]  not(isnull(test.t1.a)), not(isnull(test.t1.b))",
          "│   └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root partition:all data:Selection",
          "  └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "    └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Result": [
          "1 1"
        ],
        "Warning": null
      },
      {
        "SQL": "select /*+ hash_join_build(t1) */ t1.a, t2.a from t1 join t2 on t1.a=t2.a and t1.b=t2.b",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t1.a, test.t2.a) eq(test.t1.b, test.t2.b)]",
          "├─TableReader(Build) root partition:all data:Selection",
          "│ └─Selection cop[tikv]  not(isnull(test.t1.a)), not(isnull(test.t1.b))",
          "│   └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root partition:all data:Selection",
          "  └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "    └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Result": [
          "1 1"
        ],
        "Warning": null
      },
      {
        "SQL": "select /*+ hash_join_probe(t1) */ t1.a, t2.a from t1 join t2 on t1.a=t2.a and t1.b=t2.b",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t1.a, test.t2.a) eq(test.t1.b, test.t2.b)]",
          "├─TableReader(Build) root partition:all data:Selection",
          "│ └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "│   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root partition:all data:Selection",
          "  └─Selection cop[tikv]  not(isnull(test.t1.a)), not(isnull(test.t1.b))",
          "    └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Result": [
          "1 1"
        ],
        "Warning": null
      }
    ]
  },
  {
    "Name": "TestHJBuildAndProbeHint4TiFlash",
    "Cases": [
      {
        "SQL": "select /*+ hash_join_build(t2) */ t1.a, t2.a from t1 join t2 on t1.a=t2.a and t1.b=t2.b",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t1.a, test.t2.a",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t1.a, test.t2.a) eq(test.t1.b, test.t2.b)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "      └─TableFullScan(Probe) mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select /*+ hash_join_probe(t2) */ t1.a, t2.a from t1 join t2 on t1.a=t2.a and t1.b=t2.b",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t1.a, test.t2.a",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t1.a, test.t2.a) eq(test.t1.b, test.t2.b)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "      └─TableFullScan(Probe) mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select /*+ hash_join_build(t1) */ t1.a, t2.a from t1 join t2 on t1.a=t2.a and t1.b=t2.b",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t1.a, test.t2.a",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t1.a, test.t2.a) eq(test.t1.b, test.t2.b)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "      └─TableFullScan(Probe) mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select /*+ hash_join_probe(t1) */ t1.a, t2.a from t1 join t2 on t1.a=t2.a and t1.b=t2.b",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t1.a, test.t2.a",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t1.a, test.t2.a) eq(test.t1.b, test.t2.b)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─TableFullScan mpp[tiflash] table:t2 keep order:false, stats:pseudo",
          "      └─TableFullScan(Probe) mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warning": null
      }
    ]
  },
  {
    "Name": "TestCountStarForTiFlash",
    "Cases": [
      {
        "SQL": "select count(*) from t",
        "Plan": [
          "HashAgg root  funcs:count(Column)->Column",
          "└─TableReader root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─HashAgg mpp[tiflash]  funcs:count(test.t.d)->Column",
          "      └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select count(1), count(3.1415), count(0), count(null) from t -- every count but count(null) can be rewritten",
        "Plan": [
          "HashAgg root  funcs:count(Column)->Column, funcs:count(Column)->Column, funcs:count(Column)->Column, funcs:count(Column)->Column",
          "└─TableReader root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─HashAgg mpp[tiflash]  funcs:count(test.t.d)->Column, funcs:count(test.t.d)->Column, funcs:count(test.t.d)->Column, funcs:count(NULL)->Column",
          "      └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select count(*) from t where a=1",
        "Plan": [
          "StreamAgg root  funcs:count(1)->Column",
          "└─TableReader root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─Selection mpp[tiflash]  eq(test.t.a, 1)",
          "      └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select count(*) from t_pick_row_id",
        "Plan": [
          "HashAgg root  funcs:count(Column)->Column",
          "└─TableReader root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─HashAgg mpp[tiflash]  funcs:count(test.t_pick_row_id._tidb_rowid)->Column",
          "      └─TableFullScan mpp[tiflash] table:t_pick_row_id keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select t.b, t.c from (select count(*) as c from t) a, t where a.c=t.a -- test recursive",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, Column)]",
          "├─HashAgg(Build) root  funcs:count(Column)->Column",
          "│ └─TableReader root  MppVersion: 3, data:ExchangeSender",
          "│   └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "│     └─HashAgg mpp[tiflash]  funcs:count(test.t.d)->Column",
          "│       └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select * from t outTable where outTable.a > (select count(*) from t inn where inn.a = outTable.b) -- shouldn't be rewritten for correlated sub query",
        "Plan": [
          "Projection root  test.t.a, test.t.b, test.t.c, test.t.d, test.t.e, test.t.f, test.t.g, test.t.h",
          "└─Apply root  CARTESIAN inner join, other cond:gt(test.t.a, Column)",
          "  ├─TableReader(Build) root  MppVersion: 3, data:ExchangeSender",
          "  │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  │   └─TableFullScan mpp[tiflash] table:outTable keep order:false, stats:pseudo",
          "  └─HashAgg(Probe) root  funcs:count(Column)->Column",
          "    └─TableReader root  MppVersion: 3, data:ExchangeSender",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "        └─HashAgg mpp[tiflash]  funcs:count(1)->Column",
          "          └─Selection mpp[tiflash]  eq(cast(test.t.a, double BINARY), cast(test.t.b, double BINARY))",
          "            └─TableFullScan mpp[tiflash] table:inn keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select count(*) from t t1, t t2 where t1.a=t2.e -- shouldn't be rewritten when join under agg",
        "Plan": [
          "HashAgg root  funcs:count(Column)->Column",
          "└─TableReader root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─HashAgg mpp[tiflash]  funcs:count(1)->Column",
          "      └─Projection mpp[tiflash]  test.t.a",
          "        └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.e)]",
          "          ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "          │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "          │   └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo",
          "          └─TableFullScan(Probe) mpp[tiflash] table:t2 keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select count(distinct 1) from t -- shouldn't be rewritten",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  Column",
          "    └─HashAgg mpp[tiflash]  funcs:count(distinct Column)->Column",
          "      └─ExchangeReceiver mpp[tiflash]  ",
          "        └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough, Compression: FAST",
          "          └─HashAgg mpp[tiflash]  group by:1, ",
          "            └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select count(1), count(a), count(b) from t -- keep count(1)",
        "Plan": [
          "HashAgg root  funcs:count(Column)->Column, funcs:count(Column)->Column, funcs:count(Column)->Column",
          "└─TableReader root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─HashAgg mpp[tiflash]  funcs:count(1)->Column, funcs:count(test.t.a)->Column, funcs:count(test.t.b)->Column",
          "      └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select a, count(*) from t group by a -- shouldn't be rewritten",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, Column",
          "    └─Projection mpp[tiflash]  Column, test.t.a",
          "      └─HashAgg mpp[tiflash]  group by:test.t.a, funcs:count(1)->Column, funcs:firstrow(test.t.a)->test.t.a",
          "        └─ExchangeReceiver mpp[tiflash]  ",
          "          └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "            └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select sum(a) from t -- sum shouldn't be rewritten",
        "Plan": [
          "HashAgg root  funcs:sum(Column)->Column",
          "└─TableReader root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─HashAgg mpp[tiflash]  funcs:sum(Column)->Column",
          "      └─Projection mpp[tiflash]  cast(test.t.a, decimal(10,0) BINARY)->Column",
          "        └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warning": null
      }
    ]
  },
  {
    "Name": "TestHashAggPushdownToTiFlashCompute",
    "Cases": [
      {
        "SQL": "select  /*+ agg_to_cop() hash_agg() */  avg( distinct  tbl_15.col_96 ) as r0 , min(   tbl_15.col_92 ) as r1 , sum( distinct  tbl_15.col_91 ) as r2 , max(   tbl_15.col_92 ) as r3 from tbl_15 where tbl_15.col_94 != '2033-01-09' and tbl_15.col_93 > 7623.679908049186   order by r0,r1,r2,r3 limit 79 ;",
        "Plan": [
          "Limit root  offset:0, count:79",
          "└─Sort root  Column, Column, Column, Column",
          "  └─HashAgg root  funcs:avg(distinct Column)->Column, funcs:min(Column)->Column, funcs:sum(distinct Column)->Column, funcs:max(Column)->Column",
          "    └─Projection root  cast(test.tbl_15.col_96, decimal(10,0) UNSIGNED BINARY)->Column, Column->Column, cast(test.tbl_15.col_91, decimal(3,0) UNSIGNED BINARY)->Column, Column->Column",
          "      └─PartitionUnion root  ",
          "        ├─TableReader root  MppVersion: 3, data:ExchangeSender",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "        │   └─HashAgg mpp[tiflash]  group by:test.tbl_15.col_91, test.tbl_15.col_96, funcs:firstrow(test.tbl_15.col_96)->test.tbl_15.col_96, funcs:min(Column)->Column, funcs:firstrow(test.tbl_15.col_91)->test.tbl_15.col_91, funcs:max(Column)->Column, funcs:firstrow(test.tbl_15.col_96)->test.tbl_15.col_96, funcs:firstrow(test.tbl_15.col_91)->test.tbl_15.col_91",
          "        │     └─ExchangeReceiver mpp[tiflash]  ",
          "        │       └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.tbl_15.col_96, collate: binary], [name: test.tbl_15.col_91, collate: binary]",
          "        │         └─HashAgg mpp[tiflash]  group by:test.tbl_15.col_91, test.tbl_15.col_96, funcs:min(test.tbl_15.col_92)->Column, funcs:max(test.tbl_15.col_92)->Column",
          "        │           └─Selection mpp[tiflash]  gt(test.tbl_15.col_93, 7623.679908049186), ne(test.tbl_15.col_94, 2033-01-09 00:00:00.000000)",
          "        │             └─TableFullScan mpp[tiflash] table:tbl_15, partition:p0 keep order:false, stats:pseudo",
          "        ├─TableReader root  MppVersion: 3, data:ExchangeSender",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "        │   └─HashAgg mpp[tiflash]  group by:test.tbl_15.col_91, test.tbl_15.col_96, funcs:firstrow(test.tbl_15.col_96)->test.tbl_15.col_96, funcs:min(Column)->Column, funcs:firstrow(test.tbl_15.col_91)->test.tbl_15.col_91, funcs:max(Column)->Column, funcs:firstrow(test.tbl_15.col_96)->test.tbl_15.col_96, funcs:firstrow(test.tbl_15.col_91)->test.tbl_15.col_91",
          "        │     └─ExchangeReceiver mpp[tiflash]  ",
          "        │       └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.tbl_15.col_96, collate: binary], [name: test.tbl_15.col_91, collate: binary]",
          "        │         └─HashAgg mpp[tiflash]  group by:test.tbl_15.col_91, test.tbl_15.col_96, funcs:min(test.tbl_15.col_92)->Column, funcs:max(test.tbl_15.col_92)->Column",
          "        │           └─Selection mpp[tiflash]  gt(test.tbl_15.col_93, 7623.679908049186), ne(test.tbl_15.col_94, 2033-01-09 00:00:00.000000)",
          "        │             └─TableFullScan mpp[tiflash] table:tbl_15, partition:p1 keep order:false, stats:pseudo",
          "        ├─TableReader root  MppVersion: 3, data:ExchangeSender",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "        │   └─HashAgg mpp[tiflash]  group by:test.tbl_15.col_91, test.tbl_15.col_96, funcs:firstrow(test.tbl_15.col_96)->test.tbl_15.col_96, funcs:min(Column)->Column, funcs:firstrow(test.tbl_15.col_91)->test.tbl_15.col_91, funcs:max(Column)->Column, funcs:firstrow(test.tbl_15.col_96)->test.tbl_15.col_96, funcs:firstrow(test.tbl_15.col_91)->test.tbl_15.col_91",
          "        │     └─ExchangeReceiver mpp[tiflash]  ",
          "        │       └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.tbl_15.col_96, collate: binary], [name: test.tbl_15.col_91, collate: binary]",
          "        │         └─HashAgg mpp[tiflash]  group by:test.tbl_15.col_91, test.tbl_15.col_96, funcs:min(test.tbl_15.col_92)->Column, funcs:max(test.tbl_15.col_92)->Column",
          "        │           └─Selection mpp[tiflash]  gt(test.tbl_15.col_93, 7623.679908049186), ne(test.tbl_15.col_94, 2033-01-09 00:00:00.000000)",
          "        │             └─TableFullScan mpp[tiflash] table:tbl_15, partition:p2 keep order:false, stats:pseudo",
          "        └─TableReader root  MppVersion: 3, data:ExchangeSender",
          "          └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "            └─HashAgg mpp[tiflash]  group by:test.tbl_15.col_91, test.tbl_15.col_96, funcs:firstrow(test.tbl_15.col_96)->test.tbl_15.col_96, funcs:min(Column)->Column, funcs:firstrow(test.tbl_15.col_91)->test.tbl_15.col_91, funcs:max(Column)->Column, funcs:firstrow(test.tbl_15.col_96)->test.tbl_15.col_96, funcs:firstrow(test.tbl_15.col_91)->test.tbl_15.col_91",
          "              └─ExchangeReceiver mpp[tiflash]  ",
          "                └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.tbl_15.col_96, collate: binary], [name: test.tbl_15.col_91, collate: binary]",
          "                  └─HashAgg mpp[tiflash]  group by:test.tbl_15.col_91, test.tbl_15.col_96, funcs:min(test.tbl_15.col_92)->Column, funcs:max(test.tbl_15.col_92)->Column",
          "                    └─Selection mpp[tiflash]  gt(test.tbl_15.col_93, 7623.679908049186), ne(test.tbl_15.col_94, 2033-01-09 00:00:00.000000)",
          "                      └─TableFullScan mpp[tiflash] table:tbl_15, partition:p3 keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select  /*+ agg_to_cop() hash_agg() */  count(1) from tbl_15 ;",
        "Plan": [
          "HashAgg root  funcs:count(Column)->Column",
          "└─PartitionUnion root  ",
          "  ├─HashAgg root  funcs:count(Column)->Column",
          "  │ └─TableReader root  MppVersion: 3, data:ExchangeSender",
          "  │   └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  │     └─HashAgg mpp[tiflash]  funcs:count(test.tbl_15.col_91)->Column",
          "  │       └─TableFullScan mpp[tiflash] table:tbl_15, partition:p0 keep order:false, stats:pseudo",
          "  ├─HashAgg root  funcs:count(Column)->Column",
          "  │ └─TableReader root  MppVersion: 3, data:ExchangeSender",
          "  │   └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  │     └─HashAgg mpp[tiflash]  funcs:count(test.tbl_15.col_91)->Column",
          "  │       └─TableFullScan mpp[tiflash] table:tbl_15, partition:p1 keep order:false, stats:pseudo",
          "  ├─HashAgg root  funcs:count(Column)->Column",
          "  │ └─TableReader root  MppVersion: 3, data:ExchangeSender",
          "  │   └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  │     └─HashAgg mpp[tiflash]  funcs:count(test.tbl_15.col_91)->Column",
          "  │       └─TableFullScan mpp[tiflash] table:tbl_15, partition:p2 keep order:false, stats:pseudo",
          "  └─HashAgg root  funcs:count(Column)->Column",
          "    └─TableReader root  MppVersion: 3, data:ExchangeSender",
          "      └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "        └─HashAgg mpp[tiflash]  funcs:count(test.tbl_15.col_91)->Column",
          "          └─TableFullScan mpp[tiflash] table:tbl_15, partition:p3 keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select  /*+ agg_to_cop() stream_agg() */  avg(   tbl_16.col_100 ) as r0 from tbl_16 where tbl_16.col_100 in ( 10672141 ) or tbl_16.col_104 in ( 'yfEG1t!*b' ,'C1*bqx_qyO' ,'vQ^yUpKHr&j#~' ) group by tbl_16.col_100  order by r0 limit 20 ;",
        "Plan": [
          "TopN root  Column, offset:0, count:20",
          "└─HashAgg root  group by:test.tbl_16.col_100, funcs:avg(Column, Column)->Column",
          "  └─PartitionUnion root  ",
          "    ├─StreamAgg root  group by:Column, funcs:count(Column)->Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.tbl_16.col_100",
          "    │ └─Projection root  test.tbl_16.col_100->Column, cast(test.tbl_16.col_100, decimal(8,0) UNSIGNED BINARY)->Column, test.tbl_16.col_100->Column",
          "    │   └─Sort root  test.tbl_16.col_100",
          "    │     └─TableReader root  MppVersion: 3, data:ExchangeSender",
          "    │       └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    │         └─Selection mpp[tiflash]  or(eq(test.tbl_16.col_100, 10672141), in(test.tbl_16.col_104, \"yfEG1t!*b\", \"C1*bqx_qyO\", \"vQ^yUpKHr&j#~\"))",
          "    │           └─TableFullScan mpp[tiflash] table:tbl_16, partition:p0 keep order:false, stats:pseudo",
          "    └─StreamAgg root  group by:Column, funcs:count(Column)->Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.tbl_16.col_100",
          "      └─Projection root  test.tbl_16.col_100->Column, cast(test.tbl_16.col_100, decimal(8,0) UNSIGNED BINARY)->Column, test.tbl_16.col_100->Column",
          "        └─Sort root  test.tbl_16.col_100",
          "          └─TableReader root  MppVersion: 3, data:ExchangeSender",
          "            └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "              └─Selection mpp[tiflash]  or(eq(test.tbl_16.col_100, 10672141), in(test.tbl_16.col_104, \"yfEG1t!*b\", \"C1*bqx_qyO\", \"vQ^yUpKHr&j#~\"))",
          "                └─TableFullScan mpp[tiflash] table:tbl_16, partition:p1 keep order:false, stats:pseudo"
        ],
        "Warning": null
      }
    ]
  },
  {
    "Name": "TestIssues49377Plan",
    "Cases": [
      {
        "SQL": "select 1,1,1 union all ((select * from employee where dept_id = 1)  union all ( select * from employee where dept_id = 1 order by employee_id ) order by 1 );",
        "Plan": [
          "Union root  ",
          "├─Projection root  1->Column, 1->Column, 1->Column",
          "│ └─TableDual root  rows:1",
          "└─Projection root  cast(Column, bigint(11) BINARY)->Column, Column->Column, cast(Column, bigint(11) BINARY)->Column",
          "  └─Sort root  Column",
          "    └─Union root  ",
          "      ├─TableReader root  data:Selection",
          "      │ └─Selection cop[tikv]  eq(test.employee.dept_id, 1)",
          "      │   └─TableFullScan cop[tikv] table:employee keep order:false, stats:pseudo",
          "      └─Sort root  test.employee.employee_id",
          "        └─TableReader root  data:Selection",
          "          └─Selection cop[tikv]  eq(test.employee.dept_id, 1)",
          "            └─TableFullScan cop[tikv] table:employee keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select 1,1,1 union all ((select * from employee where dept_id = 1)  union all ( select * from employee where dept_id = 1 order by employee_id ) order by 1 limit 1);",
        "Plan": [
          "Union root  ",
          "├─Projection root  1->Column, 1->Column, 1->Column",
          "│ └─TableDual root  rows:1",
          "└─Projection root  cast(Column, bigint(11) BINARY)->Column, Column->Column, cast(Column, bigint(11) BINARY)->Column",
          "  └─TopN root  Column, offset:0, count:1",
          "    └─Union root  ",
          "      ├─TopN root  test.employee.employee_id, offset:0, count:1",
          "      │ └─TableReader root  data:TopN",
          "      │   └─TopN cop[tikv]  test.employee.employee_id, offset:0, count:1",
          "      │     └─Selection cop[tikv]  eq(test.employee.dept_id, 1)",
          "      │       └─TableFullScan cop[tikv] table:employee keep order:false, stats:pseudo",
          "      └─TopN root  test.employee.employee_id, offset:0, count:1",
          "        └─TableReader root  data:TopN",
          "          └─TopN cop[tikv]  test.employee.employee_id, offset:0, count:1",
          "            └─Selection cop[tikv]  eq(test.employee.dept_id, 1)",
          "              └─TableFullScan cop[tikv] table:employee keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select * from employee where dept_id = 1 union all ( select * from employee where dept_id = 1 order by employee_id) union all ( select * from employee where dept_id = 1 union all ( select * from employee where dept_id = 1 order by employee_id ) limit 1);",
        "Plan": [
          "Union root  ",
          "├─TableReader root  data:Selection",
          "│ └─Selection cop[tikv]  eq(test.employee.dept_id, 1)",
          "│   └─TableFullScan cop[tikv] table:employee keep order:false, stats:pseudo",
          "├─Sort root  test.employee.employee_id",
          "│ └─TableReader root  data:Selection",
          "│   └─Selection cop[tikv]  eq(test.employee.dept_id, 1)",
          "│     └─TableFullScan cop[tikv] table:employee keep order:false, stats:pseudo",
          "└─Limit root  offset:0, count:1",
          "  └─Union root  ",
          "    ├─Limit root  offset:0, count:1",
          "    │ └─TableReader root  data:Limit",
          "    │   └─Limit cop[tikv]  offset:0, count:1",
          "    │     └─Selection cop[tikv]  eq(test.employee.dept_id, 1)",
          "    │       └─TableFullScan cop[tikv] table:employee keep order:false, stats:pseudo",
          "    └─TopN root  test.employee.employee_id, offset:0, count:1",
          "      └─TableReader root  data:TopN",
          "        └─TopN cop[tikv]  test.employee.employee_id, offset:0, count:1",
          "          └─Selection cop[tikv]  eq(test.employee.dept_id, 1)",
          "            └─TableFullScan cop[tikv] table:employee keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "select * from employee where dept_id = 1 union all ( select * from employee where dept_id = 1 order by employee_id) union all ( select * from employee where dept_id = 1 union all ( select * from employee where dept_id = 1 order by employee_id ) order by 1 limit 1);",
        "Plan": [
          "Union root  ",
          "├─TableReader root  data:Selection",
          "│ └─Selection cop[tikv]  eq(test.employee.dept_id, 1)",
          "│   └─TableFullScan cop[tikv] table:employee keep order:false, stats:pseudo",
          "├─Sort root  test.employee.employee_id",
          "│ └─TableReader root  data:Selection",
          "│   └─Selection cop[tikv]  eq(test.employee.dept_id, 1)",
          "│     └─TableFullScan cop[tikv] table:employee keep order:false, stats:pseudo",
          "└─TopN root  Column, offset:0, count:1",
          "  └─Union root  ",
          "    ├─TopN root  test.employee.employee_id, offset:0, count:1",
          "    │ └─TableReader root  data:TopN",
          "    │   └─TopN cop[tikv]  test.employee.employee_id, offset:0, count:1",
          "    │     └─Selection cop[tikv]  eq(test.employee.dept_id, 1)",
          "    │       └─TableFullScan cop[tikv] table:employee keep order:false, stats:pseudo",
          "    └─TopN root  test.employee.employee_id, offset:0, count:1",
          "      └─TableReader root  data:TopN",
          "        └─TopN cop[tikv]  test.employee.employee_id, offset:0, count:1",
          "          └─Selection cop[tikv]  eq(test.employee.dept_id, 1)",
          "            └─TableFullScan cop[tikv] table:employee keep order:false, stats:pseudo"
        ],
        "Warning": null
      }
    ]
  },
  {
    "Name": "TestPointgetIndexChoosen",
    "Cases": [
      {
        "SQL": "select * from t where b=1 and c='1';",
        "Plan": [
          "Point_Get root table:t, index:ubc(b, c) "
        ],
        "Warning": null
      },
      {
        "SQL": "select * from t where b=1 and c='1' and d='1';",
        "Plan": [
          "Selection root  eq(test.t.d, \"1\")",
          "└─Point_Get root table:t, index:ubc(b, c) "
        ],
        "Warning": null
      },
      {
        "SQL": "select * from t where b in (1,2,3) and c in ('1');",
        "Plan": [
          "Batch_Point_Get root table:t, index:ubc(b, c) keep order:false, desc:false"
        ],
        "Warning": null
      }
    ]
  },
  {
    "Name": "TestAlwaysTruePredicateWithSubquery",
    "Cases": [
      {
        "SQL": "SHOW ERRORS WHERE TRUE = ALL ( SELECT TRUE GROUP BY 1 LIMIT 1 ) IS NULL IS NOT NULL;",
        "Plan": null,
        "Warning": null
      },
      {
        "SQL": "explain format = 'plan_tree' select * from t WHERE TRUE = ALL ( SELECT TRUE GROUP BY 1 LIMIT 1 ) IS NULL IS NOT NULL;",
        "Plan": [
          "HashJoin root  CARTESIAN inner join",
          "├─StreamAgg(Build) root  funcs:count(1)->Column",
          "│ └─Limit root  offset:0, count:1",
          "│   └─HashAgg root  group by:1, funcs:firstrow(1)->Column",
          "│     └─TableDual root  rows:1",
          "└─TableReader(Probe) root  data:TableFullScan",
          "  └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "explain format = 'plan_tree' select * from t WHERE TRUE = ALL ( SELECT TRUE from t GROUP BY 1 LIMIT 1 ) is null is not null;",
        "Plan": [
          "HashJoin root  CARTESIAN inner join",
          "├─StreamAgg(Build) root  funcs:count(1)->Column",
          "│ └─Limit root  offset:0, count:1",
          "│   └─HashAgg root  group by:Column, funcs:firstrow(Column)->Column",
          "│     └─TableReader root  data:HashAgg",
          "│       └─HashAgg cop[tikv]  group by:1, funcs:firstrow(1)->Column",
          "│         └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  data:TableFullScan",
          "  └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warning": null
      }
    ]
  },
  {
    "Name": "TestExplainExpand",
    "Cases": [
      {
        "SQL": "explain format = 'plan_tree' select count(1) from t group by a, b with rollup; -- 1. simple agg",
        "Plan": [
          "HashAgg root  group by:Column, Column, gid, funcs:count(1)->Column",
          "└─Expand root  level-projection:[<nil>->Column, <nil>->Column, 0->gid],[Column, <nil>->Column, 1->gid],[Column, Column, 3->gid]; schema: [Column,Column,gid]",
          "  └─TableReader root  data:TableFullScan",
          "    └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "explain format = 'plan_tree' select sum(c), count(1) from t group by a, b with rollup; -- 2. non-grouping set col c",
        "Plan": [
          "HashAgg root  group by:Column, Column, Column, funcs:sum(Column)->Column, funcs:count(1)->Column",
          "└─Projection root  cast(test.t.c, decimal(10,0) BINARY)->Column, Column->Column, Column->Column, gid->Column",
          "  └─Expand root  level-projection:[test.t.c, <nil>->Column, <nil>->Column, 0->gid],[test.t.c, Column, <nil>->Column, 1->gid],[test.t.c, Column, Column, 3->gid]; schema: [test.t.c,Column,Column,gid]",
          "    └─Projection root  test.t.c, test.t.a->Column, test.t.b->Column",
          "      └─TableReader root  data:TableFullScan",
          "        └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "explain format = 'plan_tree' select count(a) from t group by a, b with rollup; -- 3. should keep the original col a",
        "Plan": [
          "HashAgg root  group by:Column, Column, gid, funcs:count(test.t.a)->Column",
          "└─Expand root  level-projection:[test.t.a, <nil>->Column, <nil>->Column, 0->gid],[test.t.a, Column, <nil>->Column, 1->gid],[test.t.a, Column, Column, 3->gid]; schema: [test.t.a,Column,Column,gid]",
          "  └─Projection root  test.t.a, test.t.a->Column, test.t.b->Column",
          "    └─TableReader root  data:TableFullScan",
          "      └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "explain format = 'plan_tree' select grouping(a) from t group by a, b with rollup; -- 4. contain grouping function ref to grouping set column a",
        "Plan": [
          "Projection root  grouping(gid)->Column",
          "└─HashAgg root  group by:Column, Column, gid, funcs:firstrow(gid)->gid",
          "  └─Expand root  level-projection:[<nil>->Column, <nil>->Column, 0->gid],[Column, <nil>->Column, 1->gid],[Column, Column, 3->gid]; schema: [Column,Column,gid]",
          "    └─TableReader root  data:TableFullScan",
          "      └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "explain format = 'plan_tree' select grouping(a,b) from t group by a, b with rollup; -- 5. grouping function contains grouping set column a,c",
        "Plan": [
          "Projection root  grouping(gid)->Column",
          "└─HashAgg root  group by:Column, Column, gid, funcs:firstrow(gid)->gid",
          "  └─Expand root  level-projection:[<nil>->Column, <nil>->Column, 0->gid],[Column, <nil>->Column, 1->gid],[Column, Column, 3->gid]; schema: [Column,Column,gid]",
          "    └─TableReader root  data:TableFullScan",
          "      └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "explain format = 'plan_tree' select a, grouping(b,a) from t group by a,b with rollup; -- 6. resolve normal column a to grouping set column a'",
        "Plan": [
          "Projection root  Column->Column, grouping(gid)->Column",
          "└─HashAgg root  group by:Column, Column, gid, funcs:firstrow(Column)->Column, funcs:firstrow(gid)->gid",
          "  └─Expand root  level-projection:[<nil>->Column, <nil>->Column, 0->gid],[Column, <nil>->Column, 1->gid],[Column, Column, 3->gid]; schema: [Column,Column,gid]",
          "    └─TableReader root  data:TableFullScan",
          "      └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "explain format = 'plan_tree' select a+1, grouping(b) from t group by a+1, b with rollup; -- 7. resolve field list a+1 to grouping set column a+1",
        "Plan": [
          "Projection root  Column->Column, grouping(gid)->Column",
          "└─HashAgg root  group by:Column, Column, gid, funcs:firstrow(Column)->Column, funcs:firstrow(gid)->gid",
          "  └─Expand root  level-projection:[<nil>->Column, <nil>->Column, 0->gid],[Column, <nil>->Column, 1->gid],[Column, Column, 3->gid]; schema: [Column,Column,gid]",
          "    └─Projection root  plus(test.t.a, 1)->Column, test.t.b->Column",
          "      └─TableReader root  data:TableFullScan",
          "        └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "explain format = 'plan_tree' SELECT SUM(profit) AS profit FROM sales GROUP BY year+2, year+profit WITH ROLLUP order by year+2; -- 8. order by item year+2 resolve to gby grouping expression",
        "Plan": [
          "Projection root  Column",
          "└─Sort root  Column",
          "  └─HashAgg root  group by:Column, Column, Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->Column",
          "    └─Projection root  cast(test.sales.profit, decimal(10,0) BINARY)->Column, Column->Column, Column->Column, gid->Column",
          "      └─Expand root  level-projection:[test.sales.profit, <nil>->Column, <nil>->Column, 0->gid],[test.sales.profit, Column, <nil>->Column, 1->gid],[test.sales.profit, Column, Column, 3->gid]; schema: [test.sales.profit,Column,Column,gid]",
          "        └─Projection root  test.sales.profit, plus(test.sales.year, 2)->Column, plus(test.sales.year, test.sales.profit)->Column",
          "          └─TableReader root  data:TableFullScan",
          "            └─TableFullScan cop[tikv] table:sales keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "explain format = 'plan_tree' SELECT year+2, SUM(profit) AS profit FROM sales GROUP BY year+2, year+profit WITH ROLLUP order by year+2; -- 9. order by item year+2 resolve to select field",
        "Plan": [
          "Projection root  Column->Column, Column",
          "└─Sort root  Column",
          "  └─HashAgg root  group by:Column, Column, Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->Column",
          "    └─Projection root  cast(test.sales.profit, decimal(10,0) BINARY)->Column, Column->Column, Column->Column, gid->Column",
          "      └─Expand root  level-projection:[test.sales.profit, <nil>->Column, <nil>->Column, 0->gid],[test.sales.profit, Column, <nil>->Column, 1->gid],[test.sales.profit, Column, Column, 3->gid]; schema: [test.sales.profit,Column,Column,gid]",
          "        └─Projection root  test.sales.profit, plus(test.sales.year, 2)->Column, plus(test.sales.year, test.sales.profit)->Column",
          "          └─TableReader root  data:TableFullScan",
          "            └─TableFullScan cop[tikv] table:sales keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "explain format = 'plan_tree' SELECT year+2 as y, SUM(profit) as profit FROM sales GROUP BY year+2, year+profit WITH ROLLUP having y > 2002 order by year+2, profit; -- 10. having (year+2) shouldn't be pushed down",
        "Plan": [
          "Projection root  Column, Column",
          "└─Sort root  Column, Column",
          "  └─HashAgg root  group by:Column, Column, Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->Column",
          "    └─Projection root  cast(test.sales.profit, decimal(10,0) BINARY)->Column, Column->Column, Column->Column, gid->Column",
          "      └─Selection root  gt(Column, 2002)",
          "        └─Expand root  level-projection:[test.sales.profit, <nil>->Column, <nil>->Column, 0->gid],[test.sales.profit, Column, <nil>->Column, 1->gid],[test.sales.profit, Column, Column, 3->gid]; schema: [test.sales.profit,Column,Column,gid]",
          "          └─Projection root  test.sales.profit, plus(test.sales.year, 2)->Column, plus(test.sales.year, test.sales.profit)->Column",
          "            └─TableReader root  data:TableFullScan",
          "              └─TableFullScan cop[tikv] table:sales keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "explain format = 'plan_tree' SELECT year+2 as y, SUM(profit) AS profit, grouping(year+2) FROM sales GROUP BY year+2, year+profit WITH ROLLUP having y > 2002 order by year+2, profit; -- 11. grouping function validation",
        "Plan": [
          "Sort root  Column, Column",
          "└─Projection root  Column, Column, grouping(gid)->Column",
          "  └─HashAgg root  group by:Column, Column, Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->gid",
          "    └─Projection root  cast(test.sales.profit, decimal(10,0) BINARY)->Column, Column->Column, gid->Column, Column->Column",
          "      └─Selection root  gt(Column, 2002)",
          "        └─Expand root  level-projection:[test.sales.profit, <nil>->Column, <nil>->Column, 0->gid],[test.sales.profit, Column, <nil>->Column, 1->gid],[test.sales.profit, Column, Column, 3->gid]; schema: [test.sales.profit,Column,Column,gid]",
          "          └─Projection root  test.sales.profit, plus(test.sales.year, 2)->Column, plus(test.sales.year, test.sales.profit)->Column",
          "            └─TableReader root  data:TableFullScan",
          "              └─TableFullScan cop[tikv] table:sales keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "explain format = 'plan_tree' SELECT year, country, product, SUM(profit) AS profit FROM sales GROUP BY year, country, product with rollup order by grouping(year); -- 12. grouping function in order by clause",
        "Plan": [
          "Projection root  Column, Column->Column, Column->Column, Column",
          "└─Projection root  Column, Column, Column, Column, gid",
          "  └─Sort root  Column",
          "    └─Projection root  Column, Column, Column, Column, gid, grouping(gid)->Column",
          "      └─HashAgg root  group by:Column, Column, Column, Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->gid",
          "        └─Projection root  cast(test.sales.profit, decimal(10,0) BINARY)->Column, Column->Column, Column->Column, Column->Column, gid->Column",
          "          └─Expand root  level-projection:[test.sales.profit, <nil>->Column, <nil>->Column, <nil>->Column, 0->gid],[test.sales.profit, Column, <nil>->Column, <nil>->Column, 1->gid],[test.sales.profit, Column, Column, <nil>->Column, 3->gid],[test.sales.profit, Column, Column, Column, 7->gid]; schema: [test.sales.profit,Column,Column,Column,gid]",
          "            └─Projection root  test.sales.profit, test.sales.year->Column, test.sales.country->Column, test.sales.product->Column",
          "              └─TableReader root  data:TableFullScan",
          "                └─TableFullScan cop[tikv] table:sales keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "explain format = 'plan_tree' SELECT country, product, SUM(profit) AS profit FROM sales GROUP BY country, country, product with rollup order by grouping(country); -- 13. 12 under gpos case",
        "Plan": [
          "Projection root  Column, Column->Column, Column",
          "└─Projection root  Column, Column, Column, gid",
          "  └─Sort root  Column",
          "    └─Projection root  Column, Column, Column, gid, grouping(gid)->Column",
          "      └─HashAgg root  group by:Column, Column, Column, Column, Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->gid",
          "        └─Projection root  cast(test.sales.profit, decimal(10,0) BINARY)->Column, Column->Column, Column->Column, gid->Column, gpos->Column",
          "          └─Expand root  level-projection:[test.sales.profit, <nil>->Column, <nil>->Column, 0->gid, 0->gpos],[test.sales.profit, Column, <nil>->Column, 1->gid, 1->gpos],[test.sales.profit, Column, <nil>->Column, 1->gid, 2->gpos],[test.sales.profit, Column, Column, 3->gid, 3->gpos]; schema: [test.sales.profit,Column,Column,gid,gpos]",
          "            └─Projection root  test.sales.profit, test.sales.country->Column, test.sales.product->Column",
          "              └─TableReader root  data:TableFullScan",
          "                └─TableFullScan cop[tikv] table:sales keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "explain format = 'plan_tree' SELECT year, country, product, SUM(profit) AS profit FROM sales GROUP BY year, country, product with rollup having grouping(year) > 0 order by grouping(year); -- 14. grouping function in having clause",
        "Plan": [
          "Projection root  Column, Column->Column, Column->Column, Column",
          "└─Projection root  Column, Column, Column, Column, gid",
          "  └─Sort root  Column",
          "    └─Projection root  Column, Column, Column, Column, gid, grouping(gid)->Column",
          "      └─HashAgg root  group by:Column, Column, Column, Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->gid",
          "        └─Projection root  cast(test.sales.profit, decimal(10,0) BINARY)->Column, Column->Column, Column->Column, Column->Column, gid->Column",
          "          └─Selection root  gt(grouping(gid), 0)",
          "            └─Expand root  level-projection:[test.sales.profit, <nil>->Column, <nil>->Column, <nil>->Column, 0->gid],[test.sales.profit, Column, <nil>->Column, <nil>->Column, 1->gid],[test.sales.profit, Column, Column, <nil>->Column, 3->gid],[test.sales.profit, Column, Column, Column, 7->gid]; schema: [test.sales.profit,Column,Column,Column,gid]",
          "              └─Projection root  test.sales.profit, test.sales.year->Column, test.sales.country->Column, test.sales.product->Column",
          "                └─TableReader root  data:TableFullScan",
          "                  └─TableFullScan cop[tikv] table:sales keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "explain format = 'plan_tree' SELECT country, product, SUM(profit) AS profit FROM sales GROUP BY country, country, product with rollup having grouping(country) > 0 order by grouping(country); -- 15. 14 under gpos case",
        "Plan": [
          "Projection root  Column, Column->Column, Column",
          "└─Projection root  Column, Column, Column, gid",
          "  └─Sort root  Column",
          "    └─Projection root  Column, Column, Column, gid, grouping(gid)->Column",
          "      └─HashAgg root  group by:Column, Column, Column, Column, Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->gid",
          "        └─Projection root  cast(test.sales.profit, decimal(10,0) BINARY)->Column, Column->Column, Column->Column, gid->Column, gpos->Column",
          "          └─Selection root  gt(grouping(gid), 0)",
          "            └─Expand root  level-projection:[test.sales.profit, <nil>->Column, <nil>->Column, 0->gid, 0->gpos],[test.sales.profit, Column, <nil>->Column, 1->gid, 1->gpos],[test.sales.profit, Column, <nil>->Column, 1->gid, 2->gpos],[test.sales.profit, Column, Column, 3->gid, 3->gpos]; schema: [test.sales.profit,Column,Column,gid,gpos]",
          "              └─Projection root  test.sales.profit, test.sales.country->Column, test.sales.product->Column",
          "                └─TableReader root  data:TableFullScan",
          "                  └─TableFullScan cop[tikv] table:sales keep order:false, stats:pseudo"
        ],
        "Warning": null
      },
      {
        "SQL": "explain format = 'plan_tree' SELECT year, country, product, grouping(year, country, product) from sales group by year, country, product with rollup having grouping(year, country, product) <> 0; -- 16. grouping function recreating fix",
        "Plan": [
          "Projection root  Column->Column, Column->Column, Column->Column, grouping(gid)->Column",
          "└─HashAgg root  group by:Column, Column, Column, gid, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column, funcs:firstrow(gid)->gid",
          "  └─Selection root  ne(grouping(gid), 0)",
          "    └─Expand root  level-projection:[<nil>->Column, <nil>->Column, <nil>->Column, 0->gid],[Column, <nil>->Column, <nil>->Column, 1->gid],[Column, Column, <nil>->Column, 3->gid],[Column, Column, Column, 7->gid]; schema: [Column,Column,Column,gid]",
          "      └─TableReader root  data:TableFullScan",
          "        └─TableFullScan cop[tikv] table:sales keep order:false, stats:pseudo"
        ],
        "Warning": null
      }
    ]
  },
  {
    "Name": "TestLimitPushdown",
    "Cases": [
      {
        "SQL": "select /*+ use_index(t1, c1) */ * from t1 order by c1 limit 200;",
        "Plan": [
          "Projection root  test.t1.c1, test.t1.c2",
          "└─IndexLookUp root  limit embedded(offset:0, count:200)",
          "  ├─Limit(Build) cop[tikv]  offset:0, count:200",
          "  │ └─IndexFullScan cop[tikv] table:t1, index:c1(c1) keep order:true",
          "  └─TableRowIDScan(Probe) cop[tikv] table:t1 keep order:false"
        ],
        "Warn": null
      }
    ]
  }
]
