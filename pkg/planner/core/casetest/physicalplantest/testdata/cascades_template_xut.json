[
  {
    "Name": "TestRuleAggElimination4Join",
    "Cases": [
      {
        "SQL": "SELECT t1.id1, t1.id2, SUM(t1.id3)  FROM t1, t2  WHERE t1.id1=t2.id1 AND t1.id2=t2.id2  GROUP BY t1.id1, t1.id2;",
        "Plan": [
<<<<<<< HEAD
          "Projection root  test.t1.id1, test.t1.id2, Column#13",
          "└─Projection root  cast(test.t1.id3, decimal(32,0) BINARY)->Column#13, test.t1.id1, test.t1.id2",
=======
          "Projection root  test.t1.id1, test.t1.id2, Column",
          "└─Projection root  cast(test.t1.id3, decimal(32,0) BINARY)->Column, test.t1.id1, test.t1.id2",
>>>>>>> master
          "  └─HashJoin root  inner join, equal:[eq(test.t1.id1, test.t2.id1) eq(test.t1.id2, test.t2.id2)]",
          "    ├─IndexReader(Build) root  index:IndexFullScan",
          "    │ └─IndexFullScan cop[tikv] table:t2, index:UK_id1_id2(id1, id2) keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:TableFullScan",
          "      └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "SELECT t1.id1, t1.id2, SUM(t1.id3)  FROM t1, t4  WHERE t1.id1=t4.id1 AND t1.id2=t4.id2  GROUP BY t1.id1, t1.id2;",
        "Plan": [
<<<<<<< HEAD
          "Projection root  test.t1.id1, test.t1.id2, Column#13",
          "└─HashAgg root  group by:Column#18, Column#19, funcs:sum(Column#17)->Column#13, funcs:firstrow(Column#18)->test.t1.id1, funcs:firstrow(Column#19)->test.t1.id2",
          "  └─Projection root  cast(test.t1.id3, decimal(10,0) BINARY)->Column#17, test.t1.id1->Column#18, test.t1.id2->Column#19",
=======
          "Projection root  test.t1.id1, test.t1.id2, Column",
          "└─HashAgg root  group by:Column, Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.t1.id1, funcs:firstrow(Column)->test.t1.id2",
          "  └─Projection root  cast(test.t1.id3, decimal(10,0) BINARY)->Column, test.t1.id1->Column, test.t1.id2->Column",
>>>>>>> master
          "    └─HashJoin root  inner join, equal:[eq(test.t1.id1, test.t4.id1) eq(test.t1.id2, test.t4.id2)]",
          "      ├─IndexReader(Build) root  index:IndexFullScan",
          "      │ └─IndexFullScan cop[tikv] table:t4, index:UK_id1_id2(id1, id2) keep order:false, stats:pseudo",
          "      └─TableReader(Probe) root  data:TableFullScan",
          "        └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "SELECT t1.id1, t1.id2, COUNT(t1.id3) FROM t1, t2 WHERE t1.id1 = t2.id1 GROUP BY t1.id1, t1.id2;",
        "Plan": [
<<<<<<< HEAD
          "Projection root  test.t1.id1, test.t1.id2, Column#13",
          "└─HashAgg root  group by:test.t1.id1, test.t1.id2, funcs:count(test.t1.id3)->Column#13, funcs:firstrow(test.t1.id1)->test.t1.id1, funcs:firstrow(test.t1.id2)->test.t1.id2",
=======
          "Projection root  test.t1.id1, test.t1.id2, Column",
          "└─HashAgg root  group by:test.t1.id1, test.t1.id2, funcs:count(test.t1.id3)->Column, funcs:firstrow(test.t1.id1)->test.t1.id1, funcs:firstrow(test.t1.id2)->test.t1.id2",
>>>>>>> master
          "  └─HashJoin root  inner join, equal:[eq(test.t1.id1, test.t2.id1)]",
          "    ├─IndexReader(Build) root  index:IndexFullScan",
          "    │ └─IndexFullScan cop[tikv] table:t2, index:UK_id1_id2(id1, id2) keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:TableFullScan",
          "      └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "SELECT t1.id1, t1.id2, COUNT(t1.id3) FROM t1, t2, t3 WHERE t1.id1=t2.id1 AND t1.id2=t2.id2   AND t2.id1=t3.id1 AND t2.id2=t3.id2 GROUP BY t1.id1, t1.id2;",
        "Plan": [
<<<<<<< HEAD
          "Projection root  test.t1.id1, test.t1.id2, Column#19",
          "└─Projection root  1->Column#19, test.t1.id1, test.t1.id2",
=======
          "Projection root  test.t1.id1, test.t1.id2, Column",
          "└─Projection root  1->Column, test.t1.id1, test.t1.id2",
>>>>>>> master
          "  └─HashJoin root  inner join, equal:[eq(test.t2.id1, test.t3.id1) eq(test.t2.id2, test.t3.id2)]",
          "    ├─IndexReader(Build) root  index:IndexFullScan",
          "    │ └─IndexFullScan cop[tikv] table:t3, index:UK_id1_id2(id1, id2) keep order:false, stats:pseudo",
          "    └─HashJoin(Probe) root  inner join, equal:[eq(test.t1.id1, test.t2.id1) eq(test.t1.id2, test.t2.id2)]",
          "      ├─IndexReader(Build) root  index:IndexFullScan",
          "      │ └─IndexFullScan cop[tikv] table:t2, index:UK_id1_id2(id1, id2) keep order:false, stats:pseudo",
          "      └─TableReader(Probe) root  data:TableFullScan",
          "        └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "SELECT t1.id1, t1.id2, COUNT(t1.id3) FROM t1, t2, t4 WHERE t1.id1=t2.id1 AND t1.id2=t2.id2   AND t2.id1=t4.id1 AND t2.id2=t4.id2 GROUP BY t1.id1, t1.id2;",
        "Plan": [
<<<<<<< HEAD
          "Projection root  test.t1.id1, test.t1.id2, Column#19",
          "└─HashAgg root  group by:test.t1.id1, test.t1.id2, funcs:count(test.t1.id3)->Column#19, funcs:firstrow(test.t1.id1)->test.t1.id1, funcs:firstrow(test.t1.id2)->test.t1.id2",
=======
          "Projection root  test.t1.id1, test.t1.id2, Column",
          "└─HashAgg root  group by:test.t1.id1, test.t1.id2, funcs:count(test.t1.id3)->Column, funcs:firstrow(test.t1.id1)->test.t1.id1, funcs:firstrow(test.t1.id2)->test.t1.id2",
>>>>>>> master
          "  └─HashJoin root  inner join, equal:[eq(test.t2.id1, test.t4.id1) eq(test.t2.id2, test.t4.id2)]",
          "    ├─IndexReader(Build) root  index:IndexFullScan",
          "    │ └─IndexFullScan cop[tikv] table:t4, index:UK_id1_id2(id1, id2) keep order:false, stats:pseudo",
          "    └─HashJoin(Probe) root  inner join, equal:[eq(test.t1.id1, test.t2.id1) eq(test.t1.id2, test.t2.id2)]",
          "      ├─IndexReader(Build) root  index:IndexFullScan",
          "      │ └─IndexFullScan cop[tikv] table:t2, index:UK_id1_id2(id1, id2) keep order:false, stats:pseudo",
          "      └─TableReader(Probe) root  data:TableFullScan",
          "        └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "SELECT t1.id1, t1.id2, COUNT(t1.id3) FROM t1, t2, t3, t4 WHERE t1.id1=t2.id1 AND t1.id2=t2.id2   AND t2.id1=t3.id1 AND t2.id2=t3.id2 AND t3.id1=t4.id1 AND t3.id2=t4.id2 GROUP BY t1.id1, t1.id2;",
        "Plan": [
<<<<<<< HEAD
          "Projection root  test.t1.id1, test.t1.id2, Column#25",
          "└─HashAgg root  group by:test.t1.id1, test.t1.id2, funcs:count(test.t1.id3)->Column#25, funcs:firstrow(test.t1.id1)->test.t1.id1, funcs:firstrow(test.t1.id2)->test.t1.id2",
=======
          "Projection root  test.t1.id1, test.t1.id2, Column",
          "└─HashAgg root  group by:test.t1.id1, test.t1.id2, funcs:count(test.t1.id3)->Column, funcs:firstrow(test.t1.id1)->test.t1.id1, funcs:firstrow(test.t1.id2)->test.t1.id2",
>>>>>>> master
          "  └─MergeJoin root  inner join, left key:test.t3.id1, test.t3.id2, right key:test.t4.id1, test.t4.id2",
          "    ├─IndexReader(Build) root  index:IndexFullScan",
          "    │ └─IndexFullScan cop[tikv] table:t4, index:UK_id1_id2(id1, id2) keep order:true, stats:pseudo",
          "    └─MergeJoin(Probe) root  inner join, left key:test.t2.id1, test.t2.id2, right key:test.t3.id1, test.t3.id2",
          "      ├─IndexReader(Build) root  index:IndexFullScan",
          "      │ └─IndexFullScan cop[tikv] table:t3, index:UK_id1_id2(id1, id2) keep order:true, stats:pseudo",
          "      └─IndexHashJoin(Probe) root  inner join, inner:IndexLookUp, outer key:test.t2.id1, test.t2.id2, inner key:test.t1.id1, test.t1.id2, equal cond:eq(test.t2.id1, test.t1.id1), eq(test.t2.id2, test.t1.id2)",
          "        ├─IndexReader(Build) root  index:IndexFullScan",
          "        │ └─IndexFullScan cop[tikv] table:t2, index:UK_id1_id2(id1, id2) keep order:true, stats:pseudo",
          "        └─IndexLookUp(Probe) root  ",
          "          ├─IndexRangeScan(Build) cop[tikv] table:t1, index:UK_id1_id2(id1, id2) range: decided by [eq(test.t1.id1, test.t2.id1) eq(test.t1.id2, test.t2.id2)], keep order:false, stats:pseudo",
          "          └─TableRowIDScan(Probe) cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "SELECT t1.id1, t1.id2, COUNT(t1.id3) FROM t1, t2 WHERE ABS(t1.id1) = t2.id1 AND t1.id2 = t2.id2 GROUP BY t1.id1, t1.id2;",
        "Plan": [
<<<<<<< HEAD
          "Projection root  test.t1.id1, test.t1.id2, Column#13",
          "└─Projection root  1->Column#13, test.t1.id1, test.t1.id2",
          "  └─HashJoin root  inner join, equal:[eq(test.t2.id2, test.t1.id2) eq(test.t2.id1, Column#14)]",
          "    ├─Projection(Build) root  test.t1.id1, test.t1.id2, abs(test.t1.id1)->Column#14",
=======
          "Projection root  test.t1.id1, test.t1.id2, Column",
          "└─Projection root  1->Column, test.t1.id1, test.t1.id2",
          "  └─HashJoin root  inner join, equal:[eq(test.t2.id2, test.t1.id2) eq(test.t2.id1, Column)]",
          "    ├─Projection(Build) root  test.t1.id1, test.t1.id2, abs(test.t1.id1)->Column",
>>>>>>> master
          "    │ └─TableReader root  data:TableFullScan",
          "    │   └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "    └─IndexReader(Probe) root  index:IndexFullScan",
          "      └─IndexFullScan cop[tikv] table:t2, index:UK_id1_id2(id1, id2) keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "SELECT t1.id1, t1.id2, COUNT(t1.id3) FROM t1, t2 WHERE t1.id1 = ABS(t2.id1) AND t1.id2 = t2.id2 GROUP BY t1.id1, t1.id2;",
        "Plan": [
<<<<<<< HEAD
          "Projection root  test.t1.id1, test.t1.id2, Column#13",
          "└─HashAgg root  group by:test.t1.id1, test.t1.id2, funcs:count(test.t1.id3)->Column#13, funcs:firstrow(test.t1.id1)->test.t1.id1, funcs:firstrow(test.t1.id2)->test.t1.id2",
          "  └─HashJoin root  inner join, equal:[eq(test.t1.id2, test.t2.id2) eq(test.t1.id1, Column#14)]",
          "    ├─Projection(Build) root  test.t2.id2, abs(test.t2.id1)->Column#14",
=======
          "Projection root  test.t1.id1, test.t1.id2, Column",
          "└─HashAgg root  group by:test.t1.id1, test.t1.id2, funcs:count(test.t1.id3)->Column, funcs:firstrow(test.t1.id1)->test.t1.id1, funcs:firstrow(test.t1.id2)->test.t1.id2",
          "  └─HashJoin root  inner join, equal:[eq(test.t1.id2, test.t2.id2) eq(test.t1.id1, Column)]",
          "    ├─Projection(Build) root  test.t2.id2, abs(test.t2.id1)->Column",
>>>>>>> master
          "    │ └─IndexReader root  index:IndexFullScan",
          "    │   └─IndexFullScan cop[tikv] table:t2, index:UK_id1_id2(id1, id2) keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:TableFullScan",
          "      └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "SELECT t1.id1, t1.id2, SUM(t1.id3) FROM t1 WHERE EXISTS ( SELECT 1 FROM t2 WHERE t1.id1=t2.id1 AND t1.id2=t2.id2 ) GROUP BY t1.id1, t1.id2;",
        "Plan": [
<<<<<<< HEAD
          "Projection root  test.t1.id1, test.t1.id2, cast(test.t1.id3, decimal(32,0) BINARY)->Column#14",
=======
          "Projection root  test.t1.id1, test.t1.id2, cast(test.t1.id3, decimal(32,0) BINARY)->Column",
>>>>>>> master
          "└─HashJoin root  semi join, left side:TableReader, equal:[eq(test.t1.id1, test.t2.id1) eq(test.t1.id2, test.t2.id2)]",
          "  ├─IndexReader(Build) root  index:IndexFullScan",
          "  │ └─IndexFullScan cop[tikv] table:t2, index:UK_id1_id2(id1, id2) keep order:false, stats:pseudo",
          "  └─TableReader(Probe) root  data:TableFullScan",
          "    └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "SELECT t1.id1, t1.id2, COUNT(t1.id3) FROM t1 left join t2 on t1.id1 = t2.id1 and t1.id2 = t2.id2  inner join t3 on t1.id1 = t3.id1 and t1.id2 = t3.id2 GROUP BY t1.id1, t1.id2;",
        "Plan": [
<<<<<<< HEAD
          "Projection root  test.t1.id1, test.t1.id2, Column#19",
          "└─Projection root  1->Column#19, test.t1.id1, test.t1.id2",
=======
          "Projection root  test.t1.id1, test.t1.id2, Column",
          "└─Projection root  1->Column, test.t1.id1, test.t1.id2",
>>>>>>> master
          "  └─HashJoin root  inner join, equal:[eq(test.t1.id1, test.t3.id1) eq(test.t1.id2, test.t3.id2)]",
          "    ├─IndexReader(Build) root  index:IndexFullScan",
          "    │ └─IndexFullScan cop[tikv] table:t3, index:UK_id1_id2(id1, id2) keep order:false, stats:pseudo",
          "    └─HashJoin(Probe) root  left outer join, left side:TableReader, equal:[eq(test.t1.id1, test.t2.id1) eq(test.t1.id2, test.t2.id2)]",
          "      ├─IndexReader(Build) root  index:IndexFullScan",
          "      │ └─IndexFullScan cop[tikv] table:t2, index:UK_id1_id2(id1, id2) keep order:false, stats:pseudo",
          "      └─TableReader(Probe) root  data:TableFullScan",
          "        └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "SELECT t1.id1, t1.id2, COUNT(t1.id3) FROM t1 left join t2 on t1.id1 = t2.id1 and t1.id2 = t2.id2  inner join t4 on t1.id1 = t4.id1 and t1.id2 = t4.id2 GROUP BY t1.id1, t1.id2;",
        "Plan": [
<<<<<<< HEAD
          "Projection root  test.t1.id1, test.t1.id2, Column#19",
          "└─HashAgg root  group by:test.t1.id1, test.t1.id2, funcs:count(test.t1.id3)->Column#19, funcs:firstrow(test.t1.id1)->test.t1.id1, funcs:firstrow(test.t1.id2)->test.t1.id2",
=======
          "Projection root  test.t1.id1, test.t1.id2, Column",
          "└─HashAgg root  group by:test.t1.id1, test.t1.id2, funcs:count(test.t1.id3)->Column, funcs:firstrow(test.t1.id1)->test.t1.id1, funcs:firstrow(test.t1.id2)->test.t1.id2",
>>>>>>> master
          "  └─HashJoin root  inner join, equal:[eq(test.t1.id1, test.t4.id1) eq(test.t1.id2, test.t4.id2)]",
          "    ├─IndexReader(Build) root  index:IndexFullScan",
          "    │ └─IndexFullScan cop[tikv] table:t4, index:UK_id1_id2(id1, id2) keep order:false, stats:pseudo",
          "    └─HashJoin(Probe) root  left outer join, left side:TableReader, equal:[eq(test.t1.id1, test.t2.id1) eq(test.t1.id2, test.t2.id2)]",
          "      ├─IndexReader(Build) root  index:IndexFullScan",
          "      │ └─IndexFullScan cop[tikv] table:t2, index:UK_id1_id2(id1, id2) keep order:false, stats:pseudo",
          "      └─TableReader(Probe) root  data:TableFullScan",
          "        └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      }
    ]
  },
  {
    "Name": "TestIssue62331",
    "Cases": [
      {
        "SQL": "select /*+ read_from_storage(tiflash[t1]) */ /*+ use_index(t1) */ /*+ agg_to_cop() hash_agg() */  bit_and(t1.col_2) as r0, bit_xor(t1.col_2) as r1 , substring(t1.col_2 ,4) as r2 from t1 where t1.col_1 in ('04:00:09.00' ,'21:06:18.00' ,'18:43:53.00') group by t1.col_1,t1.col_2  having not(t1.col_1 <> '06:32:23.00');",
        "Plan": [
<<<<<<< HEAD
          "Projection root  ifnull(cast(test.t1.col_2, bigint(21) UNSIGNED BINARY), 18446744073709551615)->Column#8, ifnull(cast(test.t1.col_2, bigint(21) UNSIGNED BINARY), 0)->Column#9, substring(cast(test.t1.col_2, var_string(20)), 4)->Column#10",
=======
          "Projection root  ifnull(cast(test.t1.col_2, bigint(21) UNSIGNED BINARY), 18446744073709551615)->Column, ifnull(cast(test.t1.col_2, bigint(21) UNSIGNED BINARY), 0)->Column, substring(cast(test.t1.col_2, var_string(20)), 4)->Column",
>>>>>>> master
          "└─TableDual root  rows:0"
        ],
        "Warn": [
          "[planner:1815]No available path for table test.t1 with the store type tiflash of the hint /*+ read_from_storage */, please check the status of the table replica and variable value of tidb_isolation_read_engines(map[0:{} 1:{} 2:{}])",
          "[parser:8066]Optimizer hint can only be followed by certain keywords like SELECT, INSERT, etc.",
          "[parser:8066]Optimizer hint can only be followed by certain keywords like SELECT, INSERT, etc."
        ]
      }
    ]
  }
]
