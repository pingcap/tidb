[
  {
    "Name": "TestIndexJoinInnerIndexNDV",
    "Cases": [
      {
        "SQL": "explain format = 'brief' select /*+ inl_join(t2) */ * from t1, t2 where t1.a = t2.a and t1.b = t2.b and t1.c = t2.c",
        "Plan": [
          "IndexJoin 3.00 root  inner join, inner:IndexLookUp, outer key:test.t1.c, inner key:test.t2.c, equal cond:eq(test.t1.a, test.t2.a), eq(test.t1.b, test.t2.b), eq(test.t1.c, test.t2.c)",
          "├─TableReader(Build) 3.00 root  data:TableFullScan",
          "│ └─TableFullScan 3.00 cop[tikv] table:t1 keep order:false",
          "└─IndexLookUp(Probe) 3.00 root  ",
          "  ├─IndexRangeScan(Build) 3.00 cop[tikv] table:t2, index:idx2(c) range: decided by [eq(test.t2.c, test.t1.c)], keep order:false",
          "  └─TableRowIDScan(Probe) 3.00 cop[tikv] table:t2 keep order:false"
        ]
      }
    ]
  },
  {
    "Name": "TestIndexJoinUniqueCompositeIndex",
    "Cases": [
      {
        "SQL": "explain format = 'brief' select /*+ TIDB_INLJ(t2) */ * from t1 join t2 on t1.a = t2.a and t1.c = t2.c",
        "Plan": [
          "IndexJoin 2.00 root  inner join, inner:IndexLookUp, outer key:test.t1.a, inner key:test.t2.a, equal cond:eq(test.t1.a, test.t2.a), eq(test.t1.c, test.t2.c)",
          "├─TableReader(Build) 1.00 root  data:TableFullScan",
          "│ └─TableFullScan 1.00 cop[tikv] table:t1 keep order:false",
          "└─IndexLookUp(Probe) 2.00 root  ",
          "  ├─IndexRangeScan(Build) 2.00 cop[tikv] table:t2, index:PRIMARY(a, b) range: decided by [eq(test.t2.a, test.t1.a)], keep order:false",
          "  └─TableRowIDScan(Probe) 2.00 cop[tikv] table:t2 keep order:false"
        ]
      },
      {
        "SQL": "explain format = 'brief' select /*+ TIDB_INLJ(t2) */ * from t1 join t2 on t1.a = t2.a and t1.c <= t2.b",
        "Plan": [
          "IndexJoin 2.00 root  inner join, inner:IndexLookUp, outer key:test.t1.a, inner key:test.t2.a, equal cond:eq(test.t1.a, test.t2.a), other cond:le(test.t1.c, test.t2.b)",
          "├─TableReader(Build) 1.00 root  data:TableFullScan",
          "│ └─TableFullScan 1.00 cop[tikv] table:t1 keep order:false",
          "└─IndexLookUp(Probe) 2.00 root  ",
          "  ├─IndexRangeScan(Build) 2.00 cop[tikv] table:t2, index:PRIMARY(a, b) range: decided by [eq(test.t2.a, test.t1.a) le(test.t1.c, test.t2.b)], keep order:false",
          "  └─TableRowIDScan(Probe) 2.00 cop[tikv] table:t2 keep order:false"
        ]
      },
      {
        "SQL": "explain format = 'brief' select /*+ TIDB_INLJ(t2) */ * from t1 join t2 on t1.a = t2.a and t2.b = 1",
        "Plan": [
          "IndexJoin 1.00 root  inner join, inner:IndexLookUp, outer key:test.t1.a, inner key:test.t2.a, equal cond:eq(test.t1.a, test.t2.a)",
          "├─TableReader(Build) 1.00 root  data:TableFullScan",
          "│ └─TableFullScan 1.00 cop[tikv] table:t1 keep order:false",
          "└─IndexLookUp(Probe) 1.00 root  ",
          "  ├─IndexRangeScan(Build) 1.00 cop[tikv] table:t2, index:PRIMARY(a, b) range: decided by [eq(test.t2.a, test.t1.a) eq(test.t2.b, 1)], keep order:false",
          "  └─TableRowIDScan(Probe) 1.00 cop[tikv] table:t2 keep order:false"
        ]
      }
    ]
  },
  {
    "Name": "TestIndexMerge",
    "Cases": [
      {
        "SQL": "explain format = 'brief' select /*+ USE_INDEX_MERGE(t, a, b) */ * from t where a = 1 or b = 2",
        "Plan": [
          "IndexMerge 2.00 root  type: union",
          "├─IndexRangeScan(Build) 1.00 cop[tikv] table:t, index:a(a) range:[1,1], keep order:false, stats:pseudo",
          "├─IndexRangeScan(Build) 1.00 cop[tikv] table:t, index:b(b) range:[2,2], keep order:false, stats:pseudo",
          "└─TableRowIDScan(Probe) 2.00 cop[tikv] table:t keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "explain format = 'brief' select /*+ USE_INDEX_MERGE(t, A, B) */ * from t where a = 1 or b = 2",
        "Plan": [
          "IndexMerge 2.00 root  type: union",
          "├─IndexRangeScan(Build) 1.00 cop[tikv] table:t, index:a(a) range:[1,1], keep order:false, stats:pseudo",
          "├─IndexRangeScan(Build) 1.00 cop[tikv] table:t, index:b(b) range:[2,2], keep order:false, stats:pseudo",
          "└─TableRowIDScan(Probe) 2.00 cop[tikv] table:t keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "explain format = 'brief' select /*+ USE_INDEX_MERGE(t, primary) */ * from t where 1 or t.c",
        "Plan": [
          "TableReader 10000.00 root  data:TableFullScan",
          "└─TableFullScan 10000.00 cop[tikv] table:t keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "explain format = 'brief' select /*+ USE_INDEX_MERGE(t, a, b, c) */ * from t where 1 or t.a = 1 or t.b = 2",
        "Plan": [
          "TableReader 10000.00 root  data:Selection",
          "└─Selection 10000.00 cop[tikv]  or(1, or(eq(test.t.a, 1), eq(test.t.b, 2)))",
          "  └─TableFullScan 10000.00 cop[tikv] table:t keep order:false, stats:pseudo"
        ]
      }
    ]
  },
  {
    "Name": "TestIndexJoinTableRange",
    "Cases": [
      {
        "SQL": "desc format = 'brief' select /*+ TIDB_INLJ(t2)*/ * from t1, t2 where t1.a = t2.a and t1.b = t2.b",
        "Plan": [
          "IndexJoin 12487.50 root  inner join, inner:TableReader, outer key:test.t1.a, inner key:test.t2.a, equal cond:eq(test.t1.a, test.t2.a), eq(test.t1.b, test.t2.b)",
          "├─IndexReader(Build) 9990.00 root  index:IndexFullScan",
          "│ └─IndexFullScan 9990.00 cop[tikv] table:t1, index:idx_t1_b(b) keep order:false, stats:pseudo",
          "└─TableReader(Probe) 9980.01 root  data:Selection",
          "  └─Selection 9980.01 cop[tikv]  not(isnull(test.t2.b))",
          "    └─TableRangeScan 9990.00 cop[tikv] table:t2 range: decided by [test.t1.a], keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "desc format = 'brief' select /*+ TIDB_INLJ(t2)*/ * from t1, t2 where t1.a = t2.a and t1.b = t2.a and t1.b = t2.b",
        "Plan": [
          "IndexJoin 12487.50 root  inner join, inner:TableReader, outer key:test.t1.a, test.t1.b, inner key:test.t2.a, test.t2.a, equal cond:eq(test.t1.a, test.t2.a), eq(test.t1.b, test.t2.a), eq(test.t1.b, test.t2.b)",
          "├─IndexReader(Build) 9990.00 root  index:IndexFullScan",
          "│ └─IndexFullScan 9990.00 cop[tikv] table:t1, index:idx_t1_b(b) keep order:false, stats:pseudo",
          "└─TableReader(Probe) 9980.01 root  data:Selection",
          "  └─Selection 9980.01 cop[tikv]  not(isnull(test.t2.b))",
          "    └─TableRangeScan 9990.00 cop[tikv] table:t2 range: decided by [test.t1.a test.t1.b], keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "desc format = 'brief' select /*+ INL_JOIN(t4) */ * from t3 join t4 on t3.a = t4.a where t4.b = 1",
        "Plan": [
          "Projection 12.50 root  test.t3.a, test.t3.b, test.t3.c, test.t4.a, test.t4.b, test.t4.c",
          "└─IndexJoin 12.50 root  inner join, inner:TableReader, outer key:test.t3.a, inner key:test.t4.a, equal cond:eq(test.t3.a, test.t4.a)",
          "  ├─TableReader(Build) 9990.00 root  data:Selection",
          "  │ └─Selection 9990.00 cop[tikv]  not(isnull(test.t3.a))",
          "  │   └─TableFullScan 10000.00 cop[tikv] table:t3 keep order:false, stats:pseudo",
          "  └─TableReader(Probe) 9.99 root  data:Selection",
          "    └─Selection 9.99 cop[tikv]  eq(test.t4.b, 1)",
          "      └─TableRangeScan 9990.00 cop[tikv] table:t4 range: decided by [eq(test.t4.a, test.t3.a) eq(test.t4.b, 1)], keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "desc format = 'brief' select /*+ INL_JOIN(t4) */ * from t3 join t4 on t3.b = t4.b where t4.a = 1",
        "Plan": [
          "Projection 12.50 root  test.t3.a, test.t3.b, test.t3.c, test.t4.a, test.t4.b, test.t4.c",
          "└─IndexJoin 12.50 root  inner join, inner:TableReader, outer key:test.t3.b, inner key:test.t4.b, equal cond:eq(test.t3.b, test.t4.b)",
          "  ├─TableReader(Build) 9990.00 root  data:Selection",
          "  │ └─Selection 9990.00 cop[tikv]  not(isnull(test.t3.b))",
          "  │   └─TableFullScan 10000.00 cop[tikv] table:t3 keep order:false, stats:pseudo",
          "  └─TableReader(Probe) 9.99 root  data:Selection",
          "    └─Selection 9.99 cop[tikv]  eq(test.t4.a, 1)",
          "      └─TableRangeScan 9990.00 cop[tikv] table:t4 range: decided by [eq(test.t4.b, test.t3.b) eq(test.t4.a, 1)], keep order:false, stats:pseudo"
        ]
      }
    ]
  },
  {
    "Name": "TestAccessPathOnClusterIndex",
    "Cases": [
      {
        "SQL": "select * from t1",
        "Plan": [
          "TableReader 3.00 root  data:TableFullScan",
          "└─TableFullScan 3.00 cop[tikv] table:t1 keep order:false"
        ],
        "Res": [
          "1 111 1.1000000000 11",
          "2 222 2.2000000000 12",
          "3 333 3.3000000000 13"
        ]
      },
      {
        "SQL": "select * from t1 where t1.a >= 1 and t1.a < 4",
        "Plan": [
          "TableReader 3.00 root  data:TableRangeScan",
          "└─TableRangeScan 3.00 cop[tikv] table:t1 range:[1,4), keep order:false"
        ],
        "Res": [
          "1 111 1.1000000000 11",
          "2 222 2.2000000000 12",
          "3 333 3.3000000000 13"
        ]
      },
      {
        "SQL": "select * from t1 where t1.a = 1 and t1.b < \"333\"",
        "Plan": [
          "TableReader 0.82 root  data:TableRangeScan",
          "└─TableRangeScan 0.82 cop[tikv] table:t1 range:[1 -inf,1 \"333\"), keep order:false"
        ],
        "Res": [
          "1 111 1.1000000000 11"
        ]
      },
      {
        "SQL": "select t1.a, t1.b, t1.c from t1 where t1.c = 3.3",
        "Plan": [
          "IndexReader 1.00 root  index:IndexRangeScan",
          "└─IndexRangeScan 1.00 cop[tikv] table:t1, index:c(c) range:[3.3000000000,3.3000000000], keep order:false"
        ],
        "Res": [
          "3 333 3.3000000000"
        ]
      },
      {
        "SQL": "select t1.b, t1.c from t1 where t1.c = 2.2",
        "Plan": [
          "IndexReader 1.00 root  index:IndexRangeScan",
          "└─IndexRangeScan 1.00 cop[tikv] table:t1, index:c(c) range:[2.2000000000,2.2000000000], keep order:false"
        ],
        "Res": [
          "222 2.2000000000"
        ]
      },
      {
        "SQL": "select /*+ use_index(t1, c) */ * from t1",
        "Plan": [
          "IndexLookUp 3.00 root  ",
          "├─IndexFullScan(Build) 3.00 cop[tikv] table:t1, index:c(c) keep order:false",
          "└─TableRowIDScan(Probe) 3.00 cop[tikv] table:t1 keep order:false"
        ],
        "Res": [
          "1 111 1.1000000000 11",
          "2 222 2.2000000000 12",
          "3 333 3.3000000000 13"
        ]
      },
      {
        "SQL": "select * from t1 use index(c) where t1.c in (2.2, 3.3)",
        "Plan": [
          "IndexLookUp 2.00 root  ",
          "├─IndexRangeScan(Build) 2.00 cop[tikv] table:t1, index:c(c) range:[2.2000000000,2.2000000000], [3.3000000000,3.3000000000], keep order:false",
          "└─TableRowIDScan(Probe) 2.00 cop[tikv] table:t1 keep order:false"
        ],
        "Res": [
          "2 222 2.2000000000 12",
          "3 333 3.3000000000 13"
        ]
      },
      {
        "SQL": "select * from t1 where t1.a = 1 order by b",
        "Plan": [
          "TableReader 1.00 root  data:TableRangeScan",
          "└─TableRangeScan 1.00 cop[tikv] table:t1 range:[1,1], keep order:true"
        ],
        "Res": [
          "1 111 1.1000000000 11"
        ]
      },
      {
        "SQL": "select * from t1 order by a, b limit 1",
        "Plan": [
          "Limit 1.00 root  offset:0, count:1",
          "└─TableReader 1.00 root  data:Limit",
          "  └─Limit 1.00 cop[tikv]  offset:0, count:1",
          "    └─TableFullScan 1.00 cop[tikv] table:t1 keep order:true"
        ],
        "Res": [
          "1 111 1.1000000000 11"
        ]
      },
      {
        "SQL": "select /*+ use_index_merge(t1 primary, c) */ * from t1 where t1.a >= 1 or t1.c = 2.2",
        "Plan": [
          "IndexMerge 3.00 root  type: union",
          "├─TableRangeScan(Build) 3.00 cop[tikv] table:t1 range:[1,+inf], keep order:false",
          "├─IndexRangeScan(Build) 1.00 cop[tikv] table:t1, index:c(c) range:[2.2000000000,2.2000000000], keep order:false",
          "└─TableRowIDScan(Probe) 3.00 cop[tikv] table:t1 keep order:false"
        ],
        "Res": [
          "1 111 1.1000000000 11",
          "2 222 2.2000000000 12",
          "3 333 3.3000000000 13"
        ]
      },
      {
        "SQL": "select /*+ use_index_merge(t1 primary, c) */ * from t1 where t1.a = 1 and t1.b = '111' or t1.c = 3.3",
        "Plan": [
          "IndexMerge 1.67 root  type: union",
          "├─TableRangeScan(Build) 1.00 cop[tikv] table:t1 range:[1 \"111\",1 \"111\"], keep order:false",
          "├─IndexRangeScan(Build) 1.00 cop[tikv] table:t1, index:c(c) range:[3.3000000000,3.3000000000], keep order:false",
          "└─TableRowIDScan(Probe) 1.67 cop[tikv] table:t1 keep order:false"
        ],
        "Res": [
          "1 111 1.1000000000 11",
          "3 333 3.3000000000 13"
        ]
      }
    ]
  },
  {
    "Name": "TestIndexJoinOnClusteredIndex",
    "Cases": [
      {
        "SQL": "select /*+ inl_join(t1, t2) */ * from t t1 join t t2 on t1.a = t2.a",
        "Plan": [
          "IndexJoin 3.00 root  inner join, inner:TableReader, outer key:test.t.a, inner key:test.t.a, equal cond:eq(test.t.a, test.t.a)",
          "├─TableReader(Build) 3.00 root  data:TableFullScan",
          "│ └─TableFullScan 3.00 cop[tikv] table:t1 keep order:false",
          "└─TableReader(Probe) 3.00 root  data:TableRangeScan",
          "  └─TableRangeScan 3.00 cop[tikv] table:t2 range: decided by [eq(test.t.a, test.t.a)], keep order:false"
        ],
        "Res": [
          "1 111 1.1000000000 11 1 111 1.1000000000 11",
          "2 222 2.2000000000 12 2 222 2.2000000000 12",
          "3 333 3.3000000000 13 3 333 3.3000000000 13"
        ]
      },
      {
        "SQL": "select /*+ inl_merge_join(t1, t2) */ * from t t1 join t t2 on t1.a = t2.a",
        "Plan": [
          "IndexMergeJoin 3.00 root  inner join, inner:TableReader, outer key:test.t.a, inner key:test.t.a",
          "├─TableReader(Build) 3.00 root  data:TableFullScan",
          "│ └─TableFullScan 3.00 cop[tikv] table:t1 keep order:false",
          "└─TableReader(Probe) 3.00 root  data:TableRangeScan",
          "  └─TableRangeScan 3.00 cop[tikv] table:t2 range: decided by [eq(test.t.a, test.t.a)], keep order:true"
        ],
        "Res": [
          "1 111 1.1000000000 11 1 111 1.1000000000 11",
          "2 222 2.2000000000 12 2 222 2.2000000000 12",
          "3 333 3.3000000000 13 3 333 3.3000000000 13"
        ]
      },
      {
        "SQL": "select /*+ inl_hash_join(t1, t2) */ * from t t1 join t t2 on t1.a = t2.a",
        "Plan": [
          "IndexHashJoin 3.00 root  inner join, inner:TableReader, outer key:test.t.a, inner key:test.t.a, equal cond:eq(test.t.a, test.t.a)",
          "├─TableReader(Build) 3.00 root  data:TableFullScan",
          "│ └─TableFullScan 3.00 cop[tikv] table:t1 keep order:false",
          "└─TableReader(Probe) 3.00 root  data:TableRangeScan",
          "  └─TableRangeScan 3.00 cop[tikv] table:t2 range: decided by [eq(test.t.a, test.t.a)], keep order:false"
        ],
        "Res": [
          "1 111 1.1000000000 11 1 111 1.1000000000 11",
          "2 222 2.2000000000 12 2 222 2.2000000000 12",
          "3 333 3.3000000000 13 3 333 3.3000000000 13"
        ]
      },
      {
        "SQL": "select /*+ inl_join(t1, t2) */ * from t t1 join t t2 on t1.a = t2.a and t1.b = t2.b",
        "Plan": [
          "IndexJoin 3.00 root  inner join, inner:TableReader, outer key:test.t.a, test.t.b, inner key:test.t.a, test.t.b, equal cond:eq(test.t.a, test.t.a), eq(test.t.b, test.t.b)",
          "├─TableReader(Build) 3.00 root  data:TableFullScan",
          "│ └─TableFullScan 3.00 cop[tikv] table:t1 keep order:false",
          "└─TableReader(Probe) 3.00 root  data:TableRangeScan",
          "  └─TableRangeScan 3.00 cop[tikv] table:t2 range: decided by [eq(test.t.a, test.t.a) eq(test.t.b, test.t.b)], keep order:false"
        ],
        "Res": [
          "1 111 1.1000000000 11 1 111 1.1000000000 11",
          "2 222 2.2000000000 12 2 222 2.2000000000 12",
          "3 333 3.3000000000 13 3 333 3.3000000000 13"
        ]
      },
      {
        "SQL": "select /*+ inl_join(t1, t2) */ * from t t1 join t t2 on t1.c = t2.c",
        "Plan": [
          "IndexJoin 3.00 root  inner join, inner:IndexLookUp, outer key:test.t.c, inner key:test.t.c, equal cond:eq(test.t.c, test.t.c)",
          "├─TableReader(Build) 3.00 root  data:Selection",
          "│ └─Selection 3.00 cop[tikv]  not(isnull(test.t.c))",
          "│   └─TableFullScan 3.00 cop[tikv] table:t1 keep order:false",
          "└─IndexLookUp(Probe) 3.00 root  ",
          "  ├─Selection(Build) 3.00 cop[tikv]  not(isnull(test.t.c))",
          "  │ └─IndexRangeScan 3.00 cop[tikv] table:t2, index:c(c) range: decided by [eq(test.t.c, test.t.c)], keep order:false",
          "  └─TableRowIDScan(Probe) 3.00 cop[tikv] table:t2 keep order:false"
        ],
        "Res": [
          "1 111 1.1000000000 11 1 111 1.1000000000 11",
          "2 222 2.2000000000 12 2 222 2.2000000000 12",
          "3 333 3.3000000000 13 3 333 3.3000000000 13"
        ]
      },
      {
        "SQL": "select /*+ inl_merge_join(t1,t2) */ t2.a, t2.c, t2.d from t t1 left join t t2 on t1.a = t2.c;",
        "Plan": [
          "IndexMergeJoin 3.00 root  left outer join, inner:Projection, outer key:Column#9, inner key:test.t.c",
          "├─Projection(Build) 3.00 root  cast(test.t.a, decimal(10,0) BINARY)->Column#9",
          "│ └─IndexReader 3.00 root  index:IndexFullScan",
          "│   └─IndexFullScan 3.00 cop[tikv] table:t1, index:c(c) keep order:false",
          "└─Projection(Probe) 3.00 root  test.t.a, test.t.c, test.t.d",
          "  └─IndexLookUp 3.00 root  ",
          "    ├─IndexRangeScan(Build) 3.00 cop[tikv] table:t2, index:c(c) range: decided by [eq(test.t.c, Column#9)], keep order:true",
          "    └─TableRowIDScan(Probe) 3.00 cop[tikv] table:t2 keep order:false"
        ],
        "Res": [
          "<nil> <nil> <nil>",
          "<nil> <nil> <nil>",
          "<nil> <nil> <nil>"
        ]
      }
    ]
  },
  {
    "Name": "TestHeuristicIndexSelection",
    "Cases": [
      {
        "SQL": "select * from t1 where a = 3 or a = 5",
        "Plan": [
          "Batch_Point_Get_5 2.00 887.04 root table:t1 handle:[3 5], keep order:false, desc:false"
        ],
        "Warnings": [
          "Note 1105 handle of t1 is selected since the path only has point ranges"
        ]
      },
      {
        "SQL": "select f, g from t1 where f = 2 and g in (3, 4, 5)",
        "Plan": [
          "Batch_Point_Get_5 3.00 380.16 root table:t1, index:f_g(f, g) keep order:false, desc:false"
        ],
        "Warnings": [
          "Note 1105 unique index f_g of t1 is selected since the path only has point ranges with single scan"
        ]
      },
      {
        "SQL": "select * from t1 where c = 1 and (d = 2 or d = 3) and e in (4, 5)",
        "Plan": [
          "Batch_Point_Get_5 4.00 1774.08 root table:t1, index:c_d_e(c, d, e) keep order:false, desc:false"
        ],
        "Warnings": [
          "Note 1105 unique index c_d_e of t1 is selected since the path only has point ranges with double scan"
        ]
      },
      {
        "SQL": "select f, g from t1 where f = 2 and g > 3",
        "Plan": [
          "IndexReader_6 33.33 733.82 root  index:IndexRangeScan_5",
          "└─IndexRangeScan_5 33.33 6783.33 cop[tikv] table:t1, index:f_g(f, g) range:(2 3,2 +inf], keep order:false, stats:pseudo"
        ],
        "Warnings": [
          "Note 1105 unique index f_g of t1 is selected since the path only fetches limited number of rows with single scan"
        ]
      },
      {
        "SQL": "select a, b, c from t2 where a = 1 and b = 2 and c in (1, 2, 3, 4, 5)",
        "Plan": [
          "Selection_6 0.01 289.88 root  eq(test.t2.b, 2), in(test.t2.c, 1, 2, 3, 4, 5)",
          "└─Point_Get_5 1.00 190.08 root table:t2, index:idx_a(a) "
        ],
        "Warnings": [
          "Note 1105 unique index idx_a of t2 is selected since the path only has point ranges with double scan"
        ]
      },
      {
        "SQL": "select * from t3 where (a = 1 or a = 3) and b = 'xx'",
        "Plan": [
          "Batch_Point_Get_5 2.00 1449.36 root table:t3, clustered index:PRIMARY(a, b) keep order:false, desc:false"
        ],
        "Warnings": [
          "Note 1105 handle of t3 is selected since the path only has point ranges"
        ]
      },
      {
        "SQL": "select * from t4 where (a = 1 or a = 3) and b = 'xx'",
        "Plan": [
          "Batch_Point_Get_5 2.00 1449.36 root table:t4, index:PRIMARY(a, b) keep order:false, desc:false"
        ],
        "Warnings": [
          "Note 1105 unique index PRIMARY of t4 is selected since the path only has point ranges with double scan"
        ]
      },
      {
        "SQL": "select a, b from t3 where (a = 1 or a = 3) and b = 'xx'",
        "Plan": [
          "Batch_Point_Get_5 2.00 1322.64 root table:t3, clustered index:PRIMARY(a, b) keep order:false, desc:false"
        ],
        "Warnings": [
          "Note 1105 handle of t3 is selected since the path only has point ranges"
        ]
      },
      {
        "SQL": "select a, b from t4 where (a = 1 or a = 3) and b = 'xx'",
        "Plan": [
          "Batch_Point_Get_5 2.00 1322.64 root table:t4, index:PRIMARY(a, b) keep order:false, desc:false"
        ],
        "Warnings": [
          "Note 1105 unique index PRIMARY of t4 is selected since the path only has point ranges with single scan"
        ]
      },
      {
        "SQL": "update t1 set b = 2 where a = 4 or a = 6",
        "Plan": [
          "Update_4 N/A N/A root  N/A",
          "└─Batch_Point_Get_6 2.00 887.04 root table:t1 handle:[4 6], keep order:false, desc:false"
        ],
        "Warnings": [
          "Note 1105 handle of t1 is selected since the path only has point ranges"
        ]
      },
      {
        "SQL": "delete from t1 where f = 2 and g in (3, 4)",
        "Plan": [
          "Delete_4 N/A N/A root  N/A",
          "└─Selection_7 2.00 493.42 root  in(test.t1.g, 3, 4)",
          "  └─Point_Get_6 1.00 443.52 root table:t1, index:f(f) "
        ],
        "Warnings": [
          "Note 1105 unique index f of t1 is selected since the path only has point ranges with double scan"
        ]
      },
      {
        "SQL": "insert into t3 select a, b, c from t1 where f = 2",
        "Plan": [
          "Insert_1 N/A N/A root  N/A",
          "└─Projection_6 1.00 253.74 root  test.t1.a, test.t1.b, test.t1.c",
          "  └─Point_Get_7 1.00 253.44 root table:t1, index:f(f) "
        ],
        "Warnings": [
          "Note 1105 unique index f of t1 is selected since the path only has point ranges with double scan"
        ]
      },
      {
        "SQL": "replace into t3 select a, b, c from t1 where a = 3",
        "Plan": [
          "Insert_1 N/A N/A root  N/A",
          "└─Point_Get_7 1.00 190.08 root table:t1 handle:3"
        ],
        "Warnings": [
          "Note 1105 handle of t1 is selected since the path only has point ranges"
        ]
      }
    ]
  },
  {
    "Name": "TestIndexMergeWithCorrelatedColumns",
    "Cases": [
      {
        "SQL": "select * from t2 where c1 < all(select /*+ use_index_merge(t1) */ c1 from t1 where (c1 = 10 and c1 = t2.c3 or c2 = 1 and c2 = t2.c3) and substring(c3, 10)) order by c1;",
        "Plan": [
          "Sort 10000.00 root  test.t2.c1",
          "└─Projection 10000.00 root  test.t2.c1, test.t2.c2, test.t2.c3",
          "  └─Apply 10000.00 root  CARTESIAN inner join, other cond:or(and(lt(test.t2.c1, Column#8), if(ne(Column#9, 0), NULL, 1)), or(eq(Column#10, 0), if(isnull(test.t2.c1), NULL, 0)))",
          "    ├─TableReader(Build) 10000.00 root  data:TableFullScan",
          "    │ └─TableFullScan 10000.00 cop[tikv] table:t2 keep order:false, stats:pseudo",
          "    └─StreamAgg(Probe) 10000.00 root  funcs:min(test.t1.c1)->Column#8, funcs:sum(0)->Column#9, funcs:count(1)->Column#10",
          "      └─IndexMerge 63.35 root  type: union",
          "        ├─Selection(Build) 10000.00 cop[tikv]  eq(10, test.t2.c3)",
          "        │ └─TableRangeScan 10000.00 cop[tikv] table:t1 range:[10,10], keep order:false, stats:pseudo",
          "        ├─Selection(Build) 80000.00 cop[tikv]  eq(1, test.t2.c3)",
          "        │ └─IndexRangeScan 100000.00 cop[tikv] table:t1, index:c2(c2) range:[1,1], keep order:false, stats:pseudo",
          "        └─Selection(Probe) 63.35 cop[tikv]  or(and(eq(test.t1.c1, 10), eq(10, test.t2.c3)), and(eq(test.t1.c2, 1), eq(1, test.t2.c3))), substring(cast(test.t1.c3, var_string(20)), 10)",
          "          └─TableRowIDScan 89992.00 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Res": [
          "1 1 1",
          "2 2 2"
        ]
      },
      {
        "SQL": "select * from t2 where c1 < all(select /*+ use_index_merge(t1) */ c1 from t1 where (c1 = 10 and c1 = t2.c3 or c2 = 1 and c2 = t2.c3) and reverse(c3)) order by c1;",
        "Plan": [
          "Sort 10000.00 root  test.t2.c1",
          "└─Projection 10000.00 root  test.t2.c1, test.t2.c2, test.t2.c3",
          "  └─Apply 10000.00 root  CARTESIAN inner join, other cond:or(and(lt(test.t2.c1, Column#8), if(ne(Column#9, 0), NULL, 1)), or(eq(Column#10, 0), if(isnull(test.t2.c1), NULL, 0)))",
          "    ├─TableReader(Build) 10000.00 root  data:TableFullScan",
          "    │ └─TableFullScan 10000.00 cop[tikv] table:t2 keep order:false, stats:pseudo",
          "    └─StreamAgg(Probe) 10000.00 root  funcs:min(test.t1.c1)->Column#8, funcs:sum(0)->Column#9, funcs:count(1)->Column#10",
          "      └─IndexMerge 63.35 root  type: union",
          "        ├─Selection(Build) 10000.00 cop[tikv]  eq(10, test.t2.c3)",
          "        │ └─TableRangeScan 10000.00 cop[tikv] table:t1 range:[10,10], keep order:false, stats:pseudo",
          "        ├─Selection(Build) 80000.00 cop[tikv]  eq(1, test.t2.c3)",
          "        │ └─IndexRangeScan 100000.00 cop[tikv] table:t1, index:c2(c2) range:[1,1], keep order:false, stats:pseudo",
          "        └─Selection(Probe) 63.35 cop[tikv]  or(and(eq(test.t1.c1, 10), eq(10, test.t2.c3)), and(eq(test.t1.c2, 1), eq(1, test.t2.c3))), reverse(cast(test.t1.c3, var_string(20)))",
          "          └─TableRowIDScan 89992.00 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Res": [
          "2 2 2"
        ]
      },
      {
        "SQL": "select * from t2 where c1 < all(select /*+ use_index_merge(t1) */ c1 from t1 where (c1 >= 10 and c1 = t2.c3 or c2 = 1 and c2 = t2.c3) and substring(c3, 10)) order by c1;",
        "Plan": [
          "Sort 10000.00 root  test.t2.c1",
          "└─Projection 10000.00 root  test.t2.c1, test.t2.c2, test.t2.c3",
          "  └─Apply 10000.00 root  CARTESIAN inner join, other cond:or(and(lt(test.t2.c1, Column#8), if(ne(Column#9, 0), NULL, 1)), or(eq(Column#10, 0), if(isnull(test.t2.c1), NULL, 0)))",
          "    ├─TableReader(Build) 10000.00 root  data:TableFullScan",
          "    │ └─TableFullScan 10000.00 cop[tikv] table:t2 keep order:false, stats:pseudo",
          "    └─StreamAgg(Probe) 10000.00 root  funcs:min(test.t1.c1)->Column#8, funcs:sum(0)->Column#9, funcs:count(1)->Column#10",
          "      └─IndexMerge 30263.46 root  type: union",
          "        ├─Selection(Build) 33333.33 cop[tikv]  eq(test.t1.c1, test.t2.c3)",
          "        │ └─TableRangeScan 33333333.33 cop[tikv] table:t1 range:[10,+inf], keep order:false, stats:pseudo",
          "        ├─Selection(Build) 80000.00 cop[tikv]  eq(1, test.t2.c3)",
          "        │ └─IndexRangeScan 100000.00 cop[tikv] table:t1, index:c2(c2) range:[1,1], keep order:false, stats:pseudo",
          "        └─Selection(Probe) 30263.46 cop[tikv]  or(and(ge(test.t1.c1, 10), eq(test.t1.c1, test.t2.c3)), and(eq(test.t1.c2, 1), eq(1, test.t2.c3))), substring(cast(test.t1.c3, var_string(20)), 10)",
          "          └─TableRowIDScan 33386666.67 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Res": [
          "1 1 1",
          "2 2 2"
        ]
      },
      {
        "SQL": "select c_int from tt1 where c_decimal < all (select /*+ use_index_merge(tt2) */ c_decimal from tt2 where tt1.c_int = tt2.c_int and tt1.c_datetime > tt2.c_datetime and tt2.c_decimal = 9.060 or tt2.c_str <= 'interesting shtern' and tt1.c_int = tt2.c_int) order by 1;",
        "Plan": [
          "Projection 10000.00 root  test.tt1.c_int",
          "└─Apply 10000.00 root  CARTESIAN inner join, other cond:or(and(lt(test.tt1.c_decimal, Column#9), if(ne(Column#10, 0), NULL, 1)), or(eq(Column#11, 0), if(isnull(test.tt1.c_decimal), NULL, 0)))",
          "  ├─TableReader(Build) 10000.00 root  data:TableFullScan",
          "  │ └─TableFullScan 10000.00 cop[tikv] table:tt1 keep order:true, stats:pseudo",
          "  └─StreamAgg(Probe) 10000.00 root  funcs:min(Column#14)->Column#9, funcs:sum(Column#15)->Column#10, funcs:count(1)->Column#11",
          "    └─Projection 11.05 root  test.tt2.c_decimal->Column#14, cast(isnull(test.tt2.c_decimal), decimal(20,0) BINARY)->Column#15",
          "      └─IndexMerge 11.05 root  type: union",
          "        ├─Selection(Build) 10.00 cop[tikv]  eq(test.tt1.c_int, test.tt2.c_int)",
          "        │ └─IndexRangeScan 10000.00 cop[tikv] table:tt2, index:c_decimal(c_decimal) range:[9.060000,9.060000], keep order:false, stats:pseudo",
          "        ├─Selection(Build) 33233.33 cop[tikv]  eq(test.tt1.c_int, test.tt2.c_int)",
          "        │ └─IndexRangeScan 33233333.33 cop[tikv] table:tt2, index:c_str(c_str) range:[-inf,\"interesting shtern\"], keep order:false, stats:pseudo",
          "        └─Selection(Probe) 11.05 cop[tikv]  or(and(eq(test.tt1.c_int, test.tt2.c_int), and(gt(test.tt1.c_datetime, test.tt2.c_datetime), eq(test.tt2.c_decimal, 9.060))), and(le(test.tt2.c_str, \"interesting shtern\"), eq(test.tt1.c_int, test.tt2.c_int)))",
          "          └─TableRowIDScan 33243.33 cop[tikv] table:tt2 keep order:false, stats:pseudo"
        ],
        "Res": [
          "7",
          "8",
          "10"
        ]
      },
      {
        "SQL": "select c_int from tt1 where c_decimal > all (select /*+ use_index_merge(tt2) */ c_decimal from tt2 where tt2.c_int = 7 and tt2.c_int < tt1.c_decimal or tt2.c_str >= 'zzzzzzzzzzzzzzzzzzz' and tt1.c_int = tt2.c_int) order by 1;",
        "Plan": [
          "Projection 10000.00 root  test.tt1.c_int",
          "└─Apply 10000.00 root  CARTESIAN inner join, other cond:or(and(gt(test.tt1.c_decimal, Column#9), if(ne(Column#10, 0), NULL, 1)), or(eq(Column#11, 0), if(isnull(test.tt1.c_decimal), NULL, 0)))",
          "  ├─TableReader(Build) 10000.00 root  data:TableFullScan",
          "  │ └─TableFullScan 10000.00 cop[tikv] table:tt1 keep order:true, stats:pseudo",
          "  └─StreamAgg(Probe) 10000.00 root  funcs:max(Column#14)->Column#9, funcs:sum(Column#15)->Column#10, funcs:count(1)->Column#11",
          "    └─Projection 17.91 root  test.tt2.c_decimal->Column#14, cast(isnull(test.tt2.c_decimal), decimal(20,0) BINARY)->Column#15",
          "      └─IndexMerge 17.91 root  type: union",
          "        ├─Selection(Build) 10000.00 cop[tikv]  lt(7, test.tt1.c_decimal)",
          "        │ └─TableRangeScan 10000.00 cop[tikv] table:tt2 range:[7,7], keep order:false, stats:pseudo",
          "        ├─Selection(Build) 33333.33 cop[tikv]  eq(test.tt1.c_int, test.tt2.c_int)",
          "        │ └─IndexRangeScan 33333333.33 cop[tikv] table:tt2, index:c_str(c_str) range:[\"zzzzzzzzzzzzzzzzzzz\",+inf], keep order:false, stats:pseudo",
          "        └─Selection(Probe) 17.91 cop[tikv]  or(and(eq(test.tt2.c_int, 7), lt(7, test.tt1.c_decimal)), and(ge(test.tt2.c_str, \"zzzzzzzzzzzzzzzzzzz\"), eq(test.tt1.c_int, test.tt2.c_int)))",
          "          └─TableRowIDScan 43330.00 cop[tikv] table:tt2 keep order:false, stats:pseudo"
        ],
        "Res": [
          "6",
          "7",
          "8",
          "9"
        ]
      }
    ]
  },
  {
    "Name": "TestIndexMergeSerial",
    "Cases": [
      {
        "SQL": "desc format='brief' select /*+ use_index_merge(t) */ * from t where a =1 or (b=1 and b+2>1)",
        "Plan": [
          "IndexMerge 8.00 root  type: union",
          "├─IndexRangeScan(Build) 1.00 cop[tikv] table:t, index:a(a) range:[1,1], keep order:false",
          "├─Selection(Build) 1.00 cop[tikv]  1",
          "│ └─IndexRangeScan 1.00 cop[tikv] table:t, index:b(b) range:[1,1], keep order:false",
          "└─TableRowIDScan(Probe) 8.00 cop[tikv] table:t keep order:false"
        ],
        "Warnings": null
      },
      {
        "SQL": "desc format='brief' select /*+ use_index_merge(t) */ * from t where a =1 or (b=1 and length(b)=1)",
        "Plan": [
          "IndexMerge 8.00 root  type: union",
          "├─IndexRangeScan(Build) 1.00 cop[tikv] table:t, index:a(a) range:[1,1], keep order:false",
          "├─Selection(Build) 1.00 cop[tikv]  1",
          "│ └─IndexRangeScan 1.00 cop[tikv] table:t, index:b(b) range:[1,1], keep order:false",
          "└─TableRowIDScan(Probe) 8.00 cop[tikv] table:t keep order:false"
        ],
        "Warnings": null
      },
      {
        "SQL": "desc format='brief' select /*+ use_index_merge(t) */ * from t where (a=1 and length(a)=1) or (b=1 and length(b)=1)",
        "Plan": [
          "IndexMerge 8.00 root  type: union",
          "├─Selection(Build) 1.00 cop[tikv]  1",
          "│ └─IndexRangeScan 1.00 cop[tikv] table:t, index:a(a) range:[1,1], keep order:false",
          "├─Selection(Build) 1.00 cop[tikv]  1",
          "│ └─IndexRangeScan 1.00 cop[tikv] table:t, index:b(b) range:[1,1], keep order:false",
          "└─TableRowIDScan(Probe) 8.00 cop[tikv] table:t keep order:false"
        ],
        "Warnings": null
      },
      {
        "SQL": "desc format='brief' select /*+ use_index_merge(t) */ * from t where (a=1 and length(b)=1) or (b=1 and length(a)=1)",
        "Plan": [
          "IndexMerge 0.29 root  type: union",
          "├─IndexRangeScan(Build) 1.00 cop[tikv] table:t, index:a(a) range:[1,1], keep order:false",
          "├─IndexRangeScan(Build) 1.00 cop[tikv] table:t, index:b(b) range:[1,1], keep order:false",
          "└─Selection(Probe) 0.29 cop[tikv]  or(and(eq(test.t.a, 1), eq(length(cast(test.t.b, var_string(20))), 1)), and(eq(test.t.b, 1), eq(length(cast(test.t.a, var_string(20))), 1)))",
          "  └─TableRowIDScan 1.90 cop[tikv] table:t keep order:false"
        ],
        "Warnings": null
      }
    ]
  },
  {
    "Name": "TestLimitIndexLookUpKeepOrder",
    "Cases": [
      {
        "SQL": "desc format = 'brief' select * from t where a = 1 and b > 2 and b < 10 and d = 10 order by b,c limit 10",
        "Plan": [
          "Limit 0.00 root  offset:0, count:10",
          "└─Projection 0.00 root  test.t.a, test.t.b, test.t.c, test.t.d",
          "  └─IndexLookUp 0.00 root  ",
          "    ├─IndexRangeScan(Build) 2.50 cop[tikv] table:t, index:idx(a, b, c) range:(1 2,1 10), keep order:true, stats:pseudo",
          "    └─Selection(Probe) 0.00 cop[tikv]  eq(test.t.d, 10)",
          "      └─TableRowIDScan 2.50 cop[tikv] table:t keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "desc format = 'brief' select * from t where a = 1 and b > 2 and b < 10 and d = 10 order by b desc, c desc limit 10",
        "Plan": [
          "Limit 0.00 root  offset:0, count:10",
          "└─Projection 0.00 root  test.t.a, test.t.b, test.t.c, test.t.d",
          "  └─IndexLookUp 0.00 root  ",
          "    ├─IndexRangeScan(Build) 2.50 cop[tikv] table:t, index:idx(a, b, c) range:(1 2,1 10), keep order:true, desc, stats:pseudo",
          "    └─Selection(Probe) 0.00 cop[tikv]  eq(test.t.d, 10)",
          "      └─TableRowIDScan 2.50 cop[tikv] table:t keep order:false, stats:pseudo"
        ]
      }
    ]
  },
  {
    "Name": "TestIndexJoinRangeFallback",
    "Cases": [
      {
        "SQL": "set @@tidb_opt_range_max_size = 0",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format='brief' select /*+ inl_join(t1) */ * from t1 join t2 on t1.b = t2.e and t1.d = t2.g where t1.a in (1, 3) and t1.c in ('aaa', 'bbb')",
        "Plan": [
          "IndexJoin 0.50 root  inner join, inner:IndexLookUp, outer key:test.t2.e, test.t2.g, inner key:test.t1.b, test.t1.d, equal cond:eq(test.t2.e, test.t1.b), eq(test.t2.g, test.t1.d)",
          "├─TableReader(Build) 9980.01 root  data:Selection",
          "│ └─Selection 9980.01 cop[tikv]  not(isnull(test.t2.e)), not(isnull(test.t2.g))",
          "│   └─TableFullScan 10000.00 cop[tikv] table:t2 keep order:false, stats:pseudo",
          "└─IndexLookUp(Probe) 0.50 root  ",
          "  ├─Selection(Build) 249.50 cop[tikv]  not(isnull(test.t1.b)), not(isnull(test.t1.d))",
          "  │ └─IndexRangeScan 250.00 cop[tikv] table:t1, index:idx_a_b_c_d(a, b, c, d) range: decided by [eq(test.t1.b, test.t2.e) eq(test.t1.d, test.t2.g) in(test.t1.a, 1, 3) in(test.t1.c, aaa, bbb)], keep order:false, stats:pseudo",
          "  └─Selection(Probe) 0.50 cop[tikv]  in(test.t1.c, \"aaa\", \"bbb\")",
          "    └─TableRowIDScan 249.50 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "set @@tidb_opt_range_max_size = 2900",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format='brief' select /*+ inl_join(t1) */ * from t1 join t2 on t1.b = t2.e and t1.d = t2.g where t1.a in (1, 3) and t1.c in ('aaa', 'bbb')",
        "Plan": [
          "IndexJoin 0.50 root  inner join, inner:IndexLookUp, outer key:test.t2.e, inner key:test.t1.b, equal cond:eq(test.t2.e, test.t1.b), eq(test.t2.g, test.t1.d)",
          "├─TableReader(Build) 9980.01 root  data:Selection",
          "│ └─Selection 9980.01 cop[tikv]  not(isnull(test.t2.e)), not(isnull(test.t2.g))",
          "│   └─TableFullScan 10000.00 cop[tikv] table:t2 keep order:false, stats:pseudo",
          "└─IndexLookUp(Probe) 0.50 root  ",
          "  ├─Selection(Build) 249.50 cop[tikv]  not(isnull(test.t1.b)), not(isnull(test.t1.d))",
          "  │ └─IndexRangeScan 250.00 cop[tikv] table:t1, index:idx_a_b_c_d(a, b, c, d) range: decided by [eq(test.t1.b, test.t2.e) in(test.t1.a, 1, 3) in(test.t1.c, aaa, bbb)], keep order:false, stats:pseudo",
          "  └─Selection(Probe) 0.50 cop[tikv]  in(test.t1.c, \"aaa\", \"bbb\")",
          "    └─TableRowIDScan 249.50 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "Memory capacity of 2900 bytes for 'tidb_opt_range_max_size' exceeded when building ranges. Less accurate ranges such as full range are chosen"
        ]
      },
      {
        "SQL": "set @@tidb_opt_range_max_size = 2300",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format='brief' select /*+ inl_join(t1) */ * from t1 join t2 on t1.b = t2.e and t1.d = t2.g where t1.a in (1, 3) and t1.c in ('aaa', 'bbb')",
        "Plan": [
          "IndexJoin 0.50 root  inner join, inner:IndexLookUp, outer key:test.t2.e, inner key:test.t1.b, equal cond:eq(test.t2.e, test.t1.b), eq(test.t2.g, test.t1.d)",
          "├─TableReader(Build) 9980.01 root  data:Selection",
          "│ └─Selection 9980.01 cop[tikv]  not(isnull(test.t2.e)), not(isnull(test.t2.g))",
          "│   └─TableFullScan 10000.00 cop[tikv] table:t2 keep order:false, stats:pseudo",
          "└─IndexLookUp(Probe) 0.50 root  ",
          "  ├─Selection(Build) 249.50 cop[tikv]  not(isnull(test.t1.b)), not(isnull(test.t1.d))",
          "  │ └─IndexRangeScan 250.00 cop[tikv] table:t1, index:idx_a_b_c_d(a, b, c, d) range: decided by [eq(test.t1.b, test.t2.e) in(test.t1.a, 1, 3)], keep order:false, stats:pseudo",
          "  └─Selection(Probe) 0.50 cop[tikv]  in(test.t1.c, \"aaa\", \"bbb\")",
          "    └─TableRowIDScan 249.50 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "Memory capacity of 2300 bytes for 'tidb_opt_range_max_size' exceeded when building ranges. Less accurate ranges such as full range are chosen"
        ]
      },
      {
        "SQL": "set @@tidb_opt_range_max_size = 700",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format='brief' select /*+ inl_join(t1) */ * from t1 join t2 on t1.b = t2.e and t1.d = t2.g where t1.a in (1, 3) and t1.c in ('aaa', 'bbb')",
        "Plan": [
          "HashJoin 0.05 root  inner join, equal:[eq(test.t1.b, test.t2.e) eq(test.t1.d, test.t2.g)]",
          "├─IndexLookUp(Build) 0.04 root  ",
          "│ ├─Selection(Build) 19.96 cop[tikv]  not(isnull(test.t1.b)), not(isnull(test.t1.d))",
          "│ │ └─IndexRangeScan 20.00 cop[tikv] table:t1, index:idx_a_b_c_d(a, b, c, d) range:[1,1], [3,3], keep order:false, stats:pseudo",
          "│ └─Selection(Probe) 0.04 cop[tikv]  in(test.t1.c, \"aaa\", \"bbb\")",
          "│   └─TableRowIDScan 19.96 cop[tikv] table:t1 keep order:false, stats:pseudo",
          "└─TableReader(Probe) 9980.01 root  data:Selection",
          "  └─Selection 9980.01 cop[tikv]  not(isnull(test.t2.e)), not(isnull(test.t2.g))",
          "    └─TableFullScan 10000.00 cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "Memory capacity of 700 bytes for 'tidb_opt_range_max_size' exceeded when building ranges. Less accurate ranges such as full range are chosen",
          "[planner:1815]Optimizer Hint /*+ INL_JOIN(t1) */ or /*+ TIDB_INLJ(t1) */ is inapplicable"
        ]
      },
      {
        "SQL": "set @@tidb_opt_range_max_size = 0",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format='brief' select /*+ inl_join(t1) */ * from t1 join t2 on t1.a = t2.e where t1.b > 1 and t1.b < 10",
        "Plan": [
          "IndexJoin 312.19 root  inner join, inner:IndexLookUp, outer key:test.t2.e, inner key:test.t1.a, equal cond:eq(test.t2.e, test.t1.a)",
          "├─TableReader(Build) 9990.00 root  data:Selection",
          "│ └─Selection 9990.00 cop[tikv]  not(isnull(test.t2.e))",
          "│   └─TableFullScan 10000.00 cop[tikv] table:t2 keep order:false, stats:pseudo",
          "└─IndexLookUp(Probe) 312.19 root  ",
          "  ├─Selection(Build) 312.19 cop[tikv]  not(isnull(test.t1.a))",
          "  │ └─IndexRangeScan 312.50 cop[tikv] table:t1, index:idx_a_b_c_d(a, b, c, d) range: decided by [eq(test.t1.a, test.t2.e) gt(test.t1.b, 1) lt(test.t1.b, 10)], keep order:false, stats:pseudo",
          "  └─TableRowIDScan(Probe) 312.19 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "set @@tidb_opt_range_max_size = 300",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format='brief' select /*+ inl_join(t1) */ * from t1 join t2 on t1.a = t2.e where t1.b > 1 and t1.b < 10",
        "Plan": [
          "IndexJoin 312.19 root  inner join, inner:IndexLookUp, outer key:test.t2.e, inner key:test.t1.a, equal cond:eq(test.t2.e, test.t1.a)",
          "├─TableReader(Build) 9990.00 root  data:Selection",
          "│ └─Selection 9990.00 cop[tikv]  not(isnull(test.t2.e))",
          "│   └─TableFullScan 10000.00 cop[tikv] table:t2 keep order:false, stats:pseudo",
          "└─IndexLookUp(Probe) 312.19 root  ",
          "  ├─Selection(Build) 312.19 cop[tikv]  gt(test.t1.b, 1), lt(test.t1.b, 10), not(isnull(test.t1.a))",
          "  │ └─IndexRangeScan 12500.00 cop[tikv] table:t1, index:idx_a_b_c_d(a, b, c, d) range: decided by [eq(test.t1.a, test.t2.e)], keep order:false, stats:pseudo",
          "  └─TableRowIDScan(Probe) 312.19 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "Memory capacity of 300 bytes for 'tidb_opt_range_max_size' exceeded when building ranges. Less accurate ranges such as full range are chosen"
        ]
      },
      {
        "SQL": "set @@tidb_opt_range_max_size = 0",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format='brief' select /*+ inl_join(t1) */ * from t1 join t2 on t1.a = t2.e where t1.b > t2.f and t1.b < t2.f + 10",
        "Plan": [
          "IndexJoin 12475.01 root  inner join, inner:IndexLookUp, outer key:test.t2.e, inner key:test.t1.a, equal cond:eq(test.t2.e, test.t1.a), other cond:gt(test.t1.b, test.t2.f), lt(test.t1.b, plus(test.t2.f, 10))",
          "├─TableReader(Build) 9980.01 root  data:Selection",
          "│ └─Selection 9980.01 cop[tikv]  not(isnull(test.t2.e)), not(isnull(test.t2.f))",
          "│   └─TableFullScan 10000.00 cop[tikv] table:t2 keep order:false, stats:pseudo",
          "└─IndexLookUp(Probe) 12475.01 root  ",
          "  ├─Selection(Build) 12475.01 cop[tikv]  not(isnull(test.t1.a)), not(isnull(test.t1.b))",
          "  │ └─IndexRangeScan 12500.00 cop[tikv] table:t1, index:idx_a_b_c_d(a, b, c, d) range: decided by [eq(test.t1.a, test.t2.e) lt(test.t1.b, plus(test.t2.f, 10)) gt(test.t1.b, test.t2.f)], keep order:false, stats:pseudo",
          "  └─TableRowIDScan(Probe) 12475.01 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "set @@tidb_opt_range_max_size = 300",
        "Plan": null,
        "Warn": null
      },
      {
        "SQL": "explain format='brief' select /*+ inl_join(t1) */ * from t1 join t2 on t1.a = t2.e where t1.b > t2.f and t1.b < t2.f + 10",
        "Plan": [
          "IndexJoin 12475.01 root  inner join, inner:IndexLookUp, outer key:test.t2.e, inner key:test.t1.a, equal cond:eq(test.t2.e, test.t1.a), other cond:gt(test.t1.b, test.t2.f), lt(test.t1.b, plus(test.t2.f, 10))",
          "├─TableReader(Build) 9980.01 root  data:Selection",
          "│ └─Selection 9980.01 cop[tikv]  not(isnull(test.t2.e)), not(isnull(test.t2.f))",
          "│   └─TableFullScan 10000.00 cop[tikv] table:t2 keep order:false, stats:pseudo",
          "└─IndexLookUp(Probe) 12475.01 root  ",
          "  ├─Selection(Build) 12475.01 cop[tikv]  not(isnull(test.t1.a)), not(isnull(test.t1.b))",
          "  │ └─IndexRangeScan 12500.00 cop[tikv] table:t1, index:idx_a_b_c_d(a, b, c, d) range: decided by [eq(test.t1.a, test.t2.e)], keep order:false, stats:pseudo",
          "  └─TableRowIDScan(Probe) 12475.01 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "Memory capacity of 300 bytes for 'tidb_opt_range_max_size' exceeded when building ranges. Less accurate ranges such as full range are chosen"
        ]
      }
    ]
  },
  {
    "Name": "TestNullConditionForPrefixIndex",
    "Cases": [
      {
        "SQL": "select count(1) from t1 where c1 = '0xfff' and c2 is not null",
        "Plan": [
          "StreamAgg 1.00 root  funcs:count(Column#7)->Column#5",
          "└─IndexReader 1.00 root  index:StreamAgg",
          "  └─StreamAgg 1.00 cop[tikv]  funcs:count(1)->Column#7",
          "    └─IndexRangeScan 99.90 cop[tikv] table:t1, index:idx2(c1, c2) range:[\"0xfff\" -inf,\"0xfff\" +inf], keep order:false, stats:pseudo"
        ],
        "Result": [
          "3"
        ]
      },
      {
        "SQL": "select count(1) from t1 where c1 = '0xfff' and c2 is null",
        "Plan": [
          "StreamAgg 1.00 root  funcs:count(1)->Column#5",
          "└─IndexReader 0.10 root  index:IndexRangeScan",
          "  └─IndexRangeScan 0.10 cop[tikv] table:t1, index:idx2(c1, c2) range:[\"0xfff\" NULL,\"0xfff\" NULL], keep order:false, stats:pseudo"
        ],
        "Result": [
          "1"
        ]
      },
      {
        "SQL": "select count(1) from t1 where c1 >= '0xfff' and c2 is not null",
        "Plan": [
          "HashAgg 1.00 root  funcs:count(Column#6)->Column#5",
          "└─IndexReader 1.00 root  index:HashAgg",
          "  └─HashAgg 1.00 cop[tikv]  funcs:count(1)->Column#6",
          "    └─Selection 3330.00 cop[tikv]  not(isnull(test.t1.c2))",
          "      └─IndexRangeScan 3333.33 cop[tikv] table:t1, index:idx2(c1, c2) range:[\"0xfff\",+inf], keep order:false, stats:pseudo"
        ],
        "Result": [
          "3"
        ]
      },
      {
        "SQL": "select count(1) from t1 where c1 >= '0xfff' and c2 is null",
        "Plan": [
          "StreamAgg 1.00 root  funcs:count(Column#7)->Column#5",
          "└─IndexReader 1.00 root  index:StreamAgg",
          "  └─StreamAgg 1.00 cop[tikv]  funcs:count(1)->Column#7",
          "    └─Selection 3.33 cop[tikv]  isnull(test.t1.c2)",
          "      └─IndexRangeScan 3333.33 cop[tikv] table:t1, index:idx2(c1, c2) range:[\"0xfff\",+inf], keep order:false, stats:pseudo"
        ],
        "Result": [
          "1"
        ]
      },
      {
        "SQL": "select count(1) from t1 where c1 = '0xfff' and (c2 + 1) is not null",
        "Plan": [
          "StreamAgg 1.00 root  funcs:count(1)->Column#5",
          "└─IndexLookUp 8.00 root  ",
          "  ├─IndexRangeScan(Build) 10.00 cop[tikv] table:t1, index:idx1(c1) range:[\"0xfff\",\"0xfff\"], keep order:false, stats:pseudo",
          "  └─Selection(Probe) 8.00 cop[tikv]  not(isnull(plus(cast(test.t1.c2, double BINARY), 1)))",
          "    └─TableRowIDScan 10.00 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Result": [
          "3"
        ]
      },
      {
        "SQL": "select count(1) from t1 where c1 = '0xfff' and (c2 + 1) is null",
        "Plan": [
          "StreamAgg 1.00 root  funcs:count(1)->Column#5",
          "└─IndexLookUp 8.00 root  ",
          "  ├─IndexRangeScan(Build) 10.00 cop[tikv] table:t1, index:idx1(c1) range:[\"0xfff\",\"0xfff\"], keep order:false, stats:pseudo",
          "  └─Selection(Probe) 8.00 cop[tikv]  isnull(plus(cast(test.t1.c2, double BINARY), 1))",
          "    └─TableRowIDScan 10.00 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Result": [
          "1"
        ]
      },
      {
        "SQL": "select c2 from t1 use index(idx2) where c1 = '0xfff' and c2 is not null",
        "Plan": [
          "Projection 99.90 root  test.t1.c2",
          "└─IndexLookUp 99.90 root  ",
          "  ├─IndexRangeScan(Build) 99.90 cop[tikv] table:t1, index:idx2(c1, c2) range:[\"0xfff\" -inf,\"0xfff\" +inf], keep order:false, stats:pseudo",
          "  └─TableRowIDScan(Probe) 99.90 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Result": [
          "",
          "111111",
          "22    "
        ]
      },
      {
        "SQL": "select c2 from t1 use index(idx2) where c1 = '0xfff' and c2 is null",
        "Plan": [
          "Projection 0.10 root  test.t1.c2",
          "└─IndexLookUp 0.10 root  ",
          "  ├─IndexRangeScan(Build) 0.10 cop[tikv] table:t1, index:idx2(c1, c2) range:[\"0xfff\" NULL,\"0xfff\" NULL], keep order:false, stats:pseudo",
          "  └─TableRowIDScan(Probe) 0.10 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Result": [
          "<nil>"
        ]
      },
      {
        "SQL": "select c2 from t1 use index(idx2) where c1 >= '0xfff' and c2 is not null",
        "Plan": [
          "Projection 3330.00 root  test.t1.c2",
          "└─IndexLookUp 3330.00 root  ",
          "  ├─Selection(Build) 3330.00 cop[tikv]  not(isnull(test.t1.c2))",
          "  │ └─IndexRangeScan 3333.33 cop[tikv] table:t1, index:idx2(c1, c2) range:[\"0xfff\",+inf], keep order:false, stats:pseudo",
          "  └─TableRowIDScan(Probe) 3330.00 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Result": [
          "",
          "111111",
          "22    "
        ]
      },
      {
        "SQL": "select c2 from t1 use index(idx2) where c1 >= '0xfff' and c2 is null",
        "Plan": [
          "Projection 3.33 root  test.t1.c2",
          "└─IndexLookUp 3.33 root  ",
          "  ├─Selection(Build) 3.33 cop[tikv]  isnull(test.t1.c2)",
          "  │ └─IndexRangeScan 3333.33 cop[tikv] table:t1, index:idx2(c1, c2) range:[\"0xfff\",+inf], keep order:false, stats:pseudo",
          "  └─TableRowIDScan(Probe) 3.33 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Result": [
          "<nil>"
        ]
      },
      {
        "SQL": "select count(1) from t2 use index(idx) where b is not null",
        "Plan": [
          "HashAgg 1.00 root  funcs:count(Column#5)->Column#4",
          "└─IndexReader 1.00 root  index:HashAgg",
          "  └─HashAgg 1.00 cop[tikv]  funcs:count(1)->Column#5",
          "    └─IndexFullScan 9990.00 cop[tikv] table:t2, index:idx(b) keep order:false, stats:pseudo"
        ],
        "Result": [
          "3"
        ]
      },
      {
        "SQL": "select count(1) from t2 use index(idx) where b is null",
        "Plan": [
          "StreamAgg 1.00 root  funcs:count(Column#6)->Column#4",
          "└─IndexReader 1.00 root  index:StreamAgg",
          "  └─StreamAgg 1.00 cop[tikv]  funcs:count(1)->Column#6",
          "    └─IndexRangeScan 10.00 cop[tikv] table:t2, index:idx(b) range:[NULL,NULL], keep order:false, stats:pseudo"
        ],
        "Result": [
          "1"
        ]
      },
      {
        "SQL": "select b from t2 use index(idx) where b is not null",
        "Plan": [
          "IndexLookUp 9990.00 root  ",
          "├─IndexFullScan(Build) 9990.00 cop[tikv] table:t2, index:idx(b) keep order:false, stats:pseudo",
          "└─TableRowIDScan(Probe) 9990.00 cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Result": [
          "",
          "aaaaaa",
          "bb    "
        ]
      },
      {
        "SQL": "select b from t2 use index(idx) where b is null",
        "Plan": [
          "IndexLookUp 10.00 root  ",
          "├─IndexRangeScan(Build) 10.00 cop[tikv] table:t2, index:idx(b) range:[NULL,NULL], keep order:false, stats:pseudo",
          "└─TableRowIDScan(Probe) 10.00 cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Result": [
          "<nil>"
        ]
      },
      {
        "SQL": "select b from t3 where a = 1 and b is not null",
        "Plan": [
          "Projection 10.00 root  test.t3.b",
          "└─TableReader 10.00 root  data:TableRangeScan",
          "  └─TableRangeScan 10.00 cop[tikv] table:t3 range:[1,1], keep order:false, stats:pseudo"
        ],
        "Result": [
          "",
          "aaaaaa",
          "bb    "
        ]
      },
      {
        "SQL": "select b from t3 where a = 1 and b is null",
        "Plan": [
          "TableDual 0.00 root  rows:0"
        ],
        "Result": null
      }
    ]
  },
  {
    "Name": "TestIndexMergeFromComposedCNFCondition",
    "Cases": [
      {
        "SQL": "explain select /*+ use_index_merge(t1, idx2, idx) */ * from t1 where 1 member of (a) and 2 member of (b); -- 1: AND index merge from multi member mv index predicate, since member of is single partial path, it can be merged with outer index merge.",
        "Plan": [
          "IndexMerge_8 10.00 root  type: intersection",
          "├─IndexRangeScan_5(Build) 10.00 cop[tikv] table:t1, index:idx(cast(`a` as signed array)) range:[1,1], keep order:false, stats:pseudo",
          "├─IndexRangeScan_6(Build) 10.00 cop[tikv] table:t1, index:idx2(cast(`b` as signed array)) range:[2,2], keep order:false, stats:pseudo",
          "└─TableRowIDScan_7(Probe) 10.00 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "explain select /*+ use_index_merge(t2, idx2, idx) */ * from t2 where 1 member of (a) and c=1 and 2 member of (b); -- 2: AND index merge from multi complicated mv index",
        "Plan": [
          "IndexMerge_8 0.10 root  type: intersection",
          "├─IndexRangeScan_5(Build) 0.10 cop[tikv] table:t2, index:idx(c, cast(`a` as signed array)) range:[1 1,1 1], keep order:false, stats:pseudo",
          "├─IndexRangeScan_6(Build) 0.10 cop[tikv] table:t2, index:idx2(cast(`b` as signed array), c) range:[2 1,2 1], keep order:false, stats:pseudo",
          "└─TableRowIDScan_7(Probe) 0.10 cop[tikv] table:t2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "explain select /*+ use_index_merge(t2, idx2, idx, idx4) */ * from t2 where 1 member of (a) and c=1 and 2 member of (b) and d=3; -- 3: AND index merge from multi complicated mv indexes and normal indexes",
        "Plan": [
          "IndexMerge_9 0.10 root  type: intersection",
          "├─IndexRangeScan_5(Build) 10.00 cop[tikv] table:t2, index:idx4(d) range:[3,3], keep order:false, stats:pseudo",
          "├─IndexRangeScan_6(Build) 0.10 cop[tikv] table:t2, index:idx(c, cast(`a` as signed array)) range:[1 1,1 1], keep order:false, stats:pseudo",
          "├─IndexRangeScan_7(Build) 0.10 cop[tikv] table:t2, index:idx2(cast(`b` as signed array), c) range:[2 1,2 1], keep order:false, stats:pseudo",
          "└─TableRowIDScan_8(Probe) 0.10 cop[tikv] table:t2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "explain select /*+ use_index_merge(t2, idx2, idx, idx3) */ * from t2 where json_contains(a, '[1, 2, 3]') and c=1 and 2 member of (b) and d=3; -- 4: AND index merge from multi complicated mv indexes (json_contains (intersection))and normal indexes",
        "Plan": [
          "IndexMerge_11 0.10 root  type: intersection",
          "├─IndexRangeScan_5(Build) 0.10 cop[tikv] table:t2, index:idx3(c, d) range:[1 3,1 3], keep order:false, stats:pseudo",
          "├─IndexRangeScan_6(Build) 0.10 cop[tikv] table:t2, index:idx(c, cast(`a` as signed array)) range:[1 1,1 1], keep order:false, stats:pseudo",
          "├─IndexRangeScan_7(Build) 0.10 cop[tikv] table:t2, index:idx(c, cast(`a` as signed array)) range:[1 2,1 2], keep order:false, stats:pseudo",
          "├─IndexRangeScan_8(Build) 0.10 cop[tikv] table:t2, index:idx(c, cast(`a` as signed array)) range:[1 3,1 3], keep order:false, stats:pseudo",
          "├─IndexRangeScan_9(Build) 0.10 cop[tikv] table:t2, index:idx2(cast(`b` as signed array), c) range:[2 1,2 1], keep order:false, stats:pseudo",
          "└─TableRowIDScan_10(Probe) 0.10 cop[tikv] table:t2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "explain select /*+ use_index_merge(t2, idx2, idx, idx3) */ * from t2 where json_overlaps(a, '[1, 2, 3]') and c=1 and 2 member of (b) and d=3; -- 5: AND index merge from multi complicated mv indexes (json_overlap (intersection))and normal indexes",
        "Plan": [
          "Selection_5 0.06 root  json_overlaps(test.t2.a, cast(\"[1, 2, 3]\", json BINARY))",
          "└─IndexMerge_9 0.10 root  type: intersection",
          "  ├─IndexRangeScan_6(Build) 0.10 cop[tikv] table:t2, index:idx3(c, d) range:[1 3,1 3], keep order:false, stats:pseudo",
          "  ├─IndexRangeScan_7(Build) 0.10 cop[tikv] table:t2, index:idx2(cast(`b` as signed array), c) range:[2 1,2 1], keep order:false, stats:pseudo",
          "  └─TableRowIDScan_8(Probe) 0.10 cop[tikv] table:t2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "explain select /*+ use_index_merge(t2, idx2, idx) */ * from t2 where 1 member of (a) and c=1 and c=2; -- 6: AND index merge from multi complicated mv indexes (empty range)",
        "Plan": [
          "TableDual_5 0.00 root  rows:0"
        ]
      }
    ]
  },
  {
    "Name": "TestIndexMergeFromComposedDNFCondition",
    "Cases": [
      {
        "SQL": "explain select /*+ use_index_merge(t2, idx2, idx) */ * from t2 where (1 member of (a) and c=1) or (2 member of (b) and c=1); -- 1: OR index merge from multi complicated mv index (memberof)",
        "Plan": [
          "IndexMerge_8 0.10 root  type: union",
          "├─IndexRangeScan_5(Build) 0.10 cop[tikv] table:t2, index:idx(c, cast(`a` as signed array)) range:[1 1,1 1], keep order:false, stats:pseudo",
          "├─IndexRangeScan_6(Build) 0.10 cop[tikv] table:t2, index:idx2(cast(`b` as signed array), c) range:[2 1,2 1], keep order:false, stats:pseudo",
          "└─TableRowIDScan_7(Probe) 0.10 cop[tikv] table:t2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "explain select /*+ use_index_merge(t2, idx2, idx) */ * from t2 where (1 member of (a) and c=1) or (2 member of (b) and c=1); -- 2: OR index merge from multi complicated mv index (memberof)",
        "Plan": [
          "IndexMerge_8 0.10 root  type: union",
          "├─IndexRangeScan_5(Build) 0.10 cop[tikv] table:t2, index:idx(c, cast(`a` as signed array)) range:[1 1,1 1], keep order:false, stats:pseudo",
          "├─IndexRangeScan_6(Build) 0.10 cop[tikv] table:t2, index:idx2(cast(`b` as signed array), c) range:[2 1,2 1], keep order:false, stats:pseudo",
          "└─TableRowIDScan_7(Probe) 0.10 cop[tikv] table:t2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "explain select /*+ use_index_merge(t2, idx2, idx) */ * from t2 where (1 member of (a) and c=1 and d=2) or (2 member of (b) and c=3 and d=2); -- 3: OR index merge from multi complicated mv index (memberof)，while each DNF item contains redundant condition, which should be remained as table filters",
        "Plan": [
          "IndexMerge_9 0.10 root  type: union",
          "├─IndexRangeScan_5(Build) 0.10 cop[tikv] table:t2, index:idx(c, cast(`a` as signed array)) range:[1 1,1 1], keep order:false, stats:pseudo",
          "├─IndexRangeScan_6(Build) 0.10 cop[tikv] table:t2, index:idx2(cast(`b` as signed array), c) range:[2 3,2 3], keep order:false, stats:pseudo",
          "└─Selection_8(Probe) 0.10 cop[tikv]  or(and(json_memberof(cast(1, json BINARY), test.t2.a), and(eq(test.t2.c, 1), eq(test.t2.d, 2))), and(json_memberof(cast(2, json BINARY), test.t2.b), and(eq(test.t2.c, 3), eq(test.t2.d, 2))))",
          "  └─TableRowIDScan_7 0.10 cop[tikv] table:t2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "explain select /*+ use_index_merge(t2, idx2, idx) */ * from t2 where ( json_contains(a, '[1, 2, 3]') and c=1 and d=2) or (2 member of (b) and c=3 and d=2); -- 4: OR index merge from multi complicated mv index (memberof)，make full use of DNF item's condition even if the predicate is intersection case (json_contains)",
        "Plan": [
          "IndexMerge_9 0.01 root  type: union",
          "├─IndexRangeScan_5(Build) 10.00 cop[tikv] table:t2, index:idx(c, cast(`a` as signed array)) range:[1,1], keep order:false, stats:pseudo",
          "├─IndexRangeScan_6(Build) 0.10 cop[tikv] table:t2, index:idx2(cast(`b` as signed array), c) range:[2 3,2 3], keep order:false, stats:pseudo",
          "└─Selection_8(Probe) 0.01 cop[tikv]  or(and(json_contains(test.t2.a, cast(\"[1, 2, 3]\", json BINARY)), and(eq(test.t2.c, 1), eq(test.t2.d, 2))), and(json_memberof(cast(2, json BINARY), test.t2.b), and(eq(test.t2.c, 3), eq(test.t2.d, 2))))",
          "  └─TableRowIDScan_7 10.00 cop[tikv] table:t2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "explain select /*+ use_index_merge(t2, idx2, idx) */ * from t2 where ( json_overlaps(a, '[1, 2, 3]') and c=1 and d=2) or (2 member of (b) and c=3 and d=2); -- 5: OR index merge from multi complicated mv index (memberof)，make full use of DNF item's condition even if the predicate is intersection case (json_contains)",
        "Plan": [
          "Selection_5 0.08 root  or(and(json_overlaps(test.t2.a, cast(\"[1, 2, 3]\", json BINARY)), and(eq(test.t2.c, 1), eq(test.t2.d, 2))), and(json_memberof(cast(2, json BINARY), test.t2.b), and(eq(test.t2.c, 3), eq(test.t2.d, 2))))",
          "└─IndexMerge_11 0.10 root  type: union",
          "  ├─IndexRangeScan_6(Build) 0.10 cop[tikv] table:t2, index:idx(c, cast(`a` as signed array)) range:[1 1,1 1], keep order:false, stats:pseudo",
          "  ├─IndexRangeScan_7(Build) 0.10 cop[tikv] table:t2, index:idx(c, cast(`a` as signed array)) range:[1 2,1 2], keep order:false, stats:pseudo",
          "  ├─IndexRangeScan_8(Build) 0.10 cop[tikv] table:t2, index:idx(c, cast(`a` as signed array)) range:[1 3,1 3], keep order:false, stats:pseudo",
          "  ├─IndexRangeScan_9(Build) 0.10 cop[tikv] table:t2, index:idx2(cast(`b` as signed array), c) range:[2 3,2 3], keep order:false, stats:pseudo",
          "  └─TableRowIDScan_10(Probe) 0.10 cop[tikv] table:t2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "explain select /*+ use_index_merge(t2, idx2, idx, idx4) */ * from t2 where ( json_contains(a, '[1, 2, 3]') and d=2) or (2 member of (b) and c=3 and d=2); -- 6: OR index merge from multi complicated mv index (memberof)，make full use of other DNF items even if one of the DNF items fails",
        "Plan": [
          "IndexMerge_9 0.01 root  type: union",
          "├─IndexRangeScan_5(Build) 10.00 cop[tikv] table:t2, index:idx4(d) range:[2,2], keep order:false, stats:pseudo",
          "├─IndexRangeScan_6(Build) 0.10 cop[tikv] table:t2, index:idx2(cast(`b` as signed array), c) range:[2 3,2 3], keep order:false, stats:pseudo",
          "└─Selection_8(Probe) 0.01 cop[tikv]  or(and(json_contains(test.t2.a, cast(\"[1, 2, 3]\", json BINARY)), eq(test.t2.d, 2)), and(json_memberof(cast(2, json BINARY), test.t2.b), and(eq(test.t2.c, 3), eq(test.t2.d, 2))))",
          "  └─TableRowIDScan_7 10.00 cop[tikv] table:t2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "explain select /*+ use_index_merge(t2, idx2, idx) */ * from t2 where (1 member of (a) and 1 member of (b) and c=3) or (3 member of (b) and c=4); -- 7: OR index merge from multi complicated mv index (memberof)，each DNF item can be more complicated like a another embedded CNF member-of composition.",
        "Plan": [
          "IndexMerge_9 0.10 root  type: union",
          "├─IndexRangeScan_5(Build) 0.10 cop[tikv] table:t2, index:idx(c, cast(`a` as signed array)) range:[3 1,3 1], keep order:false, stats:pseudo",
          "├─IndexRangeScan_6(Build) 0.10 cop[tikv] table:t2, index:idx2(cast(`b` as signed array), c) range:[3 4,3 4], keep order:false, stats:pseudo",
          "└─Selection_8(Probe) 0.10 cop[tikv]  or(and(json_memberof(cast(1, json BINARY), test.t2.a), and(json_memberof(cast(1, json BINARY), test.t2.b), eq(test.t2.c, 3))), and(json_memberof(cast(3, json BINARY), test.t2.b), eq(test.t2.c, 4)))",
          "  └─TableRowIDScan_7 0.10 cop[tikv] table:t2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "explain select /*+ use_index_merge(t2, idx2, idx) */ * from t2 where (1 member of (a) and 1 member of (b) and c=3) or (3 member of (b) and c=4) or e=1; -- 8: OR index merge from multi complicated mv index (memberof), each DNF item should be strict or lax used as index partial path.",
        "Plan": [
          "TableReader_7 25.98 root  data:Selection_6",
          "└─Selection_6 25.98 cop[tikv]  or(and(json_memberof(cast(1, json BINARY), test.t2.a), and(json_memberof(cast(1, json BINARY), test.t2.b), eq(test.t2.c, 3))), or(and(json_memberof(cast(3, json BINARY), test.t2.b), eq(test.t2.c, 4)), eq(test.t2.e, 1)))",
          "  └─TableFullScan_5 10000.00 cop[tikv] table:t2 keep order:false, stats:pseudo"
        ]
      },
      {
        "SQL": "explain select /*+ use_index_merge(t2, idx2, idx, idx4) */ * from t2 where (1 member of (a) and 1 member of (b) and c=3) or (3 member of (b) and c=4) or d=1; -- 9: OR index merge from multi complicated mv index (memberof), each DNF item should be strict or lax used as index partial path, specify the index in index merge hint",
        "Plan": [
          "IndexMerge_10 0.03 root  type: union",
          "├─IndexRangeScan_5(Build) 10.00 cop[tikv] table:t2, index:idx4(d) range:[1,1], keep order:false, stats:pseudo",
          "├─IndexRangeScan_6(Build) 0.10 cop[tikv] table:t2, index:idx(c, cast(`a` as signed array)) range:[3 1,3 1], keep order:false, stats:pseudo",
          "├─IndexRangeScan_7(Build) 0.10 cop[tikv] table:t2, index:idx2(cast(`b` as signed array), c) range:[3 4,3 4], keep order:false, stats:pseudo",
          "└─Selection_9(Probe) 0.03 cop[tikv]  or(and(json_memberof(cast(1, json BINARY), test.t2.a), and(json_memberof(cast(1, json BINARY), test.t2.b), eq(test.t2.c, 3))), or(and(json_memberof(cast(3, json BINARY), test.t2.b), eq(test.t2.c, 4)), eq(test.t2.d, 1)))",
          "  └─TableRowIDScan_8 10.00 cop[tikv] table:t2 keep order:false, stats:pseudo"
        ]
      }
    ]
  }
]
