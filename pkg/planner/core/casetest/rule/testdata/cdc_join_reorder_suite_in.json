[
  {
    "name": "TestCDCJoinReorder",
    "cases": [
      // =============================================
      // Group 1: Inner join reorder (baseline)
      // =============================================

      // 3-table inner join
      "SELECT * FROM t1 JOIN t2 ON t1.a = t2.a JOIN t3 ON t2.a = t3.a ORDER BY t1.a",
      // 4-table inner join
      "SELECT * FROM t1 JOIN t2 ON t1.a = t2.a JOIN t3 ON t2.a = t3.a JOIN t4 ON t3.a = t4.a ORDER BY t1.a",

      // =============================================
      // Group 2: LEFT JOIN + INNER JOIN
      // =============================================

      // assoc(inner, left) = 1: (t1 INNER t2) LEFT t3
      "SELECT * FROM t1 JOIN t2 ON t1.a = t2.a LEFT JOIN t3 ON t2.a = t3.a ORDER BY t1.a, t2.a",
      // assoc(left, inner) = 0: (t1 LEFT t2) INNER t3 on t1.a = t3.a
      // A conflict rule should be added to prevent incorrect reorder.
      "SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a JOIN t3 ON t1.a = t3.a ORDER BY t1.a, t3.a",
      // leftAsscom(left, inner) = 1: (t1 LEFT t2) INNER t3 on t2.a = t3.a
      // leftAsscom allows reorder when the inner join condition references the right side of the left join.
      "SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a JOIN t3 ON t2.a = t3.a ORDER BY t1.a, t2.a, t3.a",

      // =============================================
      // Group 3: RIGHT JOIN + INNER JOIN
      // =============================================

      // assoc(right, inner) = 1: (t1 RIGHT t2) INNER t3
      "SELECT * FROM t1 RIGHT JOIN t2 ON t1.a = t2.a JOIN t3 ON t2.a = t3.a ORDER BY t2.a, t3.a",
      // assoc(inner, right) = 0: (t1 INNER t2) RIGHT t3
      // A conflict rule prevents incorrect reorder.
      "SELECT * FROM t1 JOIN t2 ON t1.a = t2.a RIGHT JOIN t3 ON t2.a = t3.a ORDER BY t3.a",

      // =============================================
      // Group 4: Nested LEFT JOINs
      // =============================================

      // assoc(left, left) = 1: (t1 LEFT t2) LEFT t3 on t2.a = t3.a
      "SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a LEFT JOIN t3 ON t2.a = t3.a ORDER BY t1.a",
      // leftAsscom(left, left) = 1: (t1 LEFT t2) LEFT t3 on t1.a = t3.a
      "SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a LEFT JOIN t3 ON t1.a = t3.a ORDER BY t1.a",

      // =============================================
      // Group 5: Nested RIGHT JOINs
      // =============================================

      // assoc(right, right) = 1: (t1 RIGHT t2) RIGHT t3 on t2.a = t3.a
      "SELECT * FROM t1 RIGHT JOIN t2 ON t1.a = t2.a RIGHT JOIN t3 ON t2.a = t3.a ORDER BY t3.a",

      // =============================================
      // Group 6: LEFT + RIGHT mixed
      // =============================================

      // assoc(right, left) = 1: (t1 RIGHT t2) LEFT t3 on t2.a = t3.a
      "SELECT * FROM t1 RIGHT JOIN t2 ON t1.a = t2.a LEFT JOIN t3 ON t2.a = t3.a ORDER BY t2.a",
      // assoc(left, right) = 0: (t1 LEFT t2) RIGHT t3 on t1.a = t3.a
      // Conflict rule should prevent incorrect reorder.
      "SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a RIGHT JOIN t3 ON t1.a = t3.a ORDER BY t3.a",

      // =============================================
      // Group 7: rightAsscom(right, left) = 1
      // =============================================

      // rightAsscom(right, left) = 1: t1 RIGHT (t2 LEFT t3)
      // In SQL: t2 LEFT t3 is a subgroup; t1 RIGHT JOIN that.
      // We write it as: t1 RIGHT JOIN t2 ON t1.a = t2.a LEFT JOIN t3 ON t1.a = t3.a
      // Parse tree: (t1 RIGHT t2) LEFT t3
      // Use a different structure to test rightAsscom:
      // t2 LEFT t3 ON t2.a = t3.a, then t1 RIGHT t2 ON t1.b = t2.b
      // This is achieved via: t1 RIGHT JOIN (t2 LEFT JOIN t3 ON t2.a = t3.a) ON t1.a = t2.a
      // But MySQL syntax doesn't allow this directly. Use:
      "SELECT * FROM t2 LEFT JOIN t3 ON t2.a = t3.a RIGHT JOIN t1 ON t2.a = t1.a ORDER BY t1.a",

      // =============================================
      // Group 8: Complex 4-table mixed outer joins
      // =============================================

      // LEFT + INNER + LEFT: (t1 LEFT t2) INNER t3 LEFT t4
      "SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a JOIN t3 ON t1.a = t3.a LEFT JOIN t4 ON t3.a = t4.a ORDER BY t1.a",
      // RIGHT + INNER + RIGHT: (t1 RIGHT t2) INNER t3 RIGHT t4
      "SELECT * FROM t1 RIGHT JOIN t2 ON t1.a = t2.a JOIN t3 ON t2.a = t3.a RIGHT JOIN t4 ON t3.a = t4.a ORDER BY t4.a",
      // INNER + LEFT + RIGHT: t1 INNER t2 LEFT t3 RIGHT t4
      "SELECT * FROM t1 JOIN t2 ON t1.a = t2.a LEFT JOIN t3 ON t2.a = t3.a RIGHT JOIN t4 ON t3.a = t4.a ORDER BY t4.a",

      // =============================================
      // Group 9: All inner join with more complex conditions
      // =============================================

      // Inner join with multiple conditions
      "SELECT * FROM t1 JOIN t2 ON t1.a = t2.a AND t1.b < t2.b JOIN t3 ON t2.a = t3.a ORDER BY t1.a",
      // Inner join chain with different join columns
      "SELECT * FROM t1 JOIN t2 ON t1.a = t2.a JOIN t3 ON t2.b = t3.b ORDER BY t1.a, t2.a, t3.a",

      // =============================================
      // Group 10: Join-condition orientation and filters
      // =============================================

      // Reversed equality orientation to exercise eq condition alignment.
      "SELECT * FROM t1 JOIN t2 ON t2.a = t1.a JOIN t3 ON t3.a = t2.a ORDER BY t1.a",
      // Inner join with one-side filter in ON condition.
      "SELECT * FROM t1 JOIN t2 ON t1.a = t2.a AND t2.b > 150 JOIN t3 ON t2.a = t3.a ORDER BY t1.a, t2.a",
      // Degenerate predicate (single-side reference) + normal edge.
      "SELECT * FROM t1 JOIN t2 ON t1.b > 15 JOIN t3 ON t2.a = t3.a WHERE t1.a = 3 ORDER BY t2.a, t3.a",
      // Cross-style inner join with join predicate in WHERE.
      "SELECT * FROM t1 JOIN t2 JOIN t3 ON t2.a = t3.a WHERE t1.a = t2.a ORDER BY t1.a",

      // =============================================
      // Group 11: Reorder barriers and fallback paths
      // =============================================

      // Null-safe equality should stop join-group expansion.
      "SELECT * FROM t1 JOIN t2 ON t1.a <=> t2.a JOIN t3 ON t2.a = t3.a ORDER BY t1.a",
      // STRAIGHT_JOIN should preserve explicit order.
      "SELECT * FROM t1 STRAIGHT_JOIN t2 ON t1.a = t2.a JOIN t3 ON t2.a = t3.a ORDER BY t1.a",
      // Non-equi LEFT JOIN should not be reordered as non-inner edge.
      "SELECT * FROM t1 LEFT JOIN t2 ON t1.a < t2.a JOIN t3 ON t1.a = t3.a ORDER BY t1.a, t2.a, t3.a",
      // Non-equi RIGHT JOIN should not be reordered as non-inner edge.
      "SELECT * FROM t1 RIGHT JOIN t2 ON t1.a < t2.a JOIN t3 ON t2.a = t3.a ORDER BY t2.a, t3.a",

      // =============================================
      // Group 12: Parenthesized/derived join groups
      // =============================================

      // Explicit parenthesized mixed joins.
      "SELECT * FROM (t1 LEFT JOIN t2 ON t1.a = t2.a) JOIN (t3 JOIN t4 ON t3.a = t4.a) ON t1.a = t3.a ORDER BY t1.a, t3.a",
      // Right join over an explicit sub-join.
      "SELECT * FROM t1 RIGHT JOIN (t2 LEFT JOIN t3 ON t2.a = t3.a) ON t1.a = t2.a ORDER BY t2.a, t1.a",
      // Derived-table leafs inside join reorder.
      "SELECT * FROM (SELECT a, b FROM t1 WHERE a <= 3) x JOIN (SELECT a, b FROM t2 WHERE a <= 2) y ON x.a = y.a JOIN t3 ON y.a = t3.a ORDER BY x.a",
      // Mixed outer chain with one-side outer condition.
      "SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a AND t2.b > 150 LEFT JOIN t3 ON t1.a = t3.a JOIN t4 ON t3.a = t4.a ORDER BY t1.a, t4.a"
    ]
  }
]
