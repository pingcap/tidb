[
  {
    "Name": "TestOptimizeHintOnPartitionTable",
    "Cases": [
      {
        "SQL": "select /*+ use_index(t) */ * from t",
        "Plan": [
          "PartitionUnion 30000.00 root  ",
          "├─TableReader 10000.00 root  data:TableFullScan",
          "│ └─TableFullScan 10000.00 cop[tikv] table:t, partition:p0 keep order:false, stats:pseudo",
          "├─TableReader 10000.00 root  data:TableFullScan",
          "│ └─TableFullScan 10000.00 cop[tikv] table:t, partition:p1 keep order:false, stats:pseudo",
          "└─TableReader 10000.00 root  data:TableFullScan",
          "  └─TableFullScan 10000.00 cop[tikv] table:t, partition:p2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ use_index(t partition(p0, p1) b, c) */ * from t partition(p1,p2)",
        "Plan": [
          "PartitionUnion 20000.00 root  ",
          "├─IndexLookUp 10000.00 root  ",
          "│ ├─IndexFullScan(Build) 10000.00 cop[tikv] table:t, partition:p1, index:b(b) keep order:false, stats:pseudo",
          "│ └─TableRowIDScan(Probe) 10000.00 cop[tikv] table:t, partition:p1 keep order:false, stats:pseudo",
          "└─TableReader 10000.00 root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender 10000.00 mpp[tiflash]  ExchangeType: PassThrough",
          "    └─TableFullScan 10000.00 mpp[tiflash] table:t, partition:p2 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "Warning 1105 unknown partitions (p0) in optimizer hint /*+ USE_INDEX(t PARTITION(p0, p1) b, c) */"
        ]
      },
      {
        "SQL": "select /*+ use_index(t partition(p_non_exist)) */ * from t partition(p1,p2)",
        "Plan": [
          "PartitionUnion 20000.00 root  ",
          "├─TableReader 10000.00 root  MppVersion: 3, data:ExchangeSender",
          "│ └─ExchangeSender 10000.00 mpp[tiflash]  ExchangeType: PassThrough",
          "│   └─TableFullScan 10000.00 mpp[tiflash] table:t, partition:p1 keep order:false, stats:pseudo",
          "└─TableReader 10000.00 root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender 10000.00 mpp[tiflash]  ExchangeType: PassThrough",
          "    └─TableFullScan 10000.00 mpp[tiflash] table:t, partition:p2 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "Warning 1105 unknown partitions (p_non_exist) in optimizer hint /*+ USE_INDEX(t PARTITION(p_non_exist)) */"
        ]
      },
      {
        "SQL": "select /*+ use_index(t partition(p0, p1) b, c) */ * from t",
        "Plan": [
          "PartitionUnion 30000.00 root  ",
          "├─IndexLookUp 10000.00 root  ",
          "│ ├─IndexFullScan(Build) 10000.00 cop[tikv] table:t, partition:p0, index:b(b) keep order:false, stats:pseudo",
          "│ └─TableRowIDScan(Probe) 10000.00 cop[tikv] table:t, partition:p0 keep order:false, stats:pseudo",
          "├─IndexLookUp 10000.00 root  ",
          "│ ├─IndexFullScan(Build) 10000.00 cop[tikv] table:t, partition:p1, index:b(b) keep order:false, stats:pseudo",
          "│ └─TableRowIDScan(Probe) 10000.00 cop[tikv] table:t, partition:p1 keep order:false, stats:pseudo",
          "└─TableReader 10000.00 root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender 10000.00 mpp[tiflash]  ExchangeType: PassThrough",
          "    └─TableFullScan 10000.00 mpp[tiflash] table:t, partition:p2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ ignore_index(t partition(p0, p1) b, c) */ * from t",
        "Plan": [
          "PartitionUnion 30000.00 root  ",
          "├─TableReader 10000.00 root  MppVersion: 3, data:ExchangeSender",
          "│ └─ExchangeSender 10000.00 mpp[tiflash]  ExchangeType: PassThrough",
          "│   └─TableFullScan 10000.00 mpp[tiflash] table:t, partition:p0 keep order:false, stats:pseudo",
          "├─TableReader 10000.00 root  MppVersion: 3, data:ExchangeSender",
          "│ └─ExchangeSender 10000.00 mpp[tiflash]  ExchangeType: PassThrough",
          "│   └─TableFullScan 10000.00 mpp[tiflash] table:t, partition:p1 keep order:false, stats:pseudo",
          "└─TableReader 10000.00 root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender 10000.00 mpp[tiflash]  ExchangeType: PassThrough",
          "    └─TableFullScan 10000.00 mpp[tiflash] table:t, partition:p2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ hash_join(t1, t2 partition(p0)) */ * from t t1 join t t2 on t1.a = t2.a",
        "Plan": [
          "HashJoin 37500.00 root  inner join, equal:[eq(test.t.a, test.t.a)]",
          "├─PartitionUnion(Build) 30000.00 root  ",
          "│ ├─TableReader 10000.00 root  MppVersion: 3, data:ExchangeSender",
          "│ │ └─ExchangeSender 10000.00 mpp[tiflash]  ExchangeType: PassThrough",
          "│ │   └─TableFullScan 10000.00 mpp[tiflash] table:t2, partition:p0 keep order:false, stats:pseudo",
          "│ ├─TableReader 10000.00 root  MppVersion: 3, data:ExchangeSender",
          "│ │ └─ExchangeSender 10000.00 mpp[tiflash]  ExchangeType: PassThrough",
          "│ │   └─TableFullScan 10000.00 mpp[tiflash] table:t2, partition:p1 keep order:false, stats:pseudo",
          "│ └─TableReader 10000.00 root  MppVersion: 3, data:ExchangeSender",
          "│   └─ExchangeSender 10000.00 mpp[tiflash]  ExchangeType: PassThrough",
          "│     └─TableFullScan 10000.00 mpp[tiflash] table:t2, partition:p2 keep order:false, stats:pseudo",
          "└─PartitionUnion(Probe) 30000.00 root  ",
          "  ├─TableReader 10000.00 root  MppVersion: 3, data:ExchangeSender",
          "  │ └─ExchangeSender 10000.00 mpp[tiflash]  ExchangeType: PassThrough",
          "  │   └─TableFullScan 10000.00 mpp[tiflash] table:t1, partition:p0 keep order:false, stats:pseudo",
          "  ├─TableReader 10000.00 root  MppVersion: 3, data:ExchangeSender",
          "  │ └─ExchangeSender 10000.00 mpp[tiflash]  ExchangeType: PassThrough",
          "  │   └─TableFullScan 10000.00 mpp[tiflash] table:t1, partition:p1 keep order:false, stats:pseudo",
          "  └─TableReader 10000.00 root  MppVersion: 3, data:ExchangeSender",
          "    └─ExchangeSender 10000.00 mpp[tiflash]  ExchangeType: PassThrough",
          "      └─TableFullScan 10000.00 mpp[tiflash] table:t1, partition:p2 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "Warning 1105 Optimizer Hint /*+ HASH_JOIN(t1, t2 PARTITION(p0)) */ is inapplicable on specified partitions"
        ]
      },
      {
        "SQL": "select /*+ use_index_merge(t partition(p0)) */ * from t where t.b = 1 or t.c = \"8\"",
        "Plan": [
          "PartitionUnion 59.97 root  ",
          "├─IndexMerge 19.99 root  type: union",
          "│ ├─IndexRangeScan(Build) 10.00 cop[tikv] table:t, partition:p0, index:b(b) range:[1,1], keep order:false, stats:pseudo",
          "│ ├─IndexRangeScan(Build) 10.00 cop[tikv] table:t, partition:p0, index:c(c) range:[\"8\",\"8\"], keep order:false, stats:pseudo",
          "│ └─TableRowIDScan(Probe) 19.99 cop[tikv] table:t, partition:p0 keep order:false, stats:pseudo",
          "├─TableReader 19.99 root  MppVersion: 3, data:ExchangeSender",
          "│ └─ExchangeSender 19.99 mpp[tiflash]  ExchangeType: PassThrough",
          "│   └─TableFullScan 19.99 mpp[tiflash] table:t, partition:p1 pushed down filter:or(eq(test.t.b, 1), eq(test.t.c, \"8\")), keep order:false, stats:pseudo",
          "└─TableReader 19.99 root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender 19.99 mpp[tiflash]  ExchangeType: PassThrough",
          "    └─TableFullScan 19.99 mpp[tiflash] table:t, partition:p2 pushed down filter:or(eq(test.t.b, 1), eq(test.t.c, \"8\")), keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ use_index_merge(t partition(p0, p1) primary, b) */ * from t where t.a = 1 or t.b = 2",
        "Plan": [
          "PartitionUnion 33.00 root  ",
          "├─IndexMerge 11.00 root  type: union",
          "│ ├─TableRangeScan(Build) 1.00 cop[tikv] table:t, partition:p0 range:[1,1], keep order:false, stats:pseudo",
          "│ ├─IndexRangeScan(Build) 10.00 cop[tikv] table:t, partition:p0, index:b(b) range:[2,2], keep order:false, stats:pseudo",
          "│ └─TableRowIDScan(Probe) 11.00 cop[tikv] table:t, partition:p0 keep order:false, stats:pseudo",
          "├─IndexMerge 11.00 root  type: union",
          "│ ├─TableRangeScan(Build) 1.00 cop[tikv] table:t, partition:p1 range:[1,1], keep order:false, stats:pseudo",
          "│ ├─IndexRangeScan(Build) 10.00 cop[tikv] table:t, partition:p1, index:b(b) range:[2,2], keep order:false, stats:pseudo",
          "│ └─TableRowIDScan(Probe) 11.00 cop[tikv] table:t, partition:p1 keep order:false, stats:pseudo",
          "└─TableReader 11.00 root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender 11.00 mpp[tiflash]  ExchangeType: PassThrough",
          "    └─TableFullScan 11.00 mpp[tiflash] table:t, partition:p2 pushed down filter:or(eq(test.t.a, 1), eq(test.t.b, 2)), keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "select /*+ use_index(t partition(p0) b) */ * from t partition(p0, p1)",
        "Plan": [
          "PartitionUnion 20000.00 root  ",
          "├─IndexLookUp 10000.00 root  ",
          "│ ├─IndexFullScan(Build) 10000.00 cop[tikv] table:t, partition:p0, index:b(b) keep order:false, stats:pseudo",
          "│ └─TableRowIDScan(Probe) 10000.00 cop[tikv] table:t, partition:p0 keep order:false, stats:pseudo",
          "└─TableReader 10000.00 root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender 10000.00 mpp[tiflash]  ExchangeType: PassThrough",
          "    └─TableFullScan 10000.00 mpp[tiflash] table:t, partition:p1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      }
    ]
  },
  {
    "Name": "TestReadFromStorageHint",
    "Cases": [
      {
        "SQL": "explain format = 'plan_tree' select avg(a) from t",
        "Plan": [
          "HashAgg root  funcs:avg(Column, Column)->Column",
          "└─TableReader root  data:HashAgg",
          "  └─HashAgg batchCop[tiflash]  funcs:count(Column)->Column, funcs:sum(Column)->Column",
          "    └─Projection batchCop[tiflash]  test.t.a->Column, cast(test.t.a, decimal(10,0) BINARY)->Column",
          "      └─TableFullScan batchCop[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tiflash[t]) */ avg(a) from t",
        "Plan": [
          "HashAgg root  funcs:avg(Column, Column)->Column",
          "└─TableReader root  data:HashAgg",
          "  └─HashAgg batchCop[tiflash]  funcs:count(Column)->Column, funcs:sum(Column)->Column",
          "    └─Projection batchCop[tiflash]  test.t.a->Column, cast(test.t.a, decimal(10,0) BINARY)->Column",
          "      └─TableFullScan batchCop[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tiflash[t]) */ sum(a) from t",
        "Plan": [
          "StreamAgg root  funcs:sum(Column)->Column",
          "└─TableReader root  data:StreamAgg",
          "  └─StreamAgg batchCop[tiflash]  funcs:sum(Column)->Column",
          "    └─Projection batchCop[tiflash]  cast(test.t.a, decimal(10,0) BINARY)->Column",
          "      └─TableFullScan batchCop[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tiflash[t]) */ sum(a+1) from t",
        "Plan": [
          "StreamAgg root  funcs:sum(Column)->Column",
          "└─TableReader root  data:StreamAgg",
          "  └─StreamAgg batchCop[tiflash]  funcs:sum(Column)->Column",
          "    └─Projection batchCop[tiflash]  cast(plus(test.t.a, 1), decimal(20,0) BINARY)->Column",
          "      └─TableFullScan batchCop[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tiflash[t]) */ sum(isnull(a)) from t",
        "Plan": [
          "StreamAgg root  funcs:sum(Column)->Column",
          "└─TableReader root  data:StreamAgg",
          "  └─StreamAgg batchCop[tiflash]  funcs:sum(Column)->Column",
          "    └─Projection batchCop[tiflash]  cast(isnull(test.t.a), decimal(20,0) BINARY)->Column",
          "      └─TableFullScan batchCop[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ READ_FROM_STORAGE(TIKV[t1], TIKV[t2]) */ * from t t1, t t2 where t1.a = t2.a",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, test.t.a)]",
          "├─TableReader(Build) root  data:Selection",
          "│ └─Selection cop[tikv]  not(isnull(test.t.a))",
          "│   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  data:Selection",
          "  └─Selection cop[tikv]  not(isnull(test.t.a))",
          "    └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ READ_FROM_STORAGE(TIKV[t1], TIFLASH[t2]) */ * from t t1, t t2 where t1.a = t2.a",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, test.t.a)]",
          "├─TableReader(Build) root  data:Selection",
          "│ └─Selection cop[tiflash]  not(isnull(test.t.a))",
          "│   └─TableFullScan cop[tiflash] table:t2 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  data:Selection",
          "  └─Selection cop[tikv]  not(isnull(test.t.a))",
          "    └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select * from tt where (tt.a > 1 and tt.a < 20) or (tt.a >= 30 and tt.a < 55)",
        "Plan": [
          "TableReader root  data:TableRangeScan",
          "└─TableRangeScan cop[tikv] table:tt range:(1,20), [30,55), keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tiflash[tt]) */ * from tt where (tt.a > 1 and tt.a < 20) or (tt.a >= 30 and tt.a < 55)",
        "Plan": [
          "TableReader root  data:TableRangeScan",
          "└─TableRangeScan cop[tiflash] table:tt range:(1,20), [30,55), keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select * from ttt order by ttt.a desc",
        "Plan": [
          "TableReader root  data:TableFullScan",
          "└─TableFullScan cop[tikv] table:ttt keep order:true, desc, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tiflash[ttt]) */ * from ttt order by ttt.a desc",
        "Plan": [
          "Sort root  test.ttt.a:desc",
          "└─TableReader root  data:TableFullScan",
          "  └─TableFullScan cop[tiflash] table:ttt keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tiflash[ttt]) */ * from ttt order by ttt.a",
        "Plan": [
          "TableReader root  data:TableFullScan",
          "└─TableFullScan cop[tiflash] table:ttt keep order:true, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tikv[t, ttt]) */ * from ttt",
        "Plan": [
          "TableReader root  data:TableFullScan",
          "└─TableFullScan cop[tikv] table:ttt keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]There are no matching table names for (t) in optimizer hint /*+ READ_FROM_STORAGE(tikv[t, ttt]) */. Maybe you can use the table alias name"
        ]
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tiflash[t, ttt], tikv[tt]) */ * from ttt",
        "Plan": [
          "TableReader root  data:TableFullScan",
          "└─TableFullScan cop[tiflash] table:ttt keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]There are no matching table names for (t, tt) in optimizer hint /*+ READ_FROM_STORAGE(tiflash[t, ttt], tikv[tt]) */. Maybe you can use the table alias name"
        ]
      }
    ]
  },
  {
    "Name": "TestAllViewHintType",
    "Cases": [
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v1, v1), leading(@qb_v1 v, t2) */ * from v1;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, test.t1.a)]",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo",
          "└─HashJoin(Probe) root  inner join, equal:[eq(test.t3.a, test.t.a)]",
          "  ├─TableReader(Build) root  MppVersion: 3, data:ExchangeSender",
          "  │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  │   └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t3.a)), not(isnull(test.t3.b))",
          "    │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "        └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]leading hint is inapplicable, check if the leading hint table is valid"
        ]
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v1, v1), leading(v@qb_v1, t2@qb_v1) */ * from v1;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, test.t1.a)]",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo",
          "└─HashJoin(Probe) root  inner join, equal:[eq(test.t3.a, test.t.a)]",
          "  ├─TableReader(Build) root  MppVersion: 3, data:ExchangeSender",
          "  │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  │   └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t3.a)), not(isnull(test.t3.b))",
          "    │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "        └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]leading hint is inapplicable, check if the leading hint table is valid"
        ]
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v1, v1), leading(@qb_v1 t3, t2) */ * from v1;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, test.t1.a)]",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo",
          "└─HashJoin(Probe) root  inner join, equal:[eq(test.t3.a, test.t.a)]",
          "  ├─TableReader(Build) root  MppVersion: 3, data:ExchangeSender",
          "  │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  │   └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t3.a)), not(isnull(test.t3.b))",
          "    │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "        └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v1, v1), leading(t3@qb_v1, t2@qb_v1) */ * from v1;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, test.t1.a)]",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo",
          "└─HashJoin(Probe) root  inner join, equal:[eq(test.t3.a, test.t.a)]",
          "  ├─TableReader(Build) root  MppVersion: 3, data:ExchangeSender",
          "  │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  │   └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t3.a)), not(isnull(test.t3.b))",
          "    │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "        └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v1, v1), qb_name(qb_v, v1.v), leading(t2@qb_v1, t@qb_v) */ * from v1;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, test.t1.a)]",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo",
          "└─HashJoin(Probe) root  inner join, equal:[eq(test.t3.a, test.t.a)]",
          "  ├─TableReader(Build) root  MppVersion: 3, data:ExchangeSender",
          "  │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  │   └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t3.a)), not(isnull(test.t3.b))",
          "    │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "        └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]Only one query block name is allowed in a view hint, otherwise the hint will be invalid"
        ]
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v1, v1), hash_join(@qb_v1 v, t2) */ * from v1;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t3.a, test.t.a)]",
          "├─MergeJoin(Build) root  inner join, left key:test.t.a, right key:test.t1.a",
          "│ ├─IndexReader(Build) root  index:IndexFullScan",
          "│ │ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:true, stats:pseudo",
          "│ └─IndexReader(Probe) root  index:IndexFullScan",
          "│   └─IndexFullScan cop[tikv] table:t, index:idx_a(a) keep order:true, stats:pseudo",
          "└─HashJoin(Probe) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "  ├─TableReader(Build) root  data:Selection",
          "  │ └─Selection cop[tikv]  not(isnull(test.t3.a)), not(isnull(test.t3.b))",
          "  │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "  └─TableReader(Probe) root  data:Selection",
          "    └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "      └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v1, v1), hash_join(t2@qb_v1, t3@qb_v1) */ * from v1;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, test.t1.a)]",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo",
          "└─HashJoin(Probe) root  inner join, equal:[eq(test.t3.a, test.t.a)]",
          "  ├─TableReader(Build) root  MppVersion: 3, data:ExchangeSender",
          "  │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  │   └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t3.a)), not(isnull(test.t3.b))",
          "    │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "        └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v1, v1), hash_join_build(@qb_v1 v) */ * from v1;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t3.a, test.t.a)]",
          "├─MergeJoin(Build) root  inner join, left key:test.t.a, right key:test.t1.a",
          "│ ├─IndexReader(Build) root  index:IndexFullScan",
          "│ │ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:true, stats:pseudo",
          "│ └─IndexReader(Probe) root  index:IndexFullScan",
          "│   └─IndexFullScan cop[tikv] table:t, index:idx_a(a) keep order:true, stats:pseudo",
          "└─HashJoin(Probe) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "  ├─TableReader(Build) root  data:Selection",
          "  │ └─Selection cop[tikv]  not(isnull(test.t3.a)), not(isnull(test.t3.b))",
          "  │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "  └─TableReader(Probe) root  data:Selection",
          "    └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "      └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v1, v1), hash_join_build(t2@qb_v1) */ * from v1;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, test.t1.a)]",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo",
          "└─HashJoin(Probe) root  inner join, equal:[eq(test.t3.a, test.t.a)]",
          "  ├─TableReader(Build) root  MppVersion: 3, data:ExchangeSender",
          "  │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  │   └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "    │   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t3.a)), not(isnull(test.t3.b))",
          "        └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v1, v1), hash_join_build(@qb_v1 v) */ * from v1;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t3.a, test.t.a)]",
          "├─MergeJoin(Build) root  inner join, left key:test.t.a, right key:test.t1.a",
          "│ ├─IndexReader(Build) root  index:IndexFullScan",
          "│ │ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:true, stats:pseudo",
          "│ └─IndexReader(Probe) root  index:IndexFullScan",
          "│   └─IndexFullScan cop[tikv] table:t, index:idx_a(a) keep order:true, stats:pseudo",
          "└─HashJoin(Probe) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "  ├─TableReader(Build) root  data:Selection",
          "  │ └─Selection cop[tikv]  not(isnull(test.t3.a)), not(isnull(test.t3.b))",
          "  │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "  └─TableReader(Probe) root  data:Selection",
          "    └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "      └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v1, v1), hash_join_build(t2@qb_v1) */ * from v1;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, test.t1.a)]",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo",
          "└─HashJoin(Probe) root  inner join, equal:[eq(test.t3.a, test.t.a)]",
          "  ├─TableReader(Build) root  MppVersion: 3, data:ExchangeSender",
          "  │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  │   └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "    │   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t3.a)), not(isnull(test.t3.b))",
          "        └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v1, v1), merge_join(@qb_v1 v) */ * from v1;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t3.a, test.t.a)]",
          "├─MergeJoin(Build) root  inner join, left key:test.t.a, right key:test.t1.a",
          "│ ├─IndexReader(Build) root  index:IndexFullScan",
          "│ │ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:true, stats:pseudo",
          "│ └─IndexReader(Probe) root  index:IndexFullScan",
          "│   └─IndexFullScan cop[tikv] table:t, index:idx_a(a) keep order:true, stats:pseudo",
          "└─HashJoin(Probe) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "  ├─TableReader(Build) root  data:Selection",
          "  │ └─Selection cop[tikv]  not(isnull(test.t3.a)), not(isnull(test.t3.b))",
          "  │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "  └─TableReader(Probe) root  data:Selection",
          "    └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "      └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v1, v1), merge_join(t2@qb_v1) */ * from v1;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, test.t1.a)]",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo",
          "└─HashJoin(Probe) root  inner join, equal:[eq(test.t3.a, test.t.a)]",
          "  ├─TableReader(Build) root  MppVersion: 3, data:ExchangeSender",
          "  │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  │   └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "  └─MergeJoin(Probe) root  inner join, left key:test.t3.b, right key:test.t2.b",
          "    ├─Sort(Build) root  test.t2.b",
          "    │ └─TableReader root  data:Selection",
          "    │   └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "    │     └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "    └─Sort(Probe) root  test.t3.b",
          "      └─TableReader root  data:Selection",
          "        └─Selection cop[tikv]  not(isnull(test.t3.a)), not(isnull(test.t3.b))",
          "          └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v, v), INL_JOIN(@qb_v t) */ * from v;",
        "Plan": [
          "IndexJoin root  inner join, inner:IndexLookUp, outer key:test.t1.a, inner key:test.t.a, equal cond:eq(test.t1.a, test.t.a)",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo",
          "└─IndexLookUp(Probe) root  ",
          "  ├─IndexRangeScan(Build) cop[tikv] table:t, index:idx_a(a) range: decided by [eq(test.t.a, test.t1.a)], keep order:false, stats:pseudo",
          "  └─TableRowIDScan(Probe) cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v, v), INL_JOIN(t@qb_v) */ * from v;",
        "Plan": [
          "IndexJoin root  inner join, inner:IndexLookUp, outer key:test.t1.a, inner key:test.t.a, equal cond:eq(test.t1.a, test.t.a)",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo",
          "└─IndexLookUp(Probe) root  ",
          "  ├─IndexRangeScan(Build) cop[tikv] table:t, index:idx_a(a) range: decided by [eq(test.t.a, test.t1.a)], keep order:false, stats:pseudo",
          "  └─TableRowIDScan(Probe) cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v2, v2.@sel_2), hash_agg(@qb_v2) */ * from v2;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, Column)]",
          "├─HashAgg(Build) root  group by:test.t2.a, funcs:count(1)->Column",
          "│ └─HashJoin root  inner join, equal:[eq(test.t.a, test.t1.a)]",
          "│   ├─IndexReader(Build) root  index:IndexFullScan",
          "│   │ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo",
          "│   └─HashJoin(Probe) root  inner join, equal:[eq(test.t3.a, test.t.a)]",
          "│     ├─TableReader(Build) root  MppVersion: 3, data:ExchangeSender",
          "│     │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "│     │   └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "│     └─HashJoin(Probe) root  inner join, equal:[eq(test.t2.b, test.t1.b)]",
          "│       ├─TableReader(Build) root  data:Selection",
          "│       │ └─Selection cop[tikv]  not(isnull(test.t1.b))",
          "│       │   └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "│       └─HashJoin(Probe) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "│         ├─TableReader(Build) root  data:Selection",
          "│         │ └─Selection cop[tikv]  not(isnull(test.t3.a)), not(isnull(test.t3.b))",
          "│         │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "│         └─TableReader(Probe) root  data:Selection",
          "│           └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "│             └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v2, v2.@sel_2), stream_agg(@qb_v2) */ * from v2;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, Column)]",
          "├─StreamAgg(Build) root  group by:test.t2.a, funcs:count(1)->Column",
          "│ └─Sort root  test.t2.a",
          "│   └─HashJoin root  inner join, equal:[eq(test.t.a, test.t1.a)]",
          "│     ├─IndexReader(Build) root  index:IndexFullScan",
          "│     │ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo",
          "│     └─HashJoin(Probe) root  inner join, equal:[eq(test.t3.a, test.t.a)]",
          "│       ├─TableReader(Build) root  MppVersion: 3, data:ExchangeSender",
          "│       │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "│       │   └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "│       └─HashJoin(Probe) root  inner join, equal:[eq(test.t2.b, test.t1.b)]",
          "│         ├─TableReader(Build) root  data:Selection",
          "│         │ └─Selection cop[tikv]  not(isnull(test.t1.b))",
          "│         │   └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "│         └─HashJoin(Probe) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "│           ├─TableReader(Build) root  data:Selection",
          "│           │ └─Selection cop[tikv]  not(isnull(test.t3.a)), not(isnull(test.t3.b))",
          "│           │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "│           └─TableReader(Probe) root  data:Selection",
          "│             └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "│               └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v3, v3), use_index(t5@qb_v3, idx_a) */ * from v3;",
        "Plan": [
          "IndexLookUp root  ",
          "├─IndexRangeScan(Build) cop[tikv] table:t5, index:idx_a(a) range:(1,+inf], keep order:false, stats:pseudo",
          "└─Selection(Probe) cop[tikv]  lt(test.t5.b, 2)",
          "  └─TableRowIDScan cop[tikv] table:t5 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v3, v3), use_index(@qb_v3 t5, idx_b) */ * from v3;",
        "Plan": [
          "IndexLookUp root  ",
          "├─IndexRangeScan(Build) cop[tikv] table:t5, index:idx_b(b) range:[-inf,2), keep order:false, stats:pseudo",
          "└─Selection(Probe) cop[tikv]  gt(test.t5.a, 1)",
          "  └─TableRowIDScan cop[tikv] table:t5 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v3, v3), force_index(t5@qb_v3, idx_a) */ * from v3;",
        "Plan": [
          "IndexLookUp root  ",
          "├─IndexRangeScan(Build) cop[tikv] table:t5, index:idx_a(a) range:(1,+inf], keep order:false, stats:pseudo",
          "└─Selection(Probe) cop[tikv]  lt(test.t5.b, 2)",
          "  └─TableRowIDScan cop[tikv] table:t5 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v3, v3), force_index(@qb_v3 t5, idx_b) */ * from v3;",
        "Plan": [
          "IndexLookUp root  ",
          "├─IndexRangeScan(Build) cop[tikv] table:t5, index:idx_b(b) range:[-inf,2), keep order:false, stats:pseudo",
          "└─Selection(Probe) cop[tikv]  gt(test.t5.a, 1)",
          "  └─TableRowIDScan cop[tikv] table:t5 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v3, v3), ignore_index(t5@qb_v3, idx_a) */ * from v3;",
        "Plan": [
          "TableReader root  data:Selection",
          "└─Selection cop[tikv]  gt(test.t5.a, 1), lt(test.t5.b, 2)",
          "  └─TableFullScan cop[tikv] table:t5 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v3, v3), ignore_index(@qb_v3 t5, idx_b) */ * from v3;",
        "Plan": [
          "TableReader root  data:Selection",
          "└─Selection cop[tikv]  gt(test.t5.a, 1), lt(test.t5.b, 2)",
          "  └─TableFullScan cop[tikv] table:t5 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v4, v4), use_index_merge(t5@qb_v4, idx_a, idx_b) */ * from v4;",
        "Plan": [
          "IndexMerge root  type: union",
          "├─IndexRangeScan(Build) cop[tikv] table:t5, index:idx_a(a) range:(1,+inf], keep order:false, stats:pseudo",
          "├─IndexRangeScan(Build) cop[tikv] table:t5, index:idx_b(b) range:[-inf,2), keep order:false, stats:pseudo",
          "└─TableRowIDScan(Probe) cop[tikv] table:t5 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v4, v4), use_index_merge(@qb_v4 t5, idx_b, idx_a) */ * from v4;",
        "Plan": [
          "IndexMerge root  type: union",
          "├─IndexRangeScan(Build) cop[tikv] table:t5, index:idx_a(a) range:(1,+inf], keep order:false, stats:pseudo",
          "├─IndexRangeScan(Build) cop[tikv] table:t5, index:idx_b(b) range:[-inf,2), keep order:false, stats:pseudo",
          "└─TableRowIDScan(Probe) cop[tikv] table:t5 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v, v), READ_FROM_STORAGE(TIFLASH[t@qb_v], TIKV[t1@qb_v]) */ * from v;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.a, test.t1.a)]",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v5, v5.@sel_2), SEMI_JOIN_REWRITE(@qb_v5) */ * from v5;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t.b, test.t1.b)]",
          "├─HashAgg(Build) root  group by:test.t1.b, funcs:firstrow(test.t1.b)->test.t1.b",
          "│ └─TableReader root  data:HashAgg",
          "│   └─HashAgg cop[tikv]  group by:test.t1.b, ",
          "│     └─Selection cop[tikv]  not(isnull(test.t1.b))",
          "│       └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "└─TableReader(Probe) root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─Selection mpp[tiflash]  not(isnull(test.t.b))",
          "      └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v6, v6.@sel_2), NO_DECORRELATE(@qb_v6) */ * from v6;",
        "Plan": [
          "Projection root  test.t1.a, test.t1.b",
          "└─Apply root  CARTESIAN inner join, other cond:lt(cast(test.t1.a, decimal(10,0) BINARY), Column)",
          "  ├─TableReader(Build) root  data:TableFullScan",
          "  │ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "  └─MaxOneRow(Probe) root  ",
          "    └─StreamAgg root  funcs:sum(Column)->Column",
          "      └─TableReader root  data:StreamAgg",
          "        └─StreamAgg cop[tikv]  funcs:sum(test.t2.a)->Column",
          "          └─Selection cop[tikv]  eq(test.t2.b, test.t1.b)",
          "            └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v7, v7), merge(@qb_v7) */ * from v7;",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  Column, Column",
          "    └─HashAgg mpp[tiflash]  group by:Column, Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column",
          "      └─ExchangeReceiver mpp[tiflash]  ",
          "        └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: Column, collate: binary], [name: Column, collate: binary]",
          "          └─HashAgg mpp[tiflash]  group by:Column, Column, ",
          "            └─Union mpp[tiflash]  ",
          "              ├─Selection mpp[tiflash]  lt(test.t.a, 18), lt(test.t.a, 60)",
          "              │ └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "              └─Selection mpp[tiflash]  gt(test.t.b, 1), lt(test.t.a, 60)",
          "                └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v8, v8), merge(@qb_v8) */ * from v8;",
        "Plan": [
          "HashAgg root  group by:Column, funcs:firstrow(Column)->Column",
          "└─Union root  ",
          "  ├─HashJoin root  CARTESIAN inner join",
          "  │ ├─TableReader(Build) root  data:TableFullScan",
          "  │ │ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "  │ └─CTEFullScan(Probe) root CTE:cte2 data:CTE_1",
          "  └─TableReader root  data:TableFullScan",
          "    └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "CTE_1 root  Non-Recursive CTE",
          "└─HashJoin(Seed Part) root  CARTESIAN inner join",
          "  ├─CTEFullScan(Build) root CTE:cte4 data:CTE_3",
          "  └─CTEFullScan(Probe) root CTE:cte3 data:CTE_2",
          "CTE_3 root  Non-Recursive CTE",
          "└─IndexReader(Seed Part) root  index:IndexFullScan",
          "  └─IndexFullScan cop[tikv] table:t3, index:idx_a(a) keep order:false, stats:pseudo",
          "CTE_2 root  Non-Recursive CTE",
          "└─IndexReader(Seed Part) root  index:IndexFullScan",
          "  └─IndexFullScan cop[tikv] table:t2, index:idx_a(a) keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v9, v9), AGG_TO_COP(@qb_v9) */ * from v9;",
        "Plan": [
          "HashAgg root  funcs:sum(Column)->Column",
          "└─IndexReader root  index:HashAgg",
          "  └─HashAgg cop[tikv]  funcs:sum(test.t.a)->Column",
          "    └─IndexFullScan cop[tikv] table:t, index:idx_a(a) keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb_v10, v10), LIMIT_TO_COP(@qb_v10) */ * from v10;",
        "Plan": [
          "TopN root  test.t.b, offset:0, count:1",
          "└─TableReader root  data:TopN",
          "  └─TopN cop[tikv]  test.t.b, offset:0, count:1",
          "    └─Selection cop[tikv]  gt(test.t.a, 10)",
          "      └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb, v11) read_from_storage(tiflash[t@qb]), MPP_1PHASE_AGG(@qb) */ * from v11;",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, Column",
          "    └─Projection mpp[tiflash]  Column, test.t.a",
          "      └─HashAgg mpp[tiflash]  group by:Column, funcs:sum(Column)->Column, funcs:firstrow(Column)->test.t.a",
          "        └─Projection mpp[tiflash]  cast(test.t.b, decimal(10,0) BINARY)->Column, test.t.a->Column",
          "          └─ExchangeReceiver mpp[tiflash]  ",
          "            └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "              └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb, v11) read_from_storage(tiflash[t@qb]), MPP_2PHASE_AGG(@qb) */ * from v11;",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, Column",
          "    └─Projection mpp[tiflash]  Column, test.t.a",
          "      └─HashAgg mpp[tiflash]  group by:test.t.a, funcs:sum(Column)->Column, funcs:firstrow(test.t.a)->test.t.a",
          "        └─ExchangeReceiver mpp[tiflash]  ",
          "          └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "            └─HashAgg mpp[tiflash]  group by:Column, funcs:sum(Column)->Column",
          "              └─Projection mpp[tiflash]  cast(test.t.b, decimal(10,0) BINARY)->Column, test.t.a->Column",
          "                └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb, v12) read_from_storage(tiflash[t1@qb, t@qb]), shuffle_join(t1@qb, t@qb) */ * from v12;",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, test.t.b",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "      │   └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "      └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "        └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t.a, collate: binary]",
          "          └─TableFullScan mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb, v12) read_from_storage(tiflash[t1@qb, t@qb]), broadcast_join(t1@qb, t@qb) */ * from v12;",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t.a, test.t.b",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t.a, test.t.a)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo",
          "      └─TableFullScan(Probe) mpp[tiflash] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      }
    ]
  },
  {
    "Name": "TestJoinHintCompatibility",
    "Cases": [
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t3), hash_join(t1) */ * from t1 join t2 join t3 where t1.a = t2.a and t2.b = t3.b;",
        "Plan": [
          "Projection root  test.t1.a, test.t1.b, test.t2.a, test.t2.b, test.t3.a, test.t3.b",
          "└─HashJoin root  inner join, equal:[eq(test.t2.a, test.t1.a)]",
          "  ├─TableReader(Build) root  data:TableFullScan",
          "  │ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "    │   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "        └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t2), hash_join(t2) */ * from t1 join t2 join t3 where t1.a = t2.a and t2.b = t3.b;",
        "Plan": [
          "Projection root  test.t1.a, test.t1.b, test.t2.a, test.t2.b, test.t3.a, test.t3.b",
          "└─HashJoin root  inner join, equal:[eq(test.t2.a, test.t1.a)]",
          "  ├─TableReader(Build) root  data:TableFullScan",
          "  │ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t2.b, test.t3.b)]",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "    │   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "        └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t3), merge_join(t1) */ * from t1 join t2 join t3 where t1.a = t2.a and t2.b = t3.b;",
        "Plan": [
          "Projection root  test.t1.a, test.t1.b, test.t2.a, test.t2.b, test.t3.a, test.t3.b",
          "└─MergeJoin root  inner join, left key:test.t2.a, right key:test.t1.a",
          "  ├─Sort(Build) root  test.t1.a",
          "  │ └─TableReader root  data:TableFullScan",
          "  │   └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "  └─Sort(Probe) root  test.t2.a",
          "    └─HashJoin root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "      ├─TableReader(Build) root  data:Selection",
          "      │ └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "      │   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "      └─TableReader(Probe) root  data:Selection",
          "        └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "          └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t2), merge_join(t2) */ * from t1 join t2 join t3 where t1.a = t2.a and t2.b = t3.b;",
        "Plan": [
          "Projection root  test.t1.a, test.t1.b, test.t2.a, test.t2.b, test.t3.a, test.t3.b",
          "└─HashJoin root  inner join, equal:[eq(test.t2.a, test.t1.a)]",
          "  ├─TableReader(Build) root  data:TableFullScan",
          "  │ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "  └─MergeJoin(Probe) root  inner join, left key:test.t2.b, right key:test.t3.b",
          "    ├─Sort(Build) root  test.t3.b",
          "    │ └─TableReader root  data:Selection",
          "    │   └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "    │     └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "    └─Sort(Probe) root  test.t2.b",
          "      └─TableReader root  data:Selection",
          "        └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "          └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t3), inl_join(t1) */ * from t1 join t2 join t3 where t1.a = t2.a and t2.b = t3.b;",
        "Plan": [
          "Projection root  test.t1.a, test.t1.b, test.t2.a, test.t2.b, test.t3.a, test.t3.b",
          "└─IndexJoin root  inner join, inner:IndexLookUp, outer key:test.t2.a, inner key:test.t1.a, equal cond:eq(test.t2.a, test.t1.a)",
          "  ├─HashJoin(Build) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "  │ ├─TableReader(Build) root  data:Selection",
          "  │ │ └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "  │ │   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "  │ └─TableReader(Probe) root  data:Selection",
          "  │   └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "  │     └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "  └─IndexLookUp(Probe) root  ",
          "    ├─IndexRangeScan(Build) cop[tikv] table:t1, index:idx_a(a) range: decided by [eq(test.t1.a, test.t2.a)], keep order:false, stats:pseudo",
          "    └─TableRowIDScan(Probe) cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t2), inl_join(t2) */ * from t1 join t2 join t3 where t1.a = t2.a and t2.b = t3.b;",
        "Plan": [
          "Projection root  test.t1.a, test.t1.b, test.t2.a, test.t2.b, test.t3.a, test.t3.b",
          "└─HashJoin root  inner join, equal:[eq(test.t2.a, test.t1.a)]",
          "  ├─TableReader(Build) root  data:TableFullScan",
          "  │ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "  └─IndexJoin(Probe) root  inner join, inner:IndexLookUp, outer key:test.t3.b, inner key:test.t2.b, equal cond:eq(test.t3.b, test.t2.b)",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "    │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "    └─IndexLookUp(Probe) root  ",
          "      ├─Selection(Build) cop[tikv]  not(isnull(test.t2.b))",
          "      │ └─IndexRangeScan cop[tikv] table:t2, index:idx_b(b) range: decided by [eq(test.t2.b, test.t3.b)], keep order:false, stats:pseudo",
          "      └─Selection(Probe) cop[tikv]  not(isnull(test.t2.a))",
          "        └─TableRowIDScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t3), hash_join_build(t1) */ * from t1 join t2 join t3 where t1.a = t2.a and t2.b = t3.b;",
        "Plan": [
          "Projection root  test.t1.a, test.t1.b, test.t2.a, test.t2.b, test.t3.a, test.t3.b",
          "└─HashJoin root  inner join, equal:[eq(test.t2.a, test.t1.a)]",
          "  ├─TableReader(Build) root  data:TableFullScan",
          "  │ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "    │   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "        └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t2), hash_join_build(t2) */ * from t1 join t2 join t3 where t1.a = t2.a and t2.b = t3.b;",
        "Plan": [
          "Projection root  test.t1.a, test.t1.b, test.t2.a, test.t2.b, test.t3.a, test.t3.b",
          "└─HashJoin root  inner join, equal:[eq(test.t2.a, test.t1.a)]",
          "  ├─TableReader(Build) root  data:TableFullScan",
          "  │ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t2.b, test.t3.b)]",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "    │   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "        └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t3), hash_join_probe(t1) */ * from t1 join t2 join t3 where t1.a = t2.a and t2.b = t3.b;",
        "Plan": [
          "Projection root  test.t1.a, test.t1.b, test.t2.a, test.t2.b, test.t3.a, test.t3.b",
          "└─HashJoin root  inner join, equal:[eq(test.t2.a, test.t1.a)]",
          "  ├─HashJoin(Build) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "  │ ├─TableReader(Build) root  data:Selection",
          "  │ │ └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "  │ │   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "  │ └─TableReader(Probe) root  data:Selection",
          "  │   └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "  │     └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "  └─TableReader(Probe) root  data:TableFullScan",
          "    └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t2), hash_join_probe(t2) */ * from t1 join t2 join t3 where t1.a = t2.a and t2.b = t3.b;",
        "Plan": [
          "Projection root  test.t1.a, test.t1.b, test.t2.a, test.t2.b, test.t3.a, test.t3.b",
          "└─HashJoin root  inner join, equal:[eq(test.t2.a, test.t1.a)]",
          "  ├─TableReader(Build) root  data:TableFullScan",
          "  │ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t2.b, test.t3.b)]",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "    │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "        └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t6), shuffle_join(t4) */ * from t4 join t5 join t6 where t4.a = t5.a and t5.b = t6.b;",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t4.a, test.t4.b, test.t5.a, test.t5.b, test.t6.a, test.t6.b",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t5.a, test.t4.a)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t4.a, collate: binary]",
          "      │   └─Selection mpp[tiflash]  not(isnull(test.t4.a))",
          "      │     └─TableFullScan mpp[tiflash] table:t4 keep order:false, stats:pseudo",
          "      └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "        └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t5.a, collate: binary]",
          "          └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t6.b, test.t5.b)]",
          "            ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "            │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "            │   └─Selection mpp[tiflash]  not(isnull(test.t5.a)), not(isnull(test.t5.b))",
          "            │     └─TableFullScan mpp[tiflash] table:t5 keep order:false, stats:pseudo",
          "            └─Selection(Probe) mpp[tiflash]  not(isnull(test.t6.b))",
          "              └─TableFullScan mpp[tiflash] table:t6 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t5), shuffle_join(t5) */ * from t4 join t5 join t6 where t4.a = t5.a and t5.b = t6.b;",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t4.a, test.t4.b, test.t5.a, test.t5.b, test.t6.a, test.t6.b",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t5.b, test.t6.b)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─Selection mpp[tiflash]  not(isnull(test.t6.b))",
          "      │     └─TableFullScan mpp[tiflash] table:t6 keep order:false, stats:pseudo",
          "      └─HashJoin(Probe) mpp[tiflash]  inner join, equal:[eq(test.t5.a, test.t4.a)]",
          "        ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t5.a, collate: binary]",
          "        │   └─Selection mpp[tiflash]  not(isnull(test.t5.a)), not(isnull(test.t5.b))",
          "        │     └─TableFullScan mpp[tiflash] table:t5 keep order:false, stats:pseudo",
          "        └─ExchangeReceiver(Probe) mpp[tiflash]  ",
          "          └─ExchangeSender mpp[tiflash]  ExchangeType: HashPartition, Compression: FAST, Hash Cols: [name: test.t4.a, collate: binary]",
          "            └─Selection mpp[tiflash]  not(isnull(test.t4.a))",
          "              └─TableFullScan mpp[tiflash] table:t4 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t6), broadcast_join(t4) */ * from t4 join t5 join t6 where t4.a = t5.a and t5.b = t6.b;",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t4.a, test.t4.b, test.t5.a, test.t5.b, test.t6.a, test.t6.b",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t5.a, test.t4.a)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─Selection mpp[tiflash]  not(isnull(test.t4.a))",
          "      │     └─TableFullScan mpp[tiflash] table:t4 keep order:false, stats:pseudo",
          "      └─HashJoin(Probe) mpp[tiflash]  inner join, equal:[eq(test.t6.b, test.t5.b)]",
          "        ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "        │   └─Selection mpp[tiflash]  not(isnull(test.t5.a)), not(isnull(test.t5.b))",
          "        │     └─TableFullScan mpp[tiflash] table:t5 keep order:false, stats:pseudo",
          "        └─Selection(Probe) mpp[tiflash]  not(isnull(test.t6.b))",
          "          └─TableFullScan mpp[tiflash] table:t6 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t5), broadcast_join(t5) */ * from t4 join t5 join t6 where t4.a = t5.a and t5.b = t6.b;",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t4.a, test.t4.b, test.t5.a, test.t5.b, test.t6.a, test.t6.b",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t5.b, test.t6.b)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─Selection mpp[tiflash]  not(isnull(test.t6.b))",
          "      │     └─TableFullScan mpp[tiflash] table:t6 keep order:false, stats:pseudo",
          "      └─HashJoin(Probe) mpp[tiflash]  inner join, equal:[eq(test.t5.a, test.t4.a)]",
          "        ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "        │   └─Selection mpp[tiflash]  not(isnull(test.t5.a)), not(isnull(test.t5.b))",
          "        │     └─TableFullScan mpp[tiflash] table:t5 keep order:false, stats:pseudo",
          "        └─Selection(Probe) mpp[tiflash]  not(isnull(test.t4.a))",
          "          └─TableFullScan mpp[tiflash] table:t4 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t3), hash_join(t1) */ * from t1 join t2 on t1.a = t2.a left join t3 on t2.b = t3.b;",
        "Plan": [
          "Projection root  test.t1.a, test.t1.b, test.t2.a, test.t2.b, test.t3.a, test.t3.b",
          "└─HashJoin root  inner join, equal:[eq(test.t2.a, test.t1.a)]",
          "  ├─TableReader(Build) root  data:TableFullScan",
          "  │ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  left outer join, left side:TableReader, equal:[eq(test.t2.b, test.t3.b)]",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "    │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t2.a))",
          "        └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t2), hash_join(t2) */ * from t1 join t2 on t1.a = t2.a left join t3 on t2.b = t3.b;",
        "Plan": [
          "Projection root  test.t1.a, test.t1.b, test.t2.a, test.t2.b, test.t3.a, test.t3.b",
          "└─HashJoin root  inner join, equal:[eq(test.t2.a, test.t1.a)]",
          "  ├─TableReader(Build) root  data:TableFullScan",
          "  │ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  left outer join, left side:TableReader, equal:[eq(test.t2.b, test.t3.b)]",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "    │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t2.a))",
          "        └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t3), merge_join(t1) */ * from t1 right join t2 on t1.a = t2.a join t3 on t2.b = t3.b;",
        "Plan": [
          "Projection root  test.t1.a, test.t1.b, test.t2.a, test.t2.b, test.t3.a, test.t3.b",
          "└─MergeJoin root  right outer join, left side:Sort, left key:test.t1.a, right key:test.t2.a",
          "  ├─Sort(Build) root  test.t1.a",
          "  │ └─TableReader root  data:TableFullScan",
          "  │   └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "  └─Sort(Probe) root  test.t2.a",
          "    └─HashJoin root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "      ├─TableReader(Build) root  data:Selection",
          "      │ └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "      │   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "      └─TableReader(Probe) root  data:Selection",
          "        └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "          └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t2), merge_join(t2) */ * from t1 right join t2 on t1.a = t2.a join t3 on t2.b = t3.b;",
        "Plan": [
          "HashJoin root  right outer join, left side:TableReader, equal:[eq(test.t1.a, test.t2.a)]",
          "├─TableReader(Build) root  data:TableFullScan",
          "│ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "└─MergeJoin(Probe) root  inner join, left key:test.t2.b, right key:test.t3.b",
          "  ├─Sort(Build) root  test.t3.b",
          "  │ └─TableReader root  data:Selection",
          "  │   └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "  │     └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "  └─Sort(Probe) root  test.t2.b",
          "    └─TableReader root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "        └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t3), inl_join(t1) */ * from t1 join t2 on t1.a = t2.a straight_join t3 on t2.b = t3.b;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t2.b, test.t3.b)]",
          "├─TableReader(Build) root  data:Selection",
          "│ └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "│   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "└─Projection(Probe) root  test.t1.a, test.t1.b, test.t2.a, test.t2.b",
          "  └─IndexJoin root  inner join, inner:IndexLookUp, outer key:test.t2.a, inner key:test.t1.a, equal cond:eq(test.t2.a, test.t1.a)",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "    │   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "    └─IndexLookUp(Probe) root  ",
          "      ├─IndexRangeScan(Build) cop[tikv] table:t1, index:idx_a(a) range: decided by [eq(test.t1.a, test.t2.a)], keep order:false, stats:pseudo",
          "      └─TableRowIDScan(Probe) cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]leading hint is inapplicable, check the join type or the join algorithm hint"
        ]
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t2), inl_join(t2) */ * from t1 join t2 on t1.a = t2.a straight_join t3 on t2.b = t3.b;",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t2.b, test.t3.b)]",
          "├─TableReader(Build) root  data:Selection",
          "│ └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "│   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "└─Projection(Probe) root  test.t1.a, test.t1.b, test.t2.a, test.t2.b",
          "  └─IndexJoin root  inner join, inner:IndexLookUp, outer key:test.t1.a, inner key:test.t2.a, equal cond:eq(test.t1.a, test.t2.a)",
          "    ├─TableReader(Build) root  data:TableFullScan",
          "    │ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "    └─IndexLookUp(Probe) root  ",
          "      ├─Selection(Build) cop[tikv]  not(isnull(test.t2.a))",
          "      │ └─IndexRangeScan cop[tikv] table:t2, index:idx_a(a) range: decided by [eq(test.t2.a, test.t1.a)], keep order:false, stats:pseudo",
          "      └─Selection(Probe) cop[tikv]  not(isnull(test.t2.b))",
          "        └─TableRowIDScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t3), hash_join_build(t1) */ * from t1 cross join t2 on t1.a = t2.a join t3 on t2.b = t3.b;",
        "Plan": [
          "Projection root  test.t1.a, test.t1.b, test.t2.a, test.t2.b, test.t3.a, test.t3.b",
          "└─HashJoin root  inner join, equal:[eq(test.t2.a, test.t1.a)]",
          "  ├─TableReader(Build) root  data:TableFullScan",
          "  │ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "    │   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "        └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t2), hash_join_probe(t2) */ * from t1 cross join t2 on t1.a = t2.a join t3 on t2.b = t3.b;",
        "Plan": [
          "Projection root  test.t1.a, test.t1.b, test.t2.a, test.t2.b, test.t3.a, test.t3.b",
          "└─HashJoin root  inner join, equal:[eq(test.t2.a, test.t1.a)]",
          "  ├─TableReader(Build) root  data:TableFullScan",
          "  │ └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t2.b, test.t3.b)]",
          "    ├─TableReader(Build) root  data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t3.b))",
          "    │   └─TableFullScan cop[tikv] table:t3 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "        └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select * from v",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t1.a, test.t.a)]",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t, index:idx_a(a) keep order:false, stats:pseudo",
          "└─IndexJoin(Probe) root  inner join, inner:IndexLookUp, outer key:test.t2.b, inner key:test.t1.b, equal cond:eq(test.t2.b, test.t1.b)",
          "  ├─IndexReader(Build) root  index:IndexFullScan",
          "  │ └─IndexFullScan cop[tikv] table:t2, index:idx_b(b) keep order:false, stats:pseudo",
          "  └─IndexLookUp(Probe) root  ",
          "    ├─Selection(Build) cop[tikv]  not(isnull(test.t1.b))",
          "    │ └─IndexRangeScan cop[tikv] table:t1, index:idx_b(b) range: decided by [eq(test.t1.b, test.t2.b)], keep order:false, stats:pseudo",
          "    └─TableRowIDScan(Probe) cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select * from v1",
        "Plan": [
          "MergeJoin root  inner join, left key:test.t1.a, right key:test.t.a",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t, index:idx_a(a) keep order:true, stats:pseudo",
          "└─Sort(Probe) root  test.t1.a",
          "  └─HashJoin root  inner join, equal:[eq(test.t2.b, test.t1.b)]",
          "    ├─IndexReader(Build) root  index:IndexFullScan",
          "    │ └─IndexFullScan cop[tikv] table:t2, index:idx_b(b) keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t1.b))",
          "        └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb, v2), leading(t2@qb), merge_join(t@qb) */ * from v2",
        "Plan": [
          "MergeJoin root  inner join, left key:test.t1.a, right key:test.t.a",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t, index:idx_a(a) keep order:true, stats:pseudo",
          "└─Sort(Probe) root  test.t1.a",
          "  └─HashJoin root  inner join, equal:[eq(test.t2.b, test.t1.b)]",
          "    ├─IndexReader(Build) root  index:IndexFullScan",
          "    │ └─IndexFullScan cop[tikv] table:t2, index:idx_b(b) keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t1.b))",
          "        └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ qb_name(qb, v2), leading(t1@qb), inl_join(t1@qb) */ * from v2",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t1.a, test.t.a)]",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t, index:idx_a(a) keep order:false, stats:pseudo",
          "└─IndexJoin(Probe) root  inner join, inner:IndexLookUp, outer key:test.t2.b, inner key:test.t1.b, equal cond:eq(test.t2.b, test.t1.b)",
          "  ├─IndexReader(Build) root  index:IndexFullScan",
          "  │ └─IndexFullScan cop[tikv] table:t2, index:idx_b(b) keep order:false, stats:pseudo",
          "  └─IndexLookUp(Probe) root  ",
          "    ├─Selection(Build) cop[tikv]  not(isnull(test.t1.b))",
          "    │ └─IndexRangeScan cop[tikv] table:t1, index:idx_b(b) range: decided by [eq(test.t1.b, test.t2.b)], keep order:false, stats:pseudo",
          "    └─TableRowIDScan(Probe) cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' with tt as (select /*+ leading(t3), merge_join(t1) */ t1.a from t1 join t2 join t3 where t1.a = t2.a and t2.b=t3.b) select * from tt t1 join tt t2 on t1.a=t2.a",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t1.a, test.t1.a)]",
          "├─Selection(Build) root  not(isnull(test.t1.a))",
          "│ └─CTEFullScan root CTE:tt AS t2 data:CTE_0",
          "└─Selection(Probe) root  not(isnull(test.t1.a))",
          "  └─CTEFullScan root CTE:tt AS t1 data:CTE_0",
          "CTE_0 root  Non-Recursive CTE",
          "└─MergeJoin(Seed Part) root  inner join, left key:test.t2.a, right key:test.t1.a",
          "  ├─IndexReader(Build) root  index:IndexFullScan",
          "  │ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:true, stats:pseudo",
          "  └─Sort(Probe) root  test.t2.a",
          "    └─HashJoin root  inner join, equal:[eq(test.t3.b, test.t2.b)]",
          "      ├─IndexReader(Build) root  index:IndexFullScan",
          "      │ └─IndexFullScan cop[tikv] table:t3, index:idx_b(b) keep order:false, stats:pseudo",
          "      └─TableReader(Probe) root  data:Selection",
          "        └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "          └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' with tt as (select /*+ leading(t2), inl_join(t2) */ t1.a from t1 join t2 join t3 where t1.a = t2.a and t2.b=t3.b) select * from tt t1 join tt t2 on t1.a=t2.a",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t1.a, test.t1.a)]",
          "├─Selection(Build) root  not(isnull(test.t1.a))",
          "│ └─CTEFullScan root CTE:tt AS t2 data:CTE_0",
          "└─Selection(Probe) root  not(isnull(test.t1.a))",
          "  └─CTEFullScan root CTE:tt AS t1 data:CTE_0",
          "CTE_0 root  Non-Recursive CTE",
          "└─HashJoin(Seed Part) root  inner join, equal:[eq(test.t2.a, test.t1.a)]",
          "  ├─IndexReader(Build) root  index:IndexFullScan",
          "  │ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:false, stats:pseudo",
          "  └─IndexJoin(Probe) root  inner join, inner:IndexLookUp, outer key:test.t3.b, inner key:test.t2.b, equal cond:eq(test.t3.b, test.t2.b)",
          "    ├─IndexReader(Build) root  index:IndexFullScan",
          "    │ └─IndexFullScan cop[tikv] table:t3, index:idx_b(b) keep order:false, stats:pseudo",
          "    └─IndexLookUp(Probe) root  ",
          "      ├─Selection(Build) cop[tikv]  not(isnull(test.t2.b))",
          "      │ └─IndexRangeScan cop[tikv] table:t2, index:idx_b(b) range: decided by [eq(test.t2.b, test.t3.b)], keep order:false, stats:pseudo",
          "      └─Selection(Probe) cop[tikv]  not(isnull(test.t2.a))",
          "        └─TableRowIDScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' with tt as (select /*+ merge(), leading(t3), inl_join(t1) */ t1.a from t1 join t2 join t3 where t1.a = t2.a and t2.b=t3.b) select * from tt t1 join tt t2 on t1.a=t2.a",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t2.b, test.t3.b)]",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t3, index:idx_b(b) keep order:false, stats:pseudo",
          "└─HashJoin(Probe) root  inner join, equal:[eq(test.t1.a, test.t2.a)]",
          "  ├─TableReader(Build) root  data:Selection",
          "  │ └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "  │   └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "  └─IndexJoin(Probe) root  inner join, inner:IndexReader, outer key:test.t1.a, inner key:test.t1.a, equal cond:eq(test.t1.a, test.t1.a)",
          "    ├─IndexJoin(Build) root  inner join, inner:IndexReader, outer key:test.t2.a, inner key:test.t1.a, equal cond:eq(test.t2.a, test.t1.a)",
          "    │ ├─HashJoin(Build) root  inner join, equal:[eq(test.t2.b, test.t3.b)]",
          "    │ │ ├─IndexReader(Build) root  index:IndexFullScan",
          "    │ │ │ └─IndexFullScan cop[tikv] table:t3, index:idx_b(b) keep order:false, stats:pseudo",
          "    │ │ └─TableReader(Probe) root  data:Selection",
          "    │ │   └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "    │ │     └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "    │ └─IndexReader(Probe) root  index:IndexRangeScan",
          "    │   └─IndexRangeScan cop[tikv] table:t1, index:idx_a(a) range: decided by [eq(test.t1.a, test.t2.a)], keep order:false, stats:pseudo",
          "    └─IndexReader(Probe) root  index:IndexRangeScan",
          "      └─IndexRangeScan cop[tikv] table:t1, index:idx_a(a) range: decided by [eq(test.t1.a, test.t1.a)], keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]We can only use one leading hint at most, when multiple leading hints are used, all leading hints will be invalid"
        ]
      },
      {
        "SQL": "explain format = 'plan_tree' with tt as (select /*+ leading(t2), merge_join(t2), merge() */ t1.a from t1 join t2 join t3 where t1.a = t2.a and t2.b=t3.b) select * from tt t1 join tt t2 on t1.a=t2.a",
        "Plan": [
          "HashJoin root  inner join, equal:[eq(test.t2.b, test.t3.b)]",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t3, index:idx_b(b) keep order:false, stats:pseudo",
          "└─MergeJoin(Probe) root  inner join, left key:test.t1.a, right key:test.t2.a",
          "  ├─Sort(Build) root  test.t2.a",
          "  │ └─TableReader root  data:Selection",
          "  │   └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "  │     └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "  └─MergeJoin(Probe) root  inner join, left key:test.t1.a, right key:test.t1.a",
          "    ├─IndexReader(Build) root  index:IndexFullScan",
          "    │ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:true, stats:pseudo",
          "    └─MergeJoin(Probe) root  inner join, left key:test.t2.a, right key:test.t1.a",
          "      ├─IndexReader(Build) root  index:IndexFullScan",
          "      │ └─IndexFullScan cop[tikv] table:t1, index:idx_a(a) keep order:true, stats:pseudo",
          "      └─Sort(Probe) root  test.t2.a",
          "        └─MergeJoin root  inner join, left key:test.t2.b, right key:test.t3.b",
          "          ├─IndexReader(Build) root  index:IndexFullScan",
          "          │ └─IndexFullScan cop[tikv] table:t3, index:idx_b(b) keep order:true, stats:pseudo",
          "          └─Sort(Probe) root  test.t2.b",
          "            └─TableReader root  data:Selection",
          "              └─Selection cop[tikv]  not(isnull(test.t2.a)), not(isnull(test.t2.b))",
          "                └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]We can only use one leading hint at most, when multiple leading hints are used, all leading hints will be invalid"
        ]
      },
      {
        "SQL": "explain format = 'plan_tree' SELECT /*+ leading(t2@sel_2), merge_join(t) */ * FROM t join t1 on t.a = t1.a WHERE EXISTS (SELECT 1 FROM t2 WHERE t2.b = t1.b);",
        "Plan": [
          "HashJoin root  semi join, left side:Projection, equal:[eq(test.t1.b, test.t2.b)]",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t2, index:idx_b(b) keep order:false, stats:pseudo",
          "└─Projection(Probe) root  test.t.a, test.t.b, test.t1.a, test.t1.b",
          "  └─MergeJoin root  inner join, left key:test.t1.a, right key:test.t.a",
          "    ├─Sort(Build) root  test.t.a",
          "    │ └─TableReader root  data:TableFullScan",
          "    │   └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo",
          "    └─Sort(Probe) root  test.t1.a",
          "      └─TableReader root  data:Selection",
          "        └─Selection cop[tikv]  not(isnull(test.t1.b))",
          "          └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]leading hint is inapplicable, check the join type or the join algorithm hint"
        ]
      },
      {
        "SQL": "explain format = 'plan_tree' SELECT /*+ leading(t1), inl_join(t1) */ * FROM t join t1 on t.a = t1.a WHERE EXISTS (SELECT 1 FROM t2 WHERE t2.b = t1.b);",
        "Plan": [
          "HashJoin root  semi join, left side:Projection, equal:[eq(test.t1.b, test.t2.b)]",
          "├─IndexReader(Build) root  index:IndexFullScan",
          "│ └─IndexFullScan cop[tikv] table:t2, index:idx_b(b) keep order:false, stats:pseudo",
          "└─Projection(Probe) root  test.t.a, test.t.b, test.t1.a, test.t1.b",
          "  └─IndexJoin root  inner join, inner:IndexLookUp, outer key:test.t.a, inner key:test.t1.a, equal cond:eq(test.t.a, test.t1.a)",
          "    ├─TableReader(Build) root  data:TableFullScan",
          "    │ └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo",
          "    └─IndexLookUp(Probe) root  ",
          "      ├─IndexRangeScan(Build) cop[tikv] table:t1, index:idx_a(a) range: decided by [eq(test.t1.a, test.t.a)], keep order:false, stats:pseudo",
          "      └─Selection(Probe) cop[tikv]  not(isnull(test.t1.b))",
          "        └─TableRowIDScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' SELECT /*+ leading(t2@sel_2), merge_join(t) */ * FROM t join t1 on t.a = t1.a WHERE EXISTS (SELECT /*+ SEMI_JOIN_REWRITE() */ 1 FROM t2 WHERE t2.b = t1.b);",
        "Plan": [
          "Projection root  test.t.a, test.t.b, test.t1.a, test.t1.b",
          "└─MergeJoin root  inner join, left key:test.t1.a, right key:test.t.a",
          "  ├─Sort(Build) root  test.t.a",
          "  │ └─TableReader root  data:TableFullScan",
          "  │   └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo",
          "  └─Sort(Probe) root  test.t1.a",
          "    └─HashJoin root  inner join, equal:[eq(test.t2.b, test.t1.b)]",
          "      ├─StreamAgg(Build) root  group by:test.t2.b, funcs:firstrow(test.t2.b)->test.t2.b",
          "      │ └─IndexReader root  index:StreamAgg",
          "      │   └─StreamAgg cop[tikv]  group by:test.t2.b, ",
          "      │     └─IndexFullScan cop[tikv] table:t2, index:idx_b(b) keep order:true, stats:pseudo",
          "      └─TableReader(Probe) root  data:Selection",
          "        └─Selection cop[tikv]  not(isnull(test.t1.b))",
          "          └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' SELECT /*+ leading(t1), inl_join(t1) */ * FROM t join t1 on t.a = t1.a WHERE EXISTS (SELECT /*+ SEMI_JOIN_REWRITE() */ 1 FROM t2 WHERE t2.b = t1.b);",
        "Plan": [
          "Projection root  test.t.a, test.t.b, test.t1.a, test.t1.b",
          "└─HashJoin root  inner join, equal:[eq(test.t1.b, test.t2.b)]",
          "  ├─StreamAgg(Build) root  group by:test.t2.b, funcs:firstrow(test.t2.b)->test.t2.b",
          "  │ └─IndexReader root  index:StreamAgg",
          "  │   └─StreamAgg cop[tikv]  group by:test.t2.b, ",
          "  │     └─IndexFullScan cop[tikv] table:t2, index:idx_b(b) keep order:true, stats:pseudo",
          "  └─IndexJoin(Probe) root  inner join, inner:IndexLookUp, outer key:test.t.a, inner key:test.t1.a, equal cond:eq(test.t.a, test.t1.a)",
          "    ├─TableReader(Build) root  data:TableFullScan",
          "    │ └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo",
          "    └─IndexLookUp(Probe) root  ",
          "      ├─IndexRangeScan(Build) cop[tikv] table:t1, index:idx_a(a) range: decided by [eq(test.t1.a, test.t.a)], keep order:false, stats:pseudo",
          "      └─Selection(Probe) cop[tikv]  not(isnull(test.t1.b))",
          "        └─TableRowIDScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t2@sel_2) merge_join(t) */ * from t join t1 on t.a = t1.a where t1.a < (select sum(t2.a) from t2 where t2.b = t1.b);",
        "Plan": [
          "Projection root  test.t.a, test.t.b, test.t1.a, test.t1.b",
          "└─HashJoin root  inner join, equal:[eq(test.t1.b, test.t2.b)], other cond:lt(cast(test.t1.a, decimal(10,0) BINARY), Column)",
          "  ├─HashAgg(Build) root  group by:test.t2.b, funcs:sum(Column)->Column, funcs:firstrow(test.t2.b)->test.t2.b",
          "  │ └─TableReader root  data:HashAgg",
          "  │   └─HashAgg cop[tikv]  group by:test.t2.b, funcs:sum(test.t2.a)->Column",
          "  │     └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "  │       └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "  └─MergeJoin(Probe) root  inner join, left key:test.t1.a, right key:test.t.a",
          "    ├─Sort(Build) root  test.t.a",
          "    │ └─TableReader root  data:TableFullScan",
          "    │   └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo",
          "    └─Sort(Probe) root  test.t1.a",
          "      └─TableReader root  data:Selection",
          "        └─Selection cop[tikv]  not(isnull(test.t1.b))",
          "          └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]There are no matching table names for (t2) in optimizer hint /*+ LEADING(t2) */. Maybe you can use the table alias name"
        ]
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t1), inl_join(t1) */ * from t join t1 on t.a = t1.a where t1.a < (select sum(t2.a) from t2 where t2.b = t1.b);",
        "Plan": [
          "Projection root  test.t.a, test.t.b, test.t1.a, test.t1.b",
          "└─HashJoin root  inner join, equal:[eq(test.t1.b, test.t2.b)], other cond:lt(cast(test.t1.a, decimal(10,0) BINARY), Column)",
          "  ├─HashAgg(Build) root  group by:test.t2.b, funcs:sum(Column)->Column, funcs:firstrow(test.t2.b)->test.t2.b",
          "  │ └─TableReader root  data:HashAgg",
          "  │   └─HashAgg cop[tikv]  group by:test.t2.b, funcs:sum(test.t2.a)->Column",
          "  │     └─Selection cop[tikv]  not(isnull(test.t2.b))",
          "  │       └─TableFullScan cop[tikv] table:t2 keep order:false, stats:pseudo",
          "  └─IndexJoin(Probe) root  inner join, inner:IndexLookUp, outer key:test.t.a, inner key:test.t1.a, equal cond:eq(test.t.a, test.t1.a)",
          "    ├─TableReader(Build) root  data:TableFullScan",
          "    │ └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo",
          "    └─IndexLookUp(Probe) root  ",
          "      ├─IndexRangeScan(Build) cop[tikv] table:t1, index:idx_a(a) range: decided by [eq(test.t1.a, test.t.a)], keep order:false, stats:pseudo",
          "      └─Selection(Probe) cop[tikv]  not(isnull(test.t1.b))",
          "        └─TableRowIDScan cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+leading(t2@sel_2)  merge_join(t) */ * from t join t1 on t.a = t1.a where t1.a < (select /*+ NO_DECORRELATE() */ sum(t2.a) from t2 where t2.b = t1.b);",
        "Plan": [
          "Projection root  test.t.a, test.t.b, test.t1.a, test.t1.b",
          "└─Apply root  CARTESIAN inner join, other cond:lt(cast(test.t1.a, decimal(10,0) BINARY), Column)",
          "  ├─MergeJoin(Build) root  inner join, left key:test.t.a, right key:test.t1.a",
          "  │ ├─Sort(Build) root  test.t1.a",
          "  │ │ └─TableReader root  data:TableFullScan",
          "  │ │   └─TableFullScan cop[tikv] table:t1 keep order:false, stats:pseudo",
          "  │ └─Sort(Probe) root  test.t.a",
          "  │   └─TableReader root  data:TableFullScan",
          "  │     └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo",
          "  └─MaxOneRow(Probe) root  ",
          "    └─StreamAgg root  funcs:sum(Column)->Column",
          "      └─Projection root  cast(test.t2.a, decimal(10,0) BINARY)->Column",
          "        └─IndexLookUp root  ",
          "          ├─IndexRangeScan(Build) cop[tikv] table:t2, index:idx_b(b) range: decided by [eq(test.t2.b, test.t1.b)], keep order:false, stats:pseudo",
          "          └─TableRowIDScan(Probe) cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]There are no matching table names for (t2) in optimizer hint /*+ LEADING(t2) */. Maybe you can use the table alias name"
        ]
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t1), inl_join(t1) */ * from t join t1 on t.a = t1.a where t1.a < (select /*+ NO_DECORRELATE() */ sum(t2.a) from t2 where t2.b = t1.b);",
        "Plan": [
          "Projection root  test.t.a, test.t.b, test.t1.a, test.t1.b",
          "└─Apply root  CARTESIAN inner join, other cond:lt(cast(test.t1.a, decimal(10,0) BINARY), Column)",
          "  ├─Projection(Build) root  test.t.a, test.t.b, test.t1.a, test.t1.b",
          "  │ └─IndexJoin root  inner join, inner:IndexLookUp, outer key:test.t.a, inner key:test.t1.a, equal cond:eq(test.t.a, test.t1.a)",
          "  │   ├─TableReader(Build) root  data:TableFullScan",
          "  │   │ └─TableFullScan cop[tikv] table:t keep order:false, stats:pseudo",
          "  │   └─IndexLookUp(Probe) root  ",
          "  │     ├─IndexRangeScan(Build) cop[tikv] table:t1, index:idx_a(a) range: decided by [eq(test.t1.a, test.t.a)], keep order:false, stats:pseudo",
          "  │     └─TableRowIDScan(Probe) cop[tikv] table:t1 keep order:false, stats:pseudo",
          "  └─MaxOneRow(Probe) root  ",
          "    └─StreamAgg root  funcs:sum(Column)->Column",
          "      └─Projection root  cast(test.t2.a, decimal(10,0) BINARY)->Column",
          "        └─IndexLookUp root  ",
          "          ├─IndexRangeScan(Build) cop[tikv] table:t2, index:idx_b(b) range: decided by [eq(test.t2.b, test.t1.b)], keep order:false, stats:pseudo",
          "          └─TableRowIDScan(Probe) cop[tikv] table:t2 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t9), hash_join(t7) */ * from t7 join t8 join t9 where t7.a = t8.a and t8.b = t9.b;",
        "Plan": [
          "Projection root  test.t7.a, test.t7.b, test.t8.a, test.t8.b, test.t9.a, test.t9.b",
          "└─HashJoin root  inner join, equal:[eq(test.t8.a, test.t7.a)]",
          "  ├─TableReader(Build) root partition:all data:Selection",
          "  │ └─Selection cop[tikv]  not(isnull(test.t7.a))",
          "  │   └─TableFullScan cop[tikv] table:t7 keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t9.b, test.t8.b)]",
          "    ├─TableReader(Build) root partition:all data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t8.a)), not(isnull(test.t8.b))",
          "    │   └─TableFullScan cop[tikv] table:t8 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root partition:all data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t9.b))",
          "        └─TableFullScan cop[tikv] table:t9 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ leading(t8), hash_join(t8) */ * from t7 join t8 join t9 where t7.a = t8.a and t8.b = t9.b;",
        "Plan": [
          "Projection root  test.t7.a, test.t7.b, test.t8.a, test.t8.b, test.t9.a, test.t9.b",
          "└─HashJoin root  inner join, equal:[eq(test.t8.b, test.t9.b)]",
          "  ├─TableReader(Build) root partition:all data:Selection",
          "  │ └─Selection cop[tikv]  not(isnull(test.t9.b))",
          "  │   └─TableFullScan cop[tikv] table:t9 keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t8.a, test.t7.a)]",
          "    ├─TableReader(Build) root partition:all data:Selection",
          "    │ └─Selection cop[tikv]  not(isnull(test.t8.a)), not(isnull(test.t8.b))",
          "    │   └─TableFullScan cop[tikv] table:t8 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root partition:all data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t7.a))",
          "        └─TableFullScan cop[tikv] table:t7 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tikv[t4, t6]), leading(t6), hash_join_build(t4) */ * from t4 join t5 join t6 where t4.a = t5.a and t5.b = t6.b;",
        "Plan": [
          "Projection root  test.t4.a, test.t4.b, test.t5.a, test.t5.b, test.t6.a, test.t6.b",
          "└─HashJoin root  inner join, equal:[eq(test.t5.a, test.t4.a)]",
          "  ├─TableReader(Build) root  data:Selection",
          "  │ └─Selection cop[tikv]  not(isnull(test.t4.a))",
          "  │   └─TableFullScan cop[tikv] table:t4 keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t6.b, test.t5.b)]",
          "    ├─TableReader(Build) root  MppVersion: 3, data:ExchangeSender",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t5.a)), not(isnull(test.t5.b))",
          "    │     └─TableFullScan mpp[tiflash] table:t5 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t6.b))",
          "        └─TableFullScan cop[tikv] table:t6 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tikv[t5]), leading(t5), hash_join_probe(t5) */ * from t4 join t5 join t6 where t4.a = t5.a and t5.b = t6.b;",
        "Plan": [
          "Projection root  test.t4.a, test.t4.b, test.t5.a, test.t5.b, test.t6.a, test.t6.b",
          "└─HashJoin root  inner join, equal:[eq(test.t5.b, test.t6.b)]",
          "  ├─TableReader(Build) root  MppVersion: 3, data:ExchangeSender",
          "  │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  │   └─Selection mpp[tiflash]  not(isnull(test.t6.b))",
          "  │     └─TableFullScan mpp[tiflash] table:t6 keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) root  inner join, equal:[eq(test.t5.a, test.t4.a)]",
          "    ├─TableReader(Build) root  MppVersion: 3, data:ExchangeSender",
          "    │ └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    │   └─Selection mpp[tiflash]  not(isnull(test.t4.a))",
          "    │     └─TableFullScan mpp[tiflash] table:t4 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) root  data:Selection",
          "      └─Selection cop[tikv]  not(isnull(test.t5.a)), not(isnull(test.t5.b))",
          "        └─TableFullScan cop[tikv] table:t5 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tiflash[t4, t6]), leading(t6), hash_join_build(t4) */ * from t4 join t5 join t6 where t4.a = t5.a and t5.b = t6.b;",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t4.a, test.t4.b, test.t5.a, test.t5.b, test.t6.a, test.t6.b",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t5.a, test.t4.a)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─Selection mpp[tiflash]  not(isnull(test.t4.a))",
          "      │     └─TableFullScan mpp[tiflash] table:t4 keep order:false, stats:pseudo",
          "      └─HashJoin(Probe) mpp[tiflash]  inner join, equal:[eq(test.t6.b, test.t5.b)]",
          "        ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "        │   └─Selection mpp[tiflash]  not(isnull(test.t5.a)), not(isnull(test.t5.b))",
          "        │     └─TableFullScan mpp[tiflash] table:t5 keep order:false, stats:pseudo",
          "        └─Selection(Probe) mpp[tiflash]  not(isnull(test.t6.b))",
          "          └─TableFullScan mpp[tiflash] table:t6 keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tiflash[t5]), leading(t5), hash_join_probe(t5) */ * from t4 join t5 join t6 where t4.a = t5.a and t5.b = t6.b;",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─Projection mpp[tiflash]  test.t4.a, test.t4.b, test.t5.a, test.t5.b, test.t6.a, test.t6.b",
          "    └─HashJoin mpp[tiflash]  inner join, equal:[eq(test.t5.b, test.t6.b)]",
          "      ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "      │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "      │   └─Selection mpp[tiflash]  not(isnull(test.t6.b))",
          "      │     └─TableFullScan mpp[tiflash] table:t6 keep order:false, stats:pseudo",
          "      └─HashJoin(Probe) mpp[tiflash]  inner join, equal:[eq(test.t5.a, test.t4.a)]",
          "        ├─ExchangeReceiver(Build) mpp[tiflash]  ",
          "        │ └─ExchangeSender mpp[tiflash]  ExchangeType: Broadcast, Compression: FAST",
          "        │   └─Selection mpp[tiflash]  not(isnull(test.t4.a))",
          "        │     └─TableFullScan mpp[tiflash] table:t4 keep order:false, stats:pseudo",
          "        └─Selection(Probe) mpp[tiflash]  not(isnull(test.t5.a)), not(isnull(test.t5.b))",
          "          └─TableFullScan mpp[tiflash] table:t5 keep order:false, stats:pseudo"
        ],
        "Warn": null
      }
    ]
  },
  {
    "Name": "TestReadFromStorageHintAndIsolationRead",
    "Cases": [
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tikv[t], tiflash[t]) */ avg(a) from t",
        "Plan": [
          "HashAgg root  funcs:avg(Column, Column)->Column",
          "└─IndexReader root  index:HashAgg",
          "  └─HashAgg cop[tikv]  funcs:count(test.t.a)->Column, funcs:sum(test.t.a)->Column",
          "    └─IndexFullScan cop[tikv] table:t, index:ia(a) keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]Storage hints are conflict, you can only specify one storage type of table test.t"
        ]
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tikv[t]) */ avg(a) from t",
        "Plan": [
          "HashAgg root  funcs:avg(Column, Column)->Column",
          "└─IndexReader root  index:HashAgg",
          "  └─HashAgg cop[tikv]  funcs:count(test.t.a)->Column, funcs:sum(test.t.a)->Column",
          "    └─IndexFullScan cop[tikv] table:t, index:ia(a) keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ read_from_storage(tiflash[t]) */ avg(a) from t",
        "Plan": [
          "HashAgg root  funcs:avg(Column, Column)->Column",
          "└─IndexReader root  index:HashAgg",
          "  └─HashAgg cop[tikv]  funcs:count(test.t.a)->Column, funcs:sum(test.t.a)->Column",
          "    └─IndexFullScan cop[tikv] table:t, index:ia(a) keep order:false, stats:pseudo"
        ],
        "Warn": [
          "[planner:1815]No available path for table test.t with the store type tiflash of the hint /*+ read_from_storage */, please check the status of the table replica and variable value of tidb_isolation_read_engines(map[0:{}])"
        ]
      }
    ]
  },
  {
    "Name": "TestIsolationReadTiFlashUseIndexHint",
    "Cases": [
      {
        "SQL": "explain format = 'plan_tree' select * from t",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select * from t use index();",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ use_index(t, idx)*/ * from t",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": [
          "TiDB doesn't support index 'idx' in the isolation read engines(value: 'tiflash')"
        ]
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ use_index(t)*/ * from t",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ use_index(t, PRIMARY)*/ * from t",
        "Plan": [
          "TableReader root  MppVersion: 3, data:ExchangeSender",
          "└─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "  └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": [
          "TiDB doesn't support index 'PRIMARY' in the isolation read engines(value: 'tiflash')"
        ]
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ use_index(t, idx_vec)*/ a from t order by VEC_COSINE_DISTANCE(`vec`, '[1, 2, 3]') limit 1;",
        "Plan": [
          "TopN root  Column, offset:0, count:1",
          "└─TableReader root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─TopN mpp[tiflash]  Column, offset:0, count:1",
          "      └─TableFullScan mpp[tiflash] table:t, index:idx_vec(vec) keep order:false, stats:pseudo, annIndex:COSINE(vec..[1,2,3], limit:1)->Column#6"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ use_index(t, idx_v)*/ a from t order by VEC_COSINE_DISTANCE(`vec`, '[1, 2, 3]') limit 1;",
        "Plan": [
          "TopN root  Column, offset:0, count:1",
          "└─TableReader root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─TopN mpp[tiflash]  Column, offset:0, count:1",
          "      └─TableFullScan mpp[tiflash] table:t, index:idx_vec(vec) keep order:false, stats:pseudo, annIndex:COSINE(vec..[1,2,3], limit:1)->Column#6"
        ],
        "Warn": null
      },
      {
        "SQL": "explain format = 'plan_tree' select /*+ ignore_index(t, idx_vec)*/ a from t order by VEC_COSINE_DISTANCE(`vec`, '[1, 2, 3]') limit 1;",
        "Plan": [
          "TopN root  Column, offset:0, count:1",
          "└─TableReader root  MppVersion: 3, data:ExchangeSender",
          "  └─ExchangeSender mpp[tiflash]  ExchangeType: PassThrough",
          "    └─TopN mpp[tiflash]  Column, offset:0, count:1",
          "      └─Projection mpp[tiflash]  test.t.a, vec_cosine_distance(test.t.vec, [1,2,3])->Column",
          "        └─TableFullScan mpp[tiflash] table:t keep order:false, stats:pseudo"
        ],
        "Warn": null
      }
    ]
  },
  {
    "Name": "TestHints",
    "Cases": [
      {
        "SQL": "select * from t1, t2, t3 union all select /*+ leading(t3, t2) */ * from t1, t2, t3 union all select * from t1, t2, t3",
        "Plan": [
          "Union 3000000000000.00 root  ",
          "├─HashJoin 1000000000000.00 root  CARTESIAN inner join",
          "│ ├─TableReader(Build) 10000.00 root  data:TableFullScan",
          "│ │ └─TableFullScan 10000.00 cop[tikv] table:t3 keep order:false, stats:pseudo",
          "│ └─HashJoin(Probe) 100000000.00 root  CARTESIAN inner join",
          "│   ├─TableReader(Build) 10000.00 root  data:TableFullScan",
          "│   │ └─TableFullScan 10000.00 cop[tikv] table:t2 keep order:false, stats:pseudo",
          "│   └─TableReader(Probe) 10000.00 root  data:TableFullScan",
          "│     └─TableFullScan 10000.00 cop[tikv] table:t1 keep order:false, stats:pseudo",
          "├─Projection 1000000000000.00 root  test.t1.a->Column#28, test.t2.a->Column#29, test.t3.a->Column#30",
          "│ └─HashJoin 1000000000000.00 root  CARTESIAN inner join",
          "│   ├─TableReader(Build) 10000.00 root  data:TableFullScan",
          "│   │ └─TableFullScan 10000.00 cop[tikv] table:t1 keep order:false, stats:pseudo",
          "│   └─HashJoin(Probe) 100000000.00 root  CARTESIAN inner join",
          "│     ├─TableReader(Build) 10000.00 root  data:TableFullScan",
          "│     │ └─TableFullScan 10000.00 cop[tikv] table:t2 keep order:false, stats:pseudo",
          "│     └─TableReader(Probe) 10000.00 root  data:TableFullScan",
          "│       └─TableFullScan 10000.00 cop[tikv] table:t3 keep order:false, stats:pseudo",
          "└─HashJoin 1000000000000.00 root  CARTESIAN inner join",
          "  ├─TableReader(Build) 10000.00 root  data:TableFullScan",
          "  │ └─TableFullScan 10000.00 cop[tikv] table:t3 keep order:false, stats:pseudo",
          "  └─HashJoin(Probe) 100000000.00 root  CARTESIAN inner join",
          "    ├─TableReader(Build) 10000.00 root  data:TableFullScan",
          "    │ └─TableFullScan 10000.00 cop[tikv] table:t2 keep order:false, stats:pseudo",
          "    └─TableReader(Probe) 10000.00 root  data:TableFullScan",
          "      └─TableFullScan 10000.00 cop[tikv] table:t1 keep order:false, stats:pseudo"
        ],
        "Warn": [
          "Warning 1815 leading hint is inapplicable, check if the leading hint table has join conditions with other tables"
        ]
      }
    ]
  },
  {
    "Name": "TestQBHintHandlerDuplicateObjects",
    "Cases": [
      {
        "SQL": "EXPLAIN WITH t AS (SELECT /*+ inl_join(e) */ em.* FROM t_employees em JOIN t_employees e WHERE em.store_id = e.department_id) SELECT * FROM t;",
        "Plan": [
          "IndexJoin_18 12500.00 root  inner join, inner:IndexReader_34, outer key:test.t_employees.store_id, inner key:test.t_employees.department_id, equal cond:eq(test.t_employees.store_id, test.t_employees.department_id)",
          "├─TableReader_32(Build) 10000.00 root  data:TableFullScan_31",
          "│ └─TableFullScan_31 10000.00 cop[tikv] table:em keep order:false, stats:pseudo",
          "└─IndexReader_34(Probe) 12500.00 root  index:IndexRangeScan_33",
          "  └─IndexRangeScan_33 12500.00 cop[tikv] table:e, index:idx(department_id) range: decided by [eq(test.t_employees.department_id, test.t_employees.store_id)], keep order:false, stats:pseudo"
        ],
        "Warn": null
      }
    ]
  }
]
