// Copyright 2025 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by hash64_equals_generator; DO NOT EDIT IT DIRECTLY.

package logicalop

import (
	"github.com/pingcap/tidb/pkg/expression"
)

// LogicalJoinShallowRef implements the copy-on-write usage.
func (op *LogicalJoin) LogicalJoinShallowRef() *LogicalJoin {
	shallow := *op
	return &shallow
}

// EqualConditionsShallowRef implements the copy-on-write usage.
func (op *LogicalJoin) EqualConditionsShallowRef() []*expression.ScalarFunction {
	EqualConditionsCP := make([]*expression.ScalarFunction, 0, len(op.EqualConditions))
	for _, one := range op.EqualConditions {
		EqualConditionsCP = append(EqualConditionsCP, one)
	}
	op.EqualConditions = EqualConditionsCP
	return op.EqualConditions
}

// NAEQConditionsShallowRef implements the copy-on-write usage.
func (op *LogicalJoin) NAEQConditionsShallowRef() []*expression.ScalarFunction {
	NAEQConditionsCP := make([]*expression.ScalarFunction, 0, len(op.NAEQConditions))
	for _, one := range op.NAEQConditions {
		NAEQConditionsCP = append(NAEQConditionsCP, one)
	}
	op.NAEQConditions = NAEQConditionsCP
	return op.NAEQConditions
}

// LeftConditionsShallowRef implements the copy-on-write usage.
func (op *LogicalJoin) LeftConditionsShallowRef() expression.CNFExprs {
	LeftConditionsCP := make(expression.CNFExprs, 0, len(op.LeftConditions))
	for _, one := range op.LeftConditions {
		LeftConditionsCP = append(LeftConditionsCP, one)
	}
	op.LeftConditions = LeftConditionsCP
	return op.LeftConditions
}

// RightConditionsShallowRef implements the copy-on-write usage.
func (op *LogicalJoin) RightConditionsShallowRef() expression.CNFExprs {
	RightConditionsCP := make(expression.CNFExprs, 0, len(op.RightConditions))
	for _, one := range op.RightConditions {
		RightConditionsCP = append(RightConditionsCP, one)
	}
	op.RightConditions = RightConditionsCP
	return op.RightConditions
}

// OtherConditionsShallowRef implements the copy-on-write usage.
func (op *LogicalJoin) OtherConditionsShallowRef() expression.CNFExprs {
	OtherConditionsCP := make(expression.CNFExprs, 0, len(op.OtherConditions))
	for _, one := range op.OtherConditions {
		OtherConditionsCP = append(OtherConditionsCP, one)
	}
	op.OtherConditions = OtherConditionsCP
	return op.OtherConditions
}
