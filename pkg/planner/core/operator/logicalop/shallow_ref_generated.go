// Copyright 2025 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by hash64_equals_generator; DO NOT EDIT IT DIRECTLY.

package logicalop

import (
	"github.com/pingcap/tidb/pkg/expression"
	"github.com/pingcap/tidb/pkg/expression/aggregation"
	"github.com/pingcap/tidb/pkg/planner/util"
)

// LogicalJoinShallowRef implements the copy-on-write usage.
func (op *LogicalJoin) LogicalJoinShallowRef() *LogicalJoin {
	shallow := *op
	return &shallow
}

// EqualConditionsShallowRef implements the copy-on-write usage.
func (op *LogicalJoin) EqualConditionsShallowRef() []*expression.ScalarFunction {
	EqualConditionsCP := make([]*expression.ScalarFunction, 0, len(op.EqualConditions))
	for _, one := range op.EqualConditions {
		EqualConditionsCP = append(EqualConditionsCP, one)
	}
	op.EqualConditions = EqualConditionsCP
	return op.EqualConditions
}

// NAEQConditionsShallowRef implements the copy-on-write usage.
func (op *LogicalJoin) NAEQConditionsShallowRef() []*expression.ScalarFunction {
	NAEQConditionsCP := make([]*expression.ScalarFunction, 0, len(op.NAEQConditions))
	for _, one := range op.NAEQConditions {
		NAEQConditionsCP = append(NAEQConditionsCP, one)
	}
	op.NAEQConditions = NAEQConditionsCP
	return op.NAEQConditions
}

// LeftConditionsShallowRef implements the copy-on-write usage.
func (op *LogicalJoin) LeftConditionsShallowRef() expression.CNFExprs {
	LeftConditionsCP := make(expression.CNFExprs, 0, len(op.LeftConditions))
	for _, one := range op.LeftConditions {
		LeftConditionsCP = append(LeftConditionsCP, one)
	}
	op.LeftConditions = LeftConditionsCP
	return op.LeftConditions
}

// RightConditionsShallowRef implements the copy-on-write usage.
func (op *LogicalJoin) RightConditionsShallowRef() expression.CNFExprs {
	RightConditionsCP := make(expression.CNFExprs, 0, len(op.RightConditions))
	for _, one := range op.RightConditions {
		RightConditionsCP = append(RightConditionsCP, one)
	}
	op.RightConditions = RightConditionsCP
	return op.RightConditions
}

// OtherConditionsShallowRef implements the copy-on-write usage.
func (op *LogicalJoin) OtherConditionsShallowRef() expression.CNFExprs {
	OtherConditionsCP := make(expression.CNFExprs, 0, len(op.OtherConditions))
	for _, one := range op.OtherConditions {
		OtherConditionsCP = append(OtherConditionsCP, one)
	}
	op.OtherConditions = OtherConditionsCP
	return op.OtherConditions
}

// LogicalProjectionShallowRef implements the copy-on-write usage.
func (op *LogicalProjection) LogicalProjectionShallowRef() *LogicalProjection {
	shallow := *op
	return &shallow
}

// ExprsShallowRef implements the copy-on-write usage.
func (op *LogicalProjection) ExprsShallowRef() []expression.Expression {
	ExprsCP := make([]expression.Expression, 0, len(op.Exprs))
	for _, one := range op.Exprs {
		ExprsCP = append(ExprsCP, one)
	}
	op.Exprs = ExprsCP
	return op.Exprs
}

// LogicalAggregationShallowRef implements the copy-on-write usage.
func (op *LogicalAggregation) LogicalAggregationShallowRef() *LogicalAggregation {
	shallow := *op
	return &shallow
}

// AggFuncsShallowRef implements the copy-on-write usage.
func (op *LogicalAggregation) AggFuncsShallowRef() []*aggregation.AggFuncDesc {
	AggFuncsCP := make([]*aggregation.AggFuncDesc, 0, len(op.AggFuncs))
	for _, one := range op.AggFuncs {
		AggFuncsCP = append(AggFuncsCP, one)
	}
	op.AggFuncs = AggFuncsCP
	return op.AggFuncs
}

// GroupByItemsShallowRef implements the copy-on-write usage.
func (op *LogicalAggregation) GroupByItemsShallowRef() []expression.Expression {
	GroupByItemsCP := make([]expression.Expression, 0, len(op.GroupByItems))
	for _, one := range op.GroupByItems {
		GroupByItemsCP = append(GroupByItemsCP, one)
	}
	op.GroupByItems = GroupByItemsCP
	return op.GroupByItems
}

// PossiblePropertiesShallowRef implements the copy-on-write usage.
func (op *LogicalAggregation) PossiblePropertiesShallowRef() [][]*expression.Column {
	PossiblePropertiesCP := make([][]*expression.Column, 0, len(op.PossibleProperties))
	for _, one := range op.PossibleProperties {
		oneCP := make([]*expression.Column, 0, len(one))
		for _, onee := range one {
			oneCP = append(oneCP, onee)
		}
		PossiblePropertiesCP = append(PossiblePropertiesCP, one)
	}
	op.PossibleProperties = PossiblePropertiesCP
	return op.PossibleProperties
}

// LogicalSortShallowRef implements the copy-on-write usage.
func (op *LogicalSort) LogicalSortShallowRef() *LogicalSort {
	shallow := *op
	return &shallow
}

// ByItemsShallowRef implements the copy-on-write usage.
func (op *LogicalSort) ByItemsShallowRef() []*util.ByItems {
	ByItemsCP := make([]*util.ByItems, 0, len(op.ByItems))
	for _, one := range op.ByItems {
		ByItemsCP = append(ByItemsCP, one)
	}
	op.ByItems = ByItemsCP
	return op.ByItems
}
