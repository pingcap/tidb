// Copyright 2026 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by deep_clone_generator; DO NOT EDIT IT DIRECTLY.

package logicalop

import "github.com/pingcap/tidb/pkg/planner/core/base"

// DeepClone implements base.LogicalPlan.
func (op *LogicalSchemaProducer) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalSchemaProducer)
	*cloned = *op
	cloned.schema = cloneSchemaPtr(op.schema)
	cloned.names = cloneNameSlice(op.names)
	cloned.BaseLogicalPlan = cloneBaseLogicalPlan(&op.BaseLogicalPlan, cloned)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalJoin) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalJoin)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	cloned.EqualConditions = cloneScalarFunctionSlice(op.EqualConditions)
	cloned.NAEQConditions = cloneScalarFunctionSlice(op.NAEQConditions)
	cloned.LeftConditions = cloneCNFExprs(op.LeftConditions)
	cloned.RightConditions = cloneCNFExprs(op.RightConditions)
	cloned.OtherConditions = cloneCNFExprs(op.OtherConditions)
	cloned.LeftProperties = cloneColumn2DSlice(op.LeftProperties)
	cloned.RightProperties = cloneColumn2DSlice(op.RightProperties)
	cloned.DefaultValues = cloneDatumSlice(op.DefaultValues)
	cloned.FullSchema = cloneSchemaPtr(op.FullSchema)
	cloned.FullNames = cloneNameSlice(op.FullNames)
	cloned.allJoinLeaf = cloneSchemaSlice(op.allJoinLeaf)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalAggregation) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalAggregation)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	cloned.AggFuncs = cloneAggFuncDescSlice(op.AggFuncs)
	cloned.GroupByItems = cloneExprSlice(op.GroupByItems)
	cloned.PossibleProperties = cloneColumn2DSlice(op.PossibleProperties)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalProjection) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalProjection)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	cloned.Exprs = cloneExprSlice(op.Exprs)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalSelection) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalSelection)
	*cloned = *op
	cloned.BaseLogicalPlan = cloneBaseLogicalPlan(&op.BaseLogicalPlan, cloned)
	cloned.Conditions = cloneExprSlice(op.Conditions)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalApply) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalApply)
	*cloned = *op
	cloned.LogicalJoin = cloneLogicalJoinAs(&op.LogicalJoin, cloned)
	cloned.CorCols = cloneCorrelatedColumnSlice(op.CorCols)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalMaxOneRow) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalMaxOneRow)
	*cloned = *op
	cloned.BaseLogicalPlan = cloneBaseLogicalPlan(&op.BaseLogicalPlan, cloned)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalTableDual) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalTableDual)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *DataSource) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(DataSource)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	cloned.AstIndexHints = cloneIndexHintSlice(op.AstIndexHints)
	cloned.IndexHints = cloneHintedIndexSlice(op.IndexHints)
	cloned.Columns = cloneModelColumnInfoSlice(op.Columns)
	cloned.IndexMergeHints = cloneHintedIndexSlice(op.IndexMergeHints)
	cloned.PushedDownConds = cloneExprSlice(op.PushedDownConds)
	cloned.AllConds = cloneExprSlice(op.AllConds)
	cloned.AllPossibleAccessPaths = cloneAccessPathSlice(op.AllPossibleAccessPaths)
	cloned.PossibleAccessPaths = cloneAccessPathSlice(op.PossibleAccessPaths)
	cloned.PartitionNames = cloneCIStrSlice(op.PartitionNames)
	cloned.HandleCols = cloneHandleCols(op.HandleCols)
	cloned.UnMutableHandleCols = cloneHandleCols(op.UnMutableHandleCols)
	cloned.TblCols = cloneColumnSlice(op.TblCols)
	cloned.TblColsByID = cloneMapInt64Column(op.TblColsByID)
	cloned.CommonHandleCols = cloneColumnSlice(op.CommonHandleCols)
	cloned.CommonHandleLens = cloneIntSlice(op.CommonHandleLens)
	cloned.PreferPartitions = cloneMapIntCIStrSlice(op.PreferPartitions)
	cloned.ColsRequiringFullLen = cloneColumnSlice(op.ColsRequiringFullLen)
	cloned.AskedColumnGroup = cloneColumn2DSlice(op.AskedColumnGroup)
	cloned.InterestingColumns = cloneColumnSlice(op.InterestingColumns)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *TiKVSingleGather) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(TiKVSingleGather)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	if op.Source != nil {
		cloned.Source = op.Source.DeepClone().(*DataSource)
	}
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalTableScan) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalTableScan)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	if op.Source != nil {
		cloned.Source = op.Source.DeepClone().(*DataSource)
	}
	cloned.HandleCols = cloneHandleCols(op.HandleCols)
	cloned.AccessConds = cloneCNFExprs(op.AccessConds)
	cloned.Ranges = cloneRangeSlice(op.Ranges)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalIndexScan) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalIndexScan)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	if op.Source != nil {
		cloned.Source = op.Source.DeepClone().(*DataSource)
	}
	cloned.AccessConds = cloneCNFExprs(op.AccessConds)
	cloned.Ranges = cloneRangeSlice(op.Ranges)
	cloned.Columns = cloneModelColumnInfoSlice(op.Columns)
	cloned.FullIdxCols = cloneColumnSlice(op.FullIdxCols)
	cloned.FullIdxColLens = cloneIntSlice(op.FullIdxColLens)
	cloned.IdxCols = cloneColumnSlice(op.IdxCols)
	cloned.IdxColLens = cloneIntSlice(op.IdxColLens)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalUnionAll) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalUnionAll)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalPartitionUnionAll) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalPartitionUnionAll)
	*cloned = *op
	cloned.LogicalUnionAll = cloneLogicalUnionAllAs(&op.LogicalUnionAll, cloned)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalSort) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalSort)
	*cloned = *op
	cloned.BaseLogicalPlan = cloneBaseLogicalPlan(&op.BaseLogicalPlan, cloned)
	cloned.ByItems = cloneByItemsSlice(op.ByItems)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalLock) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalLock)
	*cloned = *op
	cloned.BaseLogicalPlan = cloneBaseLogicalPlan(&op.BaseLogicalPlan, cloned)
	cloned.TblID2Handle = cloneMapInt64HandleCols(op.TblID2Handle)
	cloned.TblID2PhysTblIDCol = cloneMapInt64Column(op.TblID2PhysTblIDCol)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalLimit) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalLimit)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	cloned.PartitionBy = cloneSortItems(op.PartitionBy)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalWindow) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalWindow)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	cloned.WindowFuncDescs = cloneWindowFuncDescSlice(op.WindowFuncDescs)
	cloned.PartitionBy = cloneSortItems(op.PartitionBy)
	cloned.OrderBy = cloneSortItems(op.OrderBy)
	cloned.Frame = cloneWindowFrame(op.Frame)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalExpand) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalExpand)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	cloned.DistinctGroupByCol = cloneColumnSlice(op.DistinctGroupByCol)
	cloned.DistinctGbyColNames = cloneFieldNameSlice(op.DistinctGbyColNames)
	cloned.DistinctGbyExprs = cloneExprSlice(op.DistinctGbyExprs)
	cloned.RollupGroupingSets = cloneGroupingSets(op.RollupGroupingSets)
	cloned.RollupID2GIDS = cloneMapIntUint64Set(op.RollupID2GIDS)
	cloned.RollupGroupingIDs = cloneUint64Slice(op.RollupGroupingIDs)
	cloned.LevelExprs = cloneExpr2DSlice(op.LevelExprs)
	cloned.ExtraGroupingColNames = cloneStringSlice(op.ExtraGroupingColNames)
	cloned.GID = cloneColumnPtr(op.GID)
	cloned.GPos = cloneColumnPtr(op.GPos)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalUnionScan) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalUnionScan)
	*cloned = *op
	cloned.BaseLogicalPlan = cloneBaseLogicalPlan(&op.BaseLogicalPlan, cloned)
	cloned.Conditions = cloneExprSlice(op.Conditions)
	cloned.HandleCols = cloneHandleCols(op.HandleCols)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalMemTable) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalMemTable)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	cloned.Columns = cloneModelColumnInfoSlice(op.Columns)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalShow) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalShow)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	cloned.ShowContents = cloneShowContents(op.ShowContents)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalShowDDLJobs) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalShowDDLJobs)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalCTE) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalCTE)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	cloned.Cte = cloneCTEClass(op.Cte)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalCTETable) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalCTETable)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	cloned.SeedSchema = cloneSchemaPtr(op.SeedSchema)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalSequence) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalSequence)
	*cloned = *op
	cloned.BaseLogicalPlan = cloneBaseLogicalPlan(&op.BaseLogicalPlan, cloned)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *LogicalTopN) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(LogicalTopN)
	*cloned = *op
	cloned.LogicalSchemaProducer = cloneLogicalSchemaProducer(&op.LogicalSchemaProducer, cloned)
	cloned.ByItems = cloneByItemsSlice(op.ByItems)
	cloned.PartitionBy = cloneSortItems(op.PartitionBy)
	return cloned
}

// DeepClone implements base.LogicalPlan.
func (op *MockDataSource) DeepClone() base.LogicalPlan {
	if op == nil {
		return nil
	}
	cloned := new(MockDataSource)
	*cloned = *op
	cloned.BaseLogicalPlan = cloneBaseLogicalPlan(&op.BaseLogicalPlan, cloned)
	return cloned
}
