// Copyright 2017 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package core

import (
	"context"
	"slices"
	"strings"

	"github.com/pingcap/errors"
	"github.com/pingcap/tidb/pkg/expression"
	"github.com/pingcap/tidb/pkg/expression/aggregation"
	"github.com/pingcap/tidb/pkg/parser/ast"
	"github.com/pingcap/tidb/pkg/parser/mysql"
	"github.com/pingcap/tidb/pkg/parser/opcode"
	"github.com/pingcap/tidb/pkg/planner/core/base"
	"github.com/pingcap/tidb/pkg/planner/core/operator/logicalop"
	"github.com/pingcap/tidb/pkg/planner/core/rule"
	"github.com/pingcap/tidb/pkg/planner/util/coreusage"
	"github.com/pingcap/tidb/pkg/sessionctx/vardef"
	"github.com/pingcap/tidb/pkg/types"
	"github.com/pingcap/tidb/pkg/util/collate"
	"github.com/pingcap/tidb/pkg/util/dbterror/plannererrors"
	"github.com/pingcap/tidb/pkg/util/hint"
	"github.com/pingcap/tidb/pkg/util/intest"
)

// buildSubquery translates the subquery ast to plan.
// Subquery related hints are returned through hintFlags. Please see comments around HintFlagSemiJoinRewrite and PlanBuilder.subQueryHintFlags for details.
func (er *expressionRewriter) buildSubquery(ctx context.Context, planCtx *exprRewriterPlanCtx, subq *ast.SubqueryExpr, subqueryCtx subQueryCtx) (np base.LogicalPlan, hintFlags uint64, err error) {
	intest.AssertNotNil(planCtx)
	b := planCtx.builder
	if er.schema != nil {
		outerSchema := er.schema.Clone()
		b.outerSchemas = append(b.outerSchemas, outerSchema)
		b.outerNames = append(b.outerNames, er.names)
		b.outerBlockExpand = append(b.outerBlockExpand, b.currentBlockExpand)
		// set it to nil, otherwise, inner qb will use outer expand meta to rewrite expressions.
		b.currentBlockExpand = nil
		defer func() {
			b.outerSchemas = b.outerSchemas[0 : len(b.outerSchemas)-1]
			b.outerNames = b.outerNames[0 : len(b.outerNames)-1]
			b.currentBlockExpand = b.outerBlockExpand[len(b.outerBlockExpand)-1]
			b.outerBlockExpand = b.outerBlockExpand[0 : len(b.outerBlockExpand)-1]
		}()
	}
	// Store the old value before we enter the subquery and reset they to default value.
	oldSubQCtx := b.subQueryCtx
	b.subQueryCtx = subqueryCtx
	oldHintFlags := b.subQueryHintFlags
	b.subQueryHintFlags = 0
	outerWindowSpecs := b.windowSpecs
	defer func() {
		b.windowSpecs = outerWindowSpecs
		b.subQueryCtx = oldSubQCtx
		b.subQueryHintFlags = oldHintFlags
	}()

	np, err = b.buildResultSetNode(ctx, subq.Query, false)
	if err != nil {
		return nil, 0, err
	}
	hintFlags = b.subQueryHintFlags
	// Pop the handle map generated by the subquery.
	b.handleHelper.popMap()
	return np, hintFlags, nil
}

func (er *expressionRewriter) requirePlanCtx(inNode ast.Node, detail string) (ctx *exprRewriterPlanCtx, err error) {
	if ctx = er.planCtx; ctx == nil {
		if detail != "" {
			detail = ", " + detail
		}
		err = errors.Errorf("planCtx is required when rewriting node: '%T'%s", inNode, detail)
	}
	return
}

// Enter implements Visitor interface.
func (er *expressionRewriter) Enter(inNode ast.Node) (ast.Node, bool) {
	er.astNodeStack = append(er.astNodeStack, inNode)
	enterWithPlanCtx := func(fn func(*exprRewriterPlanCtx) (ast.Node, bool)) (ast.Node, bool) {
		planCtx, err := er.requirePlanCtx(inNode, "")
		if err != nil {
			er.err = err
			return inNode, true
		}
		return fn(planCtx)
	}

	switch v := inNode.(type) {
	case *ast.AggregateFuncExpr:
		return enterWithPlanCtx(func(planCtx *exprRewriterPlanCtx) (ast.Node, bool) {
			index, ok := -1, false
			if planCtx.aggrMap != nil {
				index, ok = planCtx.aggrMap[v]
			}
			if ok {
				// index < 0 indicates this is a correlated aggregate belonging to outer query,
				// for which a correlated column will be created later, so we append a null constant
				// as a temporary result expression.
				if index < 0 {
					er.ctxStackAppend(expression.NewNull(), types.EmptyName)
				} else {
					// index >= 0 indicates this is a regular aggregate column
					er.ctxStackAppend(er.schema.Columns[index], er.names[index])
				}
				return inNode, true
			}
			// replace correlated aggregate in sub-query with its corresponding correlated column
			if col, ok := planCtx.builder.correlatedAggMapper[v]; ok {
				er.ctxStackAppend(col, types.EmptyName)
				return inNode, true
			}
			er.err = plannererrors.ErrInvalidGroupFuncUse
			return inNode, true
		})
	case *ast.ColumnNameExpr:
		if planCtx := er.planCtx; planCtx != nil {
			if index, ok := planCtx.builder.colMapper[v]; ok {
				er.ctxStackAppend(er.schema.Columns[index], er.names[index])
				return inNode, true
			}
		}
	case *ast.CompareSubqueryExpr:
		return enterWithPlanCtx(func(planCtx *exprRewriterPlanCtx) (ast.Node, bool) {
			return er.handleCompareSubquery(er.ctx, planCtx, v)
		})
	case *ast.ExistsSubqueryExpr:
		return enterWithPlanCtx(func(planCtx *exprRewriterPlanCtx) (ast.Node, bool) {
			return er.handleExistSubquery(er.ctx, planCtx, v)
		})
	case *ast.PatternInExpr:
		if v.Sel != nil {
			return enterWithPlanCtx(func(planCtx *exprRewriterPlanCtx) (ast.Node, bool) {
				return er.handleInSubquery(er.ctx, planCtx, v)
			})
		}
		if len(v.List) != 1 {
			break
		}
		// For 10 in ((select * from t)), the parser won't set v.Sel.
		// So we must process this case here.
		x := v.List[0]
		for {
			switch y := x.(type) {
			case *ast.SubqueryExpr:
				v.Sel = y
				return enterWithPlanCtx(func(planCtx *exprRewriterPlanCtx) (ast.Node, bool) {
					return er.handleInSubquery(er.ctx, planCtx, v)
				})
			case *ast.ParenthesesExpr:
				x = y.Expr
			default:
				// Expect its left and right child to be a scalar value.
				er.asScalar = true
				return inNode, false
			}
		}
	case *ast.SubqueryExpr:
		return enterWithPlanCtx(func(planCtx *exprRewriterPlanCtx) (ast.Node, bool) {
			return er.handleScalarSubquery(er.ctx, planCtx, v)
		})
	case *ast.ParenthesesExpr:
	case *ast.ValuesExpr:
		return enterWithPlanCtx(func(planCtx *exprRewriterPlanCtx) (ast.Node, bool) {
			schema, names := er.schema, er.names
			// NOTE: "er.insertPlan != nil" means that we are rewriting the
			// expressions inside the assignment of "INSERT" statement. we have to
			// use the "tableSchema" of that "insertPlan".
			if planCtx.insertPlan != nil {
				schema = planCtx.insertPlan.TableSchema
				names = planCtx.insertPlan.TableColNames
			}
			idx, err := expression.FindFieldName(names, v.Column.Name)
			if err != nil {
				er.err = err
				return inNode, false
			}
			if idx < 0 {
				er.err = plannererrors.ErrUnknownColumn.GenWithStackByArgs(v.Column.Name.OrigColName(), "field list")
				return inNode, false
			}
			col := schema.Columns[idx]
			er.ctxStackAppend(expression.NewValuesFunc(er.sctx, col.Index, col.RetType), types.EmptyName)
			return inNode, true
		})
	case *ast.WindowFuncExpr:
		return enterWithPlanCtx(func(planCtx *exprRewriterPlanCtx) (ast.Node, bool) {
			intest.AssertNotNil(planCtx)
			index, ok := -1, false
			if planCtx.windowMap != nil {
				index, ok = planCtx.windowMap[v]
			}
			if !ok {
				er.err = plannererrors.ErrWindowInvalidWindowFuncUse.GenWithStackByArgs(strings.ToLower(v.Name))
				return inNode, true
			}
			er.ctxStackAppend(er.schema.Columns[index], er.names[index])
			return inNode, true
		})
	case *ast.FuncCallExpr:
		er.asScalar = true
		if _, ok := expression.DisableFoldFunctions[v.FnName.L]; ok {
			er.disableFoldCounter++
		}
		if _, ok := expression.TryFoldFunctions[v.FnName.L]; ok {
			er.tryFoldCounter++
		}
	case *ast.CaseExpr:
		er.asScalar = true
		if _, ok := expression.DisableFoldFunctions["case"]; ok {
			er.disableFoldCounter++
		}
		if _, ok := expression.TryFoldFunctions["case"]; ok {
			er.tryFoldCounter++
		}
	case *ast.BinaryOperationExpr:
		er.asScalar = true
		if v.Op == opcode.LogicAnd || v.Op == opcode.LogicOr {
			er.tryFoldCounter++
		}
	case *ast.SetCollationExpr:
		// Do nothing
	default:
		er.asScalar = true
	}
	return inNode, false
}

// canTreatInSubqueryAsExistsForFilter reports whether the IN subquery is in a WHERE/HAVING boolean chain
// composed only of AND/OR and parentheses, so it can be treated like EXISTS for filter context.
func (er *expressionRewriter) canTreatInSubqueryAsExistsForFilter(planCtx *exprRewriterPlanCtx) bool {
	if planCtx == nil {
		return false
	}
	if planCtx.curClause != whereClause && planCtx.curClause != havingClause {
		return false
	}
	if len(er.astNodeStack) == 0 {
		return false
	}
	for i := len(er.astNodeStack) - 2; i >= 0; i-- {
		switch n := er.astNodeStack[i].(type) {
		case *ast.ParenthesesExpr:
		case *ast.BinaryOperationExpr:
			if n.Op != opcode.LogicAnd && n.Op != opcode.LogicOr {
				return false
			}
		default:
			return false
		}
	}
	return true
}

func (er *expressionRewriter) buildSemiApplyFromEqualSubq(np base.LogicalPlan, planCtx *exprRewriterPlanCtx, l, r expression.Expression, not, markNoDecorrelate bool) {
	intest.AssertNotNil(planCtx)
	if er.asScalar || not {
		if expression.GetRowLen(r) == 1 {
			rCol := r.(*expression.Column)
			// If both input columns of `!= all / = any` expression are not null, we can treat the expression
			// as normal column equal condition.
			if !expression.ExprNotNull(er.sctx.GetEvalCtx(), l) || !expression.ExprNotNull(er.sctx.GetEvalCtx(), rCol) {
				rColCopy := *rCol
				rColCopy.InOperand = true
				r = &rColCopy
				l = expression.SetExprColumnInOperand(l)
			}
		} else {
			rowFunc := r.(*expression.ScalarFunction)
			rargs := rowFunc.GetArgs()
			args := make([]expression.Expression, 0, len(rargs))
			modified := false
			for i, rarg := range rargs {
				larg := expression.GetFuncArg(l, i)
				if !expression.ExprNotNull(er.sctx.GetEvalCtx(), larg) || !expression.ExprNotNull(er.sctx.GetEvalCtx(), rarg) {
					rCol := rarg.(*expression.Column)
					rColCopy := *rCol
					rColCopy.InOperand = true
					rarg = &rColCopy
					modified = true
				}
				args = append(args, rarg)
			}
			if modified {
				r, er.err = er.newFunction(ast.RowFunc, args[0].GetType(er.sctx.GetEvalCtx()), args...)
				if er.err != nil {
					return
				}
				l = expression.SetExprColumnInOperand(l)
			}
		}
	}
	var condition expression.Expression
	condition, er.err = er.constructBinaryOpFunction(l, r, ast.EQ)
	if er.err != nil {
		return
	}
	planCtx.plan, er.err = planCtx.builder.buildSemiApply(planCtx.plan, np, []expression.Expression{condition}, er.asScalar, not, false, markNoDecorrelate)
}

func (er *expressionRewriter) handleCompareSubquery(ctx context.Context, planCtx *exprRewriterPlanCtx, v *ast.CompareSubqueryExpr) (ast.Node, bool) {
	intest.AssertNotNil(planCtx)
	b := planCtx.builder
	ci := b.prepareCTECheckForSubQuery()
	defer resetCTECheckForSubQuery(ci)
	v.L.Accept(er)
	if er.err != nil {
		return v, true
	}
	lexpr := er.ctxStack[len(er.ctxStack)-1]
	subq, ok := v.R.(*ast.SubqueryExpr)
	if !ok {
		er.err = errors.Errorf("Unknown compare type %T", v.R)
		return v, true
	}
	np, hintFlags, err := er.buildSubquery(ctx, planCtx, subq, handlingCompareSubquery)
	if err != nil {
		er.err = err
		return v, true
	}
	corCols := coreusage.ExtractCorColumnsBySchema4LogicalPlan(np, planCtx.plan.Schema())
	noDecorrelate := isNoDecorrelate(planCtx, corCols, hintFlags, handlingCompareSubquery)

	// Only (a,b,c) = any (...) and (a,b,c) != all (...) can use row expression.
	canMultiCol := (!v.All && v.Op == opcode.EQ) || (v.All && v.Op == opcode.NE)
	if !canMultiCol && (expression.GetRowLen(lexpr) != 1 || np.Schema().Len() != 1) {
		er.err = expression.ErrOperandColumns.GenWithStackByArgs(1)
		return v, true
	}
	lLen := expression.GetRowLen(lexpr)
	if lLen != np.Schema().Len() {
		er.err = expression.ErrOperandColumns.GenWithStackByArgs(lLen)
		return v, true
	}
	var rexpr expression.Expression
	if np.Schema().Len() == 1 {
		rexpr = np.Schema().Columns[0]
	} else {
		args := make([]expression.Expression, 0, np.Schema().Len())
		for _, col := range np.Schema().Columns {
			args = append(args, col)
		}
		rexpr, er.err = er.newFunction(ast.RowFunc, args[0].GetType(er.sctx.GetEvalCtx()), args...)
		if er.err != nil {
			return v, true
		}
	}

	// Lexpr cannot compare with rexpr by different collate
	opString := new(strings.Builder)
	v.Op.Format(opString)
	_, er.err = expression.CheckAndDeriveCollationFromExprs(er.sctx, opString.String(), types.ETInt, lexpr, rexpr)
	if er.err != nil {
		return v, true
	}

	switch v.Op {
	// Only EQ, NE and NullEQ can be composed with and.
	case opcode.EQ, opcode.NE, opcode.NullEQ:
		if v.Op == opcode.EQ {
			if v.All {
				er.handleEQAll(planCtx, lexpr, rexpr, np, noDecorrelate)
			} else {
				// `a = any(subq)` will be rewriten as `a in (subq)`.
				er.asScalar = true
				er.buildSemiApplyFromEqualSubq(np, planCtx, lexpr, rexpr, false, noDecorrelate)
				if er.err != nil {
					return v, true
				}
			}
		} else if v.Op == opcode.NE {
			if v.All {
				// `a != all(subq)` will be rewriten as `a not in (subq)`.
				er.asScalar = true
				er.buildSemiApplyFromEqualSubq(np, planCtx, lexpr, rexpr, true, noDecorrelate)
				if er.err != nil {
					return v, true
				}
			} else {
				er.handleNEAny(planCtx, lexpr, rexpr, np, noDecorrelate)
			}
		} else {
			// TODO: Support this in future.
			er.err = errors.New("We don't support <=> all or <=> any now")
			return v, true
		}
	default:
		// When < all or > any , the agg function should use min.
		useMin := ((v.Op == opcode.LT || v.Op == opcode.LE) && v.All) || ((v.Op == opcode.GT || v.Op == opcode.GE) && !v.All)
		er.handleOtherComparableSubq(planCtx, lexpr, rexpr, np, useMin, v.Op.String(), v.All, noDecorrelate)
	}
	if er.asScalar {
		// The parent expression only use the last column in schema, which represents whether the condition is matched.
		er.ctxStack[len(er.ctxStack)-1] = planCtx.plan.Schema().Columns[planCtx.plan.Schema().Len()-1]
		er.ctxNameStk[len(er.ctxNameStk)-1] = planCtx.plan.OutputNames()[planCtx.plan.Schema().Len()-1]
	}
	return v, true
}

// handleOtherComparableSubq handles the queries like < any, < max, etc. For example, if the query is t.id < any (select s.id from s),
// it will be rewrote to t.id < (select max(s.id) from s).
func (er *expressionRewriter) handleOtherComparableSubq(planCtx *exprRewriterPlanCtx, lexpr, rexpr expression.Expression, np base.LogicalPlan, useMin bool, cmpFunc string, all, markNoDecorrelate bool) {
	intest.AssertNotNil(planCtx)
	plan4Agg := logicalop.LogicalAggregation{}.Init(planCtx.builder.ctx, planCtx.builder.getSelectOffset())
	if hintinfo := planCtx.builder.TableHints(); hintinfo != nil {
		plan4Agg.PreferAggType = hintinfo.PreferAggType
		plan4Agg.PreferAggToCop = hintinfo.PreferAggToCop
	}
	plan4Agg.SetChildren(np)

	// Create a "max" or "min" aggregation.
	funcName := ast.AggFuncMax
	if useMin {
		funcName = ast.AggFuncMin
	}
	funcMaxOrMin, err := aggregation.NewAggFuncDesc(planCtx.builder.ctx.GetExprCtx(), funcName, []expression.Expression{rexpr}, false)
	if err != nil {
		er.err = err
		return
	}

	// Create a column and append it to the schema of that aggregation.
	colMaxOrMin := &expression.Column{
		UniqueID: planCtx.builder.ctx.GetSessionVars().AllocPlanColumnID(),
		RetType:  funcMaxOrMin.RetTp,
	}
	colMaxOrMin.SetCoercibility(rexpr.Coercibility())
	schema := expression.NewSchema(colMaxOrMin)

	plan4Agg.SetOutputNames(append(plan4Agg.OutputNames(), types.EmptyName))
	plan4Agg.SetSchema(schema)
	plan4Agg.AggFuncs = []*aggregation.AggFuncDesc{funcMaxOrMin}

	cond := expression.NewFunctionInternal(er.sctx, cmpFunc, types.NewFieldType(mysql.TypeTiny), lexpr, colMaxOrMin)
	er.buildQuantifierPlan(planCtx, plan4Agg, cond, lexpr, rexpr, all, markNoDecorrelate)
}

// buildQuantifierPlan adds extra condition for any / all subquery.
func (er *expressionRewriter) buildQuantifierPlan(planCtx *exprRewriterPlanCtx, plan4Agg *logicalop.LogicalAggregation, cond, lexpr, rexpr expression.Expression, all, markNoDecorrelate bool) {
	intest.AssertNotNil(planCtx)
	innerIsNull := expression.NewFunctionInternal(er.sctx, ast.IsNull, types.NewFieldType(mysql.TypeTiny), rexpr)
	outerIsNull := expression.NewFunctionInternal(er.sctx, ast.IsNull, types.NewFieldType(mysql.TypeTiny), lexpr)
	exprCtx := planCtx.builder.ctx.GetExprCtx()
	funcSum, err := aggregation.NewAggFuncDesc(exprCtx, ast.AggFuncSum, []expression.Expression{innerIsNull}, false)
	if err != nil {
		er.err = err
		return
	}
	sessVars := planCtx.builder.ctx.GetSessionVars()
	colSum := &expression.Column{
		UniqueID: sessVars.AllocPlanColumnID(),
		RetType:  funcSum.RetTp,
	}
	plan4Agg.AggFuncs = append(plan4Agg.AggFuncs, funcSum)
	plan4Agg.Schema().Append(colSum)
	innerHasNull := expression.NewFunctionInternal(er.sctx, ast.NE, types.NewFieldType(mysql.TypeTiny), colSum, expression.NewZero())

	// Build `count(1)` aggregation to check if subquery is empty.
	funcCount, err := aggregation.NewAggFuncDesc(exprCtx, ast.AggFuncCount, []expression.Expression{expression.NewOne()}, false)
	if err != nil {
		er.err = err
		return
	}
	colCount := &expression.Column{
		UniqueID: sessVars.AllocPlanColumnID(),
		RetType:  funcCount.RetTp,
	}
	plan4Agg.AggFuncs = append(plan4Agg.AggFuncs, funcCount)
	plan4Agg.Schema().Append(colCount)

	if all {
		// All of the inner record set should not contain null value. So for t.id < all(select s.id from s), it
		// should be rewrote to t.id < min(s.id) and if(sum(s.id is null) != 0, null, true).
		innerNullChecker := expression.NewFunctionInternal(er.sctx, ast.If, types.NewFieldType(mysql.TypeTiny), innerHasNull, expression.NewNull(), expression.NewOne())
		cond = expression.ComposeCNFCondition(er.sctx, cond, innerNullChecker)
		// If the subquery is empty, it should always return true.
		emptyChecker := expression.NewFunctionInternal(er.sctx, ast.EQ, types.NewFieldType(mysql.TypeTiny), colCount, expression.NewZero())
		// If outer key is null, and subquery is not empty, it should always return null, even when it is `null = all (1, 2)`.
		outerNullChecker := expression.NewFunctionInternal(er.sctx, ast.If, types.NewFieldType(mysql.TypeTiny), outerIsNull, expression.NewNull(), expression.NewZero())
		cond = expression.ComposeDNFCondition(er.sctx, cond, emptyChecker, outerNullChecker)
	} else {
		// For "any" expression, if the subquery has null and the cond returns false, the result should be NULL.
		// Specifically, `t.id < any (select s.id from s)` would be rewrote to `t.id < max(s.id) or if(sum(s.id is null) != 0, null, false)`
		innerNullChecker := expression.NewFunctionInternal(er.sctx, ast.If, types.NewFieldType(mysql.TypeTiny), innerHasNull, expression.NewNull(), expression.NewZero())
		cond = expression.ComposeDNFCondition(er.sctx, cond, innerNullChecker)
		// If the subquery is empty, it should always return false.
		emptyChecker := expression.NewFunctionInternal(er.sctx, ast.NE, types.NewFieldType(mysql.TypeTiny), colCount, expression.NewZero())
		// If outer key is null, and subquery is not empty, it should return null.
		outerNullChecker := expression.NewFunctionInternal(er.sctx, ast.If, types.NewFieldType(mysql.TypeTiny), outerIsNull, expression.NewNull(), expression.NewOne())
		cond = expression.ComposeCNFCondition(er.sctx, cond, emptyChecker, outerNullChecker)
	}

	// TODO: Add a Projection if any argument of aggregate funcs or group by items are scalar functions.
	// plan4Agg.buildProjectionIfNecessary()
	if !er.asScalar {
		// For Semi LogicalApply without aux column, the result is no matter false or null. So we can add it to join predicate.
		planCtx.plan, er.err = planCtx.builder.buildSemiApply(planCtx.plan, plan4Agg, []expression.Expression{cond}, false, false, false, markNoDecorrelate)
		return
	}
	// If we treat the result as a scalar value, we will add a projection with a extra column to output true, false or null.
	outerSchemaLen := planCtx.plan.Schema().Len()
	planCtx.plan = planCtx.builder.buildApplyWithJoinType(planCtx.plan, plan4Agg, base.InnerJoin, markNoDecorrelate)
	joinSchema := planCtx.plan.Schema()
	proj := logicalop.LogicalProjection{
		Exprs: expression.Column2Exprs(joinSchema.Clone().Columns[:outerSchemaLen]),
	}.Init(planCtx.builder.ctx, planCtx.builder.getSelectOffset())
	proj.SetOutputNames(make([]*types.FieldName, outerSchemaLen, outerSchemaLen+1))
	names := proj.OutputNames()
	copy(names, planCtx.plan.OutputNames())
	proj.SetOutputNames(names)
	proj.SetSchema(expression.NewSchema(joinSchema.Clone().Columns[:outerSchemaLen]...))
	proj.Exprs = append(proj.Exprs, cond)
	proj.Schema().Append(&expression.Column{
		UniqueID: sessVars.AllocPlanColumnID(),
		RetType:  cond.GetType(er.sctx.GetEvalCtx()),
	})
	proj.SetOutputNames(append(proj.OutputNames(), types.EmptyName))
	proj.SetChildren(planCtx.plan)
	planCtx.plan = proj
}

// handleNEAny handles the case of != any. For example, if the query is t.id != any (select s.id from s), it will be rewrote to
// t.id != s.id or count(distinct s.id) > 1 or [any checker]. If there are two different values in s.id ,
// there must exist a s.id that doesn't equal to t.id.
func (er *expressionRewriter) handleNEAny(planCtx *exprRewriterPlanCtx, lexpr, rexpr expression.Expression, np base.LogicalPlan, markNoDecorrelate bool) {
	intest.AssertNotNil(planCtx)
	sctx := planCtx.builder.ctx
	exprCtx := sctx.GetExprCtx()
	// If there is NULL in s.id column, s.id should be the value that isn't null in condition t.id != s.id.
	// So use function max to filter NULL.
	maxFunc, err := aggregation.NewAggFuncDesc(exprCtx, ast.AggFuncMax, []expression.Expression{rexpr}, false)
	if err != nil {
		er.err = err
		return
	}
	countFunc, err := aggregation.NewAggFuncDesc(exprCtx, ast.AggFuncCount, []expression.Expression{rexpr}, true)
	if err != nil {
		er.err = err
		return
	}
	plan4Agg := logicalop.LogicalAggregation{
		AggFuncs: []*aggregation.AggFuncDesc{maxFunc, countFunc},
	}.Init(sctx, planCtx.builder.getSelectOffset())
	if hintinfo := planCtx.builder.TableHints(); hintinfo != nil {
		plan4Agg.PreferAggType = hintinfo.PreferAggType
		plan4Agg.PreferAggToCop = hintinfo.PreferAggToCop
	}
	plan4Agg.SetChildren(np)
	maxResultCol := &expression.Column{
		UniqueID: sctx.GetSessionVars().AllocPlanColumnID(),
		RetType:  maxFunc.RetTp,
	}
	maxResultCol.SetCoercibility(rexpr.Coercibility())
	count := &expression.Column{
		UniqueID: sctx.GetSessionVars().AllocPlanColumnID(),
		RetType:  countFunc.RetTp,
	}
	plan4Agg.SetOutputNames(append(plan4Agg.OutputNames(), types.EmptyName, types.EmptyName))
	plan4Agg.SetSchema(expression.NewSchema(maxResultCol, count))
	gtFunc := expression.NewFunctionInternal(er.sctx, ast.GT, types.NewFieldType(mysql.TypeTiny), count, expression.NewOne())
	neCond := expression.NewFunctionInternal(er.sctx, ast.NE, types.NewFieldType(mysql.TypeTiny), lexpr, maxResultCol)
	cond := expression.ComposeDNFCondition(er.sctx, gtFunc, neCond)
	er.buildQuantifierPlan(planCtx, plan4Agg, cond, lexpr, rexpr, false, markNoDecorrelate)
}

// handleEQAll handles the case of = all. For example, if the query is t.id = all (select s.id from s), it will be rewrote to
// t.id = (select s.id from s having count(distinct s.id) <= 1 and [all checker]).
func (er *expressionRewriter) handleEQAll(planCtx *exprRewriterPlanCtx, lexpr, rexpr expression.Expression, np base.LogicalPlan, markNoDecorrelate bool) {
	intest.AssertNotNil(planCtx)
	sctx := planCtx.builder.ctx
	exprCtx := sctx.GetExprCtx()
	// If there is NULL in s.id column, s.id should be the value that isn't null in condition t.id == s.id.
	// So use function max to filter NULL.
	maxFunc, err := aggregation.NewAggFuncDesc(exprCtx, ast.AggFuncMax, []expression.Expression{rexpr}, false)
	if err != nil {
		er.err = err
		return
	}
	countFunc, err := aggregation.NewAggFuncDesc(exprCtx, ast.AggFuncCount, []expression.Expression{rexpr}, true)
	if err != nil {
		er.err = err
		return
	}
	plan4Agg := logicalop.LogicalAggregation{
		AggFuncs: []*aggregation.AggFuncDesc{maxFunc, countFunc},
	}.Init(sctx, planCtx.builder.getSelectOffset())
	if hintinfo := planCtx.builder.TableHints(); hintinfo != nil {
		plan4Agg.PreferAggType = hintinfo.PreferAggType
		plan4Agg.PreferAggToCop = hintinfo.PreferAggToCop
	}
	plan4Agg.SetChildren(np)
	plan4Agg.SetOutputNames(append(plan4Agg.OutputNames(), types.EmptyName))

	maxResultCol := &expression.Column{
		UniqueID: sctx.GetSessionVars().AllocPlanColumnID(),
		RetType:  maxFunc.RetTp,
	}
	maxResultCol.SetCoercibility(rexpr.Coercibility())
	plan4Agg.SetOutputNames(append(plan4Agg.OutputNames(), types.EmptyName))
	count := &expression.Column{
		UniqueID: sctx.GetSessionVars().AllocPlanColumnID(),
		RetType:  countFunc.RetTp,
	}
	plan4Agg.SetSchema(expression.NewSchema(maxResultCol, count))
	leFunc := expression.NewFunctionInternal(er.sctx, ast.LE, types.NewFieldType(mysql.TypeTiny), count, expression.NewOne())
	eqCond := expression.NewFunctionInternal(er.sctx, ast.EQ, types.NewFieldType(mysql.TypeTiny), lexpr, maxResultCol)
	cond := expression.ComposeCNFCondition(er.sctx, leFunc, eqCond)
	er.buildQuantifierPlan(planCtx, plan4Agg, cond, lexpr, rexpr, true, markNoDecorrelate)
}

func (er *expressionRewriter) handleExistSubquery(ctx context.Context, planCtx *exprRewriterPlanCtx, v *ast.ExistsSubqueryExpr) (ast.Node, bool) {
	intest.AssertNotNil(planCtx)
	b := planCtx.builder
	ci := b.prepareCTECheckForSubQuery()
	defer resetCTECheckForSubQuery(ci)
	subq, ok := v.Sel.(*ast.SubqueryExpr)
	if !ok {
		er.err = errors.Errorf("Unknown exists type %T", v.Sel)
		return v, true
	}
	np, hintFlags, err := er.buildSubquery(ctx, planCtx, subq, handlingExistsSubquery)
	if err != nil {
		er.err = err
		return v, true
	}
	// Add LIMIT 1 when noDecorrelate is true for EXISTS subqueries to enable early exit
	corCols := coreusage.ExtractCorColumnsBySchema4LogicalPlan(np, planCtx.plan.Schema())
	noDecorrelate := isNoDecorrelate(planCtx, corCols, hintFlags, handlingExistsSubquery)
	if noDecorrelate {
		// Only add LIMIT 1 if the query doesn't already contain a LIMIT clause
		if !hasLimit(np) {
			limitClause := &ast.Limit{
				Count: ast.NewValueExpr(1, "", ""),
			}
			var err error
			np, err = planCtx.builder.buildLimit(np, limitClause)
			if err != nil {
				er.err = err
				return v, true
			}
		}
	}
	np = er.popExistsSubPlan(planCtx, np)
	semiJoinRewrite := hintFlags&hint.HintFlagSemiJoinRewrite > 0
	if semiJoinRewrite && noDecorrelate {
		b.ctx.GetSessionVars().StmtCtx.SetHintWarning(
			"NO_DECORRELATE() and SEMI_JOIN_REWRITE() are in conflict. Both will be ineffective.")
		noDecorrelate = false
		semiJoinRewrite = false
	}

	if b.disableSubQueryPreprocessing || len(coreusage.ExtractCorrelatedCols4LogicalPlan(np)) > 0 || hasCTEConsumerInSubPlan(np) {
		planCtx.plan, er.err = b.buildSemiApply(planCtx.plan, np, nil, er.asScalar, v.Not, semiJoinRewrite, noDecorrelate)
		if er.err != nil || !er.asScalar {
			return v, true
		}
		er.ctxStackAppend(planCtx.plan.Schema().Columns[planCtx.plan.Schema().Len()-1], planCtx.plan.OutputNames()[planCtx.plan.Schema().Len()-1])
	} else {
		// We don't want nth_plan hint to affect separately executed subqueries here, so disable nth_plan temporarily.
		nthPlanBackup := b.ctx.GetSessionVars().StmtCtx.StmtHints.ForceNthPlan
		b.ctx.GetSessionVars().StmtCtx.StmtHints.ForceNthPlan = -1
		physicalPlan, _, err := DoOptimize(ctx, planCtx.builder.ctx, b.optFlag, np)
		b.ctx.GetSessionVars().StmtCtx.StmtHints.ForceNthPlan = nthPlanBackup
		if err != nil {
			er.err = err
			return v, true
		}
		if b.ctx.GetSessionVars().StmtCtx.InExplainStmt && !b.ctx.GetSessionVars().StmtCtx.InExplainAnalyzeStmt && b.ctx.GetSessionVars().ExplainNonEvaledSubQuery {
			newColID := b.ctx.GetSessionVars().AllocPlanColumnID()
			subqueryCtx := ScalarSubqueryEvalCtx{
				scalarSubQuery: physicalPlan,
				ctx:            ctx,
				is:             b.is,
				outputColIDs:   []int64{newColID},
			}.Init(b.ctx, np.QueryBlockOffset())
			scalarSubQ := &ScalarSubQueryExpr{
				scalarSubqueryColID: newColID,
				evalCtx:             subqueryCtx,
			}
			scalarSubQ.RetType = np.Schema().Columns[0].GetType(er.sctx.GetEvalCtx())
			scalarSubQ.SetCoercibility(np.Schema().Columns[0].Coercibility())
			b.ctx.GetSessionVars().RegisterScalarSubQ(subqueryCtx)
			if v.Not {
				notWrapped, err := expression.NewFunction(b.ctx.GetExprCtx(), ast.UnaryNot, types.NewFieldType(mysql.TypeTiny), scalarSubQ)
				if err != nil {
					er.err = err
					return v, true
				}
				er.ctxStackAppend(notWrapped, types.EmptyName)
				return v, true
			}
			er.ctxStackAppend(scalarSubQ, types.EmptyName)
			return v, true
		}
		// register the subquery plan but continue with normal execution
		subqueryCtx := ScalarSubqueryEvalCtx{
			scalarSubQuery: physicalPlan,
			ctx:            ctx,
			is:             b.is,
		}.Init(planCtx.builder.ctx, np.QueryBlockOffset())
		newColIDs := make([]int64, 0, np.Schema().Len())
		for range np.Schema().Columns {
			newColID := planCtx.builder.ctx.GetSessionVars().AllocPlanColumnID()
			newColIDs = append(newColIDs, newColID)
		}
		subqueryCtx.outputColIDs = newColIDs

		planCtx.builder.ctx.GetSessionVars().RegisterScalarSubQ(subqueryCtx)

		row, err := EvalSubqueryFirstRow(ctx, physicalPlan, b.is, b.ctx)
		if err != nil {
			er.err = err
			return v, true
		}
		if (row != nil && !v.Not) || (row == nil && v.Not) {
			er.ctxStackAppend(expression.NewSignedOne(), types.EmptyName)
		} else {
			er.ctxStackAppend(expression.NewSignedZero(), types.EmptyName)
		}
	}
	return v, true
}

// popExistsSubPlan will remove the useless plan in exist's child.
// See comments inside the method for more details.
func (*expressionRewriter) popExistsSubPlan(planCtx *exprRewriterPlanCtx, p base.LogicalPlan) base.LogicalPlan {
	intest.AssertNotNil(planCtx)
out:
	for {
		switch plan := p.(type) {
		// This can be removed when in exists clause,
		// e.g. exists(select count(*) from t order by a) is equal to exists t.
		case *logicalop.LogicalProjection, *logicalop.LogicalSort:
			p = p.Children()[0]
		case *logicalop.LogicalAggregation:
			if len(plan.GroupByItems) == 0 {
				p = logicalop.LogicalTableDual{RowCount: 1}.Init(planCtx.builder.ctx, planCtx.builder.getSelectOffset())
				break out
			}
			p = p.Children()[0]
		default:
			break out
		}
	}
	return p
}

func (er *expressionRewriter) handleInSubquery(ctx context.Context, planCtx *exprRewriterPlanCtx, v *ast.PatternInExpr) (ast.Node, bool) {
	intest.AssertNotNil(planCtx)
	ci := planCtx.builder.prepareCTECheckForSubQuery()
	defer resetCTECheckForSubQuery(ci)
	asScalar := er.asScalar
	er.asScalar = true
	v.Expr.Accept(er)
	if er.err != nil {
		return v, true
	}
	lexpr := er.ctxStack[len(er.ctxStack)-1]
	subq, ok := v.Sel.(*ast.SubqueryExpr)
	if !ok {
		er.err = errors.Errorf("Unknown compare type %T", v.Sel)
		return v, true
	}
	np, hintFlags, err := er.buildSubquery(ctx, planCtx, subq, handlingInSubquery)
	if err != nil {
		er.err = err
		return v, true
	}
	lLen := expression.GetRowLen(lexpr)
	if lLen != np.Schema().Len() {
		er.err = expression.ErrOperandColumns.GenWithStackByArgs(lLen)
		return v, true
	}
	var rexpr expression.Expression
	markInOperand := v.Not || (asScalar && !er.canTreatInSubqueryAsExistsForFilter(planCtx))
	if np.Schema().Len() == 1 {
		rexpr = np.Schema().Columns[0]
		rCol := rexpr.(*expression.Column)
		// For AntiSemiJoin/LeftOuterSemiJoin/AntiLeftOuterSemiJoin, we cannot treat `in` expression as
		// normal column equal condition, so we specially mark the inner operand here.
		if markInOperand {
			// If both input columns of `in` expression are not null, we can treat the expression
			// as normal column equal condition instead. Otherwise, mark the left and right side.
			// eg: for some optimization, the column substitute in right side in projection elimination
			// will cause case  like <lcol EQ rcol(inOperand)> as <lcol EQ constant> which is not
			// a valid null-aware EQ. (null in lcol still need to be null-aware)
			if !expression.ExprNotNull(er.sctx.GetEvalCtx(), lexpr) || !expression.ExprNotNull(er.sctx.GetEvalCtx(), rCol) {
				rColCopy := *rCol
				rColCopy.InOperand = true
				rexpr = &rColCopy
				lexpr = expression.SetExprColumnInOperand(lexpr)
			}
		}
	} else {
		args := make([]expression.Expression, 0, np.Schema().Len())
		for i, col := range np.Schema().Columns {
			if markInOperand {
				larg := expression.GetFuncArg(lexpr, i)
				// If both input columns of `in` expression are not null, we can treat the expression
				// as normal column equal condition instead. Otherwise, mark the left and right side.
				if !expression.ExprNotNull(er.sctx.GetEvalCtx(), larg) || !expression.ExprNotNull(er.sctx.GetEvalCtx(), col) {
					rarg := *col
					rarg.InOperand = true
					col = &rarg
					if larg != nil {
						lexpr.(*expression.ScalarFunction).GetArgs()[i] = expression.SetExprColumnInOperand(larg)
					}
				}
			}
			args = append(args, col)
		}
		rexpr, er.err = er.newFunction(ast.RowFunc, args[0].GetType(er.sctx.GetEvalCtx()), args...)
		if er.err != nil {
			return v, true
		}
	}
	checkCondition, err := er.constructBinaryOpFunction(lexpr, rexpr, ast.EQ)
	if err != nil {
		er.err = err
		return v, true
	}

	// If the leftKey and the rightKey have different collations, don't convert the sub-query to an inner-join
	// since when converting we will add a distinct-agg upon the right child and this distinct-agg doesn't have the right collation.
	// To keep it simple, we forbid this converting if they have different collations.
	// tested by TestCollateSubQuery.
	lt, rt := lexpr.GetType(er.sctx.GetEvalCtx()), rexpr.GetType(er.sctx.GetEvalCtx())
	collFlag := collate.CompatibleCollate(lt.GetCollate(), rt.GetCollate())
	corCols := coreusage.ExtractCorColumnsBySchema4LogicalPlan(np, planCtx.plan.Schema())
	noDecorrelate := isNoDecorrelate(planCtx, corCols, hintFlags, handlingInSubquery)

	// If it's not the form of `not in (SUBQUERY)`,
	// and has no correlated column from the current level plan(if the correlated column is from upper level,
	// we can treat it as constant, because the upper LogicalApply cannot be eliminated since current node is a join node),
	// and don't need to append a scalar value, we can rewrite it to inner join.
	if planCtx.builder.ctx.GetSessionVars().GetAllowInSubqToJoinAndAgg() && !v.Not && !asScalar && len(corCols) == 0 && collFlag {
		// We need to try to eliminate the agg and the projection produced by this operation.
		planCtx.builder.optFlag |= rule.FlagEliminateAgg
		planCtx.builder.optFlag |= rule.FlagEliminateProjection
		planCtx.builder.optFlag |= rule.FlagJoinReOrder
		planCtx.builder.optFlag |= rule.FlagEmptySelectionEliminator
		// Build distinct for the inner query.
		agg, err := planCtx.builder.buildDistinct(np, np.Schema().Len())
		if err != nil {
			er.err = err
			return v, true
		}
		// Build inner join above the aggregation.
		join := logicalop.LogicalJoin{JoinType: base.InnerJoin}.Init(planCtx.builder.ctx, planCtx.builder.getSelectOffset())
		join.SetChildren(planCtx.plan, agg)
		join.SetSchema(expression.MergeSchema(planCtx.plan.Schema(), agg.Schema()))
		join.SetOutputNames(make([]*types.FieldName, planCtx.plan.Schema().Len()+agg.Schema().Len()))
		copy(join.OutputNames(), planCtx.plan.OutputNames())
		copy(join.OutputNames()[planCtx.plan.Schema().Len():], agg.OutputNames())
		join.AttachOnConds(expression.SplitCNFItems(checkCondition))
		// set FullSchema and FullNames for this join
		if left, ok := planCtx.plan.(*logicalop.LogicalJoin); ok && left.FullSchema != nil {
			join.FullSchema = left.FullSchema
			join.FullNames = left.FullNames
		}
		// Set join hint for this join.
		if planCtx.builder.TableHints() != nil {
			join.SetPreferredJoinTypeAndOrder(planCtx.builder.TableHints())
		}
		planCtx.plan = join
	} else {
		semiRewrite := hintFlags&hint.HintFlagSemiJoinRewrite > 0
		planCtx.plan, er.err = planCtx.builder.buildSemiApply(planCtx.plan, np, expression.SplitCNFItems(checkCondition), asScalar, v.Not, semiRewrite, noDecorrelate)
		if er.err != nil {
			return v, true
		}
	}

	er.ctxStackPop(1)
	if asScalar {
		col := planCtx.plan.Schema().Columns[planCtx.plan.Schema().Len()-1]
		er.ctxStackAppend(col, planCtx.plan.OutputNames()[planCtx.plan.Schema().Len()-1])
	}
	return v, true
}

func isNoDecorrelate(planCtx *exprRewriterPlanCtx, corCols []*expression.CorrelatedColumn, hintFlags uint64, sCtx subQueryCtx) bool {
	noDecorrelate := hintFlags&hint.HintFlagNoDecorrelate > 0

	if len(corCols) == 0 {
		if noDecorrelate {
			planCtx.builder.ctx.GetSessionVars().StmtCtx.SetHintWarning(
				"NO_DECORRELATE() is inapplicable because there are no correlated columns.")
			noDecorrelate = false
		}
	} else {
		semiJoinRewrite := hintFlags&hint.HintFlagSemiJoinRewrite > 0
		// We can't override noDecorrelate via the variable for EXISTS subqueries with semi join rewrite
		// as this will cause a conflict that will result in both being disabled in later code
		// SemiJoinRewrite does not check the variable TiDBOptEnableSemiJoinRewrite.
		// If that variable is enabled - we can still choose NOT to decorrelate here.
		if !(semiJoinRewrite && sCtx == handlingExistsSubquery) {
			// Only support scalar and exists subqueries
			validSubqType := sCtx == handlingScalarSubquery || sCtx == handlingExistsSubquery
			if validSubqType && planCtx.curClause == fieldList { // subquery is in the select list
				planCtx.builder.ctx.GetSessionVars().RecordRelevantOptVar(vardef.TiDBOptEnableNoDecorrelateInSelect)
				// If it isn't already enabled via hint, and variable is set, then enable it
				if !noDecorrelate && planCtx.builder.ctx.GetSessionVars().EnableNoDecorrelateInSelect {
					noDecorrelate = true
				}
			}
		}
	}
	return noDecorrelate
}

func (er *expressionRewriter) handleScalarSubquery(ctx context.Context, planCtx *exprRewriterPlanCtx, v *ast.SubqueryExpr) (ast.Node, bool) {
	intest.AssertNotNil(planCtx)
	ci := planCtx.builder.prepareCTECheckForSubQuery()
	defer resetCTECheckForSubQuery(ci)
	np, hintFlags, err := er.buildSubquery(ctx, planCtx, v, handlingScalarSubquery)
	if err != nil {
		er.err = err
		return v, true
	}
	np = planCtx.builder.buildMaxOneRow(np)
	correlatedColumn := coreusage.ExtractCorColumnsBySchema4LogicalPlan(np, planCtx.plan.Schema())
	noDecorrelate := isNoDecorrelate(planCtx, correlatedColumn, hintFlags, handlingScalarSubquery)

	if planCtx.builder.disableSubQueryPreprocessing || len(coreusage.ExtractCorrelatedCols4LogicalPlan(np)) > 0 || hasCTEConsumerInSubPlan(np) {
		planCtx.plan = planCtx.builder.buildApplyWithJoinType(planCtx.plan, np, base.LeftOuterJoin, noDecorrelate)
		if np.Schema().Len() > 1 {
			newCols := make([]expression.Expression, 0, np.Schema().Len())
			for _, col := range np.Schema().Columns {
				newCols = append(newCols, col)
			}
			expr, err1 := er.newFunction(ast.RowFunc, newCols[0].GetType(er.sctx.GetEvalCtx()), newCols...)
			if err1 != nil {
				er.err = err1
				return v, true
			}
			er.ctxStackAppend(expr, types.EmptyName)
		} else {
			er.ctxStackAppend(planCtx.plan.Schema().Columns[planCtx.plan.Schema().Len()-1], planCtx.plan.OutputNames()[planCtx.plan.Schema().Len()-1])
		}
		return v, true
	}
	// We don't want nth_plan hint to affect separately executed subqueries here, so disable nth_plan temporarily.
	nthPlanBackup := planCtx.builder.ctx.GetSessionVars().StmtCtx.StmtHints.ForceNthPlan
	planCtx.builder.ctx.GetSessionVars().StmtCtx.StmtHints.ForceNthPlan = -1
	physicalPlan, _, err := DoOptimize(ctx, planCtx.builder.ctx, planCtx.builder.optFlag, np)
	planCtx.builder.ctx.GetSessionVars().StmtCtx.StmtHints.ForceNthPlan = nthPlanBackup
	if err != nil {
		er.err = err
		return v, true
	}
	if planCtx.builder.ctx.GetSessionVars().StmtCtx.InExplainStmt && !planCtx.builder.ctx.GetSessionVars().StmtCtx.InExplainAnalyzeStmt && planCtx.builder.ctx.GetSessionVars().ExplainNonEvaledSubQuery {
		subqueryCtx := ScalarSubqueryEvalCtx{
			scalarSubQuery: physicalPlan,
			ctx:            ctx,
			is:             planCtx.builder.is,
		}.Init(planCtx.builder.ctx, np.QueryBlockOffset())
		newColIDs := make([]int64, 0, np.Schema().Len())
		newScalarSubQueryExprs := make([]expression.Expression, 0, np.Schema().Len())
		for _, col := range np.Schema().Columns {
			newColID := planCtx.builder.ctx.GetSessionVars().AllocPlanColumnID()
			scalarSubQ := &ScalarSubQueryExpr{
				scalarSubqueryColID: newColID,
				evalCtx:             subqueryCtx,
			}
			scalarSubQ.RetType = col.RetType
			scalarSubQ.SetCoercibility(col.Coercibility())
			newColIDs = append(newColIDs, newColID)
			newScalarSubQueryExprs = append(newScalarSubQueryExprs, scalarSubQ)
		}
		subqueryCtx.outputColIDs = newColIDs

		planCtx.builder.ctx.GetSessionVars().RegisterScalarSubQ(subqueryCtx)
		if len(newScalarSubQueryExprs) == 1 {
			er.ctxStackAppend(newScalarSubQueryExprs[0], types.EmptyName)
		} else {
			rowFunc, err := er.newFunction(ast.RowFunc, newScalarSubQueryExprs[0].GetType(er.sctx.GetEvalCtx()), newScalarSubQueryExprs...)
			if err != nil {
				er.err = err
				return v, true
			}
			er.ctxStack = append(er.ctxStack, rowFunc)
		}
		return v, true
	}

	// register the subquery plan but continue with normal execution
	subqueryCtx := ScalarSubqueryEvalCtx{
		scalarSubQuery: physicalPlan,
		ctx:            ctx,
		is:             planCtx.builder.is,
	}.Init(planCtx.builder.ctx, np.QueryBlockOffset())
	newColIDs := make([]int64, 0, np.Schema().Len())
	for range np.Schema().Columns {
		newColID := planCtx.builder.ctx.GetSessionVars().AllocPlanColumnID()
		newColIDs = append(newColIDs, newColID)
	}
	subqueryCtx.outputColIDs = newColIDs

	planCtx.builder.ctx.GetSessionVars().RegisterScalarSubQ(subqueryCtx)
	row, err := EvalSubqueryFirstRow(ctx, physicalPlan, planCtx.builder.is, planCtx.builder.ctx)
	if err != nil {
		er.err = err
		return v, true
	}
	newCols := make([]expression.Expression, 0, np.Schema().Len())
	for i, data := range row {
		constant := &expression.Constant{
			Value:         data,
			RetType:       np.Schema().Columns[i].GetType(er.sctx.GetEvalCtx()),
			SubqueryRefID: newColIDs[i],
		}
		constant.SetCoercibility(np.Schema().Columns[i].Coercibility())
		newCols = append(newCols, constant)
	}

	if np.Schema().Len() > 1 {
		expr, err := er.newFunction(ast.RowFunc, newCols[0].GetType(er.sctx.GetEvalCtx()), newCols...)
		if err != nil {
			er.err = err
			return v, true
		}
		er.ctxStackAppend(expr, types.EmptyName)
	} else {
		er.ctxStackAppend(newCols[0], types.EmptyName)
	}
	return v, true
}

func hasCTEConsumerInSubPlan(p base.LogicalPlan) bool {
	if _, ok := p.(*logicalop.LogicalCTE); ok {
		return true
	}
	return slices.ContainsFunc(p.Children(), hasCTEConsumerInSubPlan)
}
