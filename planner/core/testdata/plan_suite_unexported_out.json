[
  {
    "Name": "TestEagerAggregation",
    "Cases": [
      "DataScan(t)->Aggr(sum(test.t.a),sum(plus(test.t.a, 1)),count(test.t.a))->Projection",
      "DataScan(t)->Aggr(sum(plus(test.t.a, test.t.b)),sum(plus(test.t.a, test.t.c)),count(test.t.a))->Sel([gt(Column#13, 0)])->Projection->Sort->Projection",
      "Join{DataScan(a)->Aggr(sum(test.t.a),firstrow(test.t.c))->DataScan(b)}(test.t.c,test.t.c)->Aggr(sum(Column#26))->Projection",
      "Join{DataScan(a)->DataScan(b)->Aggr(sum(test.t.a),firstrow(test.t.c))}(test.t.c,test.t.c)->Aggr(sum(Column#26))->Projection",
      "Join{DataScan(a)->DataScan(b)->Aggr(sum(test.t.a),firstrow(test.t.c))}(test.t.c,test.t.c)->Aggr(sum(Column#26),firstrow(test.t.a))->Projection",
      "Join{DataScan(a)->Aggr(sum(test.t.a),firstrow(test.t.c))->DataScan(b)}(test.t.c,test.t.c)->Aggr(sum(Column#26),firstrow(test.t.a))->Projection",
      "Join{DataScan(a)->DataScan(b)}(test.t.c,test.t.c)->Aggr(sum(test.t.a),sum(test.t.a))->Projection",
      "Join{DataScan(a)->Aggr(sum(test.t.a),firstrow(test.t.c))->DataScan(b)}(test.t.c,test.t.c)->Aggr(sum(Column#27),max(test.t.a))->Projection",
      "Join{DataScan(a)->DataScan(b)->Aggr(sum(test.t.a),firstrow(test.t.c))}(test.t.c,test.t.c)->Aggr(max(test.t.a),sum(Column#27))->Projection",
      "Join{Join{DataScan(a)->DataScan(b)}(test.t.c,test.t.c)->DataScan(c)}(test.t.c,test.t.c)->Aggr(sum(test.t.a))->Projection",
      "Join{DataScan(a)->DataScan(b)->Aggr(sum(test.t.a),firstrow(test.t.c))}(test.t.c,test.t.c)->Aggr(sum(Column#26))->Projection",
      "Join{DataScan(a)->Aggr(sum(test.t.a),firstrow(test.t.c))->DataScan(b)}(test.t.c,test.t.c)->Aggr(sum(Column#26))->Projection",
      "Join{DataScan(a)->Aggr(sum(test.t.a),firstrow(test.t.c))->DataScan(b)}(test.t.c,test.t.c)->Aggr(sum(Column#26))->Projection",
      "DataScan(t)->Aggr(sum(test.t.a))->Projection",
      "UnionAll{DataScan(a)->Projection->Aggr(sum(test.t.c),firstrow(test.t.d))->DataScan(b)->Projection->Aggr(sum(test.t.a),firstrow(test.t.b))->DataScan(c)->Projection->Aggr(sum(test.t.b),firstrow(test.t.e))}->Aggr(sum(Column#40))->Projection",
      "Join{DataScan(a)->DataScan(b)->Aggr(max(test.t.b),firstrow(test.t.c))}(test.t.c,test.t.c)->Projection->Projection",
      "Join{DataScan(a)->DataScan(b)}(test.t.a,test.t.a)->Aggr(max(test.t.b),max(test.t.b))->Projection",
      "UnionAll{DataScan(a)->Projection->Projection->Projection->DataScan(b)->Projection->Projection->Projection}->Aggr(max(Column#38))->Projection",
      "Join{DataScan(a)->DataScan(b)}(test.t.a,test.t.a)(test.t.b,test.t.b)->Aggr(max(test.t.c))->Projection",
      "Join{DataScan(t1)->DataScan(t2)}(test.t.a,test.t.a)->Projection->Projection",
      "UnionAll{DataScan(t1)->Projection->Aggr(count(test.t.a),sum(test.t.a))->DataScan(t2)->Projection->Aggr(count(test.t.a),sum(test.t.a))}->Aggr(avg(Column#38, Column#39))->Projection",
      "UnionAll{DataScan(t1)->Projection->Projection->Projection->DataScan(t2)->Projection->Projection->Projection}->Aggr(count(distinct Column#25))->Projection",
      "UnionAll{DataScan(t1)->Projection->Aggr(firstrow(test.t.b),firstrow(test.t.b))->DataScan(t2)->Projection->Aggr(firstrow(test.t.b),firstrow(test.t.b))}->Aggr(count(distinct Column#26))->Projection",
      "UnionAll{DataScan(t1)->Projection->Aggr(approx_count_distinct(test.t.a))->DataScan(t2)->Projection->Aggr(approx_count_distinct(test.t.a))}->Aggr(approx_count_distinct(Column#38))->Projection",
      "UnionAll{DataScan(t1)->Projection->Aggr(approx_count_distinct(test.t.b))->DataScan(t2)->Projection->Aggr(approx_count_distinct(test.t.b))}->Aggr(approx_count_distinct(Column#38))->Projection"
    ]
  },
  {
    "Name": "TestPlanBuilder",
    "Cases": [
      "DataScan(t)->Lock->Projection",
      "TableReader(Table(t)->Limit)->Limit->Update",
      "TableReader(Table(t)->Limit)->Limit->Delete",
      "*core.Explain",
      "*core.Explain",
      "*core.Explain",
      "*core.Explain",
      "*core.Explain",
      "*core.Explain",
      "*core.Explain",
      "*core.Explain",
      "TableReader(Table(t))->Insert",
      "Show->Sel([eq(cast(Column#4, double BINARY), 0)])->Projection",
      "Dual->Projection",
      "Dual->Projection",
      "Dual->Projection",
      "Join{DataScan(t1)->DataScan(t2)}->Projection",
      "Join{DataScan(t1)->DataScan(t2)}->Projection",
      "LeftHashJoin{LeftHashJoin{TableReader(Table(t))->IndexLookUp(Index(t.c_d_e)[[666,666]], Table(t))}(test.t.a,test.t.b)->IndexReader(Index(t.c_d_e)[[42,42]])}(test.t.b,test.t.a)->Sel([or(Column#25, Column#38)])->Projection->Delete",
      "LeftHashJoin{TableReader(Table(t))->IndexReader(Index(t.c_d_e)[[NULL,+inf]])->HashAgg}(test.t.b,test.t.c)->Update"
    ]
  },
  {
    "Name": "TestPredicatePushDown",
    "Cases": [
      "Join{DataScan(a)->DataScan(b)}(test.t.a,test.t.a)->Aggr(count(1))->Projection",
      "DataScan(t)->Projection->Projection",
      "DataScan(t)->Projection->Projection",
      "DataScan(t)->Projection->Projection",
      "DataScan(t)->Projection->Projection",
      "Join{DataScan(ta)->DataScan(tb)}(test.t.d,test.t.b)(test.t.a,test.t.c)->Projection",
      "Join{DataScan(t1)->DataScan(t2)}(test.t.a,test.t.b)(test.t.d,test.t.d)->Projection",
      "Join{DataScan(ta)->DataScan(tb)}(test.t.d,test.t.d)->Projection",
      "Join{DataScan(ta)->DataScan(tb)}(test.t.d,test.t.d)->Projection",
      "Join{DataScan(ta)->DataScan(tb)}(test.t.d,test.t.d)->Projection",
      "Join{DataScan(ta)->DataScan(tb)}(test.t.d,test.t.d)->Projection",
      "Join{DataScan(ta)->DataScan(tb)}->Projection",
      "Join{DataScan(ta)->DataScan(tb)}->Projection",
      "Join{DataScan(ta)->DataScan(tb)}(test.t.d,test.t.d)->Projection",
      "Join{Join{DataScan(ta)->DataScan(tb)}(test.t.a,test.t.a)->DataScan(tc)}(test.t.b,test.t.b)->Projection",
      "Join{Join{DataScan(ta)->DataScan(tb)}(test.t.a,test.t.a)->DataScan(tc)}(test.t.b,test.t.b)->Projection",
      "Join{DataScan(ta)->Join{DataScan(tb)->DataScan(tc)}(test.t.b,test.t.b)}(test.t.a,test.t.a)->Projection",
      "Join{Join{DataScan(ta)->DataScan(tb)}(test.t.a,test.t.a)->Join{DataScan(tc)->DataScan(td)}(test.t.b,test.t.b)}(test.t.c,test.t.c)->Projection",
      "Join{DataScan(ta)->Join{DataScan(tb)->DataScan(tc)}(test.t.b,test.t.b)}(test.t.a,test.t.a)(test.t.c,test.t.c)->Sel([or(gt(test.t.d, 0), gt(test.t.d, 0))])->Projection",
      "Join{DataScan(ta)->DataScan(tb)}(test.t.d,test.t.d)->Sel([or(ifnull(test.t.d, 1), isnull(test.t.d))])->Projection",
      "UnionAll{DataScan(t)->Projection->Projection->DataScan(t)->Projection->Projection->DataScan(t)->Projection->Projection}->Projection",
      "Apply{DataScan(k)->DataScan(t)->Aggr(count(1))->Projection->MaxOneRow}->Projection",
      "Join{DataScan(t)->DataScan(x)}->Projection",
      "Join{DataScan(t)->DataScan(x)}(test.t.a,test.t.a)->Projection",
      "Join{DataScan(t)->DataScan(x)}(test.t.a,test.t.a)->Projection",
      "Join{Join{DataScan(t)->DataScan(x)}(test.t.a,test.t.a)->DataScan(x)}(test.t.a,test.t.a)->Projection",
      "DataScan(t)->Aggr(sum(test.t.c),firstrow(test.t.a),firstrow(test.t.b))->Projection->Projection",
      "DataScan(t)->Aggr(sum(test.t.c),firstrow(test.t.a),firstrow(test.t.b))->Projection->Projection",
      "DataScan(t)->Aggr(sum(test.t.b),firstrow(test.t.a))->Projection->Aggr(sum(Column#13),firstrow(test.t.a))->Projection->Projection",
      "DataScan(t)->Aggr(sum(test.t.b),firstrow(test.t.a))->Sel([gt(cast(test.t.a, decimal(20,0) BINARY), Column#13)])->Projection->Projection",
      "DataScan(t)->Aggr(sum(test.t.b),firstrow(test.t.a))->Sel([gt(test.t.a, 1)])->Projection->Projection",
      "Dual->Sel([gt(test.t.a, 1)])->Projection",
      "DataScan(t)->Aggr(count(test.t.a),firstrow(test.t.a))->Sel([lt(Column#13, 1)])->Projection",
      "Join{DataScan(t1)->DataScan(t2)}(test.t.a,test.t.a)->Projection",
      "Dual->Projection",
      "DataScan(t)->Projection->Projection->Window(min(test.t.a)->Column#14)->Sel([lt(test.t.a, 10) eq(test.t.b, Column#14)])->Projection->Projection",
      "DataScan(t)->Projection->Projection->Window(sum(cast(test.t.a, decimal(65,0) BINARY))->Column#14)->Sel([gt(Column#14, cast(test.t.b, decimal(20,0) BINARY))])->Projection->Projection"
    ]
  },
  {
    "Name": "TestSubquery",
    "Cases": [
      "Join{DataScan(t)->DataScan(s)}(test.t.a,test.t.a)->Projection",
      "Join{DataScan(t)->Aggr(count(test.t.c),firstrow(test.t.a))->DataScan(s)}(test.t.a,test.t.a)->Projection->Projection",
      "Join{DataScan(t)->Aggr(count(test.t.c),firstrow(test.t.a))->DataScan(s)}(test.t.a,test.t.a)->Aggr(firstrow(Column#13),count(test.t.b))->Projection->Projection",
      "Apply{DataScan(t)->DataScan(s)->Sel([eq(test.t.a, test.t.a)])->Aggr(count(test.t.b))}->Projection",
      "Join{DataScan(t)->DataScan(s)->Aggr(count(test.t.b),firstrow(test.t.a))}(test.t.a,test.t.a)->Projection->Projection->Projection",
      "Join{Join{DataScan(t1)->DataScan(t2)}->DataScan(s)->Aggr(count(test.t.b),firstrow(test.t.a))}(test.t.a,test.t.a)->Projection->Projection->Projection",
      "Join{DataScan(t)->DataScan(s)->Aggr(count(1),firstrow(test.t.a))}(test.t.a,test.t.a)->Projection->Projection->Projection",
      "Join{DataScan(t)->DataScan(s)->Aggr(firstrow(test.t.a))->Projection}(test.t.a,test.t.a)->Projection",
      "Join{DataScan(t)->DataScan(s)}(test.t.a,test.t.a)->Projection",
      "Join{DataScan(t)->DataScan(s)}(test.t.a,test.t.a)->Projection->Sel([in(10, test.t.b, 10)])->Projection",
      "Join{DataScan(t)->DataScan(s)->Aggr(sum(test.t.a))->Projection}->Projection",
      "Join{DataScan(t1)->DataScan(t)->Projection->Limit}(test.t.b,test.t.b)->Projection->Projection",
      "Join{DataScan(t)->Join{DataScan(s)->DataScan(k)}(test.t.d,test.t.d)(test.t.c,test.t.c)->Aggr(sum(test.t.a))->Projection}->Projection",
      "Join{DataScan(t1)->DataScan(t2)->Aggr(max(test.t.a),firstrow(test.t.b))}(test.t.b,test.t.b)->Projection->Sel([eq(test.t.b, Column#25)])->Projection",
      "Apply{DataScan(t1)->DataScan(t2)->Sel([eq(test.t.g, test.t.g) or(eq(test.t.b, 4), eq(test.t.b, 2))])->Aggr(avg(test.t.a))}->Projection->Sel([eq(cast(test.t.b, decimal(20,0) BINARY), Column#25)])->Projection",
      "Join{DataScan(t1)->DataScan(t2)->Aggr(max(test.t.a),firstrow(test.t.b))}(test.t.b,test.t.b)->Projection->Sel([eq(test.t.b, Column#25)])->Projection",
      "Join{DataScan(t1)->DataScan(t2)}(test.t.a,test.t.a)(test.t.b,test.t.b)->Projection",
      "Join{DataScan(t1)->DataScan(t2)}(test.t.a,test.t.a)->Projection",
      "Apply{DataScan(t1)->DataScan(t2)->Sel([eq(test.t.a, test.t.a)])->Projection->Sort->Limit}->Projection->Sel([eq(test.t.b, test.t.b)])->Projection"
    ]
  },
  {
    "Name": "TestTopNPushDown",
    "Cases": [
      "DataScan(t)->TopN([test.t.b],0,5)->Projection",
      "DataScan(t)->Limit->Projection",
      "DataScan(t)->Aggr(count(test.t.b),firstrow(test.t.a))->Limit->Projection",
      "DataScan(t)->Aggr(count(test.t.b),firstrow(test.t.a),firstrow(test.t.c))->TopN([test.t.c],0,5)->Projection",
      "Join{DataScan(t)->DataScan(s)}->TopN([test.t.a],0,5)->Projection",
      "Join{DataScan(t)->DataScan(s)}->Limit->Projection",
      "DataScan(t)->Projection->TopN([Column#13 true],0,1)->Projection",
      "Join{DataScan(t)->TopN([test.t.a],0,5)->DataScan(s)}(test.t.a,test.t.a)->TopN([test.t.a],0,5)->Projection",
      "Join{DataScan(t)->TopN([test.t.a],0,10)->DataScan(s)}(test.t.a,test.t.a)->TopN([test.t.a],5,5)->Projection",
      "Join{DataScan(t)->Limit->DataScan(s)}(test.t.a,test.t.a)->Limit->Projection",
      "Join{DataScan(t)->Limit->DataScan(s)}(test.t.a,test.t.a)->Limit->Projection",
      "Join{DataScan(t)->TopN([test.t.a],0,5)->DataScan(s)}(test.t.a,test.t.a)->TopN([test.t.a],0,5)->Projection",
      "Join{DataScan(t)->TopN([test.t.a],0,5)->DataScan(s)}(test.t.a,test.t.a)->TopN([test.t.a],0,5)->Projection",
      "Join{DataScan(t)->DataScan(s)}(test.t.a,test.t.a)->TopN([test.t.a],0,5)->Projection",
      "Join{DataScan(t)->DataScan(s)->TopN([test.t.a],0,5)}(test.t.a,test.t.a)->TopN([test.t.a],0,5)->Projection",
      "Join{DataScan(t)->DataScan(s)}(test.t.a,test.t.a)->TopN([test.t.a test.t.b],0,5)->Projection",
      "UnionAll{DataScan(t)->TopN([test.t.a test.t.b],0,5)->Projection->DataScan(s)->TopN([test.t.a test.t.b],0,5)->Projection}->TopN([Column#25 Column#26],0,5)",
      "UnionAll{DataScan(t)->TopN([test.t.a test.t.b],0,10)->Projection->DataScan(s)->TopN([test.t.a test.t.b],0,10)->Projection}->TopN([Column#25 Column#26],5,5)",
      "UnionAll{DataScan(t)->Limit->Projection->DataScan(s)->TopN([test.t.a],0,5)->Projection}->Limit",
      "Join{DataScan(t1)->TopN([test.t.b],0,5)->DataScan(t2)}(test.t.e,test.t.e)->TopN([test.t.b],0,5)->Projection",
      "Join{DataScan(t1)->DataScan(t2)}(test.t.e,test.t.e)->TopN([ifnull(test.t.h, test.t.b)],0,5)->Projection->Projection"
    ]
  },
  {
    "Name": "TestUnion",
    "Cases": [
      {
        "Best": "UnionAll{DataScan(t)->Projection->DataScan(t)->Projection}->Aggr(firstrow(Column#25))",
        "Err": false
      },
      {
        "Best": "UnionAll{DataScan(t)->Projection->DataScan(t)->Projection}",
        "Err": false
      },
      {
        "Best": "UnionAll{UnionAll{DataScan(t)->Projection->DataScan(t)->Projection}->Aggr(firstrow(Column#37))->Projection->DataScan(t)->Projection}",
        "Err": false
      },
      {
        "Best": "UnionAll{DataScan(t)->Projection->DataScan(t)->Projection->DataScan(t)->Projection->DataScan(t)->Projection->DataScan(t)->Projection}->Aggr(firstrow(Column#61))",
        "Err": false
      },
      {
        "Best": "",
        "Err": true
      },
      {
        "Best": "UnionAll{UnionAll{Dual->Projection->Dual->Projection}->Aggr(firstrow(Column#4))->Projection->Dual->Projection}->Projection->Sort",
        "Err": false
      },
      {
        "Best": "Join{UnionAll{UnionAll{Dual->Projection->Dual->Projection}->Aggr(firstrow(Column#4))->Projection->Dual->Projection}->Dual}->Sort->Projection",
        "Err": false
      }
    ]
  },
  {
    "Name": "TestWindowFunction",
    "Cases": [
      "TableReader(Table(t))->Window(avg(cast(test.t.a, decimal(65,30) BINARY))->Column#14 over(partition by test.t.a))->Projection",
      "TableReader(Table(t))->Sort->Window(avg(cast(test.t.a, decimal(65,30) BINARY))->Column#14 over(partition by test.t.b))->Projection",
      "IndexReader(Index(t.f)[[NULL,+inf]])->Projection->Sort->Window(avg(cast(Column#16, decimal(65,4) BINARY))->Column#17 over(partition by Column#15))->Projection",
      "TableReader(Table(t))->Sort->Window(avg(cast(test.t.a, decimal(65,30) BINARY))->Column#14 over(order by test.t.a, test.t.b desc range between unbounded preceding and current row))->Projection",
      "TableReader(Table(t))->Window(avg(cast(test.t.a, decimal(65,30) BINARY))->Column#14 over(partition by test.t.a))->Projection",
      "[planner:1054]Unknown column 'z' in 'field list'",
      "TableReader(Table(t))->Window(sum(cast(test.t.b, decimal(65,0) BINARY))->Column#14 over())->Sort->Projection",
      "IndexReader(Index(t.f)[[NULL,+inf]]->StreamAgg)->StreamAgg->Window(sum(Column#13)->Column#15 over())->Projection",
      "TableReader(Table(t))->Window(sum(cast(test.t.a, decimal(65,0) BINARY))->Column#14 over())->Sort->Projection",
      "TableReader(Table(t))->Window(sum(cast(test.t.a, decimal(65,0) BINARY))->Column#14 over(partition by test.t.a))->Sort->Projection",
      "TableReader(Table(t)->StreamAgg)->StreamAgg->Window(sum(Column#13)->Column#15 over())->Sort->Projection",
      "Apply{IndexReader(Index(t.f)[[NULL,+inf]])->IndexReader(Index(t.f)[[NULL,+inf]]->Sel([gt(test.t.a, test.t.a)]))->Window(sum(cast(test.t.a, decimal(65,0) BINARY))->Column#26 over())->MaxOneRow->Sel([Column#26])}->Projection",
      "[planner:3594]You cannot use the alias 'w' of an expression containing a window function in this context.'",
      "[planner:1247]Reference 'sum_a' not supported (reference to window function)",
      "[planner:3579]Window name 'w2' is not defined.",
      "[planner:3579]Window name 'w' is not defined.",
      "[planner:3580]There is a circularity in the window dependency graph.",
      "[planner:3581]A window which depends on another cannot define partitioning.",
      "[planner:3581]A window which depends on another cannot define partitioning.",
      "[planner:3582]Window 'w' has a frame definition, so cannot be referenced by another window.",
      "IndexReader(Index(t.f)[[NULL,+inf]])->Window(sum(cast(test.t.a, decimal(65,0) BINARY))->Column#14 over(rows between 1 preceding and 1 following))->Projection",
      "[planner:3583]Window '<unnamed window>' cannot inherit 'w' since both contain an ORDER BY clause.",
      "[planner:3591]Window 'w1' is defined twice.",
      "TableReader(Table(t))->Window(avg(cast(test.t.a, decimal(65,30) BINARY))->Column#14 over(partition by test.t.a))->Projection",
      "TableReader(Table(t))->Window(sum(cast(test.t.a, decimal(65,0) BINARY))->Column#14 over(partition by test.t.a))->Sort->Projection",
      "[planner:1235]This version of TiDB doesn't yet support 'GROUPS'",
      "[planner:3584]Window '<unnamed window>': frame start cannot be UNBOUNDED FOLLOWING.",
      "[planner:3585]Window '<unnamed window>': frame end cannot be UNBOUNDED PRECEDING.",
      "[planner:3596]Window '<unnamed window>': INTERVAL can only be used with RANGE frames.",
      "[planner:3586]Window '<unnamed window>': frame start or end is negative, NULL or of non-integral type",
      "[planner:3587]Window '<unnamed window>' with RANGE N PRECEDING/FOLLOWING frame requires exactly one ORDER BY expression, of numeric or temporal type",
      "[planner:3587]Window '<unnamed window>' with RANGE N PRECEDING/FOLLOWING frame requires exactly one ORDER BY expression, of numeric or temporal type",
      "[planner:3589]Window '<unnamed window>' with RANGE frame has ORDER BY expression of numeric type, INTERVAL bound value not allowed.",
      "[planner:3590]Window '<unnamed window>' has a non-constant frame bound.",
      "[planner:3586]Window '<unnamed window>': frame start or end is negative, NULL or of non-integral type",
      "[planner:3588]Window '<unnamed window>' with RANGE frame has ORDER BY expression of datetime type. Only INTERVAL bound value allowed.",
      "TableReader(Table(t))->Window(sum(cast(test.t.a, decimal(65,0) BINARY))->Column#14 over(order by test.t.a range between 1.0 preceding and 1 following))->Projection",
      "IndexReader(Index(t.f)[[NULL,+inf]])->Window(row_number()->Column#14 over())->Projection",
      "TableReader(Table(t))->HashAgg->Window(max(Column#13)->Column#15 over(rows between 1 preceding and 1 following))->Projection",
      "[planner:1210]Incorrect arguments to nth_value",
      "[planner:1210]Incorrect arguments to nth_value",
      "[planner:1210]Incorrect arguments to nth_value",
      "[planner:1210]Incorrect arguments to ntile",
      "IndexReader(Index(t.f)[[NULL,+inf]])->Window(ntile(<nil>)->Column#14 over())->Projection",
      "TableReader(Table(t))->Sort->Window(avg(cast(test.t.a, decimal(65,30) BINARY))->Column#14 over(partition by test.t.b))->Projection",
      "TableReader(Table(t))->Window(nth_value(test.t.i_date, 1)->Column#14 over())->Projection",
      "TableReader(Table(t))->Window(sum(cast(test.t.b, decimal(65,0) BINARY))->Column#15, sum(cast(test.t.c, decimal(65,0) BINARY))->Column#16 over(order by test.t.a range between unbounded preceding and current row))->Projection",
      "[planner:3593]You cannot use the window function 'sum' in this context.'",
      "[planner:3593]You cannot use the window function 'sum' in this context.'",
      "[planner:3593]You cannot use the window function 'row_number' in this context.'",
      "TableReader(Table(t))->Sort->Window(sum(cast(test.t.c, decimal(65,0) BINARY))->Column#17 over(partition by test.t.a order by test.t.c range between unbounded preceding and current row))->Sort->Window(sum(cast(test.t.b, decimal(65,0) BINARY))->Column#18 over(order by test.t.a, test.t.b, test.t.c range between unbounded preceding and current row))->Window(sum(cast(test.t.a, decimal(65,0) BINARY))->Column#19 over(partition by test.t.a order by test.t.b range between unbounded preceding and current row))->Window(sum(cast(test.t.d, decimal(65,0) BINARY))->Column#20 over())->Projection",
      "[planner:3587]Window 'w1' with RANGE N PRECEDING/FOLLOWING frame requires exactly one ORDER BY expression, of numeric or temporal type",
      "TableReader(Table(t))->Sort->Window(dense_rank()->Column#14 over(partition by test.t.b order by test.t.a desc, test.t.b desc))->Projection",
      "[planner:3587]Window 'w1' with RANGE N PRECEDING/FOLLOWING frame requires exactly one ORDER BY expression, of numeric or temporal type",
      "[planner:3585]Window 'w1': frame end cannot be UNBOUNDED PRECEDING.",
      "[planner:3584]Window 'w1': frame start cannot be UNBOUNDED FOLLOWING.",
      "[planner:3586]Window 'w1': frame start or end is negative, NULL or of non-integral type",
      "[planner:1235]This version of TiDB doesn't yet support 'IGNORE NULLS'",
      "[planner:1235]This version of TiDB doesn't yet support '<window function>(DISTINCT ..)'",
      "[planner:1235]This version of TiDB doesn't yet support 'FROM LAST'",
      "[planner:1235]This version of TiDB doesn't yet support 'IGNORE NULLS'",
      "[planner:1210]Incorrect arguments to nth_value",
      "[planner:1210]Incorrect arguments to nth_value",
      "[planner:3586]Window 'w': frame start or end is negative, NULL or of non-integral type",
      "[planner:3586]Window 'w': frame start or end is negative, NULL or of non-integral type",
      "[planner:3586]Window 'w': frame start or end is negative, NULL or of non-integral type",
      "TableReader(Table(t))->Sort->Window(row_number()->Column#14 over(partition by test.t.b))->Projection",
      "[planner:1235]This version of TiDB doesn't yet support 'group_concat as window function'"
    ]
  },
  {
    "Name": "TestWindowParallelFunction",
    "Cases": [
      "TableReader(Table(t))->Window(avg(cast(test.t.a, decimal(65,30) BINARY))->Column#14 over(partition by test.t.a))->Projection",
      "TableReader(Table(t))->Sort->Window(avg(cast(test.t.a, decimal(65,30) BINARY))->Column#14 over(partition by test.t.b))->Partition(execution info: concurrency:4, data source:TableReader_10)->Projection",
      "IndexReader(Index(t.f)[[NULL,+inf]])->Projection->Sort->Window(avg(cast(Column#16, decimal(65,4) BINARY))->Column#17 over(partition by Column#15))->Partition(execution info: concurrency:4, data source:Projection_8)->Projection",
      "TableReader(Table(t))->Sort->Window(avg(cast(test.t.a, decimal(65,30) BINARY))->Column#14 over(order by test.t.a, test.t.b desc range between unbounded preceding and current row))->Projection",
      "TableReader(Table(t))->Window(avg(cast(test.t.a, decimal(65,30) BINARY))->Column#14 over(partition by test.t.a))->Projection",
      "[planner:1054]Unknown column 'z' in 'field list'",
      "TableReader(Table(t))->Window(sum(cast(test.t.b, decimal(65,0) BINARY))->Column#14 over())->Sort->Projection",
      "IndexReader(Index(t.f)[[NULL,+inf]]->StreamAgg)->StreamAgg->Window(sum(Column#13)->Column#15 over())->Projection",
      "TableReader(Table(t))->Window(sum(cast(test.t.a, decimal(65,0) BINARY))->Column#14 over())->Sort->Projection",
      "TableReader(Table(t))->Window(sum(cast(test.t.a, decimal(65,0) BINARY))->Column#14 over(partition by test.t.a))->Sort->Projection",
      "TableReader(Table(t)->StreamAgg)->StreamAgg->Window(sum(Column#13)->Column#15 over())->Sort->Projection",
      "Apply{IndexReader(Index(t.f)[[NULL,+inf]])->IndexReader(Index(t.f)[[NULL,+inf]]->Sel([gt(test.t.a, test.t.a)]))->Window(sum(cast(test.t.a, decimal(65,0) BINARY))->Column#26 over())->MaxOneRow->Sel([Column#26])}->Projection",
      "[planner:3594]You cannot use the alias 'w' of an expression containing a window function in this context.'",
      "[planner:1247]Reference 'sum_a' not supported (reference to window function)",
      "[planner:3579]Window name 'w2' is not defined.",
      "[planner:3579]Window name 'w' is not defined.",
      "[planner:3580]There is a circularity in the window dependency graph.",
      "[planner:3581]A window which depends on another cannot define partitioning.",
      "[planner:3581]A window which depends on another cannot define partitioning.",
      "[planner:3582]Window 'w' has a frame definition, so cannot be referenced by another window.",
      "IndexReader(Index(t.f)[[NULL,+inf]])->Window(sum(cast(test.t.a, decimal(65,0) BINARY))->Column#14 over(rows between 1 preceding and 1 following))->Projection",
      "[planner:3583]Window '<unnamed window>' cannot inherit 'w' since both contain an ORDER BY clause.",
      "[planner:3591]Window 'w1' is defined twice.",
      "TableReader(Table(t))->Window(avg(cast(test.t.a, decimal(65,30) BINARY))->Column#14 over(partition by test.t.a))->Projection",
      "TableReader(Table(t))->Window(sum(cast(test.t.a, decimal(65,0) BINARY))->Column#14 over(partition by test.t.a))->Sort->Projection",
      "[planner:1235]This version of TiDB doesn't yet support 'GROUPS'",
      "[planner:3584]Window '<unnamed window>': frame start cannot be UNBOUNDED FOLLOWING.",
      "[planner:3585]Window '<unnamed window>': frame end cannot be UNBOUNDED PRECEDING.",
      "[planner:3596]Window '<unnamed window>': INTERVAL can only be used with RANGE frames.",
      "[planner:3586]Window '<unnamed window>': frame start or end is negative, NULL or of non-integral type",
      "[planner:3587]Window '<unnamed window>' with RANGE N PRECEDING/FOLLOWING frame requires exactly one ORDER BY expression, of numeric or temporal type",
      "[planner:3587]Window '<unnamed window>' with RANGE N PRECEDING/FOLLOWING frame requires exactly one ORDER BY expression, of numeric or temporal type",
      "[planner:3589]Window '<unnamed window>' with RANGE frame has ORDER BY expression of numeric type, INTERVAL bound value not allowed.",
      "[planner:3590]Window '<unnamed window>' has a non-constant frame bound.",
      "[planner:3586]Window '<unnamed window>': frame start or end is negative, NULL or of non-integral type",
      "[planner:3588]Window '<unnamed window>' with RANGE frame has ORDER BY expression of datetime type. Only INTERVAL bound value allowed.",
      "TableReader(Table(t))->Window(sum(cast(test.t.a, decimal(65,0) BINARY))->Column#14 over(order by test.t.a range between 1.0 preceding and 1 following))->Projection",
      "IndexReader(Index(t.f)[[NULL,+inf]])->Window(row_number()->Column#14 over())->Projection",
      "TableReader(Table(t))->HashAgg->Window(max(Column#13)->Column#15 over(rows between 1 preceding and 1 following))->Projection",
      "[planner:1210]Incorrect arguments to nth_value",
      "[planner:1210]Incorrect arguments to nth_value",
      "[planner:1210]Incorrect arguments to nth_value",
      "[planner:1210]Incorrect arguments to ntile",
      "IndexReader(Index(t.f)[[NULL,+inf]])->Window(ntile(<nil>)->Column#14 over())->Projection",
      "TableReader(Table(t))->Sort->Window(avg(cast(test.t.a, decimal(65,30) BINARY))->Column#14 over(partition by test.t.b))->Partition(execution info: concurrency:4, data source:TableReader_10)->Projection",
      "TableReader(Table(t))->Window(nth_value(test.t.i_date, 1)->Column#14 over())->Projection",
      "TableReader(Table(t))->Window(sum(cast(test.t.b, decimal(65,0) BINARY))->Column#15, sum(cast(test.t.c, decimal(65,0) BINARY))->Column#16 over(order by test.t.a range between unbounded preceding and current row))->Projection",
      "[planner:3593]You cannot use the window function 'sum' in this context.'",
      "[planner:3593]You cannot use the window function 'sum' in this context.'",
      "[planner:3593]You cannot use the window function 'row_number' in this context.'",
      "TableReader(Table(t))->Sort->Window(sum(cast(test.t.c, decimal(65,0) BINARY))->Column#17 over(partition by test.t.a order by test.t.c range between unbounded preceding and current row))->Sort->Window(sum(cast(test.t.b, decimal(65,0) BINARY))->Column#18 over(order by test.t.a, test.t.b, test.t.c range between unbounded preceding and current row))->Window(sum(cast(test.t.a, decimal(65,0) BINARY))->Column#19 over(partition by test.t.a order by test.t.b range between unbounded preceding and current row))->Window(sum(cast(test.t.d, decimal(65,0) BINARY))->Column#20 over())->Projection",
      "[planner:3587]Window 'w1' with RANGE N PRECEDING/FOLLOWING frame requires exactly one ORDER BY expression, of numeric or temporal type",
      "TableReader(Table(t))->Sort->Window(dense_rank()->Column#14 over(partition by test.t.b order by test.t.a desc, test.t.b desc))->Partition(execution info: concurrency:4, data source:TableReader_9)->Projection",
      "[planner:3587]Window 'w1' with RANGE N PRECEDING/FOLLOWING frame requires exactly one ORDER BY expression, of numeric or temporal type",
      "[planner:3585]Window 'w1': frame end cannot be UNBOUNDED PRECEDING.",
      "[planner:3584]Window 'w1': frame start cannot be UNBOUNDED FOLLOWING.",
      "[planner:3586]Window 'w1': frame start or end is negative, NULL or of non-integral type",
      "[planner:1235]This version of TiDB doesn't yet support 'IGNORE NULLS'",
      "[planner:1235]This version of TiDB doesn't yet support '<window function>(DISTINCT ..)'",
      "[planner:1235]This version of TiDB doesn't yet support 'FROM LAST'",
      "[planner:1235]This version of TiDB doesn't yet support 'IGNORE NULLS'",
      "[planner:1210]Incorrect arguments to nth_value",
      "[planner:1210]Incorrect arguments to nth_value",
      "[planner:3586]Window 'w': frame start or end is negative, NULL or of non-integral type",
      "[planner:3586]Window 'w': frame start or end is negative, NULL or of non-integral type",
      "[planner:3586]Window 'w': frame start or end is negative, NULL or of non-integral type",
      "TableReader(Table(t))->Sort->Window(row_number()->Column#14 over(partition by test.t.b))->Partition(execution info: concurrency:4, data source:TableReader_10)->Projection"
    ]
  },
  {
    "Name": "TestUniqueKeyInfo",
    "Cases": [
      {
        "1": [
          [
            "test.t.a"
          ]
        ],
        "2": [
          [
            "test.t.a"
          ]
        ],
        "3": [
          [
            "test.t.a"
          ]
        ]
      },
      {
        "1": [
          [
            "test.t.f"
          ],
          [
            "test.t.a"
          ]
        ],
        "2": [
          [
            "test.t.a"
          ],
          [
            "test.t.b"
          ]
        ],
        "3": [
          [
            "test.t.a"
          ],
          [
            "test.t.b"
          ]
        ]
      },
      {
        "1": [
          [
            "test.t.a"
          ]
        ],
        "2": [
          [
            "test.t.c",
            "test.t.d",
            "test.t.e"
          ]
        ],
        "3": [
          [
            "test.t.c",
            "test.t.d",
            "test.t.e"
          ]
        ]
      },
      {
        "1": [
          [
            "test.t.f"
          ],
          [
            "test.t.f",
            "test.t.g"
          ],
          [
            "test.t.a"
          ]
        ],
        "2": [
          [
            "test.t.f"
          ],
          [
            "test.t.f",
            "test.t.g"
          ]
        ],
        "3": [
          [
            "test.t.f"
          ],
          [
            "test.t.f",
            "test.t.g"
          ]
        ]
      },
      {
        "1": [
          [
            "test.t.f"
          ],
          [
            "test.t.f",
            "test.t.g"
          ],
          [
            "test.t.a"
          ]
        ],
        "2": [
          [
            "test.t.f"
          ],
          [
            "test.t.f",
            "test.t.g"
          ],
          [
            "test.t.a"
          ]
        ],
        "3": [
          [
            "test.t.f"
          ],
          [
            "test.t.f",
            "test.t.g"
          ],
          [
            "test.t.a"
          ]
        ],
        "4": [
          [
            "test.t.f"
          ],
          [
            "test.t.f",
            "test.t.g"
          ],
          [
            "test.t.a"
          ]
        ]
      },
      {
        "1": [
          [
            "test.t.f"
          ],
          [
            "test.t.a"
          ]
        ],
        "2": [
          [
            "test.t.f"
          ]
        ],
        "3": [
          [
            "test.t.f"
          ]
        ],
        "5": [
          [
            "test.t.f"
          ]
        ],
        "6": [
          [
            "test.t.f"
          ]
        ]
      },
      {
        "1": [
          [
            "test.t.f"
          ],
          [
            "test.t.f",
            "test.t.g"
          ],
          [
            "test.t.a"
          ]
        ],
        "2": [
          [
            "test.t.f"
          ],
          [
            "test.t.f",
            "test.t.g"
          ],
          [
            "test.t.a"
          ]
        ],
        "3": [
          [
            "test.t.f"
          ],
          [
            "test.t.f",
            "test.t.g"
          ],
          [
            "test.t.a"
          ]
        ],
        "4": [
          [
            "test.t.f"
          ],
          [
            "test.t.f",
            "test.t.g"
          ],
          [
            "test.t.a"
          ]
        ]
      }
    ]
  },
  {
    "Name": "TestAggPrune",
    "Cases": [
      "DataScan(t)->Projection",
      "DataScan(t)->Aggr(sum(test.t.b))->Projection",
      "DataScan(t)->Projection",
      "DataScan(t)->Projection",
      "DataScan(t)->Projection",
      "DataScan(t)->Projection",
      "DataScan(t)->Aggr(approx_count_distinct(test.t.a, test.t.b),firstrow(test.t.a))->Projection"
    ]
  },
  {
    "Name": "TestColumnPruning",
    "Cases": [
      {
        "1": [
          "test.t.a"
        ]
      },
      {
        "1": [
          "test.t.a"
        ]
      },
      {
        "1": [
          "test.t.a"
        ],
        "2": [
          "test.t.a"
        ]
      },
      {
        "1": [
          "test.t.a"
        ],
        "2": [
          "test.t.d"
        ]
      },
      {
        "1": [
          "test.t.a",
          "test.t.d"
        ],
        "2": [
          "test.t.d"
        ]
      },
      {
        "1": [
          "test.t.a",
          "test.t.d"
        ],
        "2": [
          "test.t.a",
          "test.t.b",
          "test.t.d"
        ]
      },
      {
        "1": [
          "test.t.a",
          "test.t.d"
        ],
        "2": [
          "test.t.a",
          "test.t.b",
          "test.t.d"
        ]
      },
      {
        "1": [
          "test.t.a"
        ],
        "3": [
          "test.t.a",
          "test.t.b"
        ]
      },
      {
        "1": [
          "test.t.a"
        ]
      },
      {
        "1": [
          "test.t.a",
          "test.t.b"
        ],
        "3": [
          "test.t.b"
        ]
      },
      {
        "1": [
          "test.t.a"
        ],
        "3": [
          "test.t.b"
        ]
      },
      {
        "1": [
          "test.t.a",
          "test.t.b",
          "test.t.c"
        ]
      },
      {
        "1": [
          "test.t.a",
          "test.t.b"
        ],
        "3": [
          "test.t.c"
        ]
      },
      {
        "1": [
          "test.t.a",
          "test.t.b"
        ],
        "3": [
          "test.t.c",
          "test.t.d"
        ]
      },
      {
        "1": [
          "test.t.a",
          "test.t.b"
        ],
        "3": [
          "test.t.c",
          "test.t.d"
        ]
      },
      {
        "1": [
          "test.t.a"
        ],
        "3": [
          "test.t.a"
        ]
      },
      {
        "1": [
          "test.t.a"
        ],
        "10": [
          "test.t.a"
        ],
        "12": [
          "test.t.a"
        ],
        "3": [
          "test.t.a"
        ],
        "5": [
          "Column#25"
        ],
        "8": [
          "test.t.a"
        ]
      },
      {
        "1": [
          "test.t.a"
        ]
      },
      {
        "1": [
          "test.t.a"
        ]
      },
      {
        "1": [
          "test.t.c"
        ]
      }
    ]
  },
  {
    "Name": "TestSortByItemsPruning",
    "Cases": [
      [
        "test.t.a"
      ],
      [
        "test.t.a",
        "test.t.b",
        "test.t.c"
      ],
      [
        "pow(cast(test.t.a, double BINARY), 2)",
        "test.t.b",
        "test.t.c"
      ]
    ]
  },
  {
    "Name": "TestDeriveNotNullConds",
    "Cases": [
      {
        "Plan": "Join{DataScan(t1)->DataScan(t2)}(test.t.e,test.t.e)->Projection",
        "Left": "[not(isnull(test.t.e))]",
        "Right": "[not(isnull(test.t.e))]"
      },
      {
        "Plan": "Join{DataScan(t1)->DataScan(t2)}->Projection",
        "Left": "[not(isnull(test.t.e))]",
        "Right": "[not(isnull(test.t.e))]"
      },
      {
        "Plan": "Join{DataScan(t1)->DataScan(t2)}(test.t.e,test.t.e)->Projection",
        "Left": "[not(isnull(test.t.e))]",
        "Right": "[not(isnull(test.t.e))]"
      },
      {
        "Plan": "Join{DataScan(t1)->DataScan(t2)}(test.t.e,test.t.e)->Projection",
        "Left": "[]",
        "Right": "[not(isnull(test.t.e))]"
      },
      {
        "Plan": "Join{DataScan(t1)->DataScan(t2)}->Projection",
        "Left": "[]",
        "Right": "[not(isnull(test.t.e))]"
      },
      {
        "Plan": "Join{DataScan(t1)->DataScan(t2)}(test.t.e,test.t.e)->Projection",
        "Left": "[]",
        "Right": "[not(isnull(test.t.e))]"
      },
      {
        "Plan": "Join{DataScan(t1)->DataScan(t2)}(test.t.e,test.t.e)->Projection",
        "Left": "[not(isnull(test.t.e))]",
        "Right": "[]"
      },
      {
        "Plan": "Join{DataScan(t1)->DataScan(t2)}->Projection",
        "Left": "[]",
        "Right": "[]"
      },
      {
        "Plan": "Join{DataScan(t1)->DataScan(t2)}->Projection",
        "Left": "[]",
        "Right": "[]"
      },
      {
        "Plan": "Join{DataScan(t1)->DataScan(t2)}(test.t.b,test.t.b)->Projection",
        "Left": "[]",
        "Right": "[]"
      },
      {
        "Plan": "Join{DataScan(t1)->DataScan(t2)}(test.t.b,test.t.b)->Projection",
        "Left": "[]",
        "Right": "[]"
      },
      {
        "Plan": "Join{DataScan(t1)->DataScan(t2)}->Projection",
        "Left": "[]",
        "Right": "[]"
      },
      {
        "Plan": "Join{DataScan(t1)->DataScan(t2)}(test.t.e,test.t.e)->Projection",
        "Left": "[]",
        "Right": "[]"
      }
    ]
  },
  {
    "Name": "TestTablePartition",
    "Cases": [
      "PartitionUnionAll{Partition(41)->Partition(42)->Partition(43)->Partition(44)->Partition(45)}->Projection",
      "PartitionUnionAll{Partition(41)->Partition(42)}->Projection",
      "PartitionUnionAll{Partition(41)->Partition(42)->Partition(43)}->Projection",
      "PartitionUnionAll{Partition(42)->Partition(43)}->Projection",
      "UnionAll{PartitionUnionAll{Partition(42)->Partition(43)}->Projection->Projection->PartitionUnionAll{Partition(42)->Partition(43)}->Projection->Projection}",
      "UnionAll{PartitionUnionAll{Partition(42)->Partition(43)}->Projection->Projection->PartitionUnionAll{Partition(42)->Partition(43)}->Projection->Projection}",
      "Partition(41)->Projection",
      "Partition(45)->Projection",
      "Dual->Projection",
      "Partition(41)->Projection",
      "PartitionUnionAll{Partition(41)->Partition(44)}->Projection"
    ]
  },
  {
    "Name": "TestJoinPredicatePushDown",
    "Cases": [
      {
        "Left": "[]",
        "Right": "[]"
      },
      {
        "Left": "[]",
        "Right": "[]"
      },
      {
        "Left": "[or(eq(test.t.a, 1), eq(test.t.a, 2))]",
        "Right": "[or(eq(test.t.a, 1), eq(test.t.a, 2))]"
      },
      {
        "Left": "[or(eq(test.t.c, 1), eq(test.t.a, 2))]",
        "Right": "[]"
      },
      {
        "Left": "[eq(test.t.c, 1) or(eq(test.t.a, 3), eq(test.t.a, 4))]",
        "Right": "[or(eq(test.t.a, 3), eq(test.t.a, 4))]"
      },
      {
        "Left": "[or(and(gt(test.t.a, 1), lt(test.t.a, 3)), eq(test.t.a, 2))]",
        "Right": "[or(eq(test.t.a, 1), eq(test.t.a, 2))]"
      },
      {
        "Left": "[or(eq(test.t.a, 1), eq(test.t.a, 2))]",
        "Right": "[or(eq(test.t.a, 1), eq(test.t.a, 2))]"
      },
      {
        "Left": "[]",
        "Right": "[or(eq(test.t.a, 1), eq(test.t.a, 2))]"
      },
      {
        "Left": "[]",
        "Right": "[]"
      },
      {
        "Left": "[]",
        "Right": "[]"
      },
      {
        "Left": "[]",
        "Right": "[]"
      },
      {
        "Left": "[]",
        "Right": "[or(eq(test.t.c, 1), eq(test.t.a, 2))]"
      },
      {
        "Left": "[]",
        "Right": "[or(or(eq(test.t.a, 3), eq(test.t.a, 4)), eq(test.t.a, 2))]"
      },
      {
        "Left": "[gt(test.t.a, 1)]",
        "Right": "[]"
      }
    ]
  },
  {
    "Name": "TestJoinReOrder",
    "Cases": [
      "Join{Join{Join{Join{DataScan(t1)->DataScan(t2)}(test.t.a,test.t.b)->DataScan(t3)}(test.t.a,test.t.b)->DataScan(t4)}(test.t.c,test.t.a)(test.t.c,test.t.d)->Join{DataScan(t5)->DataScan(t6)}(test.t.d,test.t.d)}->Projection",
      "Join{Join{Join{Join{DataScan(t1)->DataScan(t8)}(test.t.a,test.t.a)->DataScan(t2)}->Join{DataScan(t3)->DataScan(t4)}}->Join{Join{DataScan(t5)->DataScan(t6)}->DataScan(t7)}}->Projection",
      "Join{Join{Join{Join{DataScan(t5)->DataScan(t1)}(test.t.a,test.t.a)->DataScan(t2)}(test.t.a,test.t.a)->DataScan(t3)}(test.t.a,test.t.a)(test.t.a,test.t.a)->DataScan(t4)}(test.t.a,test.t.a)(test.t.a,test.t.a)(test.t.a,test.t.a)->Projection",
      "Join{Join{Join{DataScan(t3)->DataScan(t1)}->Join{DataScan(t2)->DataScan(t4)}}->DataScan(t5)}->Projection",
      "Apply{DataScan(o)->Join{Join{DataScan(t1)->DataScan(t3)}(test.t.a,test.t.a)->DataScan(t2)}(test.t.a,test.t.a)->Projection}->Projection",
      "Apply{DataScan(o)->Join{Join{DataScan(t1)->DataScan(t2)}->DataScan(t3)}->Projection}->Projection"
    ]
  },
  {
    "Name": "TestOuterJoinEliminator",
    "Cases": [
      "DataScan(t1)->Projection",
      "DataScan(t2)->Projection",
      "DataScan(t1)->Aggr(max(test.t.a),min(test.t.b))->Projection",
      "DataScan(t1)->Aggr(sum(distinct test.t.a))->Projection",
      "DataScan(t1)->Aggr(count(distinct test.t.a, test.t.b))->Projection",
      "DataScan(t1)->Aggr(approx_count_distinct(test.t.a, test.t.b))->Projection",
      "DataScan(t1)->Projection",
      "DataScan(t2)->Projection",
      "Join{Join{DataScan(t1)->DataScan(t2)}(test.t.a,test.t.a)->DataScan(t3)->TopN([test.t.b true],0,1)}(test.t.b,test.t.b)->TopN([test.t.b true],0,1)->Aggr(max(test.t.b))->Projection",
      "DataScan(t1)->Projection",
      "Join{DataScan(t1)->DataScan(t2)}(test.t.a,test.t.a)->Sort->Projection",
      "DataScan(a)->Projection"
    ]
  },
  {
    "Name": "TestSimplifyOuterJoin",
    "Cases": [
      {
        "Best": "Join{DataScan(t1)->DataScan(t2)}(test.t.b,test.t.b)->Sel([or(gt(test.t.c, 1), gt(test.t.c, 1))])->Projection",
        "JoinType": "left outer join"
      },
      {
        "Best": "Join{DataScan(t1)->DataScan(t2)}(test.t.b,test.t.b)->Projection",
        "JoinType": "inner join"
      },
      {
        "Best": "Join{DataScan(t1)->DataScan(t2)}(test.t.b,test.t.b)->Projection",
        "JoinType": "inner join"
      },
      {
        "Best": "Join{DataScan(t1)->DataScan(t2)}(test.t.b,test.t.b)->Sel([not(and(gt(test.t.c, 1), gt(test.t.c, 1)))])->Projection",
        "JoinType": "left outer join"
      },
      {
        "Best": "Join{DataScan(t1)->DataScan(t2)}(test.t.c,test.t.c)->Projection",
        "JoinType": "inner join"
      },
      {
        "Best": "Join{DataScan(t1)->DataScan(t2)}->Sel([nulleq(test.t.b, test.t.b)])->Projection",
        "JoinType": "left outer join"
      }
    ]
  },
  {
    "Name": "TestOuterWherePredicatePushDown",
    "Cases": [
      {
        "Sel": "[or(and(eq(test.t.a, 1), isnull(test.t.a)), and(eq(test.t.a, 2), eq(test.t.a, 2)))]",
        "Left": "[or(eq(test.t.a, 1), eq(test.t.a, 2))]",
        "Right": "[]"
      },
      {
        "Sel": "[or(and(eq(test.t.c, 1), or(eq(test.t.a, 3), eq(test.t.a, 3))), and(eq(test.t.a, 2), eq(test.t.a, 2)))]",
        "Left": "[or(eq(test.t.c, 1), eq(test.t.a, 2))]",
        "Right": "[]"
      },
      {
        "Sel": "[or(and(eq(test.t.c, 1), or(and(eq(test.t.a, 3), eq(test.t.a, 3)), and(eq(test.t.a, 4), eq(test.t.a, 4)))), and(eq(test.t.a, 2), isnull(test.t.a)))]",
        "Left": "[or(and(eq(test.t.c, 1), or(eq(test.t.a, 3), eq(test.t.a, 4))), eq(test.t.a, 2))]",
        "Right": "[]"
      }
    ]
  }
]
