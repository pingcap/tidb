[
  {
    "name": "TestIndexMergeHint4CNF",
    "cases": [
      "explain format = 'brief' select * from t where b = 1 and (a = 1 or c = 1)",
      "explain format = 'brief' select /*+ USE_INDEX_MERGE(t, a, c) */ * from t where b = 1 and (a = 1 or c = 1)"
    ]
  },
  {
    "name": "TestHintWithRequiredProperty",
    "cases": [
      "desc format = 'brief' select /*+ INL_JOIN(t2) */ * from t t1, t t2 where t1.a = t2.b order by t2.a",
      "desc format = 'brief' select /*+ INL_HASH_JOIN(t2) */ * from t t1, t t2 where t1.a = t2.b order by t2.a",
      "desc format = 'brief' select /*+ INL_MERGE_JOIN(t2)*/ t1.a, t2.a from t t1, t t2 ,t t3 where t1.a = t2.a and t3.a=t2.a",
      "desc format = 'brief' select * from t t1, (select /*+ HASH_AGG() */ b, max(a) from t t2 group by b) t2 where t1.b = t2.b order by t1.b",
      "desc format = 'brief' select /*+ INL_HASH_JOIN(t2) */ distinct t2.a from t t1 join t t2 on t1.a = t2.a",
      // This hint cannot work, so choose another plan.
      "desc format = 'brief' select /*+ INL_JOIN(t2) */ * from t t1, t t2 where t1.a = t2.c order by t1.a"
    ]
  },
  {
    "name": "TestIndexHintWarning",
    "cases": [
      "select /*+ USE_INDEX(t1, j) */ * from t1",
      "select /*+ IGNORE_INDEX(t1, j) */ * from t1",
      "select /*+ USE_INDEX(t2, a, b, c) */ * from t1",
      "select /*+ USE_INDEX(t2) */ * from t1",
      "select /*+ USE_INDEX(t1, a), USE_INDEX(t2, a), USE_INDEX(t3, a) */ * from t1, t2 where t1.a=t2.a",
      "select /*+ USE_INDEX(t3, a), USE_INDEX(t4, b), IGNORE_INDEX(t3, a) */ * from t1, t2 where t1.a=t2.a",
      "select /*+ USE_INDEX_MERGE(t3, a, b, d) */ * from t1",
      "select /*+ USE_INDEX_MERGE(t1, a, b, c, d) */ * from t1",
      "select /*+ USE_INDEX_MERGE(t1, a, b), USE_INDEX(t1, a) */ * from t1",
      "select /*+ USE_INDEX_MERGE(t1, a, b), IGNORE_INDEX(t1, a) */ * from t1",
      "select /*+ USE_INDEX_MERGE(t1, primary, a, b, c) */ * from t1"
    ]
  },
  {
    "name": "TestHintWithoutTableWarning",
    "cases": [
      "select /*+ TIDB_SMJ() */ * from t1, t2 where t1.a=t2.a",
      "select /*+ MERGE_JOIN() */ * from t1, t2 where t1.a=t2.a",
      "select /*+ INL_JOIN() */ * from t1, t2 where t1.a=t2.a",
      "select /*+ TIDB_INLJ() */ * from t1, t2 where t1.a=t2.a",
      "select /*+ INL_HASH_JOIN() */ * from t1, t2 where t1.a=t2.a",
      "select /*+ INL_MERGE_JOIN() */ * from t1, t2 where t1.a=t2.a",
      "select /*+ HASH_JOIN() */ * from t1, t2 where t1.a=t2.a",
      "select /*+ USE_INDEX() */ * from t1, t2 where t1.a=t2.a",
      "select /*+ IGNORE_INDEX() */ * from t1, t2 where t1.a=t2.a",
      "select /*+ USE_INDEX_MERGE() */ * from t1, t2 where t1.a=t2.a"
    ]
  },
  {
    "name": "TestOptimizeHintOnPartitionTable",
    "cases": [
      "select /*+ use_index(t) */ * from t",
      "select /*+ use_index(t partition(p0, p1) b, c) */ * from t partition(p1,p2)",
      "select /*+ use_index(t partition(p_non_exist)) */ * from t partition(p1,p2)",
      "select /*+ use_index(t partition(p0, p1) b, c) */ * from t",
      "select /*+ ignore_index(t partition(p0, p1) b, c) */ * from t",
      "select /*+ hash_join(t1, t2 partition(p0)) */ * from t t1 join t t2 on t1.a = t2.a",
      "select /*+ use_index_merge(t partition(p0)) */ * from t where t.b = 1 or t.c = \"8\"",
      "select /*+ use_index_merge(t partition(p0, p1) primary, b) */ * from t where t.a = 1 or t.b = 2",
      "select /*+ use_index(t partition(p0) b) */ * from t partition(p0, p1)"
    ]
  },
  {
    "name": "TestInvalidHint",
    "cases": [
      "explain format = 'brief' select /*+ use_index_merge(tt) */ * from tt where a=10 or a=20;",
      "explain format = 'brief' select /*+ use_index_merge(tt) */ * from tt where a=15 or (a < 10 or a > 20);"
    ]
  },
  {
	  "name": "TestIssue30200",
	  "cases": [
		// to_base64 and from_base64 has not been pushed to TiKV or TiFlash.
		// We expect a Selection will be added above IndexMerge.
		"select /*+ use_index_merge(t1) */ 1 from t1 where c1 = 'de' or c2 = '10' and from_base64(to_base64(c1)) = 'ab';",

		// `left` has not been pushed to TiKV, but it has been pushed to TiFlash.
		// We expect a Selection will be added above IndexMerge.
		"select /*+ use_index_merge(t1) */ 1 from t1 where c1 = 'ab' or c2 = '10' and char_length(left(c1, 10)) = 10;",

		// c3 is part of idx_1, so it will be put in partial_path's IndexFilters instead of TableFilters.
		// But it still cannot be pushed to TiKV. This case cover code in DataSource.buildIndexMergeOrPath.
		"select /*+ use_index_merge(tt1) */ 1 from tt1 where c1 = 'de' or c2 = '10' and from_base64(to_base64(c3)) = '10';",

		// to_base64(left(pk, 5)) is in partial_path's TableFilters. But it cannot be pushed to TiKV.
		// So it should be executed in TiDB. This case cover code in DataSource.buildIndexMergeOrPath.
		"select /*+ use_index_merge( tt2 ) */ 1 from tt2 where tt2.c1 in (-3896405) or tt2.pk in (1, 53330) and to_base64(left(pk, 5));",

		// This case covert expression index.
		"select /*+ use_index_merge(tt3) */ 1 from tt3 where c1 < -10 or c2 < 10 and reverse(c3) = '2';",

		// If no hint, we cannot use index merge if filter cannot be pushed to any storage.
		"select 1 from t1 where c1 = 'de' or c2 = '10' and from_base64(to_base64(c1)) = 'ab';"
	  ]
  }
]
