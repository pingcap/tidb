// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/pingcap/tipb/go-mysqlx/Datatypes/mysqlx_datatypes.proto

/*
	Package Mysqlx_Datatypes is a generated protocol buffer package.

	It is generated from these files:
		github.com/pingcap/tipb/go-mysqlx/Datatypes/mysqlx_datatypes.proto

	It has these top-level messages:
		Scalar
		Object
		Array
		Any
*/
package Mysqlx_Datatypes

import (
	"fmt"

	proto "github.com/golang/protobuf/proto"

	math "math"

	github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"

	encoding_binary "encoding/binary"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Scalar_Type int32

const (
	Scalar_V_SINT   Scalar_Type = 1
	Scalar_V_UINT   Scalar_Type = 2
	Scalar_V_NULL   Scalar_Type = 3
	Scalar_V_OCTETS Scalar_Type = 4
	Scalar_V_DOUBLE Scalar_Type = 5
	Scalar_V_FLOAT  Scalar_Type = 6
	Scalar_V_BOOL   Scalar_Type = 7
	Scalar_V_STRING Scalar_Type = 8
)

var Scalar_Type_name = map[int32]string{
	1: "V_SINT",
	2: "V_UINT",
	3: "V_NULL",
	4: "V_OCTETS",
	5: "V_DOUBLE",
	6: "V_FLOAT",
	7: "V_BOOL",
	8: "V_STRING",
}
var Scalar_Type_value = map[string]int32{
	"V_SINT":   1,
	"V_UINT":   2,
	"V_NULL":   3,
	"V_OCTETS": 4,
	"V_DOUBLE": 5,
	"V_FLOAT":  6,
	"V_BOOL":   7,
	"V_STRING": 8,
}

func (x Scalar_Type) Enum() *Scalar_Type {
	p := new(Scalar_Type)
	*p = x
	return p
}
func (x Scalar_Type) String() string {
	return proto.EnumName(Scalar_Type_name, int32(x))
}
func (x *Scalar_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Scalar_Type_value, data, "Scalar_Type")
	if err != nil {
		return err
	}
	*x = Scalar_Type(value)
	return nil
}
func (Scalar_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorMysqlxDatatypes, []int{0, 0} }

type Any_Type int32

const (
	Any_SCALAR Any_Type = 1
	Any_OBJECT Any_Type = 2
	Any_ARRAY  Any_Type = 3
)

var Any_Type_name = map[int32]string{
	1: "SCALAR",
	2: "OBJECT",
	3: "ARRAY",
}
var Any_Type_value = map[string]int32{
	"SCALAR": 1,
	"OBJECT": 2,
	"ARRAY":  3,
}

func (x Any_Type) Enum() *Any_Type {
	p := new(Any_Type)
	*p = x
	return p
}
func (x Any_Type) String() string {
	return proto.EnumName(Any_Type_name, int32(x))
}
func (x *Any_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Any_Type_value, data, "Any_Type")
	if err != nil {
		return err
	}
	*x = Any_Type(value)
	return nil
}
func (Any_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorMysqlxDatatypes, []int{3, 0} }

// a scalar
type Scalar struct {
	Type         *Scalar_Type `protobuf:"varint,1,req,name=type,enum=Mysqlx.Datatypes.Scalar_Type" json:"type,omitempty"`
	VSignedInt   *int64       `protobuf:"zigzag64,2,opt,name=v_signed_int,json=vSignedInt" json:"v_signed_int,omitempty"`
	VUnsignedInt *uint64      `protobuf:"varint,3,opt,name=v_unsigned_int,json=vUnsignedInt" json:"v_unsigned_int,omitempty"`
	// 4 is unused, was Null which doesn't have a storage anymore
	VOctets          *Scalar_Octets `protobuf:"bytes,5,opt,name=v_octets,json=vOctets" json:"v_octets,omitempty"`
	VDouble          *float64       `protobuf:"fixed64,6,opt,name=v_double,json=vDouble" json:"v_double,omitempty"`
	VFloat           *float32       `protobuf:"fixed32,7,opt,name=v_float,json=vFloat" json:"v_float,omitempty"`
	VBool            *bool          `protobuf:"varint,8,opt,name=v_bool,json=vBool" json:"v_bool,omitempty"`
	VString          *Scalar_String `protobuf:"bytes,9,opt,name=v_string,json=vString" json:"v_string,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Scalar) Reset()                    { *m = Scalar{} }
func (m *Scalar) String() string            { return proto.CompactTextString(m) }
func (*Scalar) ProtoMessage()               {}
func (*Scalar) Descriptor() ([]byte, []int) { return fileDescriptorMysqlxDatatypes, []int{0} }

func (m *Scalar) GetType() Scalar_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Scalar_V_SINT
}

func (m *Scalar) GetVSignedInt() int64 {
	if m != nil && m.VSignedInt != nil {
		return *m.VSignedInt
	}
	return 0
}

func (m *Scalar) GetVUnsignedInt() uint64 {
	if m != nil && m.VUnsignedInt != nil {
		return *m.VUnsignedInt
	}
	return 0
}

func (m *Scalar) GetVOctets() *Scalar_Octets {
	if m != nil {
		return m.VOctets
	}
	return nil
}

func (m *Scalar) GetVDouble() float64 {
	if m != nil && m.VDouble != nil {
		return *m.VDouble
	}
	return 0
}

func (m *Scalar) GetVFloat() float32 {
	if m != nil && m.VFloat != nil {
		return *m.VFloat
	}
	return 0
}

func (m *Scalar) GetVBool() bool {
	if m != nil && m.VBool != nil {
		return *m.VBool
	}
	return false
}

func (m *Scalar) GetVString() *Scalar_String {
	if m != nil {
		return m.VString
	}
	return nil
}

// a string with a charset/collation
type Scalar_String struct {
	Value            []byte  `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	Collation        *uint64 `protobuf:"varint,2,opt,name=collation" json:"collation,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Scalar_String) Reset()                    { *m = Scalar_String{} }
func (m *Scalar_String) String() string            { return proto.CompactTextString(m) }
func (*Scalar_String) ProtoMessage()               {}
func (*Scalar_String) Descriptor() ([]byte, []int) { return fileDescriptorMysqlxDatatypes, []int{0, 0} }

func (m *Scalar_String) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Scalar_String) GetCollation() uint64 {
	if m != nil && m.Collation != nil {
		return *m.Collation
	}
	return 0
}

// an opaque octet sequence, with an optional content_type
// See ``Mysqlx.Resultset.ColumnMetadata`` for list of known values.
type Scalar_Octets struct {
	Value            []byte  `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	ContentType      *uint32 `protobuf:"varint,2,opt,name=content_type,json=contentType" json:"content_type,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Scalar_Octets) Reset()                    { *m = Scalar_Octets{} }
func (m *Scalar_Octets) String() string            { return proto.CompactTextString(m) }
func (*Scalar_Octets) ProtoMessage()               {}
func (*Scalar_Octets) Descriptor() ([]byte, []int) { return fileDescriptorMysqlxDatatypes, []int{0, 1} }

func (m *Scalar_Octets) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Scalar_Octets) GetContentType() uint32 {
	if m != nil && m.ContentType != nil {
		return *m.ContentType
	}
	return 0
}

// a object
type Object struct {
	Fld              []*Object_ObjectField `protobuf:"bytes,1,rep,name=fld" json:"fld,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *Object) Reset()                    { *m = Object{} }
func (m *Object) String() string            { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()               {}
func (*Object) Descriptor() ([]byte, []int) { return fileDescriptorMysqlxDatatypes, []int{1} }

func (m *Object) GetFld() []*Object_ObjectField {
	if m != nil {
		return m.Fld
	}
	return nil
}

type Object_ObjectField struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *Any    `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Object_ObjectField) Reset()         { *m = Object_ObjectField{} }
func (m *Object_ObjectField) String() string { return proto.CompactTextString(m) }
func (*Object_ObjectField) ProtoMessage()    {}
func (*Object_ObjectField) Descriptor() ([]byte, []int) {
	return fileDescriptorMysqlxDatatypes, []int{1, 0}
}

func (m *Object_ObjectField) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Object_ObjectField) GetValue() *Any {
	if m != nil {
		return m.Value
	}
	return nil
}

// a Array
type Array struct {
	Value            []*Any `protobuf:"bytes,1,rep,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Array) Reset()                    { *m = Array{} }
func (m *Array) String() string            { return proto.CompactTextString(m) }
func (*Array) ProtoMessage()               {}
func (*Array) Descriptor() ([]byte, []int) { return fileDescriptorMysqlxDatatypes, []int{2} }

func (m *Array) GetValue() []*Any {
	if m != nil {
		return m.Value
	}
	return nil
}

// a helper to allow all field types
type Any struct {
	Type             *Any_Type `protobuf:"varint,1,req,name=type,enum=Mysqlx.Datatypes.Any_Type" json:"type,omitempty"`
	Scalar           *Scalar   `protobuf:"bytes,2,opt,name=scalar" json:"scalar,omitempty"`
	Obj              *Object   `protobuf:"bytes,3,opt,name=obj" json:"obj,omitempty"`
	Array            *Array    `protobuf:"bytes,4,opt,name=array" json:"array,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Any) Reset()                    { *m = Any{} }
func (m *Any) String() string            { return proto.CompactTextString(m) }
func (*Any) ProtoMessage()               {}
func (*Any) Descriptor() ([]byte, []int) { return fileDescriptorMysqlxDatatypes, []int{3} }

func (m *Any) GetType() Any_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Any_SCALAR
}

func (m *Any) GetScalar() *Scalar {
	if m != nil {
		return m.Scalar
	}
	return nil
}

func (m *Any) GetObj() *Object {
	if m != nil {
		return m.Obj
	}
	return nil
}

func (m *Any) GetArray() *Array {
	if m != nil {
		return m.Array
	}
	return nil
}

func init() {
	proto.RegisterType((*Scalar)(nil), "Mysqlx.Datatypes.Scalar")
	proto.RegisterType((*Scalar_String)(nil), "Mysqlx.Datatypes.Scalar.String")
	proto.RegisterType((*Scalar_Octets)(nil), "Mysqlx.Datatypes.Scalar.Octets")
	proto.RegisterType((*Object)(nil), "Mysqlx.Datatypes.Object")
	proto.RegisterType((*Object_ObjectField)(nil), "Mysqlx.Datatypes.Object.ObjectField")
	proto.RegisterType((*Array)(nil), "Mysqlx.Datatypes.Array")
	proto.RegisterType((*Any)(nil), "Mysqlx.Datatypes.Any")
	proto.RegisterEnum("Mysqlx.Datatypes.Scalar_Type", Scalar_Type_name, Scalar_Type_value)
	proto.RegisterEnum("Mysqlx.Datatypes.Any_Type", Any_Type_name, Any_Type_value)
}
func (m *Scalar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Scalar) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMysqlxDatatypes(dAtA, i, uint64(*m.Type))
	}
	if m.VSignedInt != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMysqlxDatatypes(dAtA, i, uint64((uint64(*m.VSignedInt)<<1)^uint64((*m.VSignedInt>>63))))
	}
	if m.VUnsignedInt != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMysqlxDatatypes(dAtA, i, uint64(*m.VUnsignedInt))
	}
	if m.VOctets != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMysqlxDatatypes(dAtA, i, uint64(m.VOctets.Size()))
		n1, err := m.VOctets.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.VDouble != nil {
		dAtA[i] = 0x31
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.VDouble))))
		i += 8
	}
	if m.VFloat != nil {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.VFloat))))
		i += 4
	}
	if m.VBool != nil {
		dAtA[i] = 0x40
		i++
		if *m.VBool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.VString != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMysqlxDatatypes(dAtA, i, uint64(m.VString.Size()))
		n2, err := m.VString.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Scalar_String) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Scalar_String) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMysqlxDatatypes(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Collation != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMysqlxDatatypes(dAtA, i, uint64(*m.Collation))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Scalar_Octets) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Scalar_Octets) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMysqlxDatatypes(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.ContentType != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMysqlxDatatypes(dAtA, i, uint64(*m.ContentType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Object) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fld) > 0 {
		for _, msg := range m.Fld {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMysqlxDatatypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Object_ObjectField) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object_ObjectField) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMysqlxDatatypes(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if m.Value == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMysqlxDatatypes(dAtA, i, uint64(m.Value.Size()))
		n3, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Array) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Array) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, msg := range m.Value {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMysqlxDatatypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Any) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Any) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMysqlxDatatypes(dAtA, i, uint64(*m.Type))
	}
	if m.Scalar != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMysqlxDatatypes(dAtA, i, uint64(m.Scalar.Size()))
		n4, err := m.Scalar.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Obj != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMysqlxDatatypes(dAtA, i, uint64(m.Obj.Size()))
		n5, err := m.Obj.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Array != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMysqlxDatatypes(dAtA, i, uint64(m.Array.Size()))
		n6, err := m.Array.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintMysqlxDatatypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Scalar) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMysqlxDatatypes(uint64(*m.Type))
	}
	if m.VSignedInt != nil {
		n += 1 + sozMysqlxDatatypes(uint64(*m.VSignedInt))
	}
	if m.VUnsignedInt != nil {
		n += 1 + sovMysqlxDatatypes(uint64(*m.VUnsignedInt))
	}
	if m.VOctets != nil {
		l = m.VOctets.Size()
		n += 1 + l + sovMysqlxDatatypes(uint64(l))
	}
	if m.VDouble != nil {
		n += 9
	}
	if m.VFloat != nil {
		n += 5
	}
	if m.VBool != nil {
		n += 2
	}
	if m.VString != nil {
		l = m.VString.Size()
		n += 1 + l + sovMysqlxDatatypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Scalar_String) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovMysqlxDatatypes(uint64(l))
	}
	if m.Collation != nil {
		n += 1 + sovMysqlxDatatypes(uint64(*m.Collation))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Scalar_Octets) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovMysqlxDatatypes(uint64(l))
	}
	if m.ContentType != nil {
		n += 1 + sovMysqlxDatatypes(uint64(*m.ContentType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Object) Size() (n int) {
	var l int
	_ = l
	if len(m.Fld) > 0 {
		for _, e := range m.Fld {
			l = e.Size()
			n += 1 + l + sovMysqlxDatatypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Object_ObjectField) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovMysqlxDatatypes(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovMysqlxDatatypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Array) Size() (n int) {
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, e := range m.Value {
			l = e.Size()
			n += 1 + l + sovMysqlxDatatypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Any) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMysqlxDatatypes(uint64(*m.Type))
	}
	if m.Scalar != nil {
		l = m.Scalar.Size()
		n += 1 + l + sovMysqlxDatatypes(uint64(l))
	}
	if m.Obj != nil {
		l = m.Obj.Size()
		n += 1 + l + sovMysqlxDatatypes(uint64(l))
	}
	if m.Array != nil {
		l = m.Array.Size()
		n += 1 + l + sovMysqlxDatatypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMysqlxDatatypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMysqlxDatatypes(x uint64) (n int) {
	return sovMysqlxDatatypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Scalar) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMysqlxDatatypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Scalar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Scalar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v Scalar_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Scalar_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VSignedInt", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.VSignedInt = &v2
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VUnsignedInt", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VUnsignedInt = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VOctets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VOctets == nil {
				m.VOctets = &Scalar_Octets{}
			}
			if err := m.VOctets.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field VDouble", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.VDouble = &v2
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field VFloat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.VFloat = &v2
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VBool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.VBool = &b
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VString == nil {
				m.VString = &Scalar_String{}
			}
			if err := m.VString.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMysqlxDatatypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Scalar_String) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMysqlxDatatypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: String: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: String: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collation", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Collation = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMysqlxDatatypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Scalar_Octets) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMysqlxDatatypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Octets: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Octets: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContentType = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMysqlxDatatypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMysqlxDatatypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fld", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fld = append(m.Fld, &Object_ObjectField{})
			if err := m.Fld[len(m.Fld)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMysqlxDatatypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Object_ObjectField) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMysqlxDatatypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectField: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectField: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Any{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipMysqlxDatatypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Array) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMysqlxDatatypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Array: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Array: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, &Any{})
			if err := m.Value[len(m.Value)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMysqlxDatatypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Any) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMysqlxDatatypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Any: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Any: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v Any_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Any_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scalar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scalar == nil {
				m.Scalar = &Scalar{}
			}
			if err := m.Scalar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Obj == nil {
				m.Obj = &Object{}
			}
			if err := m.Obj.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Array", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Array == nil {
				m.Array = &Array{}
			}
			if err := m.Array.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMysqlxDatatypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMysqlxDatatypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMysqlxDatatypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMysqlxDatatypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMysqlxDatatypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMysqlxDatatypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMysqlxDatatypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMysqlxDatatypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMysqlxDatatypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMysqlxDatatypes   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/pingcap/tipb/go-mysqlx/Datatypes/mysqlx_datatypes.proto", fileDescriptorMysqlxDatatypes)
}

var fileDescriptorMysqlxDatatypes = []byte{
	// 616 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x94, 0xcd, 0x6e, 0xd3, 0x4a,
	0x14, 0xc7, 0xef, 0xc4, 0x5f, 0xc9, 0x71, 0x6e, 0x65, 0x8d, 0x6e, 0x55, 0xdf, 0xa8, 0x04, 0x13,
	0x55, 0xc2, 0x80, 0x70, 0x21, 0x42, 0x2c, 0x10, 0x1b, 0xa7, 0x1f, 0xa8, 0xc8, 0xd4, 0xd2, 0x38,
	0xa9, 0xc4, 0xca, 0x72, 0x1c, 0xb7, 0x4a, 0x71, 0x3d, 0x25, 0x99, 0x8c, 0x9a, 0x97, 0x60, 0xcd,
	0x93, 0xf0, 0x0c, 0x2c, 0x79, 0x04, 0x54, 0xd6, 0xbc, 0x03, 0x9a, 0x99, 0x94, 0x06, 0x9a, 0xc2,
	0xca, 0xff, 0xf3, 0xcf, 0xef, 0x4c, 0xce, 0x9c, 0x73, 0x34, 0x70, 0xff, 0xcd, 0x7c, 0xfa, 0xbe,
	0xbc, 0xd8, 0xde, 0xcd, 0x58, 0xc6, 0xe6, 0xe7, 0xc5, 0x74, 0xfb, 0x4c, 0x1a, 0xe9, 0xe8, 0xca,
	0x08, 0xce, 0x27, 0x94, 0x51, 0xec, 0x28, 0x30, 0xf8, 0x09, 0x76, 0x3e, 0xe9, 0x60, 0x26, 0x79,
	0x56, 0x66, 0x13, 0xfc, 0x14, 0x74, 0xe1, 0xb9, 0xc8, 0xab, 0xf9, 0x6b, 0xdd, 0x3b, 0xc1, 0xef,
	0x6c, 0xa0, 0xb8, 0xa0, 0x3f, 0x3f, 0x2f, 0x88, 0x44, 0xb1, 0x07, 0x4d, 0x9e, 0x4e, 0xc7, 0x27,
	0x55, 0x31, 0x4a, 0xc7, 0x15, 0x73, 0x6b, 0x1e, 0xf2, 0x31, 0x01, 0x9e, 0x48, 0xeb, 0xa0, 0x62,
	0x78, 0x0b, 0xd6, 0x78, 0x3a, 0xab, 0x96, 0x18, 0xcd, 0x43, 0xbe, 0x4e, 0x9a, 0x7c, 0xb0, 0x30,
	0x05, 0xf5, 0x02, 0xea, 0x3c, 0xa5, 0x39, 0x2b, 0xd8, 0xd4, 0x35, 0x3c, 0xe4, 0xdb, 0xdd, 0xbb,
	0xb7, 0xfe, 0x7d, 0x2c, 0x31, 0x62, 0x71, 0x25, 0xf0, 0xff, 0x22, 0x77, 0x44, 0x67, 0xc3, 0xb2,
	0x70, 0x4d, 0x0f, 0xf9, 0x88, 0x58, 0x7c, 0x57, 0x86, 0x78, 0x03, 0x2c, 0x9e, 0x1e, 0x97, 0x34,
	0x63, 0xae, 0xe5, 0x21, 0xbf, 0x46, 0x4c, 0xbe, 0x2f, 0x22, 0xbc, 0x0e, 0x26, 0x4f, 0x87, 0x94,
	0x96, 0x6e, 0xdd, 0x43, 0x7e, 0x9d, 0x18, 0xbc, 0x47, 0x69, 0xa9, 0xca, 0x98, 0xb2, 0xc9, 0xb8,
	0x3a, 0x71, 0x1b, 0x7f, 0x29, 0x23, 0x91, 0x18, 0xb1, 0xb8, 0x12, 0xad, 0x97, 0x60, 0x2a, 0x85,
	0xff, 0x03, 0x83, 0x67, 0xe5, 0x4c, 0x35, 0xb2, 0x49, 0x54, 0x80, 0x37, 0xa1, 0x91, 0xd3, 0xb2,
	0xcc, 0xd8, 0x98, 0x56, 0xb2, 0x4f, 0x3a, 0xb9, 0x36, 0x5a, 0x21, 0x98, 0x8b, 0xeb, 0xac, 0xce,
	0xbe, 0x07, 0xcd, 0x9c, 0x56, 0xac, 0xa8, 0x58, 0x2a, 0x67, 0x24, 0x0e, 0xf8, 0x97, 0xd8, 0x0b,
	0x4f, 0x4c, 0xa4, 0x73, 0x06, 0xba, 0xf8, 0x62, 0x00, 0xf3, 0x28, 0x4d, 0x0e, 0x0e, 0xfb, 0x0e,
	0x52, 0x7a, 0x20, 0x74, 0x4d, 0xe9, 0xc3, 0x41, 0x14, 0x39, 0x1a, 0x6e, 0x42, 0xfd, 0x28, 0x8d,
	0x77, 0xfa, 0x7b, 0xfd, 0xc4, 0xd1, 0x55, 0xb4, 0x1b, 0x0f, 0x7a, 0xd1, 0x9e, 0x63, 0x60, 0x1b,
	0xac, 0xa3, 0x74, 0x3f, 0x8a, 0xc3, 0xbe, 0x63, 0xaa, 0xa4, 0x5e, 0x1c, 0x47, 0x8e, 0xa5, 0xb0,
	0xa4, 0x4f, 0x0e, 0x0e, 0x5f, 0x39, 0xf5, 0xce, 0x07, 0x04, 0x66, 0x3c, 0x3c, 0x2d, 0x72, 0x86,
	0x9f, 0x83, 0x76, 0x5c, 0x8e, 0x5c, 0xe4, 0x69, 0xbe, 0xdd, 0xdd, 0xba, 0xd9, 0x31, 0x85, 0x2d,
	0x3e, 0xfb, 0xe3, 0xa2, 0x1c, 0x11, 0x91, 0xd0, 0x8a, 0xc0, 0x5e, 0xf2, 0xb0, 0x03, 0xda, 0xbb,
	0x62, 0x2e, 0xef, 0xdd, 0x20, 0x42, 0xe2, 0x47, 0x57, 0xbd, 0xa8, 0x79, 0x35, 0xdf, 0xee, 0xae,
	0xdf, 0x3c, 0x3a, 0xac, 0xe6, 0x8b, 0x16, 0x75, 0x9e, 0x81, 0x11, 0x4e, 0x26, 0xd9, 0x52, 0x96,
	0x2a, 0xe8, 0xcf, 0x59, 0xdf, 0x11, 0x68, 0x61, 0x35, 0xc7, 0xc1, 0x2f, 0xcb, 0xdf, 0x5a, 0x99,
	0xb3, 0xbc, 0xf9, 0x4f, 0xc0, 0x9c, 0xca, 0x45, 0x90, 0xa3, 0xb0, 0xbb, 0xee, 0x6d, 0x8b, 0x42,
	0x16, 0x1c, 0x7e, 0x08, 0x1a, 0x1d, 0x9e, 0xca, 0xf5, 0x5f, 0x89, 0xab, 0x56, 0x10, 0x01, 0xe1,
	0xc7, 0x60, 0x64, 0xe2, 0x2e, 0xae, 0x2e, 0xe9, 0x8d, 0x15, 0xe5, 0x88, 0x9f, 0x89, 0xa2, 0x3a,
	0x0f, 0xae, 0x47, 0x9f, 0xec, 0x84, 0x51, 0x48, 0xd4, 0xe8, 0xe3, 0xde, 0xeb, 0xbd, 0x1d, 0x31,
	0xfa, 0x06, 0x18, 0x21, 0x21, 0xe1, 0x5b, 0x47, 0xeb, 0x05, 0x9f, 0x2f, 0xdb, 0xe8, 0xcb, 0x65,
	0x1b, 0x7d, 0xbd, 0x6c, 0xa3, 0x8f, 0xdf, 0xda, 0xff, 0xc0, 0x66, 0x4e, 0xcf, 0x02, 0xf9, 0x5e,
	0x04, 0xf9, 0xa9, 0x12, 0x17, 0xea, 0xb9, 0x18, 0xce, 0x8e, 0x7f, 0x04, 0x00, 0x00, 0xff, 0xff,
	0x15, 0x19, 0x37, 0x53, 0x5b, 0x04, 0x00, 0x00,
}
