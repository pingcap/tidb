// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: expression.proto

package tipb

import (
	"fmt"

	proto "github.com/golang/protobuf/proto"

	math "math"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ExprType int32

const (
	// Values are encoded bytes.
	ExprType_Null    ExprType = 0
	ExprType_Int64   ExprType = 1
	ExprType_Uint64  ExprType = 2
	ExprType_Float32 ExprType = 3
	ExprType_Float64 ExprType = 4
	ExprType_String  ExprType = 5
	ExprType_Bytes   ExprType = 6
	// Mysql specific types.
	ExprType_MysqlBit      ExprType = 101
	ExprType_MysqlDecimal  ExprType = 102
	ExprType_MysqlDuration ExprType = 103
	ExprType_MysqlEnum     ExprType = 104
	ExprType_MysqlHex      ExprType = 105
	ExprType_MysqlSet      ExprType = 106
	ExprType_MysqlTime     ExprType = 107
	ExprType_MysqlJson     ExprType = 108
	// Encoded value list.
	ExprType_ValueList ExprType = 151
	// Column reference. value is int64 column ID.
	ExprType_ColumnRef ExprType = 201
	// Aggregate functions.
	ExprType_Count       ExprType = 3001
	ExprType_Sum         ExprType = 3002
	ExprType_Avg         ExprType = 3003
	ExprType_Min         ExprType = 3004
	ExprType_Max         ExprType = 3005
	ExprType_First       ExprType = 3006
	ExprType_GroupConcat ExprType = 3007
	ExprType_Agg_BitAnd  ExprType = 3008
	ExprType_Agg_BitOr   ExprType = 3009
	ExprType_Agg_BitXor  ExprType = 3010
	ExprType_Std         ExprType = 3011
	ExprType_Stddev      ExprType = 3012
	ExprType_StddevPop   ExprType = 3013
	ExprType_StddevSamp  ExprType = 3014
	ExprType_VarPop      ExprType = 3015
	ExprType_VarSamp     ExprType = 3016
	ExprType_Variance    ExprType = 3017
	// Scalar Function
	ExprType_ScalarFunc ExprType = 10000
)

var ExprType_name = map[int32]string{
	0:     "Null",
	1:     "Int64",
	2:     "Uint64",
	3:     "Float32",
	4:     "Float64",
	5:     "String",
	6:     "Bytes",
	101:   "MysqlBit",
	102:   "MysqlDecimal",
	103:   "MysqlDuration",
	104:   "MysqlEnum",
	105:   "MysqlHex",
	106:   "MysqlSet",
	107:   "MysqlTime",
	108:   "MysqlJson",
	151:   "ValueList",
	201:   "ColumnRef",
	3001:  "Count",
	3002:  "Sum",
	3003:  "Avg",
	3004:  "Min",
	3005:  "Max",
	3006:  "First",
	3007:  "GroupConcat",
	3008:  "Agg_BitAnd",
	3009:  "Agg_BitOr",
	3010:  "Agg_BitXor",
	3011:  "Std",
	3012:  "Stddev",
	3013:  "StddevPop",
	3014:  "StddevSamp",
	3015:  "VarPop",
	3016:  "VarSamp",
	3017:  "Variance",
	10000: "ScalarFunc",
}
var ExprType_value = map[string]int32{
	"Null":          0,
	"Int64":         1,
	"Uint64":        2,
	"Float32":       3,
	"Float64":       4,
	"String":        5,
	"Bytes":         6,
	"MysqlBit":      101,
	"MysqlDecimal":  102,
	"MysqlDuration": 103,
	"MysqlEnum":     104,
	"MysqlHex":      105,
	"MysqlSet":      106,
	"MysqlTime":     107,
	"MysqlJson":     108,
	"ValueList":     151,
	"ColumnRef":     201,
	"Count":         3001,
	"Sum":           3002,
	"Avg":           3003,
	"Min":           3004,
	"Max":           3005,
	"First":         3006,
	"GroupConcat":   3007,
	"Agg_BitAnd":    3008,
	"Agg_BitOr":     3009,
	"Agg_BitXor":    3010,
	"Std":           3011,
	"Stddev":        3012,
	"StddevPop":     3013,
	"StddevSamp":    3014,
	"VarPop":        3015,
	"VarSamp":       3016,
	"Variance":      3017,
	"ScalarFunc":    10000,
}

func (x ExprType) Enum() *ExprType {
	p := new(ExprType)
	*p = x
	return p
}
func (x ExprType) String() string {
	return proto.EnumName(ExprType_name, int32(x))
}
func (x *ExprType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ExprType_value, data, "ExprType")
	if err != nil {
		return err
	}
	*x = ExprType(value)
	return nil
}
func (ExprType) EnumDescriptor() ([]byte, []int) { return fileDescriptorExpression, []int{0} }

type ScalarFuncSig int32

const (
	// Casting
	ScalarFuncSig_CastIntAsInt           ScalarFuncSig = 0
	ScalarFuncSig_CastIntAsReal          ScalarFuncSig = 1
	ScalarFuncSig_CastIntAsString        ScalarFuncSig = 2
	ScalarFuncSig_CastIntAsDecimal       ScalarFuncSig = 3
	ScalarFuncSig_CastIntAsTime          ScalarFuncSig = 4
	ScalarFuncSig_CastIntAsDuration      ScalarFuncSig = 5
	ScalarFuncSig_CastIntAsJson          ScalarFuncSig = 6
	ScalarFuncSig_CastRealAsInt          ScalarFuncSig = 10
	ScalarFuncSig_CastRealAsReal         ScalarFuncSig = 11
	ScalarFuncSig_CastRealAsString       ScalarFuncSig = 12
	ScalarFuncSig_CastRealAsDecimal      ScalarFuncSig = 13
	ScalarFuncSig_CastRealAsTime         ScalarFuncSig = 14
	ScalarFuncSig_CastRealAsDuration     ScalarFuncSig = 15
	ScalarFuncSig_CastRealAsJson         ScalarFuncSig = 16
	ScalarFuncSig_CastDecimalAsInt       ScalarFuncSig = 20
	ScalarFuncSig_CastDecimalAsReal      ScalarFuncSig = 21
	ScalarFuncSig_CastDecimalAsString    ScalarFuncSig = 22
	ScalarFuncSig_CastDecimalAsDecimal   ScalarFuncSig = 23
	ScalarFuncSig_CastDecimalAsTime      ScalarFuncSig = 24
	ScalarFuncSig_CastDecimalAsDuration  ScalarFuncSig = 25
	ScalarFuncSig_CastDecimalAsJson      ScalarFuncSig = 26
	ScalarFuncSig_CastStringAsInt        ScalarFuncSig = 30
	ScalarFuncSig_CastStringAsReal       ScalarFuncSig = 31
	ScalarFuncSig_CastStringAsString     ScalarFuncSig = 32
	ScalarFuncSig_CastStringAsDecimal    ScalarFuncSig = 33
	ScalarFuncSig_CastStringAsTime       ScalarFuncSig = 34
	ScalarFuncSig_CastStringAsDuration   ScalarFuncSig = 35
	ScalarFuncSig_CastStringAsJson       ScalarFuncSig = 36
	ScalarFuncSig_CastTimeAsInt          ScalarFuncSig = 40
	ScalarFuncSig_CastTimeAsReal         ScalarFuncSig = 41
	ScalarFuncSig_CastTimeAsString       ScalarFuncSig = 42
	ScalarFuncSig_CastTimeAsDecimal      ScalarFuncSig = 43
	ScalarFuncSig_CastTimeAsTime         ScalarFuncSig = 44
	ScalarFuncSig_CastTimeAsDuration     ScalarFuncSig = 45
	ScalarFuncSig_CastTimeAsJson         ScalarFuncSig = 46
	ScalarFuncSig_CastDurationAsInt      ScalarFuncSig = 50
	ScalarFuncSig_CastDurationAsReal     ScalarFuncSig = 51
	ScalarFuncSig_CastDurationAsString   ScalarFuncSig = 52
	ScalarFuncSig_CastDurationAsDecimal  ScalarFuncSig = 53
	ScalarFuncSig_CastDurationAsTime     ScalarFuncSig = 54
	ScalarFuncSig_CastDurationAsDuration ScalarFuncSig = 55
	ScalarFuncSig_CastDurationAsJson     ScalarFuncSig = 56
	ScalarFuncSig_CastJsonAsInt          ScalarFuncSig = 60
	ScalarFuncSig_CastJsonAsReal         ScalarFuncSig = 61
	ScalarFuncSig_CastJsonAsString       ScalarFuncSig = 62
	ScalarFuncSig_CastJsonAsDecimal      ScalarFuncSig = 63
	ScalarFuncSig_CastJsonAsTime         ScalarFuncSig = 64
	ScalarFuncSig_CastJsonAsDuration     ScalarFuncSig = 65
	ScalarFuncSig_CastJsonAsJson         ScalarFuncSig = 66
	ScalarFuncSig_LTInt                  ScalarFuncSig = 100
	ScalarFuncSig_LTReal                 ScalarFuncSig = 101
	ScalarFuncSig_LTDecimal              ScalarFuncSig = 102
	ScalarFuncSig_LTString               ScalarFuncSig = 103
	ScalarFuncSig_LTTime                 ScalarFuncSig = 104
	ScalarFuncSig_LTDuration             ScalarFuncSig = 105
	ScalarFuncSig_LTJson                 ScalarFuncSig = 106
	ScalarFuncSig_LEInt                  ScalarFuncSig = 110
	ScalarFuncSig_LEReal                 ScalarFuncSig = 111
	ScalarFuncSig_LEDecimal              ScalarFuncSig = 112
	ScalarFuncSig_LEString               ScalarFuncSig = 113
	ScalarFuncSig_LETime                 ScalarFuncSig = 114
	ScalarFuncSig_LEDuration             ScalarFuncSig = 115
	ScalarFuncSig_LEJson                 ScalarFuncSig = 116
	ScalarFuncSig_GTInt                  ScalarFuncSig = 120
	ScalarFuncSig_GTReal                 ScalarFuncSig = 121
	ScalarFuncSig_GTDecimal              ScalarFuncSig = 122
	ScalarFuncSig_GTString               ScalarFuncSig = 123
	ScalarFuncSig_GTTime                 ScalarFuncSig = 124
	ScalarFuncSig_GTDuration             ScalarFuncSig = 125
	ScalarFuncSig_GTJson                 ScalarFuncSig = 126
	ScalarFuncSig_GEInt                  ScalarFuncSig = 130
	ScalarFuncSig_GEReal                 ScalarFuncSig = 131
	ScalarFuncSig_GEDecimal              ScalarFuncSig = 132
	ScalarFuncSig_GEString               ScalarFuncSig = 133
	ScalarFuncSig_GETime                 ScalarFuncSig = 134
	ScalarFuncSig_GEDuration             ScalarFuncSig = 135
	ScalarFuncSig_GEJson                 ScalarFuncSig = 136
	ScalarFuncSig_EQInt                  ScalarFuncSig = 140
	ScalarFuncSig_EQReal                 ScalarFuncSig = 141
	ScalarFuncSig_EQDecimal              ScalarFuncSig = 142
	ScalarFuncSig_EQString               ScalarFuncSig = 143
	ScalarFuncSig_EQTime                 ScalarFuncSig = 144
	ScalarFuncSig_EQDuration             ScalarFuncSig = 145
	ScalarFuncSig_EQJson                 ScalarFuncSig = 146
	ScalarFuncSig_NEInt                  ScalarFuncSig = 150
	ScalarFuncSig_NEReal                 ScalarFuncSig = 151
	ScalarFuncSig_NEDecimal              ScalarFuncSig = 152
	ScalarFuncSig_NEString               ScalarFuncSig = 153
	ScalarFuncSig_NETime                 ScalarFuncSig = 154
	ScalarFuncSig_NEDuration             ScalarFuncSig = 155
	ScalarFuncSig_NEJson                 ScalarFuncSig = 156
	ScalarFuncSig_NullEQInt              ScalarFuncSig = 160
	ScalarFuncSig_NullEQReal             ScalarFuncSig = 161
	ScalarFuncSig_NullEQDecimal          ScalarFuncSig = 162
	ScalarFuncSig_NullEQString           ScalarFuncSig = 163
	ScalarFuncSig_NullEQTime             ScalarFuncSig = 164
	ScalarFuncSig_NullEQDuration         ScalarFuncSig = 165
	ScalarFuncSig_NullEQJson             ScalarFuncSig = 166
	ScalarFuncSig_PlusReal               ScalarFuncSig = 200
	ScalarFuncSig_PlusDecimal            ScalarFuncSig = 201
	ScalarFuncSig_PlusInt                ScalarFuncSig = 203
	ScalarFuncSig_MinusReal              ScalarFuncSig = 204
	ScalarFuncSig_MinusDecimal           ScalarFuncSig = 205
	ScalarFuncSig_MinusInt               ScalarFuncSig = 207
	ScalarFuncSig_MultiplyReal           ScalarFuncSig = 208
	ScalarFuncSig_MultiplyDecimal        ScalarFuncSig = 209
	ScalarFuncSig_MultiplyInt            ScalarFuncSig = 210
	ScalarFuncSig_DivideReal             ScalarFuncSig = 211
	ScalarFuncSig_DivideDecimal          ScalarFuncSig = 212
	ScalarFuncSig_AbsInt                 ScalarFuncSig = 2101
	ScalarFuncSig_AbsUInt                ScalarFuncSig = 2102
	ScalarFuncSig_AbsReal                ScalarFuncSig = 2103
	ScalarFuncSig_AbsDecimal             ScalarFuncSig = 2104
	ScalarFuncSig_CeilIntToDec           ScalarFuncSig = 2105
	ScalarFuncSig_CeilIntToInt           ScalarFuncSig = 2106
	ScalarFuncSig_CeilDecToInt           ScalarFuncSig = 2107
	ScalarFuncSig_CeilDecToDec           ScalarFuncSig = 2108
	ScalarFuncSig_CeilReal               ScalarFuncSig = 2109
	ScalarFuncSig_FloorIntToDec          ScalarFuncSig = 2110
	ScalarFuncSig_FloorIntToInt          ScalarFuncSig = 2111
	ScalarFuncSig_FloorDecToInt          ScalarFuncSig = 2112
	ScalarFuncSig_FloorDecToDec          ScalarFuncSig = 2113
	ScalarFuncSig_FloorReal              ScalarFuncSig = 2114
	ScalarFuncSig_LogicalAnd             ScalarFuncSig = 3101
	ScalarFuncSig_LogicalOr              ScalarFuncSig = 3102
	ScalarFuncSig_LogicalXor             ScalarFuncSig = 3103
	ScalarFuncSig_UnaryNot               ScalarFuncSig = 3104
	ScalarFuncSig_UnaryMinusInt          ScalarFuncSig = 3108
	ScalarFuncSig_UnaryMinusReal         ScalarFuncSig = 3109
	ScalarFuncSig_UnaryMinusDecimal      ScalarFuncSig = 3110
	ScalarFuncSig_DecimalIsNull          ScalarFuncSig = 3111
	ScalarFuncSig_DurationIsNull         ScalarFuncSig = 3112
	ScalarFuncSig_RealIsNull             ScalarFuncSig = 3113
	ScalarFuncSig_StringIsNull           ScalarFuncSig = 3114
	ScalarFuncSig_TimeIsNull             ScalarFuncSig = 3115
	ScalarFuncSig_IntIsNull              ScalarFuncSig = 3116
	ScalarFuncSig_JsonIsNull             ScalarFuncSig = 3117
	ScalarFuncSig_BitAndSig              ScalarFuncSig = 3118
	ScalarFuncSig_BitOrSig               ScalarFuncSig = 3119
	ScalarFuncSig_BitXorSig              ScalarFuncSig = 3120
	ScalarFuncSig_BitNegSig              ScalarFuncSig = 3121
	ScalarFuncSig_IntIsTrue              ScalarFuncSig = 3122
	ScalarFuncSig_RealIsTrue             ScalarFuncSig = 3123
	ScalarFuncSig_DecimalIsTrue          ScalarFuncSig = 3124
	ScalarFuncSig_IntIsFalse             ScalarFuncSig = 3125
	ScalarFuncSig_RealIsFalse            ScalarFuncSig = 3126
	ScalarFuncSig_DecimalIsFalse         ScalarFuncSig = 3127
	ScalarFuncSig_InInt                  ScalarFuncSig = 4001
	ScalarFuncSig_InReal                 ScalarFuncSig = 4002
	ScalarFuncSig_InDecimal              ScalarFuncSig = 4003
	ScalarFuncSig_InString               ScalarFuncSig = 4004
	ScalarFuncSig_InTime                 ScalarFuncSig = 4005
	ScalarFuncSig_InDuration             ScalarFuncSig = 4006
	ScalarFuncSig_InJson                 ScalarFuncSig = 4007
	ScalarFuncSig_IfNullInt              ScalarFuncSig = 4101
	ScalarFuncSig_IfNullReal             ScalarFuncSig = 4102
	ScalarFuncSig_IfNullDecimal          ScalarFuncSig = 4103
	ScalarFuncSig_IfNullString           ScalarFuncSig = 4104
	ScalarFuncSig_IfNullTime             ScalarFuncSig = 4105
	ScalarFuncSig_IfNullDuration         ScalarFuncSig = 4106
	ScalarFuncSig_IfInt                  ScalarFuncSig = 4107
	ScalarFuncSig_IfReal                 ScalarFuncSig = 4108
	ScalarFuncSig_IfDecimal              ScalarFuncSig = 4109
	ScalarFuncSig_IfString               ScalarFuncSig = 4110
	ScalarFuncSig_IfTime                 ScalarFuncSig = 4111
	ScalarFuncSig_IfDuration             ScalarFuncSig = 4112
	ScalarFuncSig_IfNullJson             ScalarFuncSig = 4113
	ScalarFuncSig_IfJson                 ScalarFuncSig = 4114
	ScalarFuncSig_CoalesceInt            ScalarFuncSig = 4201
	ScalarFuncSig_CoalesceReal           ScalarFuncSig = 4202
	ScalarFuncSig_CoalesceDecimal        ScalarFuncSig = 4203
	ScalarFuncSig_CoalesceString         ScalarFuncSig = 4204
	ScalarFuncSig_CoalesceTime           ScalarFuncSig = 4205
	ScalarFuncSig_CoalesceDuration       ScalarFuncSig = 4206
	ScalarFuncSig_CoalesceJson           ScalarFuncSig = 4207
	ScalarFuncSig_CaseWhenInt            ScalarFuncSig = 4208
	ScalarFuncSig_CaseWhenReal           ScalarFuncSig = 4209
	ScalarFuncSig_CaseWhenDecimal        ScalarFuncSig = 4210
	ScalarFuncSig_CaseWhenString         ScalarFuncSig = 4211
	ScalarFuncSig_CaseWhenTime           ScalarFuncSig = 4212
	ScalarFuncSig_CaseWhenDuration       ScalarFuncSig = 4213
	ScalarFuncSig_CaseWhenJson           ScalarFuncSig = 4214
	//
	// Here we use suffix *Sig* to avoid name conflict. After we removes
	// all same things in ExprType, we can rename them back.
	ScalarFuncSig_LikeSig        ScalarFuncSig = 4310
	ScalarFuncSig_JsonExtractSig ScalarFuncSig = 5001
	ScalarFuncSig_JsonUnquoteSig ScalarFuncSig = 5002
	ScalarFuncSig_JsonTypeSig    ScalarFuncSig = 5003
	ScalarFuncSig_JsonSetSig     ScalarFuncSig = 5004
	ScalarFuncSig_JsonInsertSig  ScalarFuncSig = 5005
	ScalarFuncSig_JsonReplaceSig ScalarFuncSig = 5006
	ScalarFuncSig_JsonRemoveSig  ScalarFuncSig = 5007
	ScalarFuncSig_JsonMergeSig   ScalarFuncSig = 5008
	ScalarFuncSig_JsonObjectSig  ScalarFuncSig = 5009
	ScalarFuncSig_JsonArraySig   ScalarFuncSig = 5010
	ScalarFuncSig_DateFormatSig  ScalarFuncSig = 6001
)

var ScalarFuncSig_name = map[int32]string{
	0:    "CastIntAsInt",
	1:    "CastIntAsReal",
	2:    "CastIntAsString",
	3:    "CastIntAsDecimal",
	4:    "CastIntAsTime",
	5:    "CastIntAsDuration",
	6:    "CastIntAsJson",
	10:   "CastRealAsInt",
	11:   "CastRealAsReal",
	12:   "CastRealAsString",
	13:   "CastRealAsDecimal",
	14:   "CastRealAsTime",
	15:   "CastRealAsDuration",
	16:   "CastRealAsJson",
	20:   "CastDecimalAsInt",
	21:   "CastDecimalAsReal",
	22:   "CastDecimalAsString",
	23:   "CastDecimalAsDecimal",
	24:   "CastDecimalAsTime",
	25:   "CastDecimalAsDuration",
	26:   "CastDecimalAsJson",
	30:   "CastStringAsInt",
	31:   "CastStringAsReal",
	32:   "CastStringAsString",
	33:   "CastStringAsDecimal",
	34:   "CastStringAsTime",
	35:   "CastStringAsDuration",
	36:   "CastStringAsJson",
	40:   "CastTimeAsInt",
	41:   "CastTimeAsReal",
	42:   "CastTimeAsString",
	43:   "CastTimeAsDecimal",
	44:   "CastTimeAsTime",
	45:   "CastTimeAsDuration",
	46:   "CastTimeAsJson",
	50:   "CastDurationAsInt",
	51:   "CastDurationAsReal",
	52:   "CastDurationAsString",
	53:   "CastDurationAsDecimal",
	54:   "CastDurationAsTime",
	55:   "CastDurationAsDuration",
	56:   "CastDurationAsJson",
	60:   "CastJsonAsInt",
	61:   "CastJsonAsReal",
	62:   "CastJsonAsString",
	63:   "CastJsonAsDecimal",
	64:   "CastJsonAsTime",
	65:   "CastJsonAsDuration",
	66:   "CastJsonAsJson",
	100:  "LTInt",
	101:  "LTReal",
	102:  "LTDecimal",
	103:  "LTString",
	104:  "LTTime",
	105:  "LTDuration",
	106:  "LTJson",
	110:  "LEInt",
	111:  "LEReal",
	112:  "LEDecimal",
	113:  "LEString",
	114:  "LETime",
	115:  "LEDuration",
	116:  "LEJson",
	120:  "GTInt",
	121:  "GTReal",
	122:  "GTDecimal",
	123:  "GTString",
	124:  "GTTime",
	125:  "GTDuration",
	126:  "GTJson",
	130:  "GEInt",
	131:  "GEReal",
	132:  "GEDecimal",
	133:  "GEString",
	134:  "GETime",
	135:  "GEDuration",
	136:  "GEJson",
	140:  "EQInt",
	141:  "EQReal",
	142:  "EQDecimal",
	143:  "EQString",
	144:  "EQTime",
	145:  "EQDuration",
	146:  "EQJson",
	150:  "NEInt",
	151:  "NEReal",
	152:  "NEDecimal",
	153:  "NEString",
	154:  "NETime",
	155:  "NEDuration",
	156:  "NEJson",
	160:  "NullEQInt",
	161:  "NullEQReal",
	162:  "NullEQDecimal",
	163:  "NullEQString",
	164:  "NullEQTime",
	165:  "NullEQDuration",
	166:  "NullEQJson",
	200:  "PlusReal",
	201:  "PlusDecimal",
	203:  "PlusInt",
	204:  "MinusReal",
	205:  "MinusDecimal",
	207:  "MinusInt",
	208:  "MultiplyReal",
	209:  "MultiplyDecimal",
	210:  "MultiplyInt",
	211:  "DivideReal",
	212:  "DivideDecimal",
	2101: "AbsInt",
	2102: "AbsUInt",
	2103: "AbsReal",
	2104: "AbsDecimal",
	2105: "CeilIntToDec",
	2106: "CeilIntToInt",
	2107: "CeilDecToInt",
	2108: "CeilDecToDec",
	2109: "CeilReal",
	2110: "FloorIntToDec",
	2111: "FloorIntToInt",
	2112: "FloorDecToInt",
	2113: "FloorDecToDec",
	2114: "FloorReal",
	3101: "LogicalAnd",
	3102: "LogicalOr",
	3103: "LogicalXor",
	3104: "UnaryNot",
	3108: "UnaryMinusInt",
	3109: "UnaryMinusReal",
	3110: "UnaryMinusDecimal",
	3111: "DecimalIsNull",
	3112: "DurationIsNull",
	3113: "RealIsNull",
	3114: "StringIsNull",
	3115: "TimeIsNull",
	3116: "IntIsNull",
	3117: "JsonIsNull",
	3118: "BitAndSig",
	3119: "BitOrSig",
	3120: "BitXorSig",
	3121: "BitNegSig",
	3122: "IntIsTrue",
	3123: "RealIsTrue",
	3124: "DecimalIsTrue",
	3125: "IntIsFalse",
	3126: "RealIsFalse",
	3127: "DecimalIsFalse",
	4001: "InInt",
	4002: "InReal",
	4003: "InDecimal",
	4004: "InString",
	4005: "InTime",
	4006: "InDuration",
	4007: "InJson",
	4101: "IfNullInt",
	4102: "IfNullReal",
	4103: "IfNullDecimal",
	4104: "IfNullString",
	4105: "IfNullTime",
	4106: "IfNullDuration",
	4107: "IfInt",
	4108: "IfReal",
	4109: "IfDecimal",
	4110: "IfString",
	4111: "IfTime",
	4112: "IfDuration",
	4113: "IfNullJson",
	4114: "IfJson",
	4201: "CoalesceInt",
	4202: "CoalesceReal",
	4203: "CoalesceDecimal",
	4204: "CoalesceString",
	4205: "CoalesceTime",
	4206: "CoalesceDuration",
	4207: "CoalesceJson",
	4208: "CaseWhenInt",
	4209: "CaseWhenReal",
	4210: "CaseWhenDecimal",
	4211: "CaseWhenString",
	4212: "CaseWhenTime",
	4213: "CaseWhenDuration",
	4214: "CaseWhenJson",
	4310: "LikeSig",
	5001: "JsonExtractSig",
	5002: "JsonUnquoteSig",
	5003: "JsonTypeSig",
	5004: "JsonSetSig",
	5005: "JsonInsertSig",
	5006: "JsonReplaceSig",
	5007: "JsonRemoveSig",
	5008: "JsonMergeSig",
	5009: "JsonObjectSig",
	5010: "JsonArraySig",
	6001: "DateFormatSig",
}
var ScalarFuncSig_value = map[string]int32{
	"CastIntAsInt":           0,
	"CastIntAsReal":          1,
	"CastIntAsString":        2,
	"CastIntAsDecimal":       3,
	"CastIntAsTime":          4,
	"CastIntAsDuration":      5,
	"CastIntAsJson":          6,
	"CastRealAsInt":          10,
	"CastRealAsReal":         11,
	"CastRealAsString":       12,
	"CastRealAsDecimal":      13,
	"CastRealAsTime":         14,
	"CastRealAsDuration":     15,
	"CastRealAsJson":         16,
	"CastDecimalAsInt":       20,
	"CastDecimalAsReal":      21,
	"CastDecimalAsString":    22,
	"CastDecimalAsDecimal":   23,
	"CastDecimalAsTime":      24,
	"CastDecimalAsDuration":  25,
	"CastDecimalAsJson":      26,
	"CastStringAsInt":        30,
	"CastStringAsReal":       31,
	"CastStringAsString":     32,
	"CastStringAsDecimal":    33,
	"CastStringAsTime":       34,
	"CastStringAsDuration":   35,
	"CastStringAsJson":       36,
	"CastTimeAsInt":          40,
	"CastTimeAsReal":         41,
	"CastTimeAsString":       42,
	"CastTimeAsDecimal":      43,
	"CastTimeAsTime":         44,
	"CastTimeAsDuration":     45,
	"CastTimeAsJson":         46,
	"CastDurationAsInt":      50,
	"CastDurationAsReal":     51,
	"CastDurationAsString":   52,
	"CastDurationAsDecimal":  53,
	"CastDurationAsTime":     54,
	"CastDurationAsDuration": 55,
	"CastDurationAsJson":     56,
	"CastJsonAsInt":          60,
	"CastJsonAsReal":         61,
	"CastJsonAsString":       62,
	"CastJsonAsDecimal":      63,
	"CastJsonAsTime":         64,
	"CastJsonAsDuration":     65,
	"CastJsonAsJson":         66,
	"LTInt":                  100,
	"LTReal":                 101,
	"LTDecimal":              102,
	"LTString":               103,
	"LTTime":                 104,
	"LTDuration":             105,
	"LTJson":                 106,
	"LEInt":                  110,
	"LEReal":                 111,
	"LEDecimal":              112,
	"LEString":               113,
	"LETime":                 114,
	"LEDuration":             115,
	"LEJson":                 116,
	"GTInt":                  120,
	"GTReal":                 121,
	"GTDecimal":              122,
	"GTString":               123,
	"GTTime":                 124,
	"GTDuration":             125,
	"GTJson":                 126,
	"GEInt":                  130,
	"GEReal":                 131,
	"GEDecimal":              132,
	"GEString":               133,
	"GETime":                 134,
	"GEDuration":             135,
	"GEJson":                 136,
	"EQInt":                  140,
	"EQReal":                 141,
	"EQDecimal":              142,
	"EQString":               143,
	"EQTime":                 144,
	"EQDuration":             145,
	"EQJson":                 146,
	"NEInt":                  150,
	"NEReal":                 151,
	"NEDecimal":              152,
	"NEString":               153,
	"NETime":                 154,
	"NEDuration":             155,
	"NEJson":                 156,
	"NullEQInt":              160,
	"NullEQReal":             161,
	"NullEQDecimal":          162,
	"NullEQString":           163,
	"NullEQTime":             164,
	"NullEQDuration":         165,
	"NullEQJson":             166,
	"PlusReal":               200,
	"PlusDecimal":            201,
	"PlusInt":                203,
	"MinusReal":              204,
	"MinusDecimal":           205,
	"MinusInt":               207,
	"MultiplyReal":           208,
	"MultiplyDecimal":        209,
	"MultiplyInt":            210,
	"DivideReal":             211,
	"DivideDecimal":          212,
	"AbsInt":                 2101,
	"AbsUInt":                2102,
	"AbsReal":                2103,
	"AbsDecimal":             2104,
	"CeilIntToDec":           2105,
	"CeilIntToInt":           2106,
	"CeilDecToInt":           2107,
	"CeilDecToDec":           2108,
	"CeilReal":               2109,
	"FloorIntToDec":          2110,
	"FloorIntToInt":          2111,
	"FloorDecToInt":          2112,
	"FloorDecToDec":          2113,
	"FloorReal":              2114,
	"LogicalAnd":             3101,
	"LogicalOr":              3102,
	"LogicalXor":             3103,
	"UnaryNot":               3104,
	"UnaryMinusInt":          3108,
	"UnaryMinusReal":         3109,
	"UnaryMinusDecimal":      3110,
	"DecimalIsNull":          3111,
	"DurationIsNull":         3112,
	"RealIsNull":             3113,
	"StringIsNull":           3114,
	"TimeIsNull":             3115,
	"IntIsNull":              3116,
	"JsonIsNull":             3117,
	"BitAndSig":              3118,
	"BitOrSig":               3119,
	"BitXorSig":              3120,
	"BitNegSig":              3121,
	"IntIsTrue":              3122,
	"RealIsTrue":             3123,
	"DecimalIsTrue":          3124,
	"IntIsFalse":             3125,
	"RealIsFalse":            3126,
	"DecimalIsFalse":         3127,
	"InInt":                  4001,
	"InReal":                 4002,
	"InDecimal":              4003,
	"InString":               4004,
	"InTime":                 4005,
	"InDuration":             4006,
	"InJson":                 4007,
	"IfNullInt":              4101,
	"IfNullReal":             4102,
	"IfNullDecimal":          4103,
	"IfNullString":           4104,
	"IfNullTime":             4105,
	"IfNullDuration":         4106,
	"IfInt":                  4107,
	"IfReal":                 4108,
	"IfDecimal":              4109,
	"IfString":               4110,
	"IfTime":                 4111,
	"IfDuration":             4112,
	"IfNullJson":             4113,
	"IfJson":                 4114,
	"CoalesceInt":            4201,
	"CoalesceReal":           4202,
	"CoalesceDecimal":        4203,
	"CoalesceString":         4204,
	"CoalesceTime":           4205,
	"CoalesceDuration":       4206,
	"CoalesceJson":           4207,
	"CaseWhenInt":            4208,
	"CaseWhenReal":           4209,
	"CaseWhenDecimal":        4210,
	"CaseWhenString":         4211,
	"CaseWhenTime":           4212,
	"CaseWhenDuration":       4213,
	"CaseWhenJson":           4214,
	"LikeSig":                4310,
	"JsonExtractSig":         5001,
	"JsonUnquoteSig":         5002,
	"JsonTypeSig":            5003,
	"JsonSetSig":             5004,
	"JsonInsertSig":          5005,
	"JsonReplaceSig":         5006,
	"JsonRemoveSig":          5007,
	"JsonMergeSig":           5008,
	"JsonObjectSig":          5009,
	"JsonArraySig":           5010,
	"DateFormatSig":          6001,
}

func (x ScalarFuncSig) Enum() *ScalarFuncSig {
	p := new(ScalarFuncSig)
	*p = x
	return p
}
func (x ScalarFuncSig) String() string {
	return proto.EnumName(ScalarFuncSig_name, int32(x))
}
func (x *ScalarFuncSig) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ScalarFuncSig_value, data, "ScalarFuncSig")
	if err != nil {
		return err
	}
	*x = ScalarFuncSig(value)
	return nil
}
func (ScalarFuncSig) EnumDescriptor() ([]byte, []int) { return fileDescriptorExpression, []int{1} }

type FieldType struct {
	Tp               int32  `protobuf:"varint,1,opt,name=tp" json:"tp"`
	Flag             uint32 `protobuf:"varint,2,opt,name=flag" json:"flag"`
	Flen             int32  `protobuf:"varint,3,opt,name=flen" json:"flen"`
	Decimal          int32  `protobuf:"varint,4,opt,name=decimal" json:"decimal"`
	Collate          int32  `protobuf:"varint,5,opt,name=collate" json:"collate"`
	Charset          string `protobuf:"bytes,6,opt,name=charset" json:"charset"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *FieldType) Reset()                    { *m = FieldType{} }
func (m *FieldType) String() string            { return proto.CompactTextString(m) }
func (*FieldType) ProtoMessage()               {}
func (*FieldType) Descriptor() ([]byte, []int) { return fileDescriptorExpression, []int{0} }

func (m *FieldType) GetTp() int32 {
	if m != nil {
		return m.Tp
	}
	return 0
}

func (m *FieldType) GetFlag() uint32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

func (m *FieldType) GetFlen() int32 {
	if m != nil {
		return m.Flen
	}
	return 0
}

func (m *FieldType) GetDecimal() int32 {
	if m != nil {
		return m.Decimal
	}
	return 0
}

func (m *FieldType) GetCollate() int32 {
	if m != nil {
		return m.Collate
	}
	return 0
}

func (m *FieldType) GetCharset() string {
	if m != nil {
		return m.Charset
	}
	return ""
}

// Evaluators should implement evaluation functions for every expression type.
type Expr struct {
	Tp               ExprType      `protobuf:"varint,1,opt,name=tp,enum=tipb.ExprType" json:"tp"`
	Val              []byte        `protobuf:"bytes,2,opt,name=val" json:"val,omitempty"`
	Children         []*Expr       `protobuf:"bytes,3,rep,name=children" json:"children,omitempty"`
	Sig              ScalarFuncSig `protobuf:"varint,4,opt,name=sig,enum=tipb.ScalarFuncSig" json:"sig"`
	FieldType        *FieldType    `protobuf:"bytes,5,opt,name=field_type,json=fieldType" json:"field_type,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Expr) Reset()                    { *m = Expr{} }
func (m *Expr) String() string            { return proto.CompactTextString(m) }
func (*Expr) ProtoMessage()               {}
func (*Expr) Descriptor() ([]byte, []int) { return fileDescriptorExpression, []int{1} }

func (m *Expr) GetTp() ExprType {
	if m != nil {
		return m.Tp
	}
	return ExprType_Null
}

func (m *Expr) GetVal() []byte {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *Expr) GetChildren() []*Expr {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Expr) GetSig() ScalarFuncSig {
	if m != nil {
		return m.Sig
	}
	return ScalarFuncSig_CastIntAsInt
}

func (m *Expr) GetFieldType() *FieldType {
	if m != nil {
		return m.FieldType
	}
	return nil
}

// ByItem type for group by and order by.
type ByItem struct {
	Expr             *Expr  `protobuf:"bytes,1,opt,name=expr" json:"expr,omitempty"`
	Desc             bool   `protobuf:"varint,2,opt,name=desc" json:"desc"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ByItem) Reset()                    { *m = ByItem{} }
func (m *ByItem) String() string            { return proto.CompactTextString(m) }
func (*ByItem) ProtoMessage()               {}
func (*ByItem) Descriptor() ([]byte, []int) { return fileDescriptorExpression, []int{2} }

func (m *ByItem) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *ByItem) GetDesc() bool {
	if m != nil {
		return m.Desc
	}
	return false
}

func init() {
	proto.RegisterType((*FieldType)(nil), "tipb.FieldType")
	proto.RegisterType((*Expr)(nil), "tipb.Expr")
	proto.RegisterType((*ByItem)(nil), "tipb.ByItem")
	proto.RegisterEnum("tipb.ExprType", ExprType_name, ExprType_value)
	proto.RegisterEnum("tipb.ScalarFuncSig", ScalarFuncSig_name, ScalarFuncSig_value)
}
func (m *FieldType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintExpression(dAtA, i, uint64(m.Tp))
	dAtA[i] = 0x10
	i++
	i = encodeVarintExpression(dAtA, i, uint64(m.Flag))
	dAtA[i] = 0x18
	i++
	i = encodeVarintExpression(dAtA, i, uint64(m.Flen))
	dAtA[i] = 0x20
	i++
	i = encodeVarintExpression(dAtA, i, uint64(m.Decimal))
	dAtA[i] = 0x28
	i++
	i = encodeVarintExpression(dAtA, i, uint64(m.Collate))
	dAtA[i] = 0x32
	i++
	i = encodeVarintExpression(dAtA, i, uint64(len(m.Charset)))
	i += copy(dAtA[i:], m.Charset)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Expr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintExpression(dAtA, i, uint64(m.Tp))
	if m.Val != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExpression(dAtA, i, uint64(len(m.Val)))
		i += copy(dAtA[i:], m.Val)
	}
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintExpression(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintExpression(dAtA, i, uint64(m.Sig))
	if m.FieldType != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintExpression(dAtA, i, uint64(m.FieldType.Size()))
		n1, err := m.FieldType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ByItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ByItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Expr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintExpression(dAtA, i, uint64(m.Expr.Size()))
		n2, err := m.Expr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	dAtA[i] = 0x10
	i++
	if m.Desc {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintExpression(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FieldType) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovExpression(uint64(m.Tp))
	n += 1 + sovExpression(uint64(m.Flag))
	n += 1 + sovExpression(uint64(m.Flen))
	n += 1 + sovExpression(uint64(m.Decimal))
	n += 1 + sovExpression(uint64(m.Collate))
	l = len(m.Charset)
	n += 1 + l + sovExpression(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Expr) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovExpression(uint64(m.Tp))
	if m.Val != nil {
		l = len(m.Val)
		n += 1 + l + sovExpression(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovExpression(uint64(l))
		}
	}
	n += 1 + sovExpression(uint64(m.Sig))
	if m.FieldType != nil {
		l = m.FieldType.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ByItem) Size() (n int) {
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	n += 2
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovExpression(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozExpression(x uint64) (n int) {
	return sovExpression(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FieldType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			m.Tp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flen", wireType)
			}
			m.Flen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal", wireType)
			}
			m.Decimal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collate", wireType)
			}
			m.Collate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Collate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Charset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			m.Tp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tp |= (ExprType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = append(m.Val[:0], dAtA[iNdEx:postIndex]...)
			if m.Val == nil {
				m.Val = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &Expr{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			m.Sig = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sig |= (ScalarFuncSig(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldType == nil {
				m.FieldType = &FieldType{}
			}
			if err := m.FieldType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ByItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ByItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ByItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExpression(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthExpression
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowExpression
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipExpression(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthExpression = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExpression   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("expression.proto", fileDescriptorExpression) }

var fileDescriptorExpression = []byte{
	// 1986 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x97, 0x49, 0x70, 0x1b, 0xc7,
	0xd5, 0xc7, 0x35, 0x24, 0x48, 0x91, 0xcd, 0xad, 0xd5, 0x22, 0x85, 0xb1, 0xbe, 0x2a, 0x12, 0xd6,
	0xe7, 0x0a, 0x69, 0x39, 0x61, 0xaa, 0x68, 0x45, 0xc9, 0x21, 0x1b, 0x17, 0x10, 0x41, 0x8a, 0x82,
	0x44, 0x12, 0x52, 0x7c, 0x73, 0x0d, 0x81, 0x06, 0x38, 0xf2, 0x60, 0x06, 0x9a, 0x69, 0xb0, 0x88,
	0x6c, 0x87, 0x24, 0xde, 0xb5, 0xfa, 0x90, 0x38, 0xbb, 0x17, 0x49, 0xce, 0xbe, 0xcb, 0x8a, 0xf7,
	0x2d, 0x8b, 0x54, 0x49, 0x2a, 0xce, 0x52, 0x39, 0xa6, 0x52, 0xca, 0x29, 0xab, 0xe3, 0x6c, 0xe7,
	0xd4, 0x7b, 0xdd, 0xaf, 0x81, 0xa1, 0x6e, 0xd3, 0xff, 0xb7, 0xfc, 0x7f, 0xaf, 0x7b, 0x16, 0x80,
	0x71, 0xb9, 0xdd, 0x8c, 0x65, 0x92, 0xf8, 0x51, 0x38, 0xdb, 0x8c, 0x23, 0x15, 0x89, 0x8c, 0xf2,
	0x9b, 0x1b, 0xfb, 0xc7, 0xeb, 0x51, 0x3d, 0x42, 0xe1, 0xed, 0x70, 0xa5, 0x63, 0x07, 0xae, 0x38,
	0x6c, 0x70, 0xd9, 0x97, 0x41, 0xb5, 0xdc, 0x6e, 0x4a, 0x31, 0xce, 0x7a, 0x54, 0xd3, 0x75, 0x72,
	0xce, 0x4c, 0xdf, 0x42, 0xe6, 0xda, 0xef, 0xa7, 0x76, 0xad, 0xf5, 0xa8, 0xa6, 0x70, 0x59, 0xa6,
	0x16, 0x78, 0x75, 0xb7, 0x27, 0xe7, 0xcc, 0x8c, 0x18, 0x1d, 0x15, 0x1d, 0x91, 0xa1, 0xdb, 0xdb,
	0x55, 0x81, 0x8a, 0x98, 0x64, 0xbb, 0xab, 0xb2, 0xe2, 0x37, 0xbc, 0xc0, 0xcd, 0x74, 0x05, 0x49,
	0x84, 0x78, 0x25, 0x0a, 0x02, 0x4f, 0x49, 0xb7, 0xaf, 0x3b, 0x6e, 0x44, 0x8c, 0x6f, 0x7a, 0x71,
	0x22, 0x95, 0xdb, 0x9f, 0x73, 0x66, 0x06, 0x6d, 0x5c, 0x8b, 0x07, 0x5e, 0x73, 0x58, 0x26, 0xbf,
	0xdd, 0x8c, 0xc5, 0x6d, 0x16, 0x79, 0x74, 0x6e, 0x74, 0x16, 0x26, 0x9d, 0x05, 0x1d, 0xc6, 0xe9,
	0x1a, 0x81, 0xb3, 0xde, 0x2d, 0x2f, 0xc0, 0x09, 0x86, 0xd7, 0xe0, 0x52, 0xbc, 0x85, 0x0d, 0x54,
	0x36, 0xfd, 0xa0, 0x1a, 0x23, 0x7e, 0xef, 0xcc, 0xd0, 0x1c, 0xeb, 0x54, 0xaf, 0xd9, 0x98, 0xb8,
	0x83, 0xf5, 0x26, 0x7e, 0x1d, 0x87, 0x18, 0x9d, 0xdb, 0xab, 0x53, 0xd6, 0x2b, 0x5e, 0xe0, 0xc5,
	0xcb, 0xad, 0xb0, 0xb2, 0xee, 0xd7, 0x8d, 0x0b, 0x64, 0x89, 0x59, 0xc6, 0x6a, 0xb0, 0x99, 0x77,
	0xab, 0x76, 0x53, 0x0f, 0x36, 0x34, 0x37, 0xa6, 0x6b, 0xec, 0x26, 0xaf, 0x0d, 0xd6, 0xe8, 0xf2,
	0xc0, 0x02, 0xeb, 0x5f, 0x68, 0x17, 0x95, 0x6c, 0x88, 0x49, 0x96, 0x81, 0x73, 0xc3, 0x41, 0xd2,
	0x28, 0xa8, 0xc3, 0x4e, 0x57, 0x65, 0x52, 0xc1, 0x09, 0x06, 0x68, 0xa7, 0x41, 0x39, 0xf8, 0x46,
	0x2f, 0x1b, 0xa0, 0x89, 0xc5, 0x00, 0xcb, 0x94, 0x5a, 0x41, 0xc0, 0x77, 0x89, 0x41, 0xd6, 0x57,
	0x0c, 0xd5, 0xe1, 0x43, 0xdc, 0x11, 0x8c, 0xf5, 0x1f, 0xf7, 0xf1, 0xba, 0x47, 0x0c, 0xb1, 0xdd,
	0xcb, 0x41, 0xe4, 0xa9, 0x3b, 0xe7, 0x78, 0xaf, 0x5d, 0x1c, 0x3e, 0xc4, 0x33, 0x90, 0xb5, 0xae,
	0x62, 0x3f, 0xac, 0xf3, 0x3e, 0x28, 0x5e, 0x68, 0x2b, 0x99, 0xf0, 0x7e, 0x31, 0xcc, 0x06, 0x8e,
	0xb4, 0x93, 0x53, 0xc1, 0x82, 0xaf, 0xb8, 0x14, 0x9c, 0x0d, 0xe3, 0x6a, 0x49, 0x1f, 0x23, 0xaf,
	0x89, 0x3d, 0x6c, 0x44, 0x2b, 0xad, 0xd8, 0x53, 0x7e, 0x14, 0xf2, 0xba, 0x18, 0x61, 0x83, 0x28,
	0xe5, 0xc3, 0x56, 0x83, 0x6f, 0xda, 0x0e, 0x1f, 0x90, 0xdb, 0xdc, 0xb7, 0xab, 0x75, 0xa9, 0xf8,
	0x49, 0x9b, 0x5a, 0xf6, 0x1b, 0x92, 0xdf, 0x63, 0x97, 0x1f, 0x4c, 0xa2, 0x90, 0x07, 0x62, 0x94,
	0x0d, 0x9e, 0xf0, 0x82, 0x96, 0x5c, 0xf1, 0x13, 0xc5, 0x3f, 0xe3, 0xc0, 0x7a, 0x31, 0x0a, 0x5a,
	0x8d, 0x70, 0x4d, 0xd6, 0xf8, 0x75, 0x18, 0xac, 0x6f, 0x31, 0x6a, 0x85, 0x8a, 0x3f, 0x93, 0x15,
	0x03, 0xac, 0x77, 0xbd, 0xd5, 0xe0, 0xcf, 0xe2, 0xd5, 0xfc, 0x56, 0x9d, 0x3f, 0x87, 0x57, 0x47,
	0xfc, 0x90, 0x3f, 0xaf, 0xaf, 0xbc, 0x6d, 0xfe, 0x42, 0x16, 0x6a, 0x96, 0xfd, 0x38, 0x51, 0xfc,
	0xc5, 0xac, 0xe0, 0x6c, 0xa8, 0x10, 0x47, 0xad, 0xe6, 0x62, 0x14, 0x56, 0x3c, 0xc5, 0x5f, 0xca,
	0x8a, 0x31, 0xc6, 0xe6, 0xeb, 0xf5, 0xbb, 0x17, 0x7c, 0x35, 0x1f, 0x56, 0xf9, 0xcb, 0x59, 0xb0,
	0x34, 0xc2, 0xd1, 0x98, 0xbf, 0xd2, 0x9d, 0x70, 0x57, 0x14, 0xf3, 0x57, 0xb5, 0xaf, 0xaa, 0xf2,
	0xd7, 0xb2, 0x62, 0x08, 0x36, 0xb0, 0x5a, 0x95, 0x5b, 0xfc, 0x47, 0x58, 0xa7, 0x17, 0xc7, 0xa2,
	0x26, 0xff, 0x31, 0xd6, 0xe9, 0xf5, 0xba, 0xd7, 0x68, 0xf2, 0x9f, 0x60, 0xf6, 0x09, 0x2f, 0x86,
	0xe8, 0x4f, 0xb3, 0x62, 0x98, 0xed, 0x3e, 0xe1, 0xc5, 0x18, 0xba, 0x96, 0x15, 0x23, 0x6c, 0xe0,
	0x84, 0x17, 0xfb, 0x5e, 0x58, 0x91, 0xfc, 0xba, 0x2e, 0xb5, 0x37, 0x1c, 0x3f, 0x5f, 0x3a, 0x78,
	0xf5, 0xff, 0xd8, 0x48, 0xea, 0x16, 0x84, 0x63, 0x59, 0xf4, 0x12, 0x55, 0x0c, 0xd5, 0x7c, 0x52,
	0x0c, 0x15, 0xdf, 0x05, 0xc7, 0x62, 0x95, 0x35, 0xe9, 0x05, 0xdc, 0x11, 0x7b, 0xd9, 0x98, 0x95,
	0xcc, 0x49, 0xf7, 0x88, 0x71, 0xc6, 0xad, 0x48, 0x87, 0xda, 0x9b, 0xaa, 0xc6, 0xa3, 0xc9, 0x88,
	0x09, 0xb6, 0xa7, 0x93, 0x48, 0x67, 0xdd, 0x97, 0xca, 0xc4, 0x53, 0xeb, 0x27, 0x09, 0x5c, 0x35,
	0x0d, 0x13, 0x82, 0x8d, 0x76, 0x24, 0xc4, 0x19, 0x22, 0x67, 0xad, 0x19, 0x9e, 0x61, 0xb2, 0xd1,
	0x2a, 0x01, 0x8d, 0xa4, 0x1b, 0x20, 0xd1, 0xa8, 0xd8, 0xc7, 0x44, 0x57, 0x2a, 0x21, 0x8d, 0xa5,
	0x73, 0x91, 0x89, 0x93, 0x99, 0x69, 0xa8, 0xb1, 0xc6, 0xc9, 0xcc, 0xaa, 0x48, 0x36, 0x21, 0xb2,
	0x6c, 0x6f, 0x4a, 0x36, 0x70, 0xfb, 0x84, 0xcb, 0xc6, 0x53, 0x01, 0xe2, 0xcb, 0xde, 0xd4, 0x09,
	0x11, 0x5d, 0x71, 0x0b, 0x9b, 0x48, 0x17, 0x10, 0xe5, 0x2d, 0x37, 0x55, 0x20, 0xe8, 0x7e, 0x3a,
	0x24, 0x6d, 0xa9, 0x39, 0x27, 0x89, 0x9e, 0x44, 0xc4, 0x9c, 0xa2, 0xf9, 0x49, 0x35, 0x94, 0x39,
	0xc2, 0x27, 0x9d, 0x20, 0x6f, 0xdd, 0xd9, 0x06, 0x19, 0x0f, 0xd0, 0x50, 0x36, 0x9d, 0x10, 0xff,
	0x7f, 0x67, 0x3e, 0x12, 0xde, 0x46, 0xc7, 0x0b, 0xd5, 0x9a, 0x6f, 0x86, 0x76, 0x5c, 0x4b, 0x48,
	0x77, 0x3b, 0x15, 0x6b, 0xcd, 0xb0, 0x1d, 0xa4, 0xa9, 0xb5, 0x4a, 0x64, 0x77, 0xa4, 0x1b, 0x20,
	0xd7, 0x5b, 0x69, 0x3c, 0x93, 0x4a, 0x54, 0x6f, 0x4b, 0xe7, 0x22, 0xd3, 0xac, 0xdd, 0x4c, 0x93,
	0xa5, 0xb9, 0xe6, 0xa8, 0x45, 0x47, 0x46, 0xb6, 0x3b, 0xed, 0x39, 0x5a, 0xdd, 0xf0, 0x1d, 0xb2,
	0x07, 0x66, 0x23, 0xc4, 0xf8, 0x8e, 0x9b, 0x9b, 0x21, 0xe7, 0x61, 0xb1, 0x9f, 0xed, 0xdb, 0x51,
	0x42, 0xac, 0xef, 0xbc, 0xb9, 0x06, 0x79, 0xdf, 0x45, 0x7b, 0x08, 0x2b, 0xcd, 0xfa, 0x6e, 0x1a,
	0x4b, 0x4b, 0xc8, 0xf9, 0x1e, 0xda, 0x43, 0xad, 0x19, 0xc6, 0xf7, 0xd2, 0xb0, 0x5a, 0x25, 0xbe,
	0xf7, 0xa5, 0x1b, 0x20, 0xdb, 0xfb, 0xc9, 0xdf, 0xa4, 0x12, 0xd7, 0x7c, 0x3a, 0x17, 0x99, 0x16,
	0xe0, 0x9d, 0xbf, 0x52, 0x06, 0x96, 0x2a, 0x7c, 0x0a, 0x56, 0xca, 0xc8, 0x20, 0xe1, 0x95, 0xbc,
	0x52, 0xee, 0xbc, 0xee, 0x87, 0xd9, 0xc0, 0x4a, 0xd9, 0xa0, 0xd4, 0x75, 0x22, 0x7a, 0x6d, 0x8a,
	0x51, 0xc6, 0x56, 0xca, 0xd6, 0xc3, 0xd7, 0x31, 0xec, 0x7d, 0x12, 0x7b, 0xe7, 0xa1, 0x77, 0x88,
	0x72, 0x1e, 0x7b, 0x47, 0xd8, 0x3b, 0x4f, 0xbd, 0x9b, 0xd8, 0x3b, 0x6f, 0x7a, 0x9f, 0xd2, 0x89,
	0xd8, 0x3b, 0xc6, 0xde, 0x79, 0xdb, 0x3b, 0xd1, 0x31, 0xec, 0xad, 0xa0, 0x77, 0x01, 0xb9, 0xb7,
	0x41, 0x2e, 0x68, 0xee, 0x36, 0xf4, 0x2e, 0x58, 0xee, 0x0f, 0x43, 0xef, 0x02, 0x71, 0x7f, 0x44,
	0x27, 0x62, 0xef, 0x8f, 0x42, 0xef, 0x42, 0x87, 0xfb, 0x63, 0x3a, 0x86, 0xbd, 0x3f, 0x0e, 0x1f,
	0x8b, 0x02, 0x72, 0x7f, 0xc2, 0x81, 0x17, 0x76, 0x41, 0x83, 0x7f, 0x12, 0xbf, 0x44, 0x05, 0x4b,
	0xfe, 0x29, 0x07, 0x5e, 0xd9, 0x05, 0x42, 0xbf, 0xd7, 0xe4, 0x62, 0xff, 0xfb, 0x1c, 0x78, 0x7f,
	0x17, 0x3a, 0xf0, 0xf7, 0x9b, 0x28, 0x3a, 0x3c, 0x80, 0xdf, 0xb0, 0xfc, 0x2a, 0x58, 0x9c, 0xc6,
	0x40, 0x7e, 0x15, 0x2d, 0xce, 0xa0, 0x45, 0x7e, 0x95, 0x2c, 0xce, 0xa2, 0x45, 0x7e, 0xd5, 0x58,
	0x9c, 0x33, 0xb9, 0x68, 0x71, 0x1e, 0x2d, 0xf2, 0xab, 0xd6, 0xe2, 0x82, 0x89, 0xa2, 0xc5, 0x23,
	0x68, 0x51, 0xc2, 0x29, 0x3e, 0x8d, 0x81, 0x92, 0x9e, 0x42, 0x7f, 0x4f, 0x4b, 0x76, 0x8a, 0x47,
	0xd1, 0xa2, 0x44, 0x53, 0x7c, 0xd6, 0xe4, 0xa2, 0xc5, 0xe7, 0xd0, 0xa2, 0xd4, 0x99, 0xe2, 0xf3,
	0x26, 0x8a, 0x16, 0x5f, 0xd0, 0x9d, 0x5a, 0x41, 0xa0, 0x27, 0x79, 0x4c, 0x67, 0xe3, 0x1a, 0xad,
	0x1e, 0x77, 0x84, 0x60, 0x23, 0x5a, 0x20, 0xbb, 0x27, 0x1c, 0xb1, 0x87, 0x0d, 0x6b, 0xcd, 0x58,
	0x3e, 0xd9, 0x55, 0x87, 0xb6, 0x17, 0xe1, 0xa3, 0x35, 0x6a, 0xea, 0xc8, 0xfa, 0x52, 0x57, 0x16,
	0xda, 0x5f, 0x46, 0xf0, 0x63, 0x41, 0x4b, 0x3f, 0x36, 0xd7, 0x1c, 0xf8, 0xae, 0xc3, 0x92, 0xac,
	0xae, 0x3b, 0xf0, 0x81, 0x05, 0x05, 0xe8, 0x7e, 0x86, 0xb4, 0x47, 0xfc, 0xd0, 0xe4, 0xff, 0x1c,
	0x41, 0x70, 0x4d, 0x05, 0xbf, 0xc0, 0x8e, 0x28, 0x41, 0xc5, 0x2f, 0x75, 0x46, 0x2b, 0x50, 0x7e,
	0x33, 0x68, 0x63, 0xd1, 0xeb, 0x8e, 0x18, 0x67, 0x63, 0x24, 0x51, 0xdd, 0xaf, 0xd0, 0x9a, 0x54,
	0x28, 0xfd, 0x35, 0xc2, 0x2e, 0xf9, 0x5b, 0x7e, 0x55, 0x62, 0xe1, 0x6f, 0x70, 0x2b, 0xb4, 0x40,
	0x65, 0xbf, 0xc5, 0xcd, 0x9c, 0xdf, 0x40, 0xb3, 0x2b, 0x1c, 0x60, 0xe7, 0x37, 0x92, 0xe3, 0xb0,
	0x7a, 0x9a, 0x56, 0x58, 0x7c, 0x95, 0xe3, 0xef, 0x8f, 0x0d, 0x0b, 0xfa, 0x43, 0x0e, 0x64, 0x8b,
	0xd2, 0x0f, 0x8a, 0xa1, 0x2a, 0x47, 0x4b, 0xb2, 0xc2, 0x9f, 0x49, 0x4b, 0xd0, 0xe4, 0x59, 0x2b,
	0x2d, 0xc9, 0x8a, 0x96, 0x9e, 0x4b, 0x4b, 0x50, 0xf8, 0x3c, 0x87, 0xa1, 0x41, 0x42, 0xaf, 0x17,
	0x38, 0x80, 0x2e, 0x07, 0x51, 0x14, 0xdb, 0xde, 0x2f, 0xee, 0xd0, 0xa0, 0xd3, 0x4b, 0x1d, 0xcd,
	0x76, 0x7f, 0x79, 0x87, 0x06, 0xb5, 0xaf, 0x70, 0xd8, 0x76, 0xd4, 0xb0, 0xff, 0xab, 0x38, 0xcb,
	0x4a, 0x54, 0xf7, 0x2b, 0x5e, 0x00, 0x3f, 0xb6, 0xbe, 0xe8, 0x42, 0x82, 0x11, 0x8e, 0xc6, 0xfc,
	0x4b, 0x6e, 0x57, 0x02, 0xfc, 0xd8, 0xfa, 0xb2, 0x0b, 0x80, 0xc7, 0x43, 0x2f, 0x6e, 0x97, 0x22,
	0xc5, 0x1f, 0x73, 0xc1, 0x04, 0x97, 0xf6, 0xa4, 0x2e, 0xba, 0x70, 0xc3, 0x74, 0x34, 0x74, 0xba,
	0xe4, 0x8a, 0x7d, 0x6c, 0x4f, 0x47, 0xa4, 0xcd, 0xbb, 0x8c, 0x0d, 0xcc, 0xaa, 0x98, 0xe0, 0xef,
	0xe6, 0xa7, 0xb0, 0x01, 0xdd, 0x6b, 0x46, 0xfc, 0x0a, 0x92, 0x40, 0x2f, 0x23, 0x7c, 0xd5, 0x85,
	0xdd, 0xd3, 0x77, 0xad, 0x91, 0xbe, 0x86, 0x39, 0x70, 0xd7, 0x1a, 0xe1, 0xeb, 0x38, 0x4e, 0x31,
	0x54, 0x66, 0xfd, 0x0d, 0x4c, 0x80, 0x1b, 0xd6, 0x08, 0xdf, 0xc4, 0x04, 0xfd, 0x4b, 0x73, 0xdd,
	0xaf, 0xf3, 0x6f, 0xe1, 0x78, 0xf8, 0x43, 0x13, 0x96, 0xdf, 0xa6, 0xf0, 0x5d, 0x11, 0xae, 0xbf,
	0x43, 0xeb, 0x92, 0xac, 0xc3, 0xfa, 0xbb, 0x9d, 0xfe, 0xe5, 0xb8, 0x25, 0xf9, 0xf7, 0xba, 0x20,
	0x51, 0xf8, 0x7e, 0x7a, 0x3c, 0xd4, 0x7e, 0x80, 0x49, 0x58, 0xb4, 0xec, 0x05, 0x89, 0xe4, 0x57,
	0x5c, 0xb8, 0x63, 0x75, 0x95, 0x56, 0x9e, 0xd6, 0x3b, 0x40, 0x65, 0x5a, 0xbc, 0xea, 0xc2, 0x4b,
	0xa4, 0x18, 0xc2, 0x1e, 0x3f, 0x3e, 0x05, 0x77, 0x6b, 0x31, 0xc4, 0xbd, 0x7d, 0x62, 0x4a, 0x53,
	0xd0, 0x9e, 0x3e, 0x39, 0x05, 0x43, 0x14, 0x43, 0xf3, 0x44, 0x5f, 0x34, 0xb9, 0xf8, 0x34, 0x5f,
	0x9a, 0xd2, 0xe6, 0xf6, 0x49, 0xbe, 0x6c, 0xa2, 0xf8, 0x14, 0x3f, 0xa5, 0x3b, 0xd5, 0x60, 0x6f,
	0xc0, 0xe6, 0xde, 0x1c, 0x66, 0xe3, 0x1a, 0xad, 0xee, 0xcb, 0xc1, 0x3c, 0x5a, 0x20, 0xbb, 0xfb,
	0x73, 0x70, 0x10, 0x5a, 0x33, 0x96, 0x0f, 0x74, 0xd5, 0xa1, 0xed, 0x83, 0x39, 0x18, 0xc8, 0xd4,
	0x91, 0xf5, 0x43, 0x39, 0x1c, 0xa8, 0x06, 0x4e, 0x0f, 0xe7, 0x10, 0xa3, 0x86, 0x2e, 0xa7, 0x73,
	0x1a, 0x83, 0x1c, 0xce, 0xe4, 0x70, 0xa0, 0x9a, 0xe9, 0x7e, 0xd6, 0xe4, 0x62, 0xe7, 0x73, 0xc6,
	0xca, 0x76, 0x3d, 0xdf, 0xe5, 0x8d, 0x43, 0x5d, 0x30, 0xe9, 0xfa, 0x4d, 0x9c, 0x83, 0xbd, 0x5e,
	0x8c, 0xbc, 0x40, 0x26, 0x15, 0x09, 0xce, 0x7f, 0x42, 0x7c, 0x52, 0xd0, 0xff, 0xcf, 0x39, 0x78,
	0xb1, 0x90, 0x44, 0x14, 0x7f, 0xc1, 0x19, 0x48, 0x35, 0x2c, 0x7f, 0x4d, 0x55, 0x23, 0xd1, 0xdf,
	0x72, 0x62, 0x82, 0x71, 0x5b, 0x4d, 0x5c, 0x7f, 0x4f, 0x65, 0x22, 0xcc, 0x1b, 0x1a, 0xc6, 0x4b,
	0xe4, 0x87, 0x36, 0x25, 0x9e, 0xeb, 0x3f, 0x74, 0x92, 0x51, 0x10, 0xe6, 0x4d, 0x0d, 0x63, 0x24,
	0x82, 0xf9, 0xa7, 0x86, 0x31, 0xaa, 0x81, 0xf9, 0x57, 0xaa, 0x1a, 0x61, 0xfe, 0xad, 0x61, 0xa8,
	0x9a, 0x60, 0xfe, 0x93, 0xca, 0x44, 0x98, 0xff, 0xe6, 0xe0, 0x2d, 0xb7, 0xe2, 0xdf, 0x23, 0xe1,
	0xce, 0xfe, 0xdd, 0xad, 0xd0, 0x1f, 0x02, 0xf9, 0x6d, 0x15, 0x7b, 0x15, 0x05, 0xe2, 0x83, 0xd3,
	0x24, 0x1e, 0x0f, 0x4f, 0xb5, 0x22, 0x85, 0x99, 0x0f, 0x4d, 0xc3, 0x10, 0x20, 0xc2, 0x9f, 0x5f,
	0x50, 0x1e, 0x9e, 0xa6, 0xa7, 0x6c, 0x5d, 0x62, 0xdd, 0xe9, 0x69, 0xb8, 0x6b, 0xf0, 0xb1, 0x0b,
	0x13, 0x19, 0xa3, 0x76, 0xc6, 0xf6, 0x5a, 0x93, 0xcd, 0xc0, 0xab, 0x60, 0xe5, 0x59, 0x9b, 0xb8,
	0x26, 0x1b, 0xd1, 0x16, 0x6a, 0xe7, 0xa6, 0x01, 0x15, 0xb4, 0x23, 0x32, 0xae, 0xa3, 0x74, 0xde,
	0xa6, 0x1d, 0xdd, 0x38, 0x29, 0x35, 0xdb, 0x05, 0x9b, 0x36, 0x1f, 0xc7, 0x5e, 0x1b, 0xa4, 0x47,
	0x30, 0x6d, 0xc9, 0x53, 0x72, 0x39, 0x8a, 0x1b, 0x1e, 0xa6, 0xbd, 0x39, 0xbb, 0x70, 0xfb, 0xb5,
	0x1b, 0x93, 0xce, 0xeb, 0x37, 0x26, 0x9d, 0x3f, 0xdc, 0x98, 0x74, 0x1e, 0xfd, 0xe3, 0xe4, 0x2e,
	0x36, 0x51, 0x89, 0x1a, 0xb3, 0x4d, 0x3f, 0xac, 0x57, 0xbc, 0xe6, 0xac, 0xf2, 0xab, 0x1b, 0xf8,
	0xcf, 0xff, 0x98, 0xf3, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfe, 0x56, 0x43, 0x4f, 0xc7, 0x11,
	0x00, 0x00,
}
