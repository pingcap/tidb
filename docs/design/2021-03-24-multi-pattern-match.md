<!--
This is a template for TiDB's change proposal process, documented [here](./README.md).
-->

# Proposal: Multi-Pattern-Match use Hyperscan

- Author(s): [blacktear23](https://github.com/blacktear23)
- Last updated:  2021-03-24
- Discussion at: N/A

## Table of Contents

* [Introduction](#introduction)
* [Motivation or Background](#motivation-or-background)
* [Detailed Design](#detailed-design)
* [Impacts & Risks](#impacts--risks)

## Introduction

This document contains a design for intergration Hyperscan to provide multi-pattern-match features.

## Motivation or Background

If user want to test a string whether match a bunch of regular expressions, user may iterate all regular expression to test input string matched or not. This way is not fast.

With multi-pattern-match features, we can use those regular expressions to build a database and test each input string that matches the regular expressions in the database. That makes users easy to use. And with Hyperscan library multi-pattern-match will execute faster than iterate all regular expression and test input is matched.

## Detailed Design

### New Functions

This design will introduce some functions with `hs_` prefix to support multi-pattern-match features.

Functions:

  * hs\_match(input, patterns, [format])
  * hs\_match\_json(input, jsonPatterns)
  * hs\_match\_all(input, patterns, [format])
  * hs\_match\_all\_json(input, jsonPatterns)
  * hs\_match\_ids(input, patterns, [format])
  * hs\_match\_ids\_json(input, jsonPatterns)
  * hs\_build\_db\_json(jsonPatterns, [encodeType])

#### hs_match(input, patterns, [format])

match any pattern in patterns

params:

   * input: string, required, table column or string for matching
   * patterns: string, required, patterns format see Patterns Format
   * format: string, optional, patterns format type see Patterns Format, default is `lines`

#### hs\_match\_json(input, jsonPatterns)

match any pattern in patterns

params:

   * input: string, required, table column or string for matching
   * jsonPatterns: string, required, patterns format in json, see Patterns Format

#### hs\_match\_all(input, patterns, [format])

match all pattern in patterns

params:

   * input: string, required, table column or string for matching
   * patterns: string, required, patterns format see Patterns Format
   * format: string, optional, patterns format type see Patterns Format, default is `lines`

#### hs\_match\_all\_json(input, jsonPatterns)

match all pattern in patterns

params:

   * input: string, required, table column or string for matching
   * jsonPatterns: string, required, patterns format in json, see Patterns Format

#### hs\_match\_ids(input, patterns, [format])
   
return matched pattern's id given in patterns, all id is separate by `,`

params:

   * input: string, required, table column or string for matching
   * patterns: string, required, patterns format see Patterns Format
   * format: string, optional, patterns format type see Patterns Format, default is `lines`

#### hs\_match\_ids\_json(input, jsonPatterns)

return matched pattern's id given in patterns, all id is separate by `,`

params:

   * input: string, required, table column or string for matching
   * jsonPatterns: string, required, patterns format in json, see Patterns Format

#### hs\_build\_db\_json(jsonPatterns, [encodeFormat])

build hyperscan database and marshal into encodeFormat

params:

   * jsonPatterns: string, required, patterns format in json, see Patterns Format
   * encodeFormat: string, optional, marshal data encode format should be `hex` or `base64`, default is `hex`

### Patterns Format

There has 4 patterns format:

* lines: each line is a regular expression.
* json: a JSON array contains many regular expressions.
* hex: a hex encoded string that generated by `hs_build_db_json`
* base64: a base64 encoded string that generated by `hs_build_db_json`

Examples:

* lines

	```
	pattern1
	pattern2
	/pattern3/i
	```
* json

	```
	[
		{"id": 1, "pattern": "pattern1"},
		{"id": 2, "pattern": "pattern2"},
		{"id": 3, "pattern": "/pattern3/i"}
	]
	```

In json format each object must contains `pattern` field which store the regular expression, and `id` field is optional. In `hs_match_ids` function all matched pattern's `id` will return as `,` splited string. For example:

```sql
mysql> select * from pats;
+------+
| pat  |
+------+
| abc$ |
| def$ |
| xyz$ |
| data |
+------+
4 rows in set (0.00 sec)

mysql> select t.data, hs_match_ids(t.data, (select group_concat(pat SEPARATOR "\n") from pats)) as `matched` from t;
+------------------+---------+
| data             | matched |
+------------------+---------+
| this is abcdata  | 4       |
| this is data def | 4,2     |
| this is data xyz | 4,3     |
+------------------+---------+
3 rows in set (0.00 sec)
```

## Impacts & Risks

As Hyperscan will dynamically linked so TiDB should introduce a conditional compile method to enable or disable Hyperscan functions support. And user want to use Hyperscan functions should install Hyperscan library first and then build TiDB.

Compile Hyperscan database with too many regular expressions is a heavy operation, so the initial design for `hs_match` series functions will only build Hyperscan database at first time executed and will cache the database untile query finished, so this means the `patterns` parameter will be treated as constant. Below query may generate wrong result:

```
select t.data, hs_match(t.data, t.dynamic_patterns, "json") from t;
```

Please note this, if there has only one regular expression to test input string, Hyperscan is always slower than TiDB builtin `regexp` functions.