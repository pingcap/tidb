# Proposal: Support Plugin

- Author(s):     [lysu](https://github.com/lysu)
- Last updated:  2018-12-10
- Discussion at:

## Abstract

This proposal proposes to introduce the plugin framework to TiDB to support TiDB plugin development.

## Background

There are many cool customize requirements need be address but not convenient to merge to TiDB mainly repo, and Go 1.9+ introduce new plugin support, we can add plugin framework to TiDB to make them can be addressed, and attract more people to mutual build TiDB ecosystem.

## Proposal

Add a plugin framework to TiDB.

## Rationale

Add the plugin framework base on Go's plugin support, but support uniform plugin manifest, package, and flexible SPI.

plugin developer can build a TiDB plugin in 7 steps:

- choose a plugin kind or no suitable need add new plugin kind
- create a normal go package, add `manifest.toml` like example one
- implement `validate`, `init`, `destroy` method which is needed for all plugin
- implement the kind special method to implement plugin logic
- use `cmd/pluginpkg` to build plugin binary, and put plugin binary into plugin deploy folder
- start TiDB with `-plugin-dir` and `-plugin-load` parameter
- `show plugin` to check it's load status

## Implementation

### Go Plugin

We build plugin framework based on Go's plugin support, at first, let's see "what is Go's plugin supported?"

Go's plugin support is simple, just as the document at https://golang.org/pkg/plugin/, we can build and use the plugin in three steps.

- build plugin via `go build -buildmode=plugin` in `main` package to make plugin `.so`
- using `plugin.Open` to `dlopen` plugin's `.so`
- using `plugin.Lookup` to `dlsym` to find symbol in plugin `.so`

There is another "undocumented" but important concept: `pluginpath` also need in the spotlight, just as previously said we let our plugin code into `main` package then `go build -buildmode=plugin` to build a plugin, `pluginpath` is the package path for a plugin after plugin packaged. e.g. we have a method named `DoIt` and `pluginpath` be `pkg1` then we can use `nm` to see method name be `pluginpath.DoIt`. 

`pluginpath` can be given by `-ldflags -pluginpath=[path-value]` or generate by [go build](https://github.com/golang/go/blob/3b137dd2df19c261a007b8a620a2182cd679d700/src/cmd/go/internal/work/gc.go#L389)(for 1.11.1 be package name if build with package folder or be a content hash if build with source file).

So we load a Go plugin with the same pluginpath twice, second `Load` call will be got an error, Go plugin use `pluginpath` to detect duplicate load.

Last things we need to take care of  Go plugin's dependence, at first, almost plugins need to depend on TiDB code to do its logic. Go runtime require runtime hash and link time hash for dependence package is equal. so we no need take care plugin to depend on TiDB some component but its code changed, and we need to release new plugin whenever TiDB new version is released.

### TiDB Plugin

Go plugin give us a good start point, but we need to do something more to let plugin be more uniform and easy to use with TiDB.

#### Manifest

Go Plugin give us the ability to open a shared library, we need some meta info to self-describe plugin, then TiDB can know how to work with the loaded library, we need the following info:

- Plugin name: we need reload plugin, so we need to load the same plugin with a different version that more higher level then `pluginpath`.
- Plugin version: plugin version makes us more easy to maintenance.
- Simple Dependence check: Go help use check build version, but in the real world that's common a plugin relies on b plugin's some new logic, we try to maintain a simple Required-Version relationship between different plugins.
- Configuration: the plugin is a standalone module, so every plugin will introduce special sysVars that just like normal MySQL variables, a user can use those variables to tweak plugin behaviors just like normal MySQL variables does.
- Stats: plugin will introduce new stats info, TiDB uses Prometheus, so the plugin can take free to push metrics to Prometheus.
- Plugin Category and Flexible SPI: TiDB can have limited plugin category and each of them accept same but abstract SPI that need the plugin to implement.

All of above construct the plugin metadata or we normally call it --- `Manifest`, it describes the metadata and how others can use it by the plugin itself.

We just use Go plugin to load plugin and plugin give us a `Manifest`, then just use manifest to interact with the plugin. (Only load/lookup is heavy CGO call, later call manifest is normal Golang method call).

#### SPI

The SPI(Service Provider Interface) for the plugin is the method return manifest and the manifest info itself. manifest return method can be generated by `pluginpkg`, so implement SPI work for the developer is to choose and construct different manifest info(`pluginpkg` also help this).

`Manifest` is base struct for all another sub manifest, the caller can use `Kind` and `DeclareXXManifest` to convert them to sub manifest.

Manifest provides common metadata:

- Kind: plugin's category, now we have an audit, authentication..and easy to add more.
- Name: name for the plugin that uses to identity plugin, so it cannot duplicate with other plugins.
- Version: one plugin we can load multiple versions into TiDB but just active one of them to support hot-fix or hot-upgrade
- RequireVersion: will make a simple relationship between different plugins
- SysVars: define the plugin's configuration info

Manifest also provide three lifecycle extension point: 

- Validate: called after loading all plugins but before onInit, so it can do cross plugins check before init.
- OnInit: let plugin can prepare resource before real work.
- OnShutDown: let plugin can clean up some outer resources before dying.

so we can image a common manifest code like this:

```
type Manifest struct {
    Kind           Kind
    Name           string
    Description    string
    Version        uint16
    RequireVersion map[string]uint16
    License        string
    BuildTime      string
    SysVars        map[string]*variable.SysVar
    Validate       func(ctx context.Context, manifest *Manifest) error
    OnInit         func(ctx context.Context) error
    OnShutdown     func(ctx context.Context) error
}
```

base on `Kind` we can define other subManifest for authentication plugin, audit plugin and so on.

Every subManifest will have a `Manifest` anonymous field as the FIRST field in struct definition, so every subManifest can use as `Manifest`(by `unsafe.Pointer` cast), for example, an audit plugin' manifest will like this:

```
type AuditManifest struct {
    Manifest
    NotifyEvent func(ctx context.Context) error
}
```

Why we chose embedded struct + unsafe.Pointer cast instead of interface way in here is the first way is more flexible than the fixed interface and more efficient to access data member, at last, we also provide the package tools and a helper method to hide those detail to plugin developer. 

#### Package tool

In this proposal, we add a simple tool `cmd/pluginpkg` to help package a plugin, and also uniform the package format.

Plugin's develop event no longer need take care previous Manifest and so on, developer just provide a `manifest.toml` configuration file like this in package:

```
name = "conn_ip_example"
kind = "Audit"
description = "just a test"
version = "2"
license = ""
sysVars = [
    {name="conn_ip_example_test_variable", scope="Global", value="2"},
    {name="conn_ip_example_test_variable2", scope="Session", value="2"},
]
validate = "Validate"
onInit = "OnInit"
onShutdown = "OnShutdown"
export = [
    {extPoint="NotifyEvent", impl="NotifyEvent"}
]
```

- name: name of the plugin, it must be unique in loaded TiDB instance
- kind: kind of plugin, it will determine the call-point in TiDB, package tool also base on it to generate a different manifest
- version: the version of a plugin, for the same plugin and same version only be loaded once
- description: description of plugin usage
- license: license of the plugin, it will display in `show plugins`
- sysVars: define the variable needed by this plugin with name, scope and default value.
- validate: specify the callback function used to validate before load, e.g. auth plugin check `-with-skip-grant-tables` configuration
- onInit: specify the callback function used to init plugin before it joins real work.
- onShutdown: the callback function will be called when plugin shutdown to release outer resource hold by plugin, normally TiDB shutdown.
- export: define callback list for the special kind plugins, e.g. for auth plugin it uses a `NotifyEvent` method to implement `notifyEvent` extension point.

`pluginpkg` will generate code and build as Go plugin, using plugin pkg we also control the plugin binary's format:

- the plugin file name is `[pluginName]-[version].so`, so we can know plugin's version from the filename.
- `pluginpath` will be `[pluginName]-[version]`, then we can load the same plugin in a different version in the same host program
- package tool also add some build time and misc info into Manifest info

Package tools add an abstract layer over manifest, so we can change manifest easier in future if needed. 

#### Plugin Point

In TiDB code, we can add new plugin point in everywhere and:

- call `plugin.GetByKind` or `plugin.Get` to find matched plugins
- call `plugin.Declare[Kind]Manifest` to cast Manifest to a special kind
- call extension point method for special manifest

we can see a simple example in `clientConn#Run` and `conn_ip_example` plugin implement. 

Add new plugin point need to modify TiDB code and pass the required context and parameters.

#### Configuration

Every plugin has its own configurations, TiDB plugin use system variable to handle configuration management requirement.

In `manifest.toml`, we can use `sysVar` field to provide plugin's variable name and its default value. Plugin's system variable will be registered as TiDB system variable, so the user can read/modify variable just like normal system variable.

Plugin's variable name must use plugin name as the prefix. at last, the plugin cannot be reloaded if we change plugin's sysVar(include default-value, add or remove variable)

We implement it by add plugin variable into `variable.SysVars` before `bootstrap`, so later `doDMLWorker` will handle them just as normal sysVars, and change `loadCommonGlobalVarsSQL` to load them. (cannot unload plugin and cannot modify sysVar during reload make this implement easier) 

#### Dependency

Go's plugin mechanism will check all dependency package hash to ensure link time and run time use some version([see code](https://github.com/golang/go/blob/50bd1c4d4eb4fac8ddeb5f063c099daccfb71b26/src/runtime/plugin.go#L52)), so we no longer need to take care compile package dependency.

but for the real world, there is maybe logic dependency between plugin. for example, some guy writes an authorization plugin but it relies on vault plugin and only works if vault enables but isn't directly rely on vault plugin's source code.

In `manifest.toml`, we can use `requireVersion` to declare A plugin require B plugin in X version, then plugin runtime will check it during load or reload phase.

### Reload

Go plugin doesn't support unload a plugin, but it can not stop us to load multiple version plugin into host program and framework ensure last reload one will be active, and others aren't unloaded but disable.

So, we can reload plugin with a different version that is packaged by `pluginpkg` to modify plugin's implement logic, although we can not change the plugin's meta info(e.g. sysVars) now, I think it's still useful.

#### Management

For add a plugin to TiDB, we need:

- add `-plugin-dir` as start argument to specify the folder contains plugins, e.g. '-plugin-dir=/data/deploy/tidb/plugin'
- add `-plugin-load` as start argument to specify the plugin id(name "-" version) that need be load, e.g. '-plugin-load=conn_limit-1'

then start TiDB will load and enable plugins.

we can see all the plugin info by:

```
mysql> show plugins;
+-----------------+--------+-------+----------------------------------------------------+---------+---------+
| Name            | Status | Type  | Library                                            | License | Version |
+-----------------+--------+-------+----------------------------------------------------+---------+---------+
| conn_limit-1    | Ready  | Audit | /data/deploy/tidb/plugin/conn_limit-1.so           |         | 1       |
+-----------------+--------+-------+----------------------------------------------------+---------+---------+
1 row in set (0.00 sec)
```

to reload a loaded plugin, just use

```
mysql> admin plugins reload conn_limit-2;
```

### Limitations

there are some limitations to the plugin, so it can not do:

- unload plugin, once plugin load into TiDB never be unloaded until server restarted, but we can reload plugin in the limited situation to hotfix plugin bug.
- read sysVars in OnInit will get unexpected value but can access `Manifest` to get the config default value
- reload cannot change the sysVar's default value or add/remove variable 
- build plugin need TiDB source code tree, it's different to MySQL that can build plugin standalone(expect Information Schema and Storage Engine plugins)
- only support written plugin in Go
