// Code generated by protoc-gen-gogo.
// source: expression.proto
// DO NOT EDIT!

package tipb

import (
	"fmt"

	proto "github.com/golang/protobuf/proto"
)
import math "math"

// discarding unused import gogoproto "gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type ExprType int32

const (
	// Values are encoded bytes.
	ExprType_Null    ExprType = 0
	ExprType_Int64   ExprType = 1
	ExprType_Uint64  ExprType = 2
	ExprType_Float32 ExprType = 3
	ExprType_Float64 ExprType = 4
	ExprType_String  ExprType = 5
	ExprType_Bytes   ExprType = 6
	// Mysql specific types.
	ExprType_MysqlBit      ExprType = 101
	ExprType_MysqlDecimal  ExprType = 102
	ExprType_MysqlDuration ExprType = 103
	ExprType_MysqlEnum     ExprType = 104
	ExprType_MysqlHex      ExprType = 105
	ExprType_MysqlSet      ExprType = 106
	ExprType_MysqlTime     ExprType = 107
	// Encoded value list.
	ExprType_ValueList ExprType = 151
	// Column reference. value is int64 column ID.
	ExprType_ColumnRef ExprType = 201
	// Unary operations, children count 1.
	ExprType_Not    ExprType = 1001
	ExprType_Neg    ExprType = 1002
	ExprType_BitNeg ExprType = 1003
	// Comparison operations.
	ExprType_LT     ExprType = 2001
	ExprType_LE     ExprType = 2002
	ExprType_EQ     ExprType = 2003
	ExprType_NE     ExprType = 2004
	ExprType_GE     ExprType = 2005
	ExprType_GT     ExprType = 2006
	ExprType_NullEQ ExprType = 2007
	// Bit operations.
	ExprType_BitAnd    ExprType = 2101
	ExprType_BitOr     ExprType = 2102
	ExprType_BitXor    ExprType = 2103
	ExprType_LeftShift ExprType = 2104
	ExprType_RighShift ExprType = 2105
	// Arithmatic.
	ExprType_Plus   ExprType = 2201
	ExprType_Minus  ExprType = 2202
	ExprType_Mul    ExprType = 2203
	ExprType_Div    ExprType = 2204
	ExprType_IntDiv ExprType = 2205
	ExprType_Mod    ExprType = 2206
	// Logic operations.
	ExprType_And ExprType = 2301
	ExprType_Or  ExprType = 2302
	ExprType_Xor ExprType = 2303
	// Aggregate functions.
	ExprType_Count       ExprType = 3001
	ExprType_Sum         ExprType = 3002
	ExprType_Avg         ExprType = 3003
	ExprType_Min         ExprType = 3004
	ExprType_Max         ExprType = 3005
	ExprType_First       ExprType = 3006
	ExprType_GroupConcat ExprType = 3007
	// Math functions.
	ExprType_Abs   ExprType = 3101
	ExprType_Pow   ExprType = 3102
	ExprType_Round ExprType = 3103
	// String functions.
	ExprType_Concat         ExprType = 3201
	ExprType_ConcatWS       ExprType = 3202
	ExprType_Left           ExprType = 3203
	ExprType_Length         ExprType = 3204
	ExprType_Lower          ExprType = 3205
	ExprType_Repeat         ExprType = 3206
	ExprType_Replace        ExprType = 3207
	ExprType_Upper          ExprType = 3208
	ExprType_Strcmp         ExprType = 3209
	ExprType_Convert        ExprType = 3210
	ExprType_Cast           ExprType = 3211
	ExprType_Substring      ExprType = 3212
	ExprType_SubstringIndex ExprType = 3213
	ExprType_Locate         ExprType = 3214
	ExprType_Trim           ExprType = 3215
	// Control flow functions.
	ExprType_If     ExprType = 3301
	ExprType_NullIf ExprType = 3302
	ExprType_IfNull ExprType = 3303
	// Time functions.
	ExprType_Date        ExprType = 3401
	ExprType_DateAdd     ExprType = 3402
	ExprType_DateSub     ExprType = 3403
	ExprType_Year        ExprType = 3411
	ExprType_YearWeek    ExprType = 3412
	ExprType_Month       ExprType = 3421
	ExprType_Week        ExprType = 3431
	ExprType_Weekday     ExprType = 3432
	ExprType_WeekOfYear  ExprType = 3433
	ExprType_Day         ExprType = 3441
	ExprType_DayName     ExprType = 3442
	ExprType_DayOfYear   ExprType = 3443
	ExprType_DayOfMonth  ExprType = 3444
	ExprType_DayOfWeek   ExprType = 3445
	ExprType_Hour        ExprType = 3451
	ExprType_Minute      ExprType = 3452
	ExprType_Second      ExprType = 3453
	ExprType_Microsecond ExprType = 3454
	ExprType_Extract     ExprType = 3461
	// Other functions;
	ExprType_Coalesce ExprType = 3501
	ExprType_Greatest ExprType = 3502
	ExprType_Least    ExprType = 3503
	// Other expressions.
	ExprType_In      ExprType = 4001
	ExprType_IsTruth ExprType = 4002
	ExprType_IsNull  ExprType = 4003
	ExprType_ExprRow ExprType = 4004
	ExprType_Like    ExprType = 4005
	ExprType_RLike   ExprType = 4006
	ExprType_Case    ExprType = 4007
)

var ExprType_name = map[int32]string{
	0:    "Null",
	1:    "Int64",
	2:    "Uint64",
	3:    "Float32",
	4:    "Float64",
	5:    "String",
	6:    "Bytes",
	101:  "MysqlBit",
	102:  "MysqlDecimal",
	103:  "MysqlDuration",
	104:  "MysqlEnum",
	105:  "MysqlHex",
	106:  "MysqlSet",
	107:  "MysqlTime",
	151:  "ValueList",
	201:  "ColumnRef",
	1001: "Not",
	1002: "Neg",
	1003: "BitNeg",
	2001: "LT",
	2002: "LE",
	2003: "EQ",
	2004: "NE",
	2005: "GE",
	2006: "GT",
	2007: "NullEQ",
	2101: "BitAnd",
	2102: "BitOr",
	2103: "BitXor",
	2104: "LeftShift",
	2105: "RighShift",
	2201: "Plus",
	2202: "Minus",
	2203: "Mul",
	2204: "Div",
	2205: "IntDiv",
	2206: "Mod",
	2301: "And",
	2302: "Or",
	2303: "Xor",
	3001: "Count",
	3002: "Sum",
	3003: "Avg",
	3004: "Min",
	3005: "Max",
	3006: "First",
	3007: "GroupConcat",
	3101: "Abs",
	3102: "Pow",
	3103: "Round",
	3201: "Concat",
	3202: "ConcatWS",
	3203: "Left",
	3204: "Length",
	3205: "Lower",
	3206: "Repeat",
	3207: "Replace",
	3208: "Upper",
	3209: "Strcmp",
	3210: "Convert",
	3211: "Cast",
	3212: "Substring",
	3213: "SubstringIndex",
	3214: "Locate",
	3215: "Trim",
	3301: "If",
	3302: "NullIf",
	3303: "IfNull",
	3401: "Date",
	3402: "DateAdd",
	3403: "DateSub",
	3411: "Year",
	3412: "YearWeek",
	3421: "Month",
	3431: "Week",
	3432: "Weekday",
	3433: "WeekOfYear",
	3441: "Day",
	3442: "DayName",
	3443: "DayOfYear",
	3444: "DayOfMonth",
	3445: "DayOfWeek",
	3451: "Hour",
	3452: "Minute",
	3453: "Second",
	3454: "Microsecond",
	3461: "Extract",
	3501: "Coalesce",
	3502: "Greatest",
	3503: "Least",
	4001: "In",
	4002: "IsTruth",
	4003: "IsNull",
	4004: "ExprRow",
	4005: "Like",
	4006: "RLike",
	4007: "Case",
}
var ExprType_value = map[string]int32{
	"Null":           0,
	"Int64":          1,
	"Uint64":         2,
	"Float32":        3,
	"Float64":        4,
	"String":         5,
	"Bytes":          6,
	"MysqlBit":       101,
	"MysqlDecimal":   102,
	"MysqlDuration":  103,
	"MysqlEnum":      104,
	"MysqlHex":       105,
	"MysqlSet":       106,
	"MysqlTime":      107,
	"ValueList":      151,
	"ColumnRef":      201,
	"Not":            1001,
	"Neg":            1002,
	"BitNeg":         1003,
	"LT":             2001,
	"LE":             2002,
	"EQ":             2003,
	"NE":             2004,
	"GE":             2005,
	"GT":             2006,
	"NullEQ":         2007,
	"BitAnd":         2101,
	"BitOr":          2102,
	"BitXor":         2103,
	"LeftShift":      2104,
	"RighShift":      2105,
	"Plus":           2201,
	"Minus":          2202,
	"Mul":            2203,
	"Div":            2204,
	"IntDiv":         2205,
	"Mod":            2206,
	"And":            2301,
	"Or":             2302,
	"Xor":            2303,
	"Count":          3001,
	"Sum":            3002,
	"Avg":            3003,
	"Min":            3004,
	"Max":            3005,
	"First":          3006,
	"GroupConcat":    3007,
	"Abs":            3101,
	"Pow":            3102,
	"Round":          3103,
	"Concat":         3201,
	"ConcatWS":       3202,
	"Left":           3203,
	"Length":         3204,
	"Lower":          3205,
	"Repeat":         3206,
	"Replace":        3207,
	"Upper":          3208,
	"Strcmp":         3209,
	"Convert":        3210,
	"Cast":           3211,
	"Substring":      3212,
	"SubstringIndex": 3213,
	"Locate":         3214,
	"Trim":           3215,
	"If":             3301,
	"NullIf":         3302,
	"IfNull":         3303,
	"Date":           3401,
	"DateAdd":        3402,
	"DateSub":        3403,
	"Year":           3411,
	"YearWeek":       3412,
	"Month":          3421,
	"Week":           3431,
	"Weekday":        3432,
	"WeekOfYear":     3433,
	"Day":            3441,
	"DayName":        3442,
	"DayOfYear":      3443,
	"DayOfMonth":     3444,
	"DayOfWeek":      3445,
	"Hour":           3451,
	"Minute":         3452,
	"Second":         3453,
	"Microsecond":    3454,
	"Extract":        3461,
	"Coalesce":       3501,
	"Greatest":       3502,
	"Least":          3503,
	"In":             4001,
	"IsTruth":        4002,
	"IsNull":         4003,
	"ExprRow":        4004,
	"Like":           4005,
	"RLike":          4006,
	"Case":           4007,
}

func (x ExprType) Enum() *ExprType {
	p := new(ExprType)
	*p = x
	return p
}
func (x ExprType) String() string {
	return proto.EnumName(ExprType_name, int32(x))
}
func (x *ExprType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ExprType_value, data, "ExprType")
	if err != nil {
		return err
	}
	*x = ExprType(value)
	return nil
}

// Evaluators should implement evaluation functions for every expression type.
type Expr struct {
	Tp               ExprType `protobuf:"varint,1,opt,name=tp,enum=tipb.ExprType" json:"tp"`
	Val              []byte   `protobuf:"bytes,2,opt,name=val" json:"val,omitempty"`
	Children         []*Expr  `protobuf:"bytes,3,rep,name=children" json:"children,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Expr) Reset()         { *m = Expr{} }
func (m *Expr) String() string { return proto.CompactTextString(m) }
func (*Expr) ProtoMessage()    {}

func (m *Expr) GetTp() ExprType {
	if m != nil {
		return m.Tp
	}
	return ExprType_Null
}

func (m *Expr) GetVal() []byte {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *Expr) GetChildren() []*Expr {
	if m != nil {
		return m.Children
	}
	return nil
}

// ByItem type for group by and order by.
type ByItem struct {
	Expr             *Expr  `protobuf:"bytes,1,opt,name=expr" json:"expr,omitempty"`
	Desc             bool   `protobuf:"varint,2,opt,name=desc" json:"desc"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ByItem) Reset()         { *m = ByItem{} }
func (m *ByItem) String() string { return proto.CompactTextString(m) }
func (*ByItem) ProtoMessage()    {}

func (m *ByItem) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *ByItem) GetDesc() bool {
	if m != nil {
		return m.Desc
	}
	return false
}

func init() {
	proto.RegisterEnum("tipb.ExprType", ExprType_name, ExprType_value)
}
func (m *Expr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Expr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintExpression(data, i, uint64(m.Tp))
	if m.Val != nil {
		data[i] = 0x12
		i++
		i = encodeVarintExpression(data, i, uint64(len(m.Val)))
		i += copy(data[i:], m.Val)
	}
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			data[i] = 0x1a
			i++
			i = encodeVarintExpression(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ByItem) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ByItem) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Expr != nil {
		data[i] = 0xa
		i++
		i = encodeVarintExpression(data, i, uint64(m.Expr.Size()))
		n1, err := m.Expr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	data[i] = 0x10
	i++
	if m.Desc {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Expression(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Expression(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintExpression(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Expr) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovExpression(uint64(m.Tp))
	if m.Val != nil {
		l = len(m.Val)
		n += 1 + l + sovExpression(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovExpression(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ByItem) Size() (n int) {
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	n += 2
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovExpression(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozExpression(x uint64) (n int) {
	return sovExpression(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Expr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			m.Tp = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Tp |= (ExprType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &Expr{})
			if err := m.Children[len(m.Children)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipExpression(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *ByItem) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipExpression(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func skipExpression(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthExpression
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipExpression(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthExpression = fmt.Errorf("proto: negative length found during unmarshaling")
)
