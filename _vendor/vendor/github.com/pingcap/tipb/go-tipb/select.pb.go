// Code generated by protoc-gen-go.
// source: select.proto
// DO NOT EDIT!

package tipb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// KeyRange is the encoded index key range, low is closed, high is open. (low <= x < high)
type KeyRange struct {
	Low              []byte `protobuf:"bytes,1,opt,name=low" json:"low,omitempty"`
	High             []byte `protobuf:"bytes,2,opt,name=high" json:"high,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *KeyRange) Reset()                    { *m = KeyRange{} }
func (m *KeyRange) String() string            { return proto.CompactTextString(m) }
func (*KeyRange) ProtoMessage()               {}
func (*KeyRange) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *KeyRange) GetLow() []byte {
	if m != nil {
		return m.Low
	}
	return nil
}

func (m *KeyRange) GetHigh() []byte {
	if m != nil {
		return m.High
	}
	return nil
}

// ByItem type for group by and order by.
type ByItem struct {
	Expr             *Expr  `protobuf:"bytes,1,opt,name=expr" json:"expr,omitempty"`
	Desc             *bool  `protobuf:"varint,2,opt,name=desc" json:"desc,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ByItem) Reset()                    { *m = ByItem{} }
func (m *ByItem) String() string            { return proto.CompactTextString(m) }
func (*ByItem) ProtoMessage()               {}
func (*ByItem) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *ByItem) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *ByItem) GetDesc() bool {
	if m != nil && m.Desc != nil {
		return *m.Desc
	}
	return false
}

// SelectRequest works like a simplified select statement.
type SelectRequest struct {
	// transaction start timestamp.
	StartTs *uint64 `protobuf:"varint,1,opt,name=start_ts" json:"start_ts,omitempty"`
	// If table_info is not null, it represents a table scan, index_info would be null.
	TableInfo *TableInfo `protobuf:"bytes,2,opt,name=table_info" json:"table_info,omitempty"`
	// If index_info is not null, it represents an index scan, table_info would be null.
	IndexInfo *IndexInfo `protobuf:"bytes,3,opt,name=index_info" json:"index_info,omitempty"`
	// fields to be selected, fields type can be column reference for simple scan.
	// or aggregation function. If no fields specified, only handle will be returned.
	Fields []*Expr `protobuf:"bytes,4,rep,name=fields" json:"fields,omitempty"`
	// disjoint handle ranges to be scanned.
	Ranges []*KeyRange `protobuf:"bytes,5,rep,name=ranges" json:"ranges,omitempty"`
	// distinct result.
	Distinct *bool `protobuf:"varint,6,opt,name=distinct" json:"distinct,omitempty"`
	// where condition.
	Where *Expr `protobuf:"bytes,7,opt,name=where" json:"where,omitempty"`
	// group by clause.
	GroupBy []*ByItem `protobuf:"bytes,8,rep,name=group_by" json:"group_by,omitempty"`
	// having clause.
	Having *Expr `protobuf:"bytes,9,opt,name=having" json:"having,omitempty"`
	// order by clause.
	OrderBy []*ByItem `protobuf:"bytes,10,rep,name=order_by" json:"order_by,omitempty"`
	// limit the result to be returned.
	Limit *int64 `protobuf:"varint,12,opt,name=limit" json:"limit,omitempty"`
	// aggregate functions
	Aggregates       []*Expr `protobuf:"bytes,13,rep,name=aggregates" json:"aggregates,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SelectRequest) Reset()                    { *m = SelectRequest{} }
func (m *SelectRequest) String() string            { return proto.CompactTextString(m) }
func (*SelectRequest) ProtoMessage()               {}
func (*SelectRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *SelectRequest) GetStartTs() uint64 {
	if m != nil && m.StartTs != nil {
		return *m.StartTs
	}
	return 0
}

func (m *SelectRequest) GetTableInfo() *TableInfo {
	if m != nil {
		return m.TableInfo
	}
	return nil
}

func (m *SelectRequest) GetIndexInfo() *IndexInfo {
	if m != nil {
		return m.IndexInfo
	}
	return nil
}

func (m *SelectRequest) GetFields() []*Expr {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *SelectRequest) GetRanges() []*KeyRange {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *SelectRequest) GetDistinct() bool {
	if m != nil && m.Distinct != nil {
		return *m.Distinct
	}
	return false
}

func (m *SelectRequest) GetWhere() *Expr {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *SelectRequest) GetGroupBy() []*ByItem {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *SelectRequest) GetHaving() *Expr {
	if m != nil {
		return m.Having
	}
	return nil
}

func (m *SelectRequest) GetOrderBy() []*ByItem {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *SelectRequest) GetLimit() int64 {
	if m != nil && m.Limit != nil {
		return *m.Limit
	}
	return 0
}

func (m *SelectRequest) GetAggregates() []*Expr {
	if m != nil {
		return m.Aggregates
	}
	return nil
}

// values are all in text format.
type Row struct {
	Handle           []byte `protobuf:"bytes,1,opt,name=handle" json:"handle,omitempty"`
	Data             []byte `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Row) Reset()                    { *m = Row{} }
func (m *Row) String() string            { return proto.CompactTextString(m) }
func (*Row) ProtoMessage()               {}
func (*Row) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *Row) GetHandle() []byte {
	if m != nil {
		return m.Handle
	}
	return nil
}

func (m *Row) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Aggregate data
type AggItem struct {
	// Count
	Count *int64 `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
	// Sum
	Value []byte `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	// Other data
	Data             []byte `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *AggItem) Reset()                    { *m = AggItem{} }
func (m *AggItem) String() string            { return proto.CompactTextString(m) }
func (*AggItem) ProtoMessage()               {}
func (*AggItem) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

func (m *AggItem) GetCount() int64 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *AggItem) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *AggItem) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Partial aggregate result for a sinlge group from part of data.
type AggGroupEntry struct {
	// Group key.
	Key []byte `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// Partial result for the group for the expr.
	Item             *AggItem `protobuf:"bytes,2,opt,name=item" json:"item,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *AggGroupEntry) Reset()                    { *m = AggGroupEntry{} }
func (m *AggGroupEntry) String() string            { return proto.CompactTextString(m) }
func (*AggGroupEntry) ProtoMessage()               {}
func (*AggGroupEntry) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

func (m *AggGroupEntry) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *AggGroupEntry) GetItem() *AggItem {
	if m != nil {
		return m.Item
	}
	return nil
}

type AggExpr struct {
	// Partial result for the expr.
	Groups           []*AggGroupEntry `protobuf:"bytes,1,rep,name=groups" json:"groups,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *AggExpr) Reset()                    { *m = AggExpr{} }
func (m *AggExpr) String() string            { return proto.CompactTextString(m) }
func (*AggExpr) ProtoMessage()               {}
func (*AggExpr) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{6} }

func (m *AggExpr) GetGroups() []*AggGroupEntry {
	if m != nil {
		return m.Groups
	}
	return nil
}

type Error struct {
	Code             *int32  `protobuf:"varint,1,opt,name=code" json:"code,omitempty"`
	Msg              *string `protobuf:"bytes,2,opt,name=msg" json:"msg,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{7} }

func (m *Error) GetCode() int32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *Error) GetMsg() string {
	if m != nil && m.Msg != nil {
		return *m.Msg
	}
	return ""
}

// Response for SelectRequest.
type SelectResponse struct {
	Error *Error `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	// Result rows.
	Rows []*Row `protobuf:"bytes,2,rep,name=rows" json:"rows,omitempty"`
	// Aggregate partial result from a single region.
	Aggs             []*AggExpr `protobuf:"bytes,3,rep,name=aggs" json:"aggs,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *SelectResponse) Reset()                    { *m = SelectResponse{} }
func (m *SelectResponse) String() string            { return proto.CompactTextString(m) }
func (*SelectResponse) ProtoMessage()               {}
func (*SelectResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{8} }

func (m *SelectResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *SelectResponse) GetRows() []*Row {
	if m != nil {
		return m.Rows
	}
	return nil
}

func (m *SelectResponse) GetAggs() []*AggExpr {
	if m != nil {
		return m.Aggs
	}
	return nil
}

func init() {
	proto.RegisterType((*KeyRange)(nil), "tipb.KeyRange")
	proto.RegisterType((*ByItem)(nil), "tipb.ByItem")
	proto.RegisterType((*SelectRequest)(nil), "tipb.SelectRequest")
	proto.RegisterType((*Row)(nil), "tipb.Row")
	proto.RegisterType((*AggItem)(nil), "tipb.AggItem")
	proto.RegisterType((*AggGroupEntry)(nil), "tipb.AggGroupEntry")
	proto.RegisterType((*AggExpr)(nil), "tipb.AggExpr")
	proto.RegisterType((*Error)(nil), "tipb.Error")
	proto.RegisterType((*SelectResponse)(nil), "tipb.SelectResponse")
}

var fileDescriptor2 = []byte{
	// 498 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x6c, 0x52, 0x41, 0x6b, 0x1b, 0x3d,
	0x10, 0xc5, 0xd9, 0x5d, 0xc7, 0x1e, 0xaf, 0xfd, 0x85, 0xfd, 0x28, 0x55, 0x5c, 0x08, 0x61, 0x4d,
	0xa1, 0x27, 0x53, 0x02, 0x3d, 0xf4, 0xd8, 0x80, 0x29, 0xa6, 0x97, 0xe2, 0xf6, 0x6e, 0xe4, 0xdd,
	0x89, 0x2c, 0xba, 0x96, 0xb6, 0x92, 0x1c, 0xc7, 0xbf, 0xb6, 0x7f, 0xa5, 0x1a, 0x69, 0xe3, 0xb4,
	0x69, 0x8e, 0x9a, 0x79, 0x6f, 0xde, 0x7b, 0x33, 0x82, 0xdc, 0x62, 0x83, 0x95, 0x9b, 0xb7, 0x46,
	0x3b, 0x5d, 0xa4, 0x4e, 0xb6, 0x9b, 0xe9, 0x05, 0x3e, 0xb4, 0x06, 0xad, 0x95, 0x5a, 0xc5, 0xfa,
	0x34, 0xb7, 0xd5, 0x16, 0x77, 0x3c, 0xbe, 0xca, 0xb7, 0x30, 0xf8, 0x82, 0xc7, 0x15, 0x57, 0x02,
	0x8b, 0x11, 0x24, 0x8d, 0x3e, 0xb0, 0xde, 0x75, 0xef, 0x5d, 0x5e, 0xe4, 0x90, 0x6e, 0xa5, 0xd8,
	0xb2, 0x33, 0x7a, 0x95, 0xef, 0xa1, 0x7f, 0x7b, 0x5c, 0x3a, 0xdc, 0x15, 0x0c, 0x52, 0x1a, 0x19,
	0x50, 0xa3, 0x1b, 0x98, 0x93, 0xca, 0x7c, 0xe1, 0x2b, 0xc4, 0xa8, 0xd1, 0x56, 0x81, 0x31, 0x28,
	0x7f, 0x9d, 0xc1, 0xf8, 0x5b, 0xf0, 0xb3, 0xc2, 0x9f, 0x7b, 0xb4, 0xae, 0xb8, 0x80, 0x81, 0x75,
	0xdc, 0xb8, 0xb5, 0xb3, 0x81, 0x9d, 0x16, 0x33, 0x00, 0xc7, 0x37, 0x0d, 0xae, 0xa5, 0xba, 0xd3,
	0x81, 0x37, 0xba, 0xf9, 0x2f, 0x4e, 0xfc, 0x4e, 0xf5, 0xa5, 0x2f, 0x13, 0x48, 0xaa, 0x1a, 0x1f,
	0x22, 0x28, 0xf9, 0x13, 0xb4, 0xa4, 0x7a, 0x00, 0x4d, 0xa1, 0x7f, 0x27, 0xb1, 0xa9, 0x2d, 0x4b,
	0xaf, 0x93, 0x67, 0xbe, 0xae, 0xa0, 0x6f, 0x28, 0x9f, 0x65, 0x59, 0xe8, 0x4d, 0x62, 0xef, 0x14,
	0xdb, 0xfb, 0xaa, 0xa5, 0x75, 0x52, 0x55, 0x8e, 0xf5, 0xc9, 0x7b, 0x71, 0x09, 0xd9, 0x61, 0x8b,
	0x06, 0xd9, 0xf9, 0x3f, 0x21, 0xaf, 0x60, 0x20, 0x8c, 0xde, 0xb7, 0xeb, 0xcd, 0x91, 0x0d, 0xc2,
	0xb8, 0x3c, 0x76, 0xbb, 0xf5, 0x78, 0x23, 0x5b, 0x7e, 0x2f, 0x95, 0x60, 0xc3, 0x97, 0xb8, 0xda,
	0xd4, 0x68, 0x88, 0x0b, 0x2f, 0x70, 0xc7, 0x90, 0x35, 0x72, 0x27, 0x1d, 0xcb, 0x3d, 0x35, 0xf1,
	0x70, 0xe0, 0x42, 0x18, 0x14, 0xdc, 0x79, 0xef, 0xe3, 0xe7, 0xb9, 0xca, 0x19, 0x24, 0x2b, 0x7d,
	0x28, 0x26, 0xa4, 0xa8, 0xea, 0x06, 0x9f, 0x0e, 0x57, 0x73, 0xc7, 0xbb, 0xc3, 0x7d, 0x80, 0xf3,
	0x4f, 0x42, 0x3c, 0x8e, 0xaf, 0xf4, 0x5e, 0xb9, 0x80, 0x4b, 0xe8, 0x79, 0xcf, 0x9b, 0x3d, 0x46,
	0xe0, 0x89, 0x96, 0x04, 0xda, 0x47, 0x18, 0x7b, 0xda, 0x67, 0x4a, 0xba, 0x50, 0xce, 0x1c, 0xe9,
	0x6f, 0xfc, 0xc0, 0x63, 0x27, 0xf1, 0x06, 0x52, 0xe9, 0x27, 0x76, 0x17, 0x1b, 0x47, 0x4f, 0x9d,
	0x4c, 0x39, 0x0f, 0x8a, 0x21, 0xf0, 0x0c, 0xfa, 0x61, 0x59, 0x74, 0x6f, 0x72, 0xff, 0xff, 0x09,
	0xf9, 0x34, 0xb9, 0x2c, 0x21, 0x5b, 0x18, 0xa3, 0xc3, 0xff, 0xa9, 0x74, 0x1d, 0x63, 0x64, 0x24,
	0xb8, 0xb3, 0x22, 0x48, 0x0c, 0xcb, 0x0d, 0x4c, 0x1e, 0xff, 0x92, 0x6d, 0xb5, 0xb2, 0xe8, 0xf7,
	0x9c, 0x21, 0xb1, 0xba, 0x7f, 0x38, 0xea, 0xf6, 0x12, 0x06, 0xbd, 0x86, 0xd4, 0xe8, 0x83, 0xf5,
	0x5c, 0x12, 0x1d, 0xc6, 0x16, 0xad, 0xca, 0xfb, 0xf6, 0x1b, 0xb5, 0x3e, 0x63, 0xf2, 0x97, 0x6f,
	0x32, 0x7b, 0x7b, 0x09, 0xaf, 0x2a, 0xbd, 0x9b, 0xb7, 0xfe, 0x76, 0x15, 0x6f, 0x7d, 0xaf, 0xde,
	0x04, 0xc0, 0xd7, 0xde, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x03, 0x58, 0x95, 0xd1, 0x59, 0x03,
	0x00, 0x00,
}
