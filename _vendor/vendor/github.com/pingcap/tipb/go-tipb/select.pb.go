// Code generated by protoc-gen-go.
// source: select.proto
// DO NOT EDIT!

package tipb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// KeyRange is the encoded index key range, low is closed, high is open. (low <= x < high)
type KeyRange struct {
	Low              []byte `protobuf:"bytes,1,opt,name=low" json:"low,omitempty"`
	High             []byte `protobuf:"bytes,2,opt,name=high" json:"high,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *KeyRange) Reset()                    { *m = KeyRange{} }
func (m *KeyRange) String() string            { return proto.CompactTextString(m) }
func (*KeyRange) ProtoMessage()               {}
func (*KeyRange) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *KeyRange) GetLow() []byte {
	if m != nil {
		return m.Low
	}
	return nil
}

func (m *KeyRange) GetHigh() []byte {
	if m != nil {
		return m.High
	}
	return nil
}

// ByItem type for group by and order by.
type ByItem struct {
	Expr             *Expr  `protobuf:"bytes,1,opt,name=expr" json:"expr,omitempty"`
	Desc             *bool  `protobuf:"varint,2,opt,name=desc" json:"desc,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ByItem) Reset()                    { *m = ByItem{} }
func (m *ByItem) String() string            { return proto.CompactTextString(m) }
func (*ByItem) ProtoMessage()               {}
func (*ByItem) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *ByItem) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *ByItem) GetDesc() bool {
	if m != nil && m.Desc != nil {
		return *m.Desc
	}
	return false
}

// SelectRequest works like a simplified select statement.
type SelectRequest struct {
	// transaction start timestamp.
	StartTs *uint64 `protobuf:"varint,1,opt,name=start_ts" json:"start_ts,omitempty"`
	// If table_info is not null, it represents a table scan, index_info would be null.
	TableInfo *TableInfo `protobuf:"bytes,2,opt,name=table_info" json:"table_info,omitempty"`
	// If index_info is not null, it represents an index scan, table_info would be null.
	IndexInfo *IndexInfo `protobuf:"bytes,3,opt,name=index_info" json:"index_info,omitempty"`
	// fields to be selected, fields type can be column reference for simple scan.
	// or aggregation function. If no fields specified, only handle will be returned.
	Fields []*Expr `protobuf:"bytes,4,rep,name=fields" json:"fields,omitempty"`
	// disjoint handle ranges to be scanned.
	Ranges []*KeyRange `protobuf:"bytes,5,rep,name=ranges" json:"ranges,omitempty"`
	// distinct result.
	Distinct *bool `protobuf:"varint,6,opt,name=distinct" json:"distinct,omitempty"`
	// where condition.
	Where *Expr `protobuf:"bytes,7,opt,name=where" json:"where,omitempty"`
	// group by clause.
	GroupBy []*ByItem `protobuf:"bytes,8,rep,name=group_by" json:"group_by,omitempty"`
	// having clause.
	Having *Expr `protobuf:"bytes,9,opt,name=having" json:"having,omitempty"`
	// order by clause.
	OrderBy []*ByItem `protobuf:"bytes,10,rep,name=order_by" json:"order_by,omitempty"`
	// limit the result to be returned.
	Limit *int64 `protobuf:"varint,12,opt,name=limit" json:"limit,omitempty"`
	// aggregate functions
	Aggregates       []*Expr `protobuf:"bytes,13,rep,name=aggregates" json:"aggregates,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SelectRequest) Reset()                    { *m = SelectRequest{} }
func (m *SelectRequest) String() string            { return proto.CompactTextString(m) }
func (*SelectRequest) ProtoMessage()               {}
func (*SelectRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *SelectRequest) GetStartTs() uint64 {
	if m != nil && m.StartTs != nil {
		return *m.StartTs
	}
	return 0
}

func (m *SelectRequest) GetTableInfo() *TableInfo {
	if m != nil {
		return m.TableInfo
	}
	return nil
}

func (m *SelectRequest) GetIndexInfo() *IndexInfo {
	if m != nil {
		return m.IndexInfo
	}
	return nil
}

func (m *SelectRequest) GetFields() []*Expr {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *SelectRequest) GetRanges() []*KeyRange {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *SelectRequest) GetDistinct() bool {
	if m != nil && m.Distinct != nil {
		return *m.Distinct
	}
	return false
}

func (m *SelectRequest) GetWhere() *Expr {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *SelectRequest) GetGroupBy() []*ByItem {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *SelectRequest) GetHaving() *Expr {
	if m != nil {
		return m.Having
	}
	return nil
}

func (m *SelectRequest) GetOrderBy() []*ByItem {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *SelectRequest) GetLimit() int64 {
	if m != nil && m.Limit != nil {
		return *m.Limit
	}
	return 0
}

func (m *SelectRequest) GetAggregates() []*Expr {
	if m != nil {
		return m.Aggregates
	}
	return nil
}

// values are all in text format.
type Row struct {
	Handle           []byte `protobuf:"bytes,1,opt,name=handle" json:"handle,omitempty"`
	Data             []byte `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Row) Reset()                    { *m = Row{} }
func (m *Row) String() string            { return proto.CompactTextString(m) }
func (*Row) ProtoMessage()               {}
func (*Row) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *Row) GetHandle() []byte {
	if m != nil {
		return m.Handle
	}
	return nil
}

func (m *Row) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type Error struct {
	Code             *int32  `protobuf:"varint,1,opt,name=code" json:"code,omitempty"`
	Msg              *string `protobuf:"bytes,2,opt,name=msg" json:"msg,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

func (m *Error) GetCode() int32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *Error) GetMsg() string {
	if m != nil && m.Msg != nil {
		return *m.Msg
	}
	return ""
}

// Response for SelectRequest.
type SelectResponse struct {
	Error *Error `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	// Result rows.
	Rows             []*Row `protobuf:"bytes,2,rep,name=rows" json:"rows,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SelectResponse) Reset()                    { *m = SelectResponse{} }
func (m *SelectResponse) String() string            { return proto.CompactTextString(m) }
func (*SelectResponse) ProtoMessage()               {}
func (*SelectResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

func (m *SelectResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *SelectResponse) GetRows() []*Row {
	if m != nil {
		return m.Rows
	}
	return nil
}

func init() {
	proto.RegisterType((*KeyRange)(nil), "tipb.KeyRange")
	proto.RegisterType((*ByItem)(nil), "tipb.ByItem")
	proto.RegisterType((*SelectRequest)(nil), "tipb.SelectRequest")
	proto.RegisterType((*Row)(nil), "tipb.Row")
	proto.RegisterType((*Error)(nil), "tipb.Error")
	proto.RegisterType((*SelectResponse)(nil), "tipb.SelectResponse")
}

var fileDescriptor2 = []byte{
	// 408 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x6c, 0x51, 0xcb, 0x6e, 0xdb, 0x30,
	0x10, 0x84, 0x23, 0xc9, 0x95, 0xd7, 0xb2, 0x1b, 0x10, 0x28, 0xca, 0xf8, 0x10, 0x04, 0x0a, 0x0a,
	0xf4, 0x64, 0x14, 0xf9, 0x84, 0x00, 0x3e, 0x18, 0xbd, 0x14, 0x6e, 0xef, 0x06, 0x2d, 0x6e, 0x28,
	0x02, 0x12, 0xa9, 0x92, 0x4c, 0x15, 0x7f, 0x6d, 0x7f, 0xa5, 0x7c, 0xa8, 0x0f, 0xa4, 0x3e, 0x72,
	0x76, 0x66, 0x77, 0x86, 0x03, 0x95, 0xc5, 0x0e, 0x1b, 0xb7, 0x1d, 0x8c, 0x76, 0x9a, 0xe4, 0x4e,
	0x0e, 0xa7, 0xcd, 0x35, 0xbe, 0x0c, 0x06, 0xad, 0x95, 0x5a, 0x25, 0x7c, 0x53, 0xd9, 0xa6, 0xc5,
	0x9e, 0xa5, 0x57, 0xfd, 0x01, 0xca, 0xcf, 0x78, 0x3e, 0x30, 0x25, 0x90, 0x2c, 0x21, 0xeb, 0xf4,
	0x48, 0x67, 0x77, 0xb3, 0x8f, 0x15, 0xa9, 0x20, 0x6f, 0xa5, 0x68, 0xe9, 0x55, 0x78, 0xd5, 0x9f,
	0x60, 0xfe, 0x78, 0xde, 0x3b, 0xec, 0x09, 0x85, 0x3c, 0xac, 0x8c, 0xac, 0xe5, 0x03, 0x6c, 0xc3,
	0x95, 0xed, 0xce, 0x23, 0x41, 0xc1, 0xd1, 0x36, 0x51, 0x51, 0xd6, 0x3f, 0xaf, 0x60, 0xf5, 0x35,
	0xfa, 0x39, 0xe0, 0xf7, 0x67, 0xb4, 0x8e, 0x5c, 0x43, 0x69, 0x1d, 0x33, 0xee, 0xe8, 0x6c, 0x54,
	0xe7, 0xe4, 0x1e, 0xc0, 0xb1, 0x53, 0x87, 0x47, 0xa9, 0x9e, 0x74, 0xd4, 0x2d, 0x1f, 0xde, 0xa6,
	0x8d, 0xdf, 0x02, 0xbe, 0xf7, 0x70, 0x20, 0x49, 0xc5, 0xf1, 0x25, 0x91, 0xb2, 0x7f, 0x49, 0xfb,
	0x80, 0x47, 0xd2, 0x06, 0xe6, 0x4f, 0x12, 0x3b, 0x6e, 0x69, 0x7e, 0x97, 0xbd, 0xf2, 0x75, 0x0b,
	0x73, 0x13, 0xf2, 0x59, 0x5a, 0xc4, 0xd9, 0x3a, 0xcd, 0xfe, 0xc4, 0xf6, 0xbe, 0xb8, 0xb4, 0x4e,
	0xaa, 0xc6, 0xd1, 0x79, 0xf0, 0x4e, 0x6e, 0xa0, 0x18, 0x5b, 0x34, 0x48, 0xdf, 0xfc, 0x17, 0xf2,
	0x16, 0x4a, 0x61, 0xf4, 0xf3, 0x70, 0x3c, 0x9d, 0x69, 0x19, 0xd7, 0x55, 0x69, 0x3a, 0x7d, 0x8f,
	0x37, 0xd2, 0xb2, 0x1f, 0x52, 0x09, 0xba, 0xb8, 0xa4, 0xd5, 0x86, 0xa3, 0x09, 0x5a, 0xb8, 0xa0,
	0x5d, 0x41, 0xd1, 0xc9, 0x5e, 0x3a, 0x5a, 0x79, 0x69, 0xe6, 0xe9, 0xc0, 0x84, 0x30, 0x28, 0x98,
	0xf3, 0xde, 0x57, 0xaf, 0x73, 0xd5, 0xf7, 0x90, 0x1d, 0xf4, 0x48, 0xd6, 0xe1, 0xa2, 0xe2, 0x1d,
	0xfe, 0x2d, 0x8e, 0x33, 0xc7, 0xa6, 0xe2, 0x6a, 0x28, 0x76, 0xc6, 0xe8, 0xd8, 0x4e, 0xa3, 0x79,
	0x22, 0x15, 0xa1, 0xea, 0xde, 0x8a, 0xc8, 0x59, 0xd4, 0x3b, 0x58, 0xff, 0x6e, 0xca, 0x0e, 0x5a,
	0x59, 0xf4, 0x29, 0x0a, 0x0c, 0xaa, 0xa9, 0xe5, 0xe5, 0x74, 0x35, 0x2e, 0x7a, 0x0f, 0xb9, 0xd1,
	0xa3, 0xf5, 0xda, 0x60, 0x68, 0x91, 0x46, 0xde, 0xc8, 0xe3, 0x0d, 0xbc, 0x6b, 0x74, 0xbf, 0x1d,
	0x7c, 0xf8, 0x86, 0x0d, 0x1e, 0xe7, 0xa7, 0x38, 0xfc, 0x32, 0xfb, 0x15, 0x00, 0x00, 0xff, 0xff,
	0xd6, 0xbb, 0xa2, 0x37, 0x9a, 0x02, 0x00, 0x00,
}
