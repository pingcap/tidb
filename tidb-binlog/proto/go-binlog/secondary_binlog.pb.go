// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: secondary_binlog.proto

/*
Package slave_binlog is a generated protocol buffer package.

It is generated from these files:

	secondary_binlog.proto

It has these top-level messages:

	Column
	ColumnInfo
	Row
	Table
	Key
	TableMutation
	DMLData
	DDLData
	Binlog
*/
package slave_binlog

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"

	github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"
	proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type MutationType int32

const (
	MutationType_Insert MutationType = 0
	MutationType_Update MutationType = 1
	MutationType_Delete MutationType = 2
)

var MutationType_name = map[int32]string{
	0: "Insert",
	1: "Update",
	2: "Delete",
}

var MutationType_value = map[string]int32{
	"Insert": 0,
	"Update": 1,
	"Delete": 2,
}

func (x MutationType) Enum() *MutationType {
	p := new(MutationType)
	*p = x
	return p
}

func (x MutationType) String() string {
	return proto.EnumName(MutationType_name, int32(x))
}

func (x *MutationType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MutationType_value, data, "MutationType")
	if err != nil {
		return err
	}
	*x = MutationType(value)
	return nil
}

func (MutationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3e5ebd7aa3410f61, []int{0}
}

type BinlogType int32

const (
	BinlogType_DML BinlogType = 0
	BinlogType_DDL BinlogType = 1
)

var BinlogType_name = map[int32]string{
	0: "DML",
	1: "DDL",
}

var BinlogType_value = map[string]int32{
	"DML": 0,
	"DDL": 1,
}

func (x BinlogType) Enum() *BinlogType {
	p := new(BinlogType)
	*p = x
	return p
}

func (x BinlogType) String() string {
	return proto.EnumName(BinlogType_name, int32(x))
}

func (x *BinlogType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(BinlogType_value, data, "BinlogType")
	if err != nil {
		return err
	}
	*x = BinlogType(value)
	return nil
}

func (BinlogType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3e5ebd7aa3410f61, []int{1}
}

// for text and char type, string_value is set
// for blob and binary type, bytes_value is set
// for enum, set, uint64_value is set
// for json, bytes_value is set
type Column struct {
	IsNull               *bool    `protobuf:"varint,1,opt,name=is_null,json=isNull,def=0" json:"is_null,omitempty"`
	Int64Value           *int64   `protobuf:"varint,2,opt,name=int64_value,json=int64Value" json:"int64_value,omitempty"`
	Uint64Value          *uint64  `protobuf:"varint,3,opt,name=uint64_value,json=uint64Value" json:"uint64_value,omitempty"`
	DoubleValue          *float64 `protobuf:"fixed64,4,opt,name=double_value,json=doubleValue" json:"double_value,omitempty"`
	BytesValue           []byte   `protobuf:"bytes,5,opt,name=bytes_value,json=bytesValue" json:"bytes_value,omitempty"`
	StringValue          *string  `protobuf:"bytes,6,opt,name=string_value,json=stringValue" json:"string_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Column) Reset()         { *m = Column{} }
func (m *Column) String() string { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()    {}
func (*Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e5ebd7aa3410f61, []int{0}
}
func (m *Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Column.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Column.Merge(m, src)
}
func (m *Column) XXX_Size() int {
	return m.Size()
}
func (m *Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Column proto.InternalMessageInfo

const Default_Column_IsNull bool = false

func (m *Column) GetIsNull() bool {
	if m != nil && m.IsNull != nil {
		return *m.IsNull
	}
	return Default_Column_IsNull
}

func (m *Column) GetInt64Value() int64 {
	if m != nil && m.Int64Value != nil {
		return *m.Int64Value
	}
	return 0
}

func (m *Column) GetUint64Value() uint64 {
	if m != nil && m.Uint64Value != nil {
		return *m.Uint64Value
	}
	return 0
}

func (m *Column) GetDoubleValue() float64 {
	if m != nil && m.DoubleValue != nil {
		return *m.DoubleValue
	}
	return 0
}

func (m *Column) GetBytesValue() []byte {
	if m != nil {
		return m.BytesValue
	}
	return nil
}

func (m *Column) GetStringValue() string {
	if m != nil && m.StringValue != nil {
		return *m.StringValue
	}
	return ""
}

type ColumnInfo struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// lower case column field type in mysql
	// https://dev.mysql.com/doc/refman/8.0/en/data-types.html
	// for numeric type: int bigint smallint tinyint float double decimal bit
	// for string type: text longtext mediumtext char tinytext varchar
	// blob longblob mediumblob binary tinyblob varbinary
	// enum set
	// for json type: json
	MysqlType            string   `protobuf:"bytes,2,opt,name=mysql_type,json=mysqlType" json:"mysql_type"`
	IsPrimaryKey         bool     `protobuf:"varint,3,opt,name=is_primary_key,json=isPrimaryKey" json:"is_primary_key"`
	Flen                 int32    `protobuf:"varint,4,opt,name=flen" json:"flen"`
	Decimal              int32    `protobuf:"varint,5,opt,name=decimal" json:"decimal"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColumnInfo) Reset()         { *m = ColumnInfo{} }
func (m *ColumnInfo) String() string { return proto.CompactTextString(m) }
func (*ColumnInfo) ProtoMessage()    {}
func (*ColumnInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e5ebd7aa3410f61, []int{1}
}
func (m *ColumnInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColumnInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnInfo.Merge(m, src)
}
func (m *ColumnInfo) XXX_Size() int {
	return m.Size()
}
func (m *ColumnInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnInfo proto.InternalMessageInfo

func (m *ColumnInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ColumnInfo) GetMysqlType() string {
	if m != nil {
		return m.MysqlType
	}
	return ""
}

func (m *ColumnInfo) GetIsPrimaryKey() bool {
	if m != nil {
		return m.IsPrimaryKey
	}
	return false
}

func (m *ColumnInfo) GetFlen() int32 {
	if m != nil {
		return m.Flen
	}
	return 0
}

func (m *ColumnInfo) GetDecimal() int32 {
	if m != nil {
		return m.Decimal
	}
	return 0
}

type Row struct {
	Columns              []*Column `protobuf:"bytes,1,rep,name=columns" json:"columns,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Row) Reset()         { *m = Row{} }
func (m *Row) String() string { return proto.CompactTextString(m) }
func (*Row) ProtoMessage()    {}
func (*Row) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e5ebd7aa3410f61, []int{2}
}
func (m *Row) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Row) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Row.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Row) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Row.Merge(m, src)
}
func (m *Row) XXX_Size() int {
	return m.Size()
}
func (m *Row) XXX_DiscardUnknown() {
	xxx_messageInfo_Row.DiscardUnknown(m)
}

var xxx_messageInfo_Row proto.InternalMessageInfo

func (m *Row) GetColumns() []*Column {
	if m != nil {
		return m.Columns
	}
	return nil
}

// Table contains mutations in a table.
type Table struct {
	SchemaName *string          `protobuf:"bytes,1,opt,name=schema_name,json=schemaName" json:"schema_name,omitempty"`
	TableName  *string          `protobuf:"bytes,2,opt,name=table_name,json=tableName" json:"table_name,omitempty"`
	ColumnInfo []*ColumnInfo    `protobuf:"bytes,3,rep,name=column_info,json=columnInfo" json:"column_info,omitempty"`
	Mutations  []*TableMutation `protobuf:"bytes,4,rep,name=mutations" json:"mutations,omitempty"`
	// will only be set with version >= 3.0.9
	UniqueKeys           []*Key   `protobuf:"bytes,5,rep,name=unique_keys,json=uniqueKeys" json:"unique_keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Table) Reset()         { *m = Table{} }
func (m *Table) String() string { return proto.CompactTextString(m) }
func (*Table) ProtoMessage()    {}
func (*Table) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e5ebd7aa3410f61, []int{3}
}
func (m *Table) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Table) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Table.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Table) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Table.Merge(m, src)
}
func (m *Table) XXX_Size() int {
	return m.Size()
}
func (m *Table) XXX_DiscardUnknown() {
	xxx_messageInfo_Table.DiscardUnknown(m)
}

var xxx_messageInfo_Table proto.InternalMessageInfo

func (m *Table) GetSchemaName() string {
	if m != nil && m.SchemaName != nil {
		return *m.SchemaName
	}
	return ""
}

func (m *Table) GetTableName() string {
	if m != nil && m.TableName != nil {
		return *m.TableName
	}
	return ""
}

func (m *Table) GetColumnInfo() []*ColumnInfo {
	if m != nil {
		return m.ColumnInfo
	}
	return nil
}

func (m *Table) GetMutations() []*TableMutation {
	if m != nil {
		return m.Mutations
	}
	return nil
}

func (m *Table) GetUniqueKeys() []*Key {
	if m != nil {
		return m.UniqueKeys
	}
	return nil
}

// Key contains Key info.
type Key struct {
	// name will be PRIMARY if it's the primary key.
	Name                 *string  `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	ColumnNames          []string `protobuf:"bytes,2,rep,name=column_names,json=columnNames" json:"column_names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Key) Reset()         { *m = Key{} }
func (m *Key) String() string { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()    {}
func (*Key) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e5ebd7aa3410f61, []int{4}
}
func (m *Key) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Key) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Key.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Key) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Key.Merge(m, src)
}
func (m *Key) XXX_Size() int {
	return m.Size()
}
func (m *Key) XXX_DiscardUnknown() {
	xxx_messageInfo_Key.DiscardUnknown(m)
}

var xxx_messageInfo_Key proto.InternalMessageInfo

func (m *Key) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Key) GetColumnNames() []string {
	if m != nil {
		return m.ColumnNames
	}
	return nil
}

type TableMutation struct {
	Type *MutationType `protobuf:"varint,1,req,name=type,enum=slave.binlog.MutationType" json:"type,omitempty"`
	Row  *Row          `protobuf:"bytes,2,req,name=row" json:"row,omitempty"`
	// for Update MutationType only
	ChangeRow            *Row     `protobuf:"bytes,3,opt,name=change_row,json=changeRow" json:"change_row,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TableMutation) Reset()         { *m = TableMutation{} }
func (m *TableMutation) String() string { return proto.CompactTextString(m) }
func (*TableMutation) ProtoMessage()    {}
func (*TableMutation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e5ebd7aa3410f61, []int{5}
}
func (m *TableMutation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableMutation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableMutation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableMutation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableMutation.Merge(m, src)
}
func (m *TableMutation) XXX_Size() int {
	return m.Size()
}
func (m *TableMutation) XXX_DiscardUnknown() {
	xxx_messageInfo_TableMutation.DiscardUnknown(m)
}

var xxx_messageInfo_TableMutation proto.InternalMessageInfo

func (m *TableMutation) GetType() MutationType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return MutationType_Insert
}

func (m *TableMutation) GetRow() *Row {
	if m != nil {
		return m.Row
	}
	return nil
}

func (m *TableMutation) GetChangeRow() *Row {
	if m != nil {
		return m.ChangeRow
	}
	return nil
}

type DMLData struct {
	// tables contains all the table changes.
	Tables               []*Table `protobuf:"bytes,1,rep,name=tables" json:"tables,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DMLData) Reset()         { *m = DMLData{} }
func (m *DMLData) String() string { return proto.CompactTextString(m) }
func (*DMLData) ProtoMessage()    {}
func (*DMLData) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e5ebd7aa3410f61, []int{6}
}
func (m *DMLData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DMLData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DMLData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DMLData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DMLData.Merge(m, src)
}
func (m *DMLData) XXX_Size() int {
	return m.Size()
}
func (m *DMLData) XXX_DiscardUnknown() {
	xxx_messageInfo_DMLData.DiscardUnknown(m)
}

var xxx_messageInfo_DMLData proto.InternalMessageInfo

func (m *DMLData) GetTables() []*Table {
	if m != nil {
		return m.Tables
	}
	return nil
}

type DDLData struct {
	// the current database use
	SchemaName *string `protobuf:"bytes,1,opt,name=schema_name,json=schemaName" json:"schema_name,omitempty"`
	// the relate table
	TableName *string `protobuf:"bytes,2,opt,name=table_name,json=tableName" json:"table_name,omitempty"`
	// ddl_query is the original ddl statement query.
	DdlQuery             []byte   `protobuf:"bytes,3,opt,name=ddl_query,json=ddlQuery" json:"ddl_query,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DDLData) Reset()         { *m = DDLData{} }
func (m *DDLData) String() string { return proto.CompactTextString(m) }
func (*DDLData) ProtoMessage()    {}
func (*DDLData) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e5ebd7aa3410f61, []int{7}
}
func (m *DDLData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DDLData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DDLData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DDLData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DDLData.Merge(m, src)
}
func (m *DDLData) XXX_Size() int {
	return m.Size()
}
func (m *DDLData) XXX_DiscardUnknown() {
	xxx_messageInfo_DDLData.DiscardUnknown(m)
}

var xxx_messageInfo_DDLData proto.InternalMessageInfo

func (m *DDLData) GetSchemaName() string {
	if m != nil && m.SchemaName != nil {
		return *m.SchemaName
	}
	return ""
}

func (m *DDLData) GetTableName() string {
	if m != nil && m.TableName != nil {
		return *m.TableName
	}
	return ""
}

func (m *DDLData) GetDdlQuery() []byte {
	if m != nil {
		return m.DdlQuery
	}
	return nil
}

// Binlog contains all the changes in a transaction.
type Binlog struct {
	Type     BinlogType `protobuf:"varint,1,opt,name=type,enum=slave.binlog.BinlogType" json:"type"`
	CommitTs int64      `protobuf:"varint,2,opt,name=commit_ts,json=commitTs" json:"commit_ts"`
	// dml_data is marshalled from DML type
	DmlData *DMLData `protobuf:"bytes,3,opt,name=dml_data,json=dmlData" json:"dml_data,omitempty"`
	DdlData *DDLData `protobuf:"bytes,4,opt,name=ddl_data,json=ddlData" json:"ddl_data,omitempty"`
	// time_zone is the time zone of timestamp value
	TimeZone             *string  `protobuf:"bytes,5,opt,name=time_zone,json=timeZone" json:"time_zone,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Binlog) Reset()         { *m = Binlog{} }
func (m *Binlog) String() string { return proto.CompactTextString(m) }
func (*Binlog) ProtoMessage()    {}
func (*Binlog) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e5ebd7aa3410f61, []int{8}
}
func (m *Binlog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Binlog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Binlog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Binlog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Binlog.Merge(m, src)
}
func (m *Binlog) XXX_Size() int {
	return m.Size()
}
func (m *Binlog) XXX_DiscardUnknown() {
	xxx_messageInfo_Binlog.DiscardUnknown(m)
}

var xxx_messageInfo_Binlog proto.InternalMessageInfo

func (m *Binlog) GetType() BinlogType {
	if m != nil {
		return m.Type
	}
	return BinlogType_DML
}

func (m *Binlog) GetCommitTs() int64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

func (m *Binlog) GetDmlData() *DMLData {
	if m != nil {
		return m.DmlData
	}
	return nil
}

func (m *Binlog) GetDdlData() *DDLData {
	if m != nil {
		return m.DdlData
	}
	return nil
}

func (m *Binlog) GetTimeZone() string {
	if m != nil && m.TimeZone != nil {
		return *m.TimeZone
	}
	return ""
}

func init() {
	proto.RegisterEnum("slave.binlog.MutationType", MutationType_name, MutationType_value)
	proto.RegisterEnum("slave.binlog.BinlogType", BinlogType_name, BinlogType_value)
	proto.RegisterType((*Column)(nil), "slave.binlog.Column")
	proto.RegisterType((*ColumnInfo)(nil), "slave.binlog.ColumnInfo")
	proto.RegisterType((*Row)(nil), "slave.binlog.Row")
	proto.RegisterType((*Table)(nil), "slave.binlog.Table")
	proto.RegisterType((*Key)(nil), "slave.binlog.Key")
	proto.RegisterType((*TableMutation)(nil), "slave.binlog.TableMutation")
	proto.RegisterType((*DMLData)(nil), "slave.binlog.DMLData")
	proto.RegisterType((*DDLData)(nil), "slave.binlog.DDLData")
	proto.RegisterType((*Binlog)(nil), "slave.binlog.Binlog")
}

func init() { proto.RegisterFile("secondary_binlog.proto", fileDescriptor_3e5ebd7aa3410f61) }

var fileDescriptor_3e5ebd7aa3410f61 = []byte{
	// 756 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x94, 0xcf, 0x8e, 0xeb, 0x34,
	0x14, 0xc6, 0xeb, 0xa6, 0xff, 0x72, 0x52, 0x46, 0xc5, 0x5c, 0x50, 0x74, 0x47, 0x74, 0x32, 0xb9,
	0x9b, 0x68, 0x90, 0xca, 0x55, 0x05, 0x57, 0xba, 0x88, 0xd5, 0x90, 0xcd, 0x68, 0xfe, 0x08, 0xac,
	0x81, 0x05, 0x9b, 0x28, 0x6d, 0xdc, 0x4e, 0x84, 0x63, 0x77, 0x6a, 0x67, 0xaa, 0xf0, 0x20, 0x88,
	0xd7, 0xe0, 0x2d, 0x66, 0x89, 0xc4, 0x1e, 0x8d, 0x86, 0x27, 0xe0, 0x0d, 0x90, 0xed, 0x64, 0xda,
	0x42, 0x77, 0xec, 0xdc, 0xef, 0xfc, 0x8e, 0xed, 0xef, 0xf3, 0x69, 0xe0, 0x13, 0x49, 0xe7, 0x82,
	0x67, 0xe9, 0xba, 0x4a, 0x66, 0x39, 0x67, 0x62, 0x39, 0x59, 0xad, 0x85, 0x12, 0x78, 0x28, 0x59,
	0xfa, 0x40, 0x27, 0x56, 0x7b, 0xfd, 0x6a, 0x29, 0x96, 0xc2, 0x14, 0x3e, 0xd7, 0x2b, 0xcb, 0x84,
	0x7f, 0x20, 0xe8, 0x7d, 0x23, 0x58, 0x59, 0x70, 0x3c, 0x86, 0x7e, 0x2e, 0x13, 0x5e, 0x32, 0xe6,
	0xa3, 0x00, 0x45, 0x83, 0xaf, 0xba, 0x8b, 0x94, 0x49, 0x4a, 0x7a, 0xb9, 0xbc, 0x29, 0x19, 0xc3,
	0x27, 0xe0, 0xe5, 0x5c, 0xbd, 0xfb, 0x22, 0x79, 0x48, 0x59, 0x49, 0xfd, 0x76, 0x80, 0x22, 0x87,
	0x80, 0x91, 0x7e, 0xd0, 0x0a, 0x3e, 0x85, 0x61, 0xb9, 0x4b, 0x38, 0x01, 0x8a, 0x3a, 0xc4, 0x2b,
	0xf7, 0x91, 0x4c, 0x94, 0x33, 0x46, 0x6b, 0xa4, 0x13, 0xa0, 0x08, 0x11, 0xcf, 0x6a, 0x16, 0x39,
	0x01, 0x6f, 0x56, 0x29, 0x2a, 0x6b, 0xa2, 0x1b, 0xa0, 0x68, 0x48, 0xc0, 0x48, 0x2f, 0x7b, 0x48,
	0xb5, 0xce, 0xf9, 0xb2, 0x26, 0x7a, 0x01, 0x8a, 0x5c, 0xe2, 0x59, 0xcd, 0x20, 0xe1, 0x6f, 0x08,
	0xc0, 0xba, 0xba, 0xe0, 0x0b, 0x81, 0x7d, 0xe8, 0xf0, 0xb4, 0xa0, 0xc6, 0x96, 0x7b, 0xde, 0x79,
	0xfc, 0xf3, 0xa4, 0x45, 0x8c, 0x82, 0xdf, 0x00, 0x14, 0x95, 0xbc, 0x67, 0x89, 0xaa, 0x56, 0xd6,
	0x52, 0x53, 0x77, 0x8d, 0x7e, 0x5b, 0xad, 0x28, 0x3e, 0x83, 0xa3, 0x5c, 0x26, 0xab, 0x75, 0x5e,
	0xe8, 0x88, 0x7f, 0xa2, 0x95, 0x71, 0x36, 0xa8, 0xc1, 0x61, 0x2e, 0xbf, 0xb5, 0xa5, 0x4b, 0x5a,
	0xe9, 0xa3, 0x16, 0x8c, 0x72, 0x63, 0xac, 0xdb, 0x1c, 0xa5, 0x15, 0x1d, 0x6f, 0x46, 0xe7, 0x79,
	0x91, 0x32, 0xe3, 0xa9, 0x29, 0x36, 0x62, 0xf8, 0x25, 0x38, 0x44, 0x6c, 0xf0, 0x04, 0xfa, 0x73,
	0x73, 0x73, 0xe9, 0xa3, 0xc0, 0x89, 0xbc, 0xe9, 0xab, 0xc9, 0xee, 0x33, 0x4e, 0xac, 0x2d, 0xd2,
	0x40, 0xe1, 0xdf, 0x08, 0xba, 0xb7, 0xe9, 0x8c, 0x99, 0xe0, 0xe4, 0xfc, 0x8e, 0x16, 0x69, 0xb2,
	0x35, 0x4b, 0xc0, 0x4a, 0x37, 0xda, 0xec, 0xa7, 0x00, 0x4a, 0x93, 0xb6, 0x6e, 0xcc, 0x12, 0xd7,
	0x28, 0xa6, 0xfc, 0x1e, 0x3c, 0xbb, 0x69, 0x92, 0xf3, 0x85, 0xf0, 0x1d, 0x73, 0xba, 0x7f, 0xe8,
	0x74, 0x1d, 0x2a, 0x81, 0xf9, 0x36, 0xe0, 0xf7, 0xe0, 0x16, 0xa5, 0x4a, 0x55, 0x2e, 0xb8, 0xf4,
	0x3b, 0xa6, 0xf1, 0x78, 0xbf, 0xd1, 0x5c, 0xf1, 0xba, 0x66, 0xc8, 0x96, 0xc6, 0x53, 0xf0, 0x4a,
	0x9e, 0xdf, 0x97, 0x54, 0x07, 0x2b, 0xfd, 0xae, 0x69, 0xfe, 0x70, 0xbf, 0xf9, 0x92, 0x56, 0x04,
	0x2c, 0x75, 0x49, 0x2b, 0x19, 0x7e, 0x0d, 0x8e, 0xce, 0x1a, 0xef, 0x3e, 0x6b, 0xfd, 0xa0, 0xa7,
	0x30, 0xac, 0x4d, 0xe8, 0x9f, 0xd2, 0x6f, 0x07, 0x8e, 0x1e, 0x0e, 0xab, 0x69, 0x9b, 0x32, 0xfc,
	0x05, 0xc1, 0x07, 0x7b, 0xd7, 0xc1, 0x13, 0xe8, 0x98, 0xf7, 0x47, 0x41, 0x3b, 0x3a, 0x9a, 0xbe,
	0xde, 0x3f, 0xbc, 0xa1, 0xf4, 0x28, 0x10, 0xc3, 0xe1, 0x37, 0xe0, 0xac, 0xc5, 0xc6, 0x6f, 0x07,
	0xed, 0xff, 0xde, 0x95, 0x88, 0x0d, 0xd1, 0x55, 0xfc, 0x16, 0x60, 0x7e, 0x97, 0xf2, 0x25, 0x4d,
	0x34, 0xab, 0x27, 0xe6, 0x20, 0xeb, 0x5a, 0x88, 0x88, 0x4d, 0xf8, 0x0e, 0xfa, 0xf1, 0xf5, 0x55,
	0x9c, 0xaa, 0x14, 0x7f, 0x06, 0x3d, 0xf3, 0x30, 0xcd, 0x10, 0x7c, 0x74, 0x20, 0x4d, 0x52, 0x23,
	0xe1, 0x02, 0xfa, 0x71, 0x6c, 0xfb, 0xfe, 0xef, 0x0c, 0x1c, 0x83, 0x9b, 0x65, 0x2c, 0xb9, 0x2f,
	0xe9, 0xda, 0x4e, 0xf9, 0x90, 0x0c, 0xb2, 0x8c, 0x7d, 0xa7, 0x7f, 0x87, 0x4f, 0x08, 0x7a, 0xe7,
	0xe6, 0x02, 0x78, 0xfa, 0x92, 0x18, 0x8a, 0x8e, 0xfe, 0x3d, 0x24, 0x96, 0xd1, 0x79, 0x35, 0x7f,
	0x00, 0x93, 0xda, 0x29, 0xb8, 0x73, 0x51, 0x14, 0xb9, 0x4a, 0x94, 0xb4, 0x5f, 0x8f, 0xba, 0x3c,
	0xb0, 0xf2, 0xad, 0xc4, 0x6f, 0x61, 0x90, 0x15, 0x2c, 0xc9, 0x52, 0x95, 0xd6, 0x89, 0x7d, 0xbc,
	0xbf, 0x75, 0x9d, 0x0f, 0xe9, 0x67, 0x05, 0x33, 0x86, 0x75, 0x47, 0x56, 0x77, 0x74, 0x0e, 0x76,
	0xc4, 0x4d, 0x47, 0x66, 0x3b, 0x8e, 0xc1, 0x55, 0x79, 0x41, 0x93, 0x9f, 0x05, 0xb7, 0x5f, 0x17,
	0x97, 0x0c, 0xb4, 0xf0, 0xa3, 0xe0, 0xf4, 0x6c, 0x0a, 0xc3, 0xdd, 0xf7, 0xc6, 0x00, 0xbd, 0x0b,
	0x2e, 0xe9, 0x5a, 0x8d, 0x5a, 0x7a, 0xfd, 0xfd, 0x2a, 0x4b, 0x15, 0x1d, 0x21, 0xbd, 0x8e, 0x29,
	0xa3, 0x8a, 0x8e, 0xda, 0x67, 0x63, 0x80, 0xad, 0x63, 0xdc, 0x07, 0x27, 0xbe, 0xbe, 0x1a, 0xb5,
	0xcc, 0x22, 0xbe, 0x1a, 0xa1, 0xf3, 0xd1, 0xe3, 0xf3, 0x18, 0xfd, 0xfe, 0x3c, 0x46, 0x4f, 0xcf,
	0x63, 0xf4, 0xeb, 0x5f, 0xe3, 0xd6, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x2f, 0xa6, 0x92, 0xaa,
	0xb1, 0x05, 0x00, 0x00,
}

func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsNull != nil {
		dAtA[i] = 0x8
		i++
		if *m.IsNull {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Int64Value != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSecondaryBinlog(dAtA, i, uint64(*m.Int64Value))
	}
	if m.Uint64Value != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSecondaryBinlog(dAtA, i, uint64(*m.Uint64Value))
	}
	if m.DoubleValue != nil {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.DoubleValue))))
		i += 8
	}
	if m.BytesValue != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSecondaryBinlog(dAtA, i, uint64(len(m.BytesValue)))
		i += copy(dAtA[i:], m.BytesValue)
	}
	if m.StringValue != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSecondaryBinlog(dAtA, i, uint64(len(*m.StringValue)))
		i += copy(dAtA[i:], *m.StringValue)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ColumnInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSecondaryBinlog(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintSecondaryBinlog(dAtA, i, uint64(len(m.MysqlType)))
	i += copy(dAtA[i:], m.MysqlType)
	dAtA[i] = 0x18
	i++
	if m.IsPrimaryKey {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	i = encodeVarintSecondaryBinlog(dAtA, i, uint64(m.Flen))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSecondaryBinlog(dAtA, i, uint64(m.Decimal))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Row) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Row) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSecondaryBinlog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Table) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SchemaName != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSecondaryBinlog(dAtA, i, uint64(len(*m.SchemaName)))
		i += copy(dAtA[i:], *m.SchemaName)
	}
	if m.TableName != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSecondaryBinlog(dAtA, i, uint64(len(*m.TableName)))
		i += copy(dAtA[i:], *m.TableName)
	}
	if len(m.ColumnInfo) > 0 {
		for _, msg := range m.ColumnInfo {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintSecondaryBinlog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Mutations) > 0 {
		for _, msg := range m.Mutations {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSecondaryBinlog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.UniqueKeys) > 0 {
		for _, msg := range m.UniqueKeys {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintSecondaryBinlog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Key) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Key) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSecondaryBinlog(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TableMutation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableMutation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSecondaryBinlog(dAtA, i, uint64(*m.Type))
	}
	if m.Row == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSecondaryBinlog(dAtA, i, uint64(m.Row.Size()))
		n1, err := m.Row.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.ChangeRow != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSecondaryBinlog(dAtA, i, uint64(m.ChangeRow.Size()))
		n2, err := m.ChangeRow.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DMLData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DMLData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, msg := range m.Tables {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSecondaryBinlog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DDLData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DDLData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SchemaName != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSecondaryBinlog(dAtA, i, uint64(len(*m.SchemaName)))
		i += copy(dAtA[i:], *m.SchemaName)
	}
	if m.TableName != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSecondaryBinlog(dAtA, i, uint64(len(*m.TableName)))
		i += copy(dAtA[i:], *m.TableName)
	}
	if m.DdlQuery != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSecondaryBinlog(dAtA, i, uint64(len(m.DdlQuery)))
		i += copy(dAtA[i:], m.DdlQuery)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Binlog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Binlog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSecondaryBinlog(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSecondaryBinlog(dAtA, i, uint64(m.CommitTs))
	if m.DmlData != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSecondaryBinlog(dAtA, i, uint64(m.DmlData.Size()))
		n3, err := m.DmlData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.DdlData != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSecondaryBinlog(dAtA, i, uint64(m.DdlData.Size()))
		n4, err := m.DdlData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.TimeZone != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSecondaryBinlog(dAtA, i, uint64(len(*m.TimeZone)))
		i += copy(dAtA[i:], *m.TimeZone)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintSecondaryBinlog(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsNull != nil {
		n += 2
	}
	if m.Int64Value != nil {
		n += 1 + sovSecondaryBinlog(uint64(*m.Int64Value))
	}
	if m.Uint64Value != nil {
		n += 1 + sovSecondaryBinlog(uint64(*m.Uint64Value))
	}
	if m.DoubleValue != nil {
		n += 9
	}
	if m.BytesValue != nil {
		l = len(m.BytesValue)
		n += 1 + l + sovSecondaryBinlog(uint64(l))
	}
	if m.StringValue != nil {
		l = len(*m.StringValue)
		n += 1 + l + sovSecondaryBinlog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColumnInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovSecondaryBinlog(uint64(l))
	l = len(m.MysqlType)
	n += 1 + l + sovSecondaryBinlog(uint64(l))
	n += 2
	n += 1 + sovSecondaryBinlog(uint64(m.Flen))
	n += 1 + sovSecondaryBinlog(uint64(m.Decimal))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Row) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovSecondaryBinlog(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaName != nil {
		l = len(*m.SchemaName)
		n += 1 + l + sovSecondaryBinlog(uint64(l))
	}
	if m.TableName != nil {
		l = len(*m.TableName)
		n += 1 + l + sovSecondaryBinlog(uint64(l))
	}
	if len(m.ColumnInfo) > 0 {
		for _, e := range m.ColumnInfo {
			l = e.Size()
			n += 1 + l + sovSecondaryBinlog(uint64(l))
		}
	}
	if len(m.Mutations) > 0 {
		for _, e := range m.Mutations {
			l = e.Size()
			n += 1 + l + sovSecondaryBinlog(uint64(l))
		}
	}
	if len(m.UniqueKeys) > 0 {
		for _, e := range m.UniqueKeys {
			l = e.Size()
			n += 1 + l + sovSecondaryBinlog(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovSecondaryBinlog(uint64(l))
	}
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			l = len(s)
			n += 1 + l + sovSecondaryBinlog(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableMutation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovSecondaryBinlog(uint64(*m.Type))
	}
	if m.Row != nil {
		l = m.Row.Size()
		n += 1 + l + sovSecondaryBinlog(uint64(l))
	}
	if m.ChangeRow != nil {
		l = m.ChangeRow.Size()
		n += 1 + l + sovSecondaryBinlog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DMLData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovSecondaryBinlog(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DDLData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaName != nil {
		l = len(*m.SchemaName)
		n += 1 + l + sovSecondaryBinlog(uint64(l))
	}
	if m.TableName != nil {
		l = len(*m.TableName)
		n += 1 + l + sovSecondaryBinlog(uint64(l))
	}
	if m.DdlQuery != nil {
		l = len(m.DdlQuery)
		n += 1 + l + sovSecondaryBinlog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Binlog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSecondaryBinlog(uint64(m.Type))
	n += 1 + sovSecondaryBinlog(uint64(m.CommitTs))
	if m.DmlData != nil {
		l = m.DmlData.Size()
		n += 1 + l + sovSecondaryBinlog(uint64(l))
	}
	if m.DdlData != nil {
		l = m.DdlData.Size()
		n += 1 + l + sovSecondaryBinlog(uint64(l))
	}
	if m.TimeZone != nil {
		l = len(*m.TimeZone)
		n += 1 + l + sovSecondaryBinlog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSecondaryBinlog(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSecondaryBinlog(x uint64) (n int) {
	return sovSecondaryBinlog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecondaryBinlog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsNull = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64Value", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Int64Value = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint64Value", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Uint64Value = &v
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.DoubleValue = &v2
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BytesValue = append(m.BytesValue[:0], dAtA[iNdEx:postIndex]...)
			if m.BytesValue == nil {
				m.BytesValue = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.StringValue = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecondaryBinlog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecondaryBinlog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MysqlType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MysqlType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimaryKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrimaryKey = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flen", wireType)
			}
			m.Flen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal", wireType)
			}
			m.Decimal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSecondaryBinlog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Row) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecondaryBinlog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Row: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Row: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecondaryBinlog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecondaryBinlog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SchemaName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TableName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnInfo = append(m.ColumnInfo, &ColumnInfo{})
			if err := m.ColumnInfo[len(m.ColumnInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mutations = append(m.Mutations, &TableMutation{})
			if err := m.Mutations[len(m.Mutations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueKeys = append(m.UniqueKeys, &Key{})
			if err := m.UniqueKeys[len(m.UniqueKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecondaryBinlog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Key) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecondaryBinlog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Key: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Key: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnNames = append(m.ColumnNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecondaryBinlog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableMutation) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecondaryBinlog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableMutation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableMutation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v MutationType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= MutationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Row", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Row == nil {
				m.Row = &Row{}
			}
			if err := m.Row.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeRow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeRow == nil {
				m.ChangeRow = &Row{}
			}
			if err := m.ChangeRow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecondaryBinlog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DMLData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecondaryBinlog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DMLData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DMLData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, &Table{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecondaryBinlog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DDLData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecondaryBinlog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DDLData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DDLData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SchemaName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TableName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DdlQuery", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DdlQuery = append(m.DdlQuery[:0], dAtA[iNdEx:postIndex]...)
			if m.DdlQuery == nil {
				m.DdlQuery = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecondaryBinlog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Binlog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecondaryBinlog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Binlog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Binlog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= BinlogType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmlData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DmlData == nil {
				m.DmlData = &DMLData{}
			}
			if err := m.DmlData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DdlData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DdlData == nil {
				m.DdlData = &DDLData{}
			}
			if err := m.DdlData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TimeZone = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecondaryBinlog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSecondaryBinlog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSecondaryBinlog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSecondaryBinlog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSecondaryBinlog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSecondaryBinlog
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthSecondaryBinlog
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSecondaryBinlog
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSecondaryBinlog(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthSecondaryBinlog
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSecondaryBinlog = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSecondaryBinlog   = fmt.Errorf("proto: integer overflow")
)
