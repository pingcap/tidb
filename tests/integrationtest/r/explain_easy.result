set tidb_cost_model_version=1;
set @@sql_mode = 'strict_trans_tables';
drop table if exists t1, t2, t3, t4;
create table t1 (c1 int primary key, c2 int, c3 int, index c2 (c2));
create table t2 (c1 int unique, c2 int);
insert into t2 values(1, 0), (2, 1);
create table t3 (a bigint, b bigint, c bigint, d bigint);
create table t4 (a int, b int, c int, index idx(a, b), primary key(a));
create index expr_idx on t4((a+b+1));
set @@session.tidb_opt_agg_push_down = 1;
set @@session.tidb_opt_insubq_to_join_and_agg=1;
set @@session.tidb_hashagg_partial_concurrency = 1;
set @@session.tidb_hashagg_final_concurrency = 1;
set @@session.tidb_window_concurrency = 1;
explain format = 'plan_tree' select * from t3 where exists (select s.a from t3 s having sum(s.a) = t3.a );
id	task	access object	operator info
HashJoin	root		semi join, left side:Projection, equal:[eq(Column, Column)]
├─StreamAgg(Build)	root		funcs:sum(Column)->Column
│ └─TableReader	root		data:StreamAgg
│   └─StreamAgg	cop[tikv]		funcs:sum(explain_easy.t3.a)->Column
│     └─TableFullScan	cop[tikv]	table:s	keep order:false, stats:pseudo
└─Projection(Probe)	root		explain_easy.t3.a, explain_easy.t3.b, explain_easy.t3.c, explain_easy.t3.d, cast(explain_easy.t3.a, decimal(20,0) BINARY)->Column
  └─TableReader	root		data:TableFullScan
    └─TableFullScan	cop[tikv]	table:t3	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t1;
id	task	access object	operator info
TableReader	root		data:TableFullScan
└─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t1 order by c2;
id	task	access object	operator info
IndexLookUp	root		
├─IndexFullScan(Build)	cop[tikv]	table:t1, index:c2(c2)	keep order:true, stats:pseudo
└─TableRowIDScan(Probe)	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t2 order by c2;
id	task	access object	operator info
Sort	root		explain_easy.t2.c2
└─TableReader	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t1 where t1.c1 > 0;
id	task	access object	operator info
TableReader	root		data:TableRangeScan
└─TableRangeScan	cop[tikv]	table:t1	range:(0,+inf], keep order:false, stats:pseudo
explain format = 'plan_tree' select t1.c1, t1.c2 from t1 where t1.c2 = 1;
id	task	access object	operator info
IndexReader	root		index:IndexRangeScan
└─IndexRangeScan	cop[tikv]	table:t1, index:c2(c2)	range:[1,1], keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t1 left join t2 on t1.c2 = t2.c1 where t1.c1 > 1;
id	task	access object	operator info
HashJoin	root		left outer join, left side:TableReader, equal:[eq(explain_easy.t1.c2, explain_easy.t2.c1)]
├─TableReader(Build)	root		data:TableRangeScan
│ └─TableRangeScan	cop[tikv]	table:t1	range:(1,+inf], keep order:false, stats:pseudo
└─TableReader(Probe)	root		data:Selection
  └─Selection	cop[tikv]		not(isnull(explain_easy.t2.c1))
    └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
explain format = 'plan_tree' update t1 set t1.c2 = 2 where t1.c1 = 1;
id	task	access object	operator info
Update	root		N/A
└─Point_Get	root	table:t1	handle:1
explain format = 'plan_tree' delete from t1 where t1.c2 = 1;
id	task	access object	operator info
Delete	root		N/A
└─IndexReader	root		index:IndexRangeScan
  └─IndexRangeScan	cop[tikv]	table:t1, index:c2(c2)	range:[1,1], keep order:false, stats:pseudo
explain format = 'plan_tree' select count(b.c2) from t1 a, t2 b where a.c1 = b.c2 group by a.c1;
id	task	access object	operator info
Projection	root		Column
└─HashJoin	root		inner join, equal:[eq(explain_easy.t1.c1, explain_easy.t2.c2)]
  ├─HashAgg(Build)	root		group by:explain_easy.t2.c2, funcs:count(Column)->Column, funcs:firstrow(explain_easy.t2.c2)->explain_easy.t2.c2
  │ └─TableReader	root		data:HashAgg
  │   └─HashAgg	cop[tikv]		group by:explain_easy.t2.c2, funcs:count(explain_easy.t2.c2)->Column
  │     └─Selection	cop[tikv]		not(isnull(explain_easy.t2.c2))
  │       └─TableFullScan	cop[tikv]	table:b	keep order:false, stats:pseudo
  └─TableReader(Probe)	root		data:TableFullScan
    └─TableFullScan	cop[tikv]	table:a	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t2 order by t2.c2 limit 0, 1;
id	task	access object	operator info
TopN	root		explain_easy.t2.c2, offset:0, count:1
└─TableReader	root		data:TopN
  └─TopN	cop[tikv]		explain_easy.t2.c2, offset:0, count:1
    └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t1 where c1 > 1 and c2 = 1 and c3 < 1;
id	task	access object	operator info
IndexLookUp	root		
├─IndexRangeScan(Build)	cop[tikv]	table:t1, index:c2(c2)	range:(1 1,1 +inf], keep order:false, stats:pseudo
└─Selection(Probe)	cop[tikv]		lt(explain_easy.t1.c3, 1)
  └─TableRowIDScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t1 where c1 = 1 and c2 > 1;
id	task	access object	operator info
Selection	root		gt(explain_easy.t1.c2, 1)
└─Point_Get	root	table:t1	handle:1
explain format = 'plan_tree' select sum(t1.c1 in (select c1 from t2)) from t1;
id	task	access object	operator info
StreamAgg	root		funcs:sum(Column)->Column
└─Projection	root		cast(Column, decimal(3,0) BINARY)->Column
  └─HashJoin	root		CARTESIAN left outer semi join, left side:TableReader, other cond:eq(explain_easy.t1.c1, explain_easy.t2.c1)
    ├─IndexReader(Build)	root		index:IndexFullScan
    │ └─IndexFullScan	cop[tikv]	table:t2, index:c1(c1)	keep order:false, stats:pseudo
    └─TableReader(Probe)	root		data:TableFullScan
      └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select c1 from t1 where c1 in (select c2 from t2);
id	task	access object	operator info
HashJoin	root		inner join, equal:[eq(explain_easy.t1.c1, explain_easy.t2.c2)]
├─HashAgg(Build)	root		group by:explain_easy.t2.c2, funcs:firstrow(explain_easy.t2.c2)->explain_easy.t2.c2
│ └─TableReader	root		data:Selection
│   └─Selection	cop[tikv]		not(isnull(explain_easy.t2.c2))
│     └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
└─TableReader(Probe)	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select (select count(1) k from t1 s where s.c1 = t1.c1 having k != 0) from t1;
id	task	access object	operator info
Projection	root		ifnull(Column, 0)->Column
└─MergeJoin	root		left outer join, left side:TableReader, left key:explain_easy.t1.c1, right key:explain_easy.t1.c1
  ├─Projection(Build)	root		1->Column, explain_easy.t1.c1
  │ └─TableReader	root		data:TableFullScan
  │   └─TableFullScan	cop[tikv]	table:s	keep order:true, stats:pseudo
  └─TableReader(Probe)	root		data:TableFullScan
    └─TableFullScan	cop[tikv]	table:t1	keep order:true, stats:pseudo
explain format = 'plan_tree' select * from information_schema.columns;
id	task	access object	operator info
MemTableScan	root	table:COLUMNS	
explain format = 'plan_tree' select * from information_schema.columns where table_name = 'T1';
id	task	access object	operator info
MemTableScan	root	table:COLUMNS	table_name:["t1"]
explain format = 'plan_tree' select * from information_schema.columns where table_schema = 'TEST' and table_name = 'T1' and column_name = 'c1';
id	task	access object	operator info
MemTableScan	root	table:COLUMNS	column_name:["c1"], table_name:["t1"], table_schema:["test"]
explain format = 'plan_tree' select c2 = (select c2 from t2 where t1.c1 = t2.c1 order by c1 limit 1) from t1;
id	task	access object	operator info
Projection	root		eq(explain_easy.t1.c2, explain_easy.t2.c2)->Column
└─Apply	root		CARTESIAN left outer join, left side:TableReader
  ├─TableReader(Build)	root		data:TableFullScan
  │ └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
  └─Projection(Probe)	root		explain_easy.t2.c2
    └─Projection	root		explain_easy.t2.c1, explain_easy.t2.c2
      └─IndexLookUp	root		limit embedded(offset:0, count:1)
        ├─Limit(Build)	cop[tikv]		offset:0, count:1
        │ └─IndexRangeScan	cop[tikv]	table:t2, index:c1(c1)	range: decided by [eq(explain_easy.t1.c1, explain_easy.t2.c1)], keep order:true, stats:pseudo
        └─TableRowIDScan(Probe)	cop[tikv]	table:t2	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t1 order by c1 desc limit 1;
id	task	access object	operator info
Limit	root		offset:0, count:1
└─TableReader	root		data:Limit
  └─Limit	cop[tikv]		offset:0, count:1
    └─TableFullScan	cop[tikv]	table:t1	keep order:true, desc, stats:pseudo
explain format = 'plan_tree' select * from t4 use index(idx) where a > 1 and b > 1 and c > 1 limit 1;
id	task	access object	operator info
Limit	root		offset:0, count:1
└─IndexLookUp	root		
  ├─Selection(Build)	cop[tikv]		gt(explain_easy.t4.b, 1)
  │ └─IndexRangeScan	cop[tikv]	table:t4, index:idx(a, b)	range:(1,+inf], keep order:false, stats:pseudo
  └─Limit(Probe)	cop[tikv]		offset:0, count:1
    └─Selection	cop[tikv]		gt(explain_easy.t4.c, 1)
      └─TableRowIDScan	cop[tikv]	table:t4	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t4 where a > 1 and c > 1 limit 1;
id	task	access object	operator info
Limit	root		offset:0, count:1
└─TableReader	root		data:Limit
  └─Limit	cop[tikv]		offset:0, count:1
    └─Selection	cop[tikv]		gt(explain_easy.t4.c, 1)
      └─TableRangeScan	cop[tikv]	table:t4	range:(1,+inf], keep order:false, stats:pseudo
explain format = 'plan_tree' select ifnull(null, t1.c1) from t1;
id	task	access object	operator info
TableReader	root		data:TableFullScan
└─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select if(10, t1.c1, t1.c2) from t1;
id	task	access object	operator info
TableReader	root		data:TableFullScan
└─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select c1 from t2 union select c1 from t2 union all select c1 from t2;
id	task	access object	operator info
Union	root		
├─HashAgg	root		group by:Column, funcs:firstrow(Column)->Column
│ └─Union	root		
│   ├─StreamAgg	root		group by:explain_easy.t2.c1, funcs:firstrow(explain_easy.t2.c1)->Column, funcs:firstrow(explain_easy.t2.c1)->Column
│   │ └─IndexReader	root		index:StreamAgg
│   │   └─StreamAgg	cop[tikv]		group by:explain_easy.t2.c1, 
│   │     └─IndexFullScan	cop[tikv]	table:t2, index:c1(c1)	keep order:true, stats:pseudo
│   └─StreamAgg	root		group by:explain_easy.t2.c1, funcs:firstrow(explain_easy.t2.c1)->Column, funcs:firstrow(explain_easy.t2.c1)->Column
│     └─IndexReader	root		index:StreamAgg
│       └─StreamAgg	cop[tikv]		group by:explain_easy.t2.c1, 
│         └─IndexFullScan	cop[tikv]	table:t2, index:c1(c1)	keep order:true, stats:pseudo
└─IndexReader	root		index:IndexFullScan
  └─IndexFullScan	cop[tikv]	table:t2, index:c1(c1)	keep order:false, stats:pseudo
explain format = 'plan_tree' select c1 from t2 union all select c1 from t2 union select c1 from t2;
id	task	access object	operator info
HashAgg	root		group by:Column, funcs:firstrow(Column)->Column
└─Union	root		
  ├─StreamAgg	root		group by:explain_easy.t2.c1, funcs:firstrow(explain_easy.t2.c1)->Column, funcs:firstrow(explain_easy.t2.c1)->Column
  │ └─IndexReader	root		index:StreamAgg
  │   └─StreamAgg	cop[tikv]		group by:explain_easy.t2.c1, 
  │     └─IndexFullScan	cop[tikv]	table:t2, index:c1(c1)	keep order:true, stats:pseudo
  ├─StreamAgg	root		group by:explain_easy.t2.c1, funcs:firstrow(explain_easy.t2.c1)->Column, funcs:firstrow(explain_easy.t2.c1)->Column
  │ └─IndexReader	root		index:StreamAgg
  │   └─StreamAgg	cop[tikv]		group by:explain_easy.t2.c1, 
  │     └─IndexFullScan	cop[tikv]	table:t2, index:c1(c1)	keep order:true, stats:pseudo
  └─StreamAgg	root		group by:explain_easy.t2.c1, funcs:firstrow(explain_easy.t2.c1)->Column, funcs:firstrow(explain_easy.t2.c1)->Column
    └─IndexReader	root		index:StreamAgg
      └─StreamAgg	cop[tikv]		group by:explain_easy.t2.c1, 
        └─IndexFullScan	cop[tikv]	table:t2, index:c1(c1)	keep order:true, stats:pseudo
select * from information_schema.tidb_indexes where table_name='t4' and table_schema='explain_easy';
TABLE_SCHEMA	TABLE_NAME	NON_UNIQUE	KEY_NAME	SEQ_IN_INDEX	COLUMN_NAME	SUB_PART	INDEX_COMMENT	Expression	INDEX_ID	IS_VISIBLE	CLUSTERED	IS_GLOBAL	PREDICATE
explain_easy	t4	0	PRIMARY	1	a	NULL		NULL	0	YES	YES	0	NULL
explain_easy	t4	1	idx	1	a	NULL		NULL	1	YES	NO	0	NULL
explain_easy	t4	1	idx	2	b	NULL		NULL	1	YES	NO	0	NULL
explain_easy	t4	1	expr_idx	1	NULL	NULL		`a` + `b` + 1	2	YES	NO	0	NULL
explain format = 'plan_tree' select count(1) from (select count(1) from (select * from t1 where c3 = 100) k) k2;
id	task	access object	operator info
StreamAgg	root		funcs:count(1)->Column
└─StreamAgg	root		funcs:count(Column)->Column
  └─TableReader	root		data:StreamAgg
    └─StreamAgg	cop[tikv]		funcs:count(1)->Column
      └─Selection	cop[tikv]		eq(explain_easy.t1.c3, 100)
        └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select 1 from (select count(c2), count(c3) from t1) k;
id	task	access object	operator info
Projection	root		1->Column
└─StreamAgg	root		funcs:count(Column)->Column
  └─TableReader	root		data:StreamAgg
    └─StreamAgg	cop[tikv]		funcs:count(1)->Column
      └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select count(1) from (select max(c2), count(c3) as m from t1) k;
id	task	access object	operator info
StreamAgg	root		funcs:count(1)->Column
└─StreamAgg	root		funcs:count(Column)->Column
  └─TableReader	root		data:StreamAgg
    └─StreamAgg	cop[tikv]		funcs:count(1)->Column
      └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select count(1) from (select count(c2) from t1 group by c3) k;
id	task	access object	operator info
StreamAgg	root		funcs:count(1)->Column
└─HashAgg	root		group by:explain_easy.t1.c3, funcs:count(Column)->Column
  └─TableReader	root		data:HashAgg
    └─HashAgg	cop[tikv]		group by:explain_easy.t1.c3, funcs:count(1)->Column
      └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
set @@session.tidb_opt_insubq_to_join_and_agg=0;
explain format = 'plan_tree' select sum(t1.c1 in (select c1 from t2)) from t1;
id	task	access object	operator info
StreamAgg	root		funcs:sum(Column)->Column
└─Projection	root		cast(Column, decimal(3,0) BINARY)->Column
  └─HashJoin	root		CARTESIAN left outer semi join, left side:TableReader, other cond:eq(explain_easy.t1.c1, explain_easy.t2.c1)
    ├─IndexReader(Build)	root		index:IndexFullScan
    │ └─IndexFullScan	cop[tikv]	table:t2, index:c1(c1)	keep order:false, stats:pseudo
    └─TableReader(Probe)	root		data:TableFullScan
      └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select 1 in (select c2 from t2) from t1;
id	task	access object	operator info
HashJoin	root		CARTESIAN left outer semi join, left side:TableReader, other cond:eq(1, explain_easy.t2.c2)
├─TableReader(Build)	root		data:TableFullScan
│ └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
└─TableReader(Probe)	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select sum(6 in (select c2 from t2)) from t1;
id	task	access object	operator info
StreamAgg	root		funcs:sum(Column)->Column
└─Projection	root		cast(Column, decimal(3,0) BINARY)->Column
  └─HashJoin	root		CARTESIAN left outer semi join, left side:TableReader, other cond:eq(6, explain_easy.t2.c2)
    ├─TableReader(Build)	root		data:TableFullScan
    │ └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
    └─TableReader(Probe)	root		data:TableFullScan
      └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format="dot" select sum(t1.c1 in (select c1 from t2)) from t1;
dot contents

digraph StreamAgg_15 {
subgraph cluster15{
node [style=filled, color=lightgrey]
color=black
label = "root"
"StreamAgg_15" -> "Projection_42"
"Projection_42" -> "HashJoin_40"
"HashJoin_40" -> "TableReader_25"
"HashJoin_40" -> "IndexReader_31"
}
subgraph cluster24{
node [style=filled, color=lightgrey]
color=black
label = "cop"
"TableFullScan_24"
}
subgraph cluster30{
node [style=filled, color=lightgrey]
color=black
label = "cop"
"IndexFullScan_30"
}
"TableReader_25" -> "TableFullScan_24"
"IndexReader_31" -> "IndexFullScan_30"
}

explain format="dot" select 1 in (select c2 from t2) from t1;
dot contents

digraph HashJoin_16 {
subgraph cluster16{
node [style=filled, color=lightgrey]
color=black
label = "root"
"HashJoin_16" -> "TableReader_18"
"HashJoin_16" -> "TableReader_22"
}
subgraph cluster17{
node [style=filled, color=lightgrey]
color=black
label = "cop"
"TableFullScan_17"
}
subgraph cluster21{
node [style=filled, color=lightgrey]
color=black
label = "cop"
"TableFullScan_21"
}
"TableReader_18" -> "TableFullScan_17"
"TableReader_22" -> "TableFullScan_21"
}

drop table if exists t1, t2, t3, t4;
drop table if exists t;
create table t(a int primary key, b int, c int, index idx(b));
explain format = 'plan_tree' select t.c in (select count(*) from t s ignore index(idx), t t1 where s.a = t.a and s.a = t1.a) from t;
id	task	access object	operator info
Projection	root		Column
└─Apply	root		CARTESIAN left outer semi join, left side:TableReader, other cond:eq(explain_easy.t.c, Column)
  ├─TableReader(Build)	root		data:TableFullScan
  │ └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
  └─StreamAgg(Probe)	root		funcs:count(1)->Column
    └─MergeJoin	root		inner join, left key:explain_easy.t.a, right key:explain_easy.t.a
      ├─TableReader(Build)	root		data:TableRangeScan
      │ └─TableRangeScan	cop[tikv]	table:t1	range: decided by [eq(explain_easy.t.a, explain_easy.t.a)], keep order:true, stats:pseudo
      └─TableReader(Probe)	root		data:TableRangeScan
        └─TableRangeScan	cop[tikv]	table:s	range: decided by [eq(explain_easy.t.a, explain_easy.t.a)], keep order:true, stats:pseudo
explain format = 'plan_tree' select t.c in (select count(*) from t s use index(idx), t t1 where s.b = t.a and s.a = t1.a) from t;
id	task	access object	operator info
Projection	root		Column
└─Apply	root		CARTESIAN left outer semi join, left side:TableReader, other cond:eq(explain_easy.t.c, Column)
  ├─TableReader(Build)	root		data:TableFullScan
  │ └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
  └─StreamAgg(Probe)	root		funcs:count(1)->Column
    └─IndexJoin	root		inner join, inner:TableReader, outer key:explain_easy.t.a, inner key:explain_easy.t.a, equal cond:eq(explain_easy.t.a, explain_easy.t.a)
      ├─IndexReader(Build)	root		index:IndexRangeScan
      │ └─IndexRangeScan	cop[tikv]	table:s, index:idx(b)	range: decided by [eq(explain_easy.t.b, explain_easy.t.a)], keep order:false, stats:pseudo
      └─TableReader(Probe)	root		data:TableRangeScan
        └─TableRangeScan	cop[tikv]	table:t1	range: decided by [explain_easy.t.a], keep order:false, stats:pseudo
explain format = 'plan_tree' select t.c in (select count(*) from t s use index(idx), t t1 where s.b = t.a and s.c = t1.a) from t;
id	task	access object	operator info
Projection	root		Column
└─Apply	root		CARTESIAN left outer semi join, left side:TableReader, other cond:eq(explain_easy.t.c, Column)
  ├─TableReader(Build)	root		data:TableFullScan
  │ └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
  └─StreamAgg(Probe)	root		funcs:count(1)->Column
    └─IndexJoin	root		inner join, inner:TableReader, outer key:explain_easy.t.c, inner key:explain_easy.t.a, equal cond:eq(explain_easy.t.c, explain_easy.t.a)
      ├─IndexLookUp(Build)	root		
      │ ├─IndexRangeScan(Build)	cop[tikv]	table:s, index:idx(b)	range: decided by [eq(explain_easy.t.b, explain_easy.t.a)], keep order:false, stats:pseudo
      │ └─Selection(Probe)	cop[tikv]		not(isnull(explain_easy.t.c))
      │   └─TableRowIDScan	cop[tikv]	table:s	keep order:false, stats:pseudo
      └─TableReader(Probe)	root		data:TableRangeScan
        └─TableRangeScan	cop[tikv]	table:t1	range: decided by [explain_easy.t.c], keep order:false, stats:pseudo
insert into t values(1, 1, 1), (2, 2 ,2), (3, 3, 3), (4, 3, 4),(5,3,5);
analyze table t;
explain format = 'plan_tree' select t.c in (select count(*) from t s, t t1 where s.b = t.a and s.b = 3 and s.a = t1.a) from t;
id	task	access object	operator info
Projection	root		Column
└─Apply	root		CARTESIAN left outer semi join, left side:TableReader, other cond:eq(explain_easy.t.c, Column)
  ├─TableReader(Build)	root		data:TableFullScan
  │ └─TableFullScan	cop[tikv]	table:t	keep order:false
  └─StreamAgg(Probe)	root		funcs:count(1)->Column
    └─MergeJoin	root		inner join, left key:explain_easy.t.a, right key:explain_easy.t.a
      ├─TableReader(Build)	root		data:Selection
      │ └─Selection	cop[tikv]		eq(explain_easy.t.a, 3)
      │   └─TableFullScan	cop[tikv]	table:t1	keep order:true
      └─IndexReader(Probe)	root		index:Selection
        └─Selection	cop[tikv]		eq(explain_easy.t.a, 3)
          └─IndexRangeScan	cop[tikv]	table:s, index:idx(b)	range:[3,3], keep order:true
explain format = 'plan_tree' select t.c in (select count(*) from t s left join t t1 on s.a = t1.a where 3 = t.a and s.b = 3) from t;
id	task	access object	operator info
Projection	root		Column
└─Apply	root		CARTESIAN left outer semi join, left side:TableReader, other cond:eq(explain_easy.t.c, Column)
  ├─TableReader(Build)	root		data:TableFullScan
  │ └─TableFullScan	cop[tikv]	table:t	keep order:false
  └─StreamAgg(Probe)	root		funcs:count(Column)->Column
    └─IndexReader	root		index:StreamAgg
      └─StreamAgg	cop[tikv]		funcs:count(1)->Column
        └─Selection	cop[tikv]		eq(3, explain_easy.t.a)
          └─IndexRangeScan	cop[tikv]	table:s, index:idx(b)	range:[3,3], keep order:false
explain format = 'plan_tree' select t.c in (select count(*) from t s right join t t1 on s.a = t1.a where 3 = t.a and t1.b = 3) from t;
id	task	access object	operator info
Projection	root		Column
└─Apply	root		CARTESIAN left outer semi join, left side:TableReader, other cond:eq(explain_easy.t.c, Column)
  ├─TableReader(Build)	root		data:TableFullScan
  │ └─TableFullScan	cop[tikv]	table:t	keep order:false
  └─StreamAgg(Probe)	root		funcs:count(Column)->Column
    └─IndexReader	root		index:StreamAgg
      └─StreamAgg	cop[tikv]		funcs:count(1)->Column
        └─Selection	cop[tikv]		eq(3, explain_easy.t.a)
          └─IndexRangeScan	cop[tikv]	table:t1, index:idx(b)	range:[3,3], keep order:false
drop table if exists t;
create table t(a int unsigned not null);
explain format = 'plan_tree' select t.a = '123455' from t;
id	task	access object	operator info
Projection	root		eq(explain_easy.t.a, 123455)->Column
└─TableReader	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format = 'plan_tree' select t.a > '123455' from t;
id	task	access object	operator info
Projection	root		gt(explain_easy.t.a, 123455)->Column
└─TableReader	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format = 'plan_tree' select t.a != '123455' from t;
id	task	access object	operator info
Projection	root		ne(explain_easy.t.a, 123455)->Column
└─TableReader	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format = 'plan_tree' select t.a = 12345678912345678998789678687678.111 from t;
id	task	access object	operator info
Projection	root		0->Column
└─TableReader	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
drop table if exists t;
create table t(a bigint, b bigint, index idx(a, b));
explain format = 'plan_tree' select * from t where a in (1, 2) and a in (1, 3);
id	task	access object	operator info
IndexReader	root		index:IndexRangeScan
└─IndexRangeScan	cop[tikv]	table:t, index:idx(a, b)	range:[1,1], keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t where b in (1, 2) and b in (1, 3);
id	task	access object	operator info
TableReader	root		data:Selection
└─Selection	cop[tikv]		in(explain_easy.t.b, 1, 2), in(explain_easy.t.b, 1, 3)
  └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t where a = 1 and a = 1;
id	task	access object	operator info
IndexReader	root		index:IndexRangeScan
└─IndexRangeScan	cop[tikv]	table:t, index:idx(a, b)	range:[1,1], keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t where a = 1 and a = 2;
id	task	access object	operator info
TableDual	root		rows:0
explain format = 'plan_tree' select * from t where b = 1 and b = 2;
id	task	access object	operator info
TableDual	root		rows:0
explain format = 'plan_tree' select * from t t1 join t t2 where t1.b = t2.b and t2.b is null;
id	task	access object	operator info
Projection	root		explain_easy.t.a, explain_easy.t.b, explain_easy.t.a, explain_easy.t.b
└─HashJoin	root		inner join, equal:[eq(explain_easy.t.b, explain_easy.t.b)]
  ├─TableReader(Build)	root		data:Selection
  │ └─Selection	cop[tikv]		isnull(explain_easy.t.b), not(isnull(explain_easy.t.b))
  │   └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
  └─TableReader(Probe)	root		data:Selection
    └─Selection	cop[tikv]		not(isnull(explain_easy.t.b))
      └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t t1 where not exists (select * from t t2 where t1.b = t2.b);
id	task	access object	operator info
HashJoin	root		anti semi join, left side:TableReader, equal:[eq(explain_easy.t.b, explain_easy.t.b)]
├─TableReader(Build)	root		data:TableFullScan
│ └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
└─TableReader(Probe)	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
drop table if exists t;
create table t(a bigint primary key);
explain format = 'plan_tree' select * from t where a = 1 and a = 2;
id	task	access object	operator info
TableDual	root		rows:0
explain format = 'plan_tree' select null or a > 1 from t;
id	task	access object	operator info
Projection	root		or(<nil>, gt(explain_easy.t.a, 1))->Column
└─TableReader	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t where a = 1 for update;
id	task	access object	operator info
Point_Get	root	table:t	handle:1
drop table if exists ta, tb;
create table ta (a varchar(20));
create table tb (a varchar(20));
begin;
insert tb values ('1');
explain format = 'plan_tree' select * from ta where a = 1;
id	task	access object	operator info
TableReader	root		data:Selection
└─Selection	cop[tikv]		eq(cast(explain_easy.ta.a, double BINARY), 1)
  └─TableFullScan	cop[tikv]	table:ta	keep order:false, stats:pseudo
rollback;
drop table if exists t1, t2;
create table t1(a int, b int, c int, primary key(a, b));
create table t2(a int, b int, c int, primary key(a));
explain format = 'plan_tree' select t1.a, t1.b from t1 left outer join t2 on t1.a = t2.a;
id	task	access object	operator info
IndexReader	root		index:IndexFullScan
└─IndexFullScan	cop[tikv]	table:t1, index:PRIMARY(a, b)	keep order:false, stats:pseudo
explain format = 'plan_tree' select distinct t1.a, t1.b from t1 left outer join t2 on t1.a = t2.a;
id	task	access object	operator info
IndexReader	root		index:IndexFullScan
└─IndexFullScan	cop[tikv]	table:t1, index:PRIMARY(a, b)	keep order:false, stats:pseudo
CREATE TABLE `test01` (
`id` bigint(20) NOT NULL AUTO_INCREMENT,
`stat_date` int(11) NOT NULL DEFAULT '0',
`show_date` varchar(20) NOT NULL DEFAULT '',
`region_id` bigint(20) unsigned NOT NULL DEFAULT '0',
`period` tinyint(3) unsigned NOT NULL DEFAULT '0',
`registration_num` bigint(20) unsigned NOT NULL DEFAULT '0',
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
CREATE TABLE `test02` (
`id` bigint(20) NOT NULL AUTO_INCREMENT,
`region_name` varchar(128) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
explain format = 'plan_tree' SELECT COUNT(1) FROM (SELECT COALESCE(b.region_name, '不详') region_name, SUM(a.registration_num) registration_num FROM (SELECT stat_date, show_date, region_id, 0 registration_num FROM test01 WHERE period = 1 AND stat_date >= 20191202 AND stat_date <= 20191202 UNION ALL SELECT stat_date, show_date, region_id, registration_num registration_num FROM test01 WHERE period = 1 AND stat_date >= 20191202 AND stat_date <= 20191202) a LEFT JOIN test02 b ON a.region_id = b.id WHERE registration_num > 0 AND a.stat_date >= '20191202' AND a.stat_date <= '20191202' GROUP BY a.stat_date , a.show_date , COALESCE(b.region_name, '不详') ) JLS;
id	task	access object	operator info
StreamAgg	root		funcs:count(1)->Column
└─HashAgg	root		group by:Column, Column, Column, funcs:count(1)->Column
  └─Projection	root		Column, Column, coalesce(explain_easy.test02.region_name, 不详)->Column
    └─IndexJoin	root		left outer join, inner:TableReader, left side:HashAgg, outer key:Column, inner key:explain_easy.test02.id, equal cond:eq(Column, explain_easy.test02.id)
      ├─HashAgg(Build)	root		group by:Column, Column, Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column, funcs:count(1)->Column
      │ └─Union	root		
      │   ├─Projection	root		Column, Column, Column, Column, Column, Column
      │   │ └─HashAgg	root		group by:explain_easy.test01.region_id, explain_easy.test01.show_date, explain_easy.test01.stat_date, funcs:firstrow(explain_easy.test01.stat_date)->Column, funcs:firstrow(explain_easy.test01.show_date)->Column, funcs:firstrow(explain_easy.test01.region_id)->Column, funcs:firstrow(explain_easy.test01.stat_date)->Column, funcs:firstrow(explain_easy.test01.show_date)->Column, funcs:firstrow(explain_easy.test01.region_id)->Column, funcs:count(1)->Column
      │   │   └─TableDual	root		rows:0
      │   └─Projection	root		Column, Column, Column, Column, Column, Column
      │     └─HashAgg	root		group by:explain_easy.test01.region_id, explain_easy.test01.show_date, explain_easy.test01.stat_date, funcs:firstrow(explain_easy.test01.stat_date)->Column, funcs:firstrow(explain_easy.test01.show_date)->Column, funcs:firstrow(explain_easy.test01.region_id)->Column, funcs:firstrow(explain_easy.test01.stat_date)->Column, funcs:firstrow(explain_easy.test01.show_date)->Column, funcs:firstrow(explain_easy.test01.region_id)->Column, funcs:count(Column)->Column
      │       └─TableReader	root		data:HashAgg
      │         └─HashAgg	cop[tikv]		group by:explain_easy.test01.region_id, explain_easy.test01.show_date, explain_easy.test01.stat_date, funcs:count(1)->Column
      │           └─Selection	cop[tikv]		eq(explain_easy.test01.period, 1), ge(explain_easy.test01.stat_date, 20191202), gt(cast(explain_easy.test01.registration_num, decimal(20,0) BINARY), 0), le(explain_easy.test01.stat_date, 20191202)
      │             └─TableFullScan	cop[tikv]	table:test01	keep order:false, stats:pseudo
      └─TableReader(Probe)	root		data:TableRangeScan
        └─TableRangeScan	cop[tikv]	table:b	range: decided by [Column], keep order:false, stats:pseudo
drop table if exists t;
create table t(a int, nb int not null, nc int not null);
explain format = 'plan_tree' select ifnull(a, 0) from t;
id	task	access object	operator info
Projection	root		ifnull(explain_easy.t.a, 0)->Column
└─TableReader	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format = 'plan_tree' select ifnull(nb, 0) from t;
id	task	access object	operator info
Projection	root		cast(explain_easy.t.nb, bigint BINARY)->Column
└─TableReader	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format = 'plan_tree' select ifnull(nb, 0), ifnull(nc, 0) from t;
id	task	access object	operator info
Projection	root		cast(explain_easy.t.nb, bigint BINARY)->Column, cast(explain_easy.t.nc, bigint BINARY)->Column
└─TableReader	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format = 'plan_tree' select ifnull(a, 0), ifnull(nb, 0) from t;
id	task	access object	operator info
Projection	root		ifnull(explain_easy.t.a, 0)->Column, cast(explain_easy.t.nb, bigint BINARY)->Column
└─TableReader	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format = 'plan_tree' select ifnull(nb, 0), ifnull(nb, 0) from t;
id	task	access object	operator info
Projection	root		cast(explain_easy.t.nb, bigint BINARY)->Column, cast(explain_easy.t.nb, bigint BINARY)->Column
└─TableReader	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format = 'plan_tree' select 1+ifnull(nb, 0) from t;
id	task	access object	operator info
Projection	root		plus(1, cast(explain_easy.t.nb, bigint BINARY))->Column
└─TableReader	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format = 'plan_tree' select 1+ifnull(a, 0) from t;
id	task	access object	operator info
Projection	root		plus(1, ifnull(explain_easy.t.a, 0))->Column
└─TableReader	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format = 'plan_tree' select 1+ifnull(nb, 0) from t where nb=1;
id	task	access object	operator info
Projection	root		plus(1, cast(explain_easy.t.nb, bigint BINARY))->Column
└─TableReader	root		data:Selection
  └─Selection	cop[tikv]		eq(explain_easy.t.nb, 1)
    └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t ta left outer join t tb on ta.nb = tb.nb and ta.a > 1 where ifnull(ta.nb, 1) or ta.nb is null;
id	task	access object	operator info
HashJoin	root		left outer join, left side:TableReader, equal:[eq(explain_easy.t.nb, explain_easy.t.nb)], left cond:[gt(explain_easy.t.a, 1)]
├─TableReader(Build)	root		data:Selection
│ └─Selection	cop[tikv]		cast(explain_easy.t.nb, bigint BINARY)
│   └─TableFullScan	cop[tikv]	table:tb	keep order:false, stats:pseudo
└─TableReader(Probe)	root		data:Selection
  └─Selection	cop[tikv]		cast(explain_easy.t.nb, bigint BINARY)
    └─TableFullScan	cop[tikv]	table:ta	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t ta right outer join t tb on ta.nb = tb.nb and ta.a > 1 where ifnull(tb.nb, 1) or tb.nb is null;
id	task	access object	operator info
HashJoin	root		right outer join, left side:TableReader, equal:[eq(explain_easy.t.nb, explain_easy.t.nb)]
├─TableReader(Build)	root		data:Selection
│ └─Selection	cop[tikv]		cast(explain_easy.t.nb, bigint BINARY), gt(explain_easy.t.a, 1)
│   └─TableFullScan	cop[tikv]	table:ta	keep order:false, stats:pseudo
└─TableReader(Probe)	root		data:Selection
  └─Selection	cop[tikv]		cast(explain_easy.t.nb, bigint BINARY)
    └─TableFullScan	cop[tikv]	table:tb	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t ta inner join t tb on ta.nb = tb.nb and ta.a > 1 where ifnull(tb.nb, 1) or tb.nb is null;
id	task	access object	operator info
HashJoin	root		inner join, equal:[eq(explain_easy.t.nb, explain_easy.t.nb)]
├─TableReader(Build)	root		data:Selection
│ └─Selection	cop[tikv]		cast(explain_easy.t.nb, bigint BINARY), gt(explain_easy.t.a, 1)
│   └─TableFullScan	cop[tikv]	table:ta	keep order:false, stats:pseudo
└─TableReader(Probe)	root		data:Selection
  └─Selection	cop[tikv]		cast(explain_easy.t.nb, bigint BINARY)
    └─TableFullScan	cop[tikv]	table:tb	keep order:false, stats:pseudo
explain format = 'plan_tree' select ifnull(t.nc, 1) in (select count(*) from t s , t t1 where s.a = t.a and s.a = t1.a) from t;
id	task	access object	operator info
Projection	root		Column
└─Apply	root		left outer semi join, left side:Projection, equal:[eq(Column, Column)]
  ├─Projection(Build)	root		explain_easy.t.a, cast(explain_easy.t.nc, bigint BINARY)->Column
  │ └─TableReader	root		data:TableFullScan
  │   └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
  └─HashAgg(Probe)	root		funcs:count(Column)->Column
    └─HashJoin	root		inner join, equal:[eq(explain_easy.t.a, explain_easy.t.a)]
      ├─HashAgg(Build)	root		group by:explain_easy.t.a, funcs:count(Column)->Column, funcs:firstrow(explain_easy.t.a)->explain_easy.t.a
      │ └─TableReader	root		data:HashAgg
      │   └─HashAgg	cop[tikv]		group by:explain_easy.t.a, funcs:count(1)->Column
      │     └─Selection	cop[tikv]		eq(explain_easy.t.a, explain_easy.t.a), not(isnull(explain_easy.t.a))
      │       └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
      └─TableReader(Probe)	root		data:Selection
        └─Selection	cop[tikv]		eq(explain_easy.t.a, explain_easy.t.a), not(isnull(explain_easy.t.a))
          └─TableFullScan	cop[tikv]	table:s	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t ta left outer join t tb on ta.nb = tb.nb and ta.a > 1 where ifnull(tb.a, 1) or tb.a is null;
id	task	access object	operator info
Selection	root		or(ifnull(explain_easy.t.a, 1), isnull(explain_easy.t.a))
└─HashJoin	root		left outer join, left side:TableReader, equal:[eq(explain_easy.t.nb, explain_easy.t.nb)], left cond:[gt(explain_easy.t.a, 1)]
  ├─TableReader(Build)	root		data:TableFullScan
  │ └─TableFullScan	cop[tikv]	table:tb	keep order:false, stats:pseudo
  └─TableReader(Probe)	root		data:TableFullScan
    └─TableFullScan	cop[tikv]	table:ta	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t ta right outer join t tb on ta.nb = tb.nb and ta.a > 1 where ifnull(tb.a, 1) or tb.a is null;
id	task	access object	operator info
HashJoin	root		right outer join, left side:TableReader, equal:[eq(explain_easy.t.nb, explain_easy.t.nb)]
├─TableReader(Build)	root		data:Selection
│ └─Selection	cop[tikv]		gt(explain_easy.t.a, 1)
│   └─TableFullScan	cop[tikv]	table:ta	keep order:false, stats:pseudo
└─TableReader(Probe)	root		data:Selection
  └─Selection	cop[tikv]		or(ifnull(explain_easy.t.a, 1), isnull(explain_easy.t.a))
    └─TableFullScan	cop[tikv]	table:tb	keep order:false, stats:pseudo
explain format = 'plan_tree' select ifnull(t.a, 1) in (select count(*) from t s , t t1 where s.a = t.a and s.a = t1.a) from t;
id	task	access object	operator info
Projection	root		Column
└─Apply	root		left outer semi join, left side:Projection, equal:[eq(Column, Column)]
  ├─Projection(Build)	root		explain_easy.t.a, ifnull(explain_easy.t.a, 1)->Column
  │ └─TableReader	root		data:TableFullScan
  │   └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
  └─HashAgg(Probe)	root		funcs:count(Column)->Column
    └─HashJoin	root		inner join, equal:[eq(explain_easy.t.a, explain_easy.t.a)]
      ├─HashAgg(Build)	root		group by:explain_easy.t.a, funcs:count(Column)->Column, funcs:firstrow(explain_easy.t.a)->explain_easy.t.a
      │ └─TableReader	root		data:HashAgg
      │   └─HashAgg	cop[tikv]		group by:explain_easy.t.a, funcs:count(1)->Column
      │     └─Selection	cop[tikv]		eq(explain_easy.t.a, explain_easy.t.a), not(isnull(explain_easy.t.a))
      │       └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
      └─TableReader(Probe)	root		data:Selection
        └─Selection	cop[tikv]		eq(explain_easy.t.a, explain_easy.t.a), not(isnull(explain_easy.t.a))
          └─TableFullScan	cop[tikv]	table:s	keep order:false, stats:pseudo
drop table if exists t;
create table t(a int);
explain format = 'plan_tree' select * from t where _tidb_rowid = 0;
id	task	access object	operator info
Point_Get	root	table:t	handle:0
explain format = 'plan_tree' select * from t where _tidb_rowid > 0;
id	task	access object	operator info
TableReader	root		data:Projection
└─Projection	cop[tikv]		explain_easy.t.a
  └─TableRangeScan	cop[tikv]	table:t	range:(0,+inf], keep order:false, stats:pseudo
explain format = 'plan_tree' select a, _tidb_rowid from t where a > 0;
id	task	access object	operator info
TableReader	root		data:Selection
└─Selection	cop[tikv]		gt(explain_easy.t.a, 0)
  └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format = 'plan_tree' select * from t where _tidb_rowid > 0 and a > 0;
id	task	access object	operator info
TableReader	root		data:Projection
└─Projection	cop[tikv]		explain_easy.t.a
  └─Selection	cop[tikv]		gt(explain_easy.t.a, 0)
    └─TableRangeScan	cop[tikv]	table:t	range:(0,+inf], keep order:false, stats:pseudo
drop table if exists t;
create table t(a int, b int, c int);
explain format = 'plan_tree' select * from (select * from t order by (select 2)) t order by a, b;
id	task	access object	operator info
Sort	root		explain_easy.t.a, explain_easy.t.b
└─TableReader	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
ScalarSubQuery	root		Output: ScalarQueryCol#6
└─MaxOneRow	root		
  └─Projection	root		2->Column
    └─TableDual	root		rows:1
explain format = 'plan_tree' select * from (select * from t order by c) t order by a, b;
id	task	access object	operator info
Sort	root		explain_easy.t.a, explain_easy.t.b
└─TableReader	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
drop table if exists t;
set @@session.tidb_opt_insubq_to_join_and_agg=1;
explain format = 'plan_tree' SELECT 0 AS a FROM dual UNION SELECT 1 AS a FROM dual ORDER BY a;
id	task	access object	operator info
Sort	root		Column
└─HashAgg	root		group by:Column, funcs:firstrow(Column)->Column
  └─Union	root		
    ├─HashAgg	root		group by:1, funcs:firstrow(0)->Column, funcs:firstrow(0)->Column
    │ └─TableDual	root		rows:1
    └─HashAgg	root		group by:1, funcs:firstrow(1)->Column, funcs:firstrow(1)->Column
      └─TableDual	root		rows:1
explain format = 'plan_tree' SELECT 0 AS a FROM dual UNION (SELECT 1 AS a FROM dual ORDER BY a);
id	task	access object	operator info
HashAgg	root		group by:Column, funcs:firstrow(Column)->Column
└─Union	root		
  ├─HashAgg	root		group by:1, funcs:firstrow(0)->Column, funcs:firstrow(0)->Column
  │ └─TableDual	root		rows:1
  └─StreamAgg	root		group by:Column, funcs:firstrow(Column)->Column, funcs:firstrow(Column)->Column
    └─Projection	root		1->Column
      └─TableDual	root		rows:1
create table t (i int key, j int, unique key (i, j));
begin;
insert into t values (1, 1);
explain format = 'plan_tree' update t set j = -j where i = 1 and j = 1;
id	task	access object	operator info
Update	root		N/A
└─Selection	root		eq(explain_easy.t.j, 1)
  └─Point_Get	root	table:t	handle:1, lock
rollback;
drop table if exists t;
create table t(a int);
begin;
insert into t values (1);
explain format = 'plan_tree' select * from t left outer join t t1 on t.a = t1.a where t.a not between 1 and 2;
id	task	access object	operator info
HashJoin	root		left outer join, left side:UnionScan, equal:[eq(explain_easy.t.a, explain_easy.t.a)]
├─UnionScan(Build)	root		not(isnull(explain_easy.t.a)), or(lt(explain_easy.t.a, 1), gt(explain_easy.t.a, 2))
│ └─TableReader	root		data:Selection
│   └─Selection	cop[tikv]		not(isnull(explain_easy.t.a)), or(lt(explain_easy.t.a, 1), gt(explain_easy.t.a, 2))
│     └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
└─UnionScan(Probe)	root		or(lt(explain_easy.t.a, 1), gt(explain_easy.t.a, 2))
  └─TableReader	root		data:Selection
    └─Selection	cop[tikv]		or(lt(explain_easy.t.a, 1), gt(explain_easy.t.a, 2))
      └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
rollback;
drop table if exists t;
create table t(a time, b date);
insert into t values (1, "1000-01-01"), (2, "1000-01-02"), (3, "1000-01-03");
analyze table t all columns;
explain format = 'plan_tree' select * from t where a = 1;
id	task	access object	operator info
TableReader	root		data:Selection
└─Selection	cop[tikv]		eq(explain_easy.t.a, 00:00:01.000000)
  └─TableFullScan	cop[tikv]	table:t	keep order:false
explain format = 'plan_tree' select * from t where b = "1000-01-01";
id	task	access object	operator info
TableReader	root		data:Selection
└─Selection	cop[tikv]		eq(explain_easy.t.b, 1000-01-01 00:00:00.000000)
  └─TableFullScan	cop[tikv]	table:t	keep order:false
drop table t;
create table t(a int);
insert into t values (1),(2),(2),(2),(9),(9),(9),(10);
analyze table t all columns with 1 buckets;
explain format = 'plan_tree' select * from t where a >= 3 and a <= 8;
id	task	access object	operator info
TableReader	root		data:Selection
└─Selection	cop[tikv]		ge(explain_easy.t.a, 3), le(explain_easy.t.a, 8)
  └─TableFullScan	cop[tikv]	table:t	keep order:false
drop table t;
create table t(a int, b int, index idx_ab(a, b));
explain format = 'plan_tree' select a, b from t where a in (1) order by b;
id	task	access object	operator info
IndexReader	root		index:IndexRangeScan
└─IndexRangeScan	cop[tikv]	table:t, index:idx_ab(a, b)	range:[1,1], keep order:true, stats:pseudo
explain format = 'plan_tree' select a, b from t where a = 1 order by b;
id	task	access object	operator info
IndexReader	root		index:IndexRangeScan
└─IndexRangeScan	cop[tikv]	table:t, index:idx_ab(a, b)	range:[1,1], keep order:true, stats:pseudo
drop table if exists t;
create table t(a int, b int);
explain format = 'plan_tree' select a, b from (select a, b, avg(b) over (partition by a)as avg_b from t) as tt where a > 10 and b < 10 and a > avg_b;
id	task	access object	operator info
Projection	root		explain_easy.t.a, explain_easy.t.b
└─Selection	root		gt(cast(explain_easy.t.a, decimal(10,0) BINARY), Column), lt(explain_easy.t.b, 10)
  └─Window	root		avg(cast(explain_easy.t.b, decimal(10,0) BINARY))->Column#5 over(partition by explain_easy.t.a)
    └─Sort	root		explain_easy.t.a
      └─TableReader	root		data:Selection
        └─Selection	cop[tikv]		gt(explain_easy.t.a, 10)
          └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
drop table if exists t;
create table t(a int, b int);
explain format="dot" select * from t where a < 2;
dot contents

digraph TableReader_8 {
subgraph cluster8{
node [style=filled, color=lightgrey]
color=black
label = "root"
"TableReader_8"
}
subgraph cluster7{
node [style=filled, color=lightgrey]
color=black
label = "cop"
"Selection_7" -> "TableFullScan_6"
}
"TableReader_8" -> "Selection_7"
}

drop table if exists t;
create table t(a binary(16) not null, b varchar(2) default null, c varchar(100) default 'aaaa', key (a,b));
explain format = 'plan_tree' select * from t where a=x'FA34E1093CB428485734E3917F000000' and b='xb';
id	task	access object	operator info
IndexLookUp	root		
├─IndexRangeScan(Build)	cop[tikv]	table:t, index:a(a, b)	range:["\xfa4\xe1\t<\xb4(HW4\xe3\x91\x7f\x00\x00\x00" "xb","\xfa4\xe1\t<\xb4(HW4\xe3\x91\x7f\x00\x00\x00" "xb"], keep order:false, stats:pseudo
└─TableRowIDScan(Probe)	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format = 'plan_tree' update t set c = 'ssss' where a=x'FA34E1093CB428485734E3917F000000' and b='xb';
id	task	access object	operator info
Update	root		N/A
└─IndexLookUp	root		
  ├─IndexRangeScan(Build)	cop[tikv]	table:t, index:a(a, b)	range:["\xfa4\xe1\t<\xb4(HW4\xe3\x91\x7f\x00\x00\x00" "xb","\xfa4\xe1\t<\xb4(HW4\xe3\x91\x7f\x00\x00\x00" "xb"], keep order:false, stats:pseudo
  └─TableRowIDScan(Probe)	cop[tikv]	table:t	keep order:false, stats:pseudo
drop table if exists t;
create table t(a int, b int);
analyze table t;
explain format = 'plan_tree' select (select count(n.a) from t) from t n;
id	task	access object	operator info
Projection	root		Column
└─Apply	root		CARTESIAN left outer join, left side:StreamAgg
  ├─StreamAgg(Build)	root		funcs:count(explain_easy.t.a)->Column
  │ └─TableReader	root		data:TableFullScan
  │   └─TableFullScan	cop[tikv]	table:n	keep order:false, stats:pseudo
  └─MaxOneRow(Probe)	root		
    └─Projection	root		Column
      └─TableReader	root		data:TableFullScan
        └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format = 'plan_tree' select (select sum((select count(a)))) from t;
id	task	access object	operator info
Projection	root		Column
└─Apply	root		CARTESIAN left outer join, left side:StreamAgg
  ├─StreamAgg(Build)	root		funcs:count(explain_easy.t.a)->Column
  │ └─TableReader	root		data:TableFullScan
  │   └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
  └─HashAgg(Probe)	root		funcs:sum(Column)->Column
    └─HashJoin	root		CARTESIAN left outer join, left side:TableDual
      ├─HashAgg(Build)	root		group by:1, funcs:sum(Column)->Column
      │ └─Projection	root		cast(Column, decimal(20,0) BINARY)->Column
      │   └─MaxOneRow	root		
      │     └─Projection	root		Column
      │       └─TableDual	root		rows:1
      └─TableDual(Probe)	root		rows:1
explain format = 'plan_tree' select count(a) from t group by b order by (select count(a));
id	task	access object	operator info
Projection	root		Column
└─Sort	root		Column
  └─Apply	root		CARTESIAN left outer join, left side:HashAgg
    ├─HashAgg(Build)	root		group by:explain_easy.t.b, funcs:count(explain_easy.t.a)->Column
    │ └─TableReader	root		data:TableFullScan
    │   └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
    └─Projection(Probe)	root		Column
      └─TableDual	root		rows:1
explain format = 'plan_tree' select (select sum(count(a))) from t;
id	task	access object	operator info
Projection	root		Column
└─Apply	root		CARTESIAN left outer join, left side:StreamAgg
  ├─StreamAgg(Build)	root		funcs:count(explain_easy.t.a)->Column
  │ └─TableReader	root		data:TableFullScan
  │   └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
  └─StreamAgg(Probe)	root		funcs:sum(Column)->Column
    └─Projection	root		cast(Column, decimal(20,0) BINARY)->Column
      └─TableDual	root		rows:1
explain format = 'plan_tree' select sum(a), (select sum(a)), count(a) from t group by b order by (select count(a));
id	task	access object	operator info
Projection	root		Column, Column, Column
└─Sort	root		Column
  └─Apply	root		CARTESIAN left outer join, left side:Apply
    ├─Apply(Build)	root		CARTESIAN left outer join, left side:HashAgg
    │ ├─HashAgg(Build)	root		group by:Column, funcs:sum(Column)->Column, funcs:count(Column)->Column
    │ │ └─Projection	root		cast(explain_easy.t.a, decimal(10,0) BINARY)->Column, explain_easy.t.a->Column, explain_easy.t.b->Column
    │ │   └─TableReader	root		data:TableFullScan
    │ │     └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
    │ └─Projection(Probe)	root		Column
    │   └─TableDual	root		rows:1
    └─Projection(Probe)	root		Column
      └─TableDual	root		rows:1
drop table if exists t;
create table t(a tinyint, b smallint, c mediumint, d int, e bigint);
insert into mysql.opt_rule_blacklist VALUES("aggregation_push_down");
admin reload opt_rule_blacklist;
explain format = 'plan_tree' select sum(t1.a) from t t1 join t t2 on t1.a=t2.a;
id	task	access object	operator info
StreamAgg	root		funcs:sum(Column)->Column
└─Projection	root		cast(explain_easy.t.a, decimal(3,0) BINARY)->Column
  └─HashJoin	root		inner join, equal:[eq(explain_easy.t.a, explain_easy.t.a)]
    ├─TableReader(Build)	root		data:Selection
    │ └─Selection	cop[tikv]		not(isnull(explain_easy.t.a))
    │   └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
    └─TableReader(Probe)	root		data:Selection
      └─Selection	cop[tikv]		not(isnull(explain_easy.t.a))
        └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select sum(t1.b) from t t1 join t t2 on t1.b=t2.b;
id	task	access object	operator info
StreamAgg	root		funcs:sum(Column)->Column
└─Projection	root		cast(explain_easy.t.b, decimal(5,0) BINARY)->Column
  └─HashJoin	root		inner join, equal:[eq(explain_easy.t.b, explain_easy.t.b)]
    ├─TableReader(Build)	root		data:Selection
    │ └─Selection	cop[tikv]		not(isnull(explain_easy.t.b))
    │   └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
    └─TableReader(Probe)	root		data:Selection
      └─Selection	cop[tikv]		not(isnull(explain_easy.t.b))
        └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select sum(t1.c) from t t1 join t t2 on t1.c=t2.c;
id	task	access object	operator info
StreamAgg	root		funcs:sum(Column)->Column
└─Projection	root		cast(explain_easy.t.c, decimal(8,0) BINARY)->Column
  └─HashJoin	root		inner join, equal:[eq(explain_easy.t.c, explain_easy.t.c)]
    ├─TableReader(Build)	root		data:Selection
    │ └─Selection	cop[tikv]		not(isnull(explain_easy.t.c))
    │   └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
    └─TableReader(Probe)	root		data:Selection
      └─Selection	cop[tikv]		not(isnull(explain_easy.t.c))
        └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select sum(t1.d) from t t1 join t t2 on t1.d=t2.d;
id	task	access object	operator info
StreamAgg	root		funcs:sum(Column)->Column
└─Projection	root		cast(explain_easy.t.d, decimal(10,0) BINARY)->Column
  └─HashJoin	root		inner join, equal:[eq(explain_easy.t.d, explain_easy.t.d)]
    ├─TableReader(Build)	root		data:Selection
    │ └─Selection	cop[tikv]		not(isnull(explain_easy.t.d))
    │   └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
    └─TableReader(Probe)	root		data:Selection
      └─Selection	cop[tikv]		not(isnull(explain_easy.t.d))
        └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select sum(t1.e) from t t1 join t t2 on t1.e=t2.e;
id	task	access object	operator info
StreamAgg	root		funcs:sum(Column)->Column
└─Projection	root		cast(explain_easy.t.e, decimal(20,0) BINARY)->Column
  └─HashJoin	root		inner join, equal:[eq(explain_easy.t.e, explain_easy.t.e)]
    ├─TableReader(Build)	root		data:Selection
    │ └─Selection	cop[tikv]		not(isnull(explain_easy.t.e))
    │   └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
    └─TableReader(Probe)	root		data:Selection
      └─Selection	cop[tikv]		not(isnull(explain_easy.t.e))
        └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select avg(t1.a) from t t1 join t t2 on t1.a=t2.a;
id	task	access object	operator info
StreamAgg	root		funcs:avg(Column)->Column
└─Projection	root		cast(explain_easy.t.a, decimal(3,0) BINARY)->Column
  └─HashJoin	root		inner join, equal:[eq(explain_easy.t.a, explain_easy.t.a)]
    ├─TableReader(Build)	root		data:Selection
    │ └─Selection	cop[tikv]		not(isnull(explain_easy.t.a))
    │   └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
    └─TableReader(Probe)	root		data:Selection
      └─Selection	cop[tikv]		not(isnull(explain_easy.t.a))
        └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select avg(t1.b) from t t1 join t t2 on t1.b=t2.b;
id	task	access object	operator info
StreamAgg	root		funcs:avg(Column)->Column
└─Projection	root		cast(explain_easy.t.b, decimal(5,0) BINARY)->Column
  └─HashJoin	root		inner join, equal:[eq(explain_easy.t.b, explain_easy.t.b)]
    ├─TableReader(Build)	root		data:Selection
    │ └─Selection	cop[tikv]		not(isnull(explain_easy.t.b))
    │   └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
    └─TableReader(Probe)	root		data:Selection
      └─Selection	cop[tikv]		not(isnull(explain_easy.t.b))
        └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select avg(t1.c) from t t1 join t t2 on t1.c=t2.c;
id	task	access object	operator info
StreamAgg	root		funcs:avg(Column)->Column
└─Projection	root		cast(explain_easy.t.c, decimal(8,0) BINARY)->Column
  └─HashJoin	root		inner join, equal:[eq(explain_easy.t.c, explain_easy.t.c)]
    ├─TableReader(Build)	root		data:Selection
    │ └─Selection	cop[tikv]		not(isnull(explain_easy.t.c))
    │   └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
    └─TableReader(Probe)	root		data:Selection
      └─Selection	cop[tikv]		not(isnull(explain_easy.t.c))
        └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select avg(t1.d) from t t1 join t t2 on t1.d=t2.d;
id	task	access object	operator info
StreamAgg	root		funcs:avg(Column)->Column
└─Projection	root		cast(explain_easy.t.d, decimal(10,0) BINARY)->Column
  └─HashJoin	root		inner join, equal:[eq(explain_easy.t.d, explain_easy.t.d)]
    ├─TableReader(Build)	root		data:Selection
    │ └─Selection	cop[tikv]		not(isnull(explain_easy.t.d))
    │   └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
    └─TableReader(Probe)	root		data:Selection
      └─Selection	cop[tikv]		not(isnull(explain_easy.t.d))
        └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
explain format = 'plan_tree' select avg(t1.e) from t t1 join t t2 on t1.e=t2.e;
id	task	access object	operator info
StreamAgg	root		funcs:avg(Column)->Column
└─Projection	root		cast(explain_easy.t.e, decimal(20,0) BINARY)->Column
  └─HashJoin	root		inner join, equal:[eq(explain_easy.t.e, explain_easy.t.e)]
    ├─TableReader(Build)	root		data:Selection
    │ └─Selection	cop[tikv]		not(isnull(explain_easy.t.e))
    │   └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
    └─TableReader(Probe)	root		data:Selection
      └─Selection	cop[tikv]		not(isnull(explain_easy.t.e))
        └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
drop table if exists t;
delete from mysql.opt_rule_blacklist where name="aggregation_push_down";
admin reload opt_rule_blacklist;
set @@sql_mode = default;
