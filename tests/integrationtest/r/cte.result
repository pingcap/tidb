set tidb_cost_model_version=1;
drop database if exists cte1;
create database cte1;
drop table if exists tbl_0;
create table tbl_0(a int);
with recursive cte_0 (col_10,col_11,col_12) AS ( select 1, 2,3 from tbl_0 UNION select col_10 + 1,col_11 + 1,col_12 + 1 from cte_0 where col_10 < 10 ) select * from cte_0;
col_10	col_11	col_12
drop table if exists tbl_1;
CREATE TABLE `tbl_1` (
`col_5` decimal(47,21) NOT NULL DEFAULT '5308.880000000000000000000',
`col_6` enum('Alice','Bob','Charlie','David') DEFAULT NULL,
`col_7` float NOT NULL,
`col_8` bigint NOT NULL DEFAULT '-688199144806783096',
`col_9` varchar(248) NOT NULL,
PRIMARY KEY (`col_5`,`col_7`,`col_9`,`col_8`),
UNIQUE KEY `idx_4` (`col_8`),
UNIQUE KEY `idx_7` (`col_5`,`col_7`,`col_8`),
UNIQUE KEY `idx_9` (`col_9`,`col_8`),
UNIQUE KEY `idx_3` (`col_9`(3),`col_8`),
UNIQUE KEY `idx_8` (`col_7`,`col_6`,`col_8`,`col_5`),
KEY `idx_5` (`col_7`),
KEY `idx_6` (`col_7`),
KEY `idx_10` (`col_9`,`col_5`),
KEY `idx_11` (`col_5`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
/*!50100 PARTITION BY HASH (`col_8`)
PARTITIONS 4 */;
with recursive cte_1 (col_13,col_14,col_15,col_16,col_17) AS ( with recursive cte_2 (col_18,col_19,col_20,col_21,col_22,col_23,col_24) AS ( select 1, 2,col_8,4,5,6,7 from tbl_1 ) select col_19,col_18,col_22,col_23,col_21 from cte_2 UNION ALL select col_13 + 1,col_14 + 1,col_15 + 1,col_16 + 1,col_17 + 1 from cte_1 where col_13 < 10 ) select * from cte_1;
col_13	col_14	col_15	col_16	col_17
with recursive cte_256 (col_969,col_970,col_971) AS ( with recursive cte_257 (col_972,col_973,col_974,col_975) AS ( select 1, 2,col_8,4 from tbl_1 UNION select col_972 + 1,col_973 + 1,col_974 + 1,col_975 + 1 from cte_257 where col_972 < 10 ) select col_975,col_974,col_973 from cte_257 UNION DISTINCT select col_969 + 1,col_970 + 1,col_971 + 1 from cte_256 where col_969 < 10 ) select * from cte_256;
col_969	col_970	col_971
drop table if exists tbl_2, tbl_3;
create table tbl_2 ( col_4 char(246) collate utf8_unicode_ci not null , col_5 char(253) collate utf8mb4_unicode_ci  )  ;
create table tbl_3 ( col_6 char(207) collate utf8mb4_unicode_ci , col_7 int unsigned not null  )  ;
insert into tbl_2 values ( "0",null ) ;
insert into tbl_2 values ( "1","0" ) ;
insert into tbl_2 values ( "1","1" ) ;
insert into tbl_2 values ( "0","0" ) ;
insert into tbl_2 values ( "0","1" ) ;
insert into tbl_3 values ( "1",0 ) ;
insert into tbl_3 values ( "1",1 ) ;
insert into tbl_3 values ( "0",0 ) ;
insert into tbl_3 values ( "0",1 ) ;
with recursive tbl_2 (col_64,col_65,col_66,col_67) AS ( select 1, col_6,col_6,4 from tbl_3 UNION DISTINCT select col_64 + 1,concat(col_65, 1),col_66 + 1,concat(col_67, 1) from tbl_2 where col_64 < 5 ) select * from tbl_2 order by col_64;
col_64	col_65	col_66	col_67
1	1	1	4
1	0	0	4
2	11	2	41
2	01	1	41
3	111	3	411
3	011	2	411
4	1111	4	4111
4	0111	3	4111
5	11111	5	41111
5	01111	4	41111
drop table if exists tbl_3, tbl_4;
create table tbl_3 ( col_6 int not null , col_7 char(95) collate utf8_general_ci  )  ;
create table tbl_4 ( col_8 char collate utf8_unicode_ci , col_9 char collate utf8mb4_bin  )  ;
insert into tbl_3 values ( 0,"1" ) ;
insert into tbl_4 values ( "1","0" ) ;
with recursive cte_2245 (col_8692,col_8693) AS ( select 1, col_7 from tbl_3 UNION  select col_8692 + 1,concat(col_8693, 1) from cte_2245 where col_8692 < 5 ) , cte_2246 (col_8694,col_8695,col_8696,col_8697) AS ( with recursive cte_2247 (col_8698,col_8699,col_8700,col_8701) AS ( select 1, cast("2" as char(20)),3,col_8 from tbl_4 ) select col_8698,col_8699,col_8700,col_8701 from cte_2247 UNION  select col_8694 + 1,col_8695 + 1,col_8696 + 1,col_8697 + 1 from cte_2246 where col_8694 < 5 ) select * from cte_2245,cte_2246 order by col_8692,col_8693,col_8696,col_8695,col_8697,col_8694;
col_8692	col_8693	col_8694	col_8695	col_8696	col_8697
1	1	1	2	3	1
1	1	2	3	4	2
1	1	3	4	5	3
1	1	4	5	6	4
1	1	5	6	7	5
2	11	1	2	3	1
2	11	2	3	4	2
2	11	3	4	5	3
2	11	4	5	6	4
2	11	5	6	7	5
3	111	1	2	3	1
3	111	2	3	4	2
3	111	3	4	5	3
3	111	4	5	6	4
3	111	5	6	7	5
4	1111	1	2	3	1
4	1111	2	3	4	2
4	1111	3	4	5	3
4	1111	4	5	6	4
4	1111	5	6	7	5
5	11111	1	2	3	1
5	11111	2	3	4	2
5	11111	3	4	5	3
5	11111	4	5	6	4
5	11111	5	6	7	5
with recursive cte2 as (select 1 as col_1, 2 as col_2) select c1.col_1, c2.col_2 from cte2 as c1, cte2 as c2 where c2.col_2 = 1;
col_1	col_2
with recursive cte (c1) as (select 1), cte1 (c2) as (select 1 union select c1 + 1 from cte, cte1) select * from cte, cte1;
c1	c2
1	1
1	2
with recursive tbl_0 (col_943,col_944,col_945,col_946,col_947) AS ( with recursive tbl_0 (col_948,col_949,col_950,col_951,col_952) AS ( select 1, 2,3,4,5 UNION ALL select col_948 + 1,col_949 + 1,col_950 + 1,col_951 + 1,col_952 + 1 from tbl_0 where col_948 < 5 ) select col_948,col_949,col_951,col_950,col_952 from tbl_0 UNION ALL select col_943 + 1,col_944 + 1,col_945 + 1,col_946 + 1,col_947 + 1 from tbl_0 where col_943 < 5 ) select * from tbl_0;
Error 1054 (42S22): Unknown column 'col_943' in 'where clause'
with recursive cte1 (c1, c2) as (select 1, '1' union select concat(c1, 1), c2 + 1 from cte1 where c1 < 100) select * from cte1;
c1	c2
1	1
11	2
111	3
with recursive cte_8 (col_51,col_52,col_53,col_54) AS ( with recursive cte_9 (col_55,col_56,col_57,col_58) AS ( select 1, 2,3,4 UNION ALL select col_55 + 1,col_56 + 1,col_57 + 1,col_58 + 1 from cte_9 where col_55 < 5 ) select col_55,col_57,col_56,col_58 from cte_9 UNION DISTINCT select col_51 + 1,col_52 + 1,col_53 + 1,col_54 + 1 from cte_8 where col_51 < 5 ) select * from cte_8;
col_51	col_52	col_53	col_54
1	3	2	4
2	4	3	5
3	5	4	6
4	6	5	7
5	7	6	8
with recursive qn as (select 1 from dual union all select 1 from dual) select * from qn;
1
1
1
with recursive qn as (select 1 as a from dual group by a union all select a+1 from qn where a<3) select * from qn;
a
1
2
3
with recursive qn as ((select 1 as a from dual order by a) union all select a+1 from qn where a<3) select * from qn;
a
1
2
3
drop table if exists employees;
CREATE TABLE employees (
ID INT PRIMARY KEY,
NAME VARCHAR(100),
MANAGER_ID INT,
INDEX (MANAGER_ID),
FOREIGN KEY (MANAGER_ID) REFERENCES employees(ID)
);
INSERT INTO employees VALUES
(333, "Yasmina", NULL),
(198, "John", 333),
(692, "Tarek", 333),
(29, "Pedro", 198),
(4610, "Sarah", 29),
(72, "Pierre", 29),
(123, "Adil", 692);
WITH RECURSIVE employees_extended AS (SELECT ID, NAME, MANAGER_ID, CAST(ID AS CHAR(200)) AS PATH FROM employees WHERE NAME='Pierre' UNION ALL SELECT S.ID, S.NAME, S.MANAGER_ID, CONCAT(M.PATH, ",", S.ID) FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.ID)   SELECT * FROM employees_extended;
ID	NAME	MANAGER_ID	PATH
72	Pierre	29	72
29	Pedro	198	72,29
198	John	333	72,29,198
333	Yasmina	NULL	72,29,198,333
with recursive cte (c1) as (select 1), cte1 (c2) as (select 1 union select c1 + 1 from cte where c1 < 10) select * from cte where c1 < 5;
c1
1
with recursive cte_581 (col_2343,col_2344,col_2345) AS ( select 1, '2',cast('3' as char(20))) , cte_582 (col_2346,col_2347,col_2348) AS ( select 1, 2, 3) select * from cte_581 as cte_as_583,cte_582 as cte_as_584,cte_582 as cte_as_585 order by cte_as_583.col_2343,cte_as_585.col_2348,cte_as_584.col_2346,cte_as_584.col_2348,cte_as_583.col_2344,cte_as_584.col_2347,cte_as_585.col_2346,cte_as_585.col_2347,cte_as_583.col_2345;
col_2343	col_2344	col_2345	col_2346	col_2347	col_2348	col_2346	col_2347	col_2348
1	2	3	1	2	3	1	2	3
with recursive tbl_3 (col_19,col_20,col_21,col_22) AS ( select 1, 2,3,4 UNION  select col_19 + 1,col_20 + 1,col_21 + 1,concat(col_22, 1) from tbl_3 where col_19 < 5 ) , cte_4 (col_23,col_24,col_25,col_26) AS ( select 1, 2,cast("3" as char(20)),4 UNION DISTINCT select col_23 + 1,col_24 + 1,concat(col_25, 1),col_26 + 1 from cte_4 where col_23 < 5 ) select * from tbl_3 as cte_as_3,cte_4 as cte_as_4,tbl_3 as cte_as_5 order by cte_as_3.col_19,cte_as_4.col_23,cte_as_4.col_25,cte_as_4.col_24,cte_as_4.col_26,cte_as_3.col_20,cte_as_5.col_22,cte_as_3.col_21,cte_as_5.col_20,cte_as_3.col_22,cte_as_5.col_19,cte_as_5.col_21;
col_19	col_20	col_21	col_22	col_23	col_24	col_25	col_26	col_19	col_20	col_21	col_22
1	2	3	4	1	2	3	4	1	2	3	4
1	2	3	4	1	2	3	4	2	3	4	41
1	2	3	4	1	2	3	4	3	4	5	411
1	2	3	4	1	2	3	4	4	5	6	4111
1	2	3	4	1	2	3	4	5	6	7	41111
1	2	3	4	2	3	31	5	1	2	3	4
1	2	3	4	2	3	31	5	2	3	4	41
1	2	3	4	2	3	31	5	3	4	5	411
1	2	3	4	2	3	31	5	4	5	6	4111
1	2	3	4	2	3	31	5	5	6	7	41111
1	2	3	4	3	4	311	6	1	2	3	4
1	2	3	4	3	4	311	6	2	3	4	41
1	2	3	4	3	4	311	6	3	4	5	411
1	2	3	4	3	4	311	6	4	5	6	4111
1	2	3	4	3	4	311	6	5	6	7	41111
1	2	3	4	4	5	3111	7	1	2	3	4
1	2	3	4	4	5	3111	7	2	3	4	41
1	2	3	4	4	5	3111	7	3	4	5	411
1	2	3	4	4	5	3111	7	4	5	6	4111
1	2	3	4	4	5	3111	7	5	6	7	41111
1	2	3	4	5	6	31111	8	1	2	3	4
1	2	3	4	5	6	31111	8	2	3	4	41
1	2	3	4	5	6	31111	8	3	4	5	411
1	2	3	4	5	6	31111	8	4	5	6	4111
1	2	3	4	5	6	31111	8	5	6	7	41111
2	3	4	41	1	2	3	4	1	2	3	4
2	3	4	41	1	2	3	4	2	3	4	41
2	3	4	41	1	2	3	4	3	4	5	411
2	3	4	41	1	2	3	4	4	5	6	4111
2	3	4	41	1	2	3	4	5	6	7	41111
2	3	4	41	2	3	31	5	1	2	3	4
2	3	4	41	2	3	31	5	2	3	4	41
2	3	4	41	2	3	31	5	3	4	5	411
2	3	4	41	2	3	31	5	4	5	6	4111
2	3	4	41	2	3	31	5	5	6	7	41111
2	3	4	41	3	4	311	6	1	2	3	4
2	3	4	41	3	4	311	6	2	3	4	41
2	3	4	41	3	4	311	6	3	4	5	411
2	3	4	41	3	4	311	6	4	5	6	4111
2	3	4	41	3	4	311	6	5	6	7	41111
2	3	4	41	4	5	3111	7	1	2	3	4
2	3	4	41	4	5	3111	7	2	3	4	41
2	3	4	41	4	5	3111	7	3	4	5	411
2	3	4	41	4	5	3111	7	4	5	6	4111
2	3	4	41	4	5	3111	7	5	6	7	41111
2	3	4	41	5	6	31111	8	1	2	3	4
2	3	4	41	5	6	31111	8	2	3	4	41
2	3	4	41	5	6	31111	8	3	4	5	411
2	3	4	41	5	6	31111	8	4	5	6	4111
2	3	4	41	5	6	31111	8	5	6	7	41111
3	4	5	411	1	2	3	4	1	2	3	4
3	4	5	411	1	2	3	4	2	3	4	41
3	4	5	411	1	2	3	4	3	4	5	411
3	4	5	411	1	2	3	4	4	5	6	4111
3	4	5	411	1	2	3	4	5	6	7	41111
3	4	5	411	2	3	31	5	1	2	3	4
3	4	5	411	2	3	31	5	2	3	4	41
3	4	5	411	2	3	31	5	3	4	5	411
3	4	5	411	2	3	31	5	4	5	6	4111
3	4	5	411	2	3	31	5	5	6	7	41111
3	4	5	411	3	4	311	6	1	2	3	4
3	4	5	411	3	4	311	6	2	3	4	41
3	4	5	411	3	4	311	6	3	4	5	411
3	4	5	411	3	4	311	6	4	5	6	4111
3	4	5	411	3	4	311	6	5	6	7	41111
3	4	5	411	4	5	3111	7	1	2	3	4
3	4	5	411	4	5	3111	7	2	3	4	41
3	4	5	411	4	5	3111	7	3	4	5	411
3	4	5	411	4	5	3111	7	4	5	6	4111
3	4	5	411	4	5	3111	7	5	6	7	41111
3	4	5	411	5	6	31111	8	1	2	3	4
3	4	5	411	5	6	31111	8	2	3	4	41
3	4	5	411	5	6	31111	8	3	4	5	411
3	4	5	411	5	6	31111	8	4	5	6	4111
3	4	5	411	5	6	31111	8	5	6	7	41111
4	5	6	4111	1	2	3	4	1	2	3	4
4	5	6	4111	1	2	3	4	2	3	4	41
4	5	6	4111	1	2	3	4	3	4	5	411
4	5	6	4111	1	2	3	4	4	5	6	4111
4	5	6	4111	1	2	3	4	5	6	7	41111
4	5	6	4111	2	3	31	5	1	2	3	4
4	5	6	4111	2	3	31	5	2	3	4	41
4	5	6	4111	2	3	31	5	3	4	5	411
4	5	6	4111	2	3	31	5	4	5	6	4111
4	5	6	4111	2	3	31	5	5	6	7	41111
4	5	6	4111	3	4	311	6	1	2	3	4
4	5	6	4111	3	4	311	6	2	3	4	41
4	5	6	4111	3	4	311	6	3	4	5	411
4	5	6	4111	3	4	311	6	4	5	6	4111
4	5	6	4111	3	4	311	6	5	6	7	41111
4	5	6	4111	4	5	3111	7	1	2	3	4
4	5	6	4111	4	5	3111	7	2	3	4	41
4	5	6	4111	4	5	3111	7	3	4	5	411
4	5	6	4111	4	5	3111	7	4	5	6	4111
4	5	6	4111	4	5	3111	7	5	6	7	41111
4	5	6	4111	5	6	31111	8	1	2	3	4
4	5	6	4111	5	6	31111	8	2	3	4	41
4	5	6	4111	5	6	31111	8	3	4	5	411
4	5	6	4111	5	6	31111	8	4	5	6	4111
4	5	6	4111	5	6	31111	8	5	6	7	41111
5	6	7	41111	1	2	3	4	1	2	3	4
5	6	7	41111	1	2	3	4	2	3	4	41
5	6	7	41111	1	2	3	4	3	4	5	411
5	6	7	41111	1	2	3	4	4	5	6	4111
5	6	7	41111	1	2	3	4	5	6	7	41111
5	6	7	41111	2	3	31	5	1	2	3	4
5	6	7	41111	2	3	31	5	2	3	4	41
5	6	7	41111	2	3	31	5	3	4	5	411
5	6	7	41111	2	3	31	5	4	5	6	4111
5	6	7	41111	2	3	31	5	5	6	7	41111
5	6	7	41111	3	4	311	6	1	2	3	4
5	6	7	41111	3	4	311	6	2	3	4	41
5	6	7	41111	3	4	311	6	3	4	5	411
5	6	7	41111	3	4	311	6	4	5	6	4111
5	6	7	41111	3	4	311	6	5	6	7	41111
5	6	7	41111	4	5	3111	7	1	2	3	4
5	6	7	41111	4	5	3111	7	2	3	4	41
5	6	7	41111	4	5	3111	7	3	4	5	411
5	6	7	41111	4	5	3111	7	4	5	6	4111
5	6	7	41111	4	5	3111	7	5	6	7	41111
5	6	7	41111	5	6	31111	8	1	2	3	4
5	6	7	41111	5	6	31111	8	2	3	4	41
5	6	7	41111	5	6	31111	8	3	4	5	411
5	6	7	41111	5	6	31111	8	4	5	6	4111
5	6	7	41111	5	6	31111	8	5	6	7	41111
with cte1 (c1) as (select 1) select * from cte1 as b, cte1 as a;
c1	c1
1	1
WITH RECURSIVE qn AS
(
select 1
union all
select 3, 0 from qn
)
select * from qn;
Error 1222 (21000): The used SELECT statements have a different number of columns
with recursive cte1 as (select 1 union all (select 1 from cte1 limit 10)) select * from cte1;
Error 1235 (42000): This version of TiDB doesn't yet support 'ORDER BY / LIMIT / SELECT DISTINCT in recursive query block of Common Table Expression'
with recursive qn as (select 123 as a union all select null from qn where a is not null) select * from qn;
a
123
NULL
with recursive q (b) as (select 1, 1 union all select 1, 1 from q) select b from q;
Error 1353 (HY000): In definition of view, derived table or common table expression, SELECT list and column names list have different column counts
drop table if exists t1;
create table t1(a int);
insert into t1 values(1);
insert into t1 values(2);
SELECT *
FROM
t1 dt
WHERE
EXISTS(
WITH RECURSIVE qn AS (SELECT a*0 AS b UNION ALL SELECT b+1 FROM qn WHERE b=0)
SELECT * FROM qn WHERE b=a
);
a
1
drop table if exists t1;
create table t1 (a int);
insert into t1 values (1);
SELECT (WITH qn AS (SELECT 10*a as a FROM t1),
qn2 AS (SELECT 3*a AS b FROM qn)                                                                                                                                                                                                                                              SELECT * from qn2 LIMIT 1)
FROM t1;
(WITH qn AS (SELECT 10*a as a FROM t1),
qn2 AS (SELECT 3*a AS b FROM qn)                                                                                                                                                                                        
30
select (with qn as (select "with") select * from qn) as scal_subq
from dual;
scal_subq
with
drop table if exists t1;
create table t1 (a int);                                                                                                                                                                                                                                                      insert into t1 values(1), (2), (3);
with q as (select * from t1)
select /*+ merge(q) no_merge(q1) */ * from q, q q1 where q.a=1 and q1.a=2;
a	a
1	2
drop table if exists t1;                                                                                                                                                                                                                                                      create table t1 (a int, b int);
with qn as (select a, b from t1) select b from qn group by a;
b
drop table if exists t1;
create table t1(a int);
insert into t1 values(1);
insert into t1 values(2);
SELECT *
FROM
t1 dt
WHERE
EXISTS(
WITH RECURSIVE qn AS (SELECT a*0+1 AS b UNION ALL SELECT b+1 FROM qn WHERE b=0)
SELECT * FROM qn WHERE b=1
);
a
1
2
drop table if exists tbl_1;
CREATE TABLE `tbl_1` (
`col_2` char(65) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
`col_3` int(11) NOT NULL
);
with recursive cte_8932 (col_34891,col_34892) AS ( with recursive cte_8932 (col_34893,col_34894,col_34895) AS ( with  tbl_1 (col_34896,col_34897,col_34898,col_34899) AS ( select 1, "2",3,col_3 from tbl_1 ) select cte_as_8958.col_34896,cte_as_8958.col_34898,cte_as_8958.col_34899 from tbl_1 as cte_as_8958 UNION DISTINCT select col_34893 + 1,concat(col_34894, 1),col_34895 + 1 from cte_8932 where col_34893 < 5 ) select cte_as_8959.col_34893,cte_as_8959.col_34895 from cte_8932 as cte_as_8959 ) select * from cte_8932 as cte_as_8960 order by cte_as_8960.col_34891,cte_as_8960.col_34892;
col_34891	col_34892
drop table if exists t1;
create table t1(c1 bigint unsigned);
insert into t1 values(0);
with recursive cte1 as (select c1 - 1 c1 from t1 union all select c1 - 1 c1 from cte1 where c1 != 0) select * from cte1 dt1, cte1 dt2;
Error 1690 (22003): BIGINT UNSIGNED value is out of range in '(cte.t1.c1 - 1)'
drop table if exists t;
create table t(a int, b int, key (b));
desc with cte as (select * from t) select * from cte;
id	estRows	task	access object	operator info
TableReader_9	10000.00	root		data:TableFullScan_8
└─TableFullScan_8	10000.00	cop[tikv]	table:t	keep order:false, stats:pseudo
create SESSION binding for with cte as (select * from t) select * from cte using with cte as (select * from t use index(b)) select * from cte;
desc with cte as (select * from t) select * from cte;
id	estRows	task	access object	operator info
IndexLookUp_10	10000.00	root		
├─IndexFullScan_8(Build)	10000.00	cop[tikv]	table:t, index:b(b)	keep order:false, stats:pseudo
└─TableRowIDScan_9(Probe)	10000.00	cop[tikv]	table:t	keep order:false, stats:pseudo
desc with cte as (select * from t use index()) select * from cte;
id	estRows	task	access object	operator info
IndexLookUp_10	10000.00	root		
├─IndexFullScan_8(Build)	10000.00	cop[tikv]	table:t, index:b(b)	keep order:false, stats:pseudo
└─TableRowIDScan_9(Probe)	10000.00	cop[tikv]	table:t	keep order:false, stats:pseudo
drop table if exists t1, tpk;
create table t1(c1 int);
insert into t1 values(1), (2), (1), (2);
create table tpk(c1 int primary key);
insert into tpk values(1), (2), (3);
// Expect a Sort operator on CTE.
explain with cte1 as (select c1 from t1) select /*+ MERGE_JOIN(dt1, dt2) */ * from t1 dt1 inner join cte1 dt2 on dt2.c1 = dt1.c1 order by 1, 2;
id	estRows	task	access object	operator info
MergeJoin_25	12487.50	root		inner join, left key:cte.t1.c1, right key:cte.t1.c1
├─Sort_23(Build)	9990.00	root		cte.t1.c1
│ └─TableReader_22	9990.00	root		data:Selection_21
│   └─Selection_21	9990.00	cop[tikv]		not(isnull(cte.t1.c1))
│     └─TableFullScan_20	10000.00	cop[tikv]	table:t1	keep order:false, stats:pseudo
└─Sort_19(Probe)	9990.00	root		cte.t1.c1
  └─TableReader_18	9990.00	root		data:Selection_17
    └─Selection_17	9990.00	cop[tikv]		not(isnull(cte.t1.c1))
      └─TableFullScan_16	10000.00	cop[tikv]	table:dt1	keep order:false, stats:pseudo
with cte1 as (select c1 from t1) select /*+ MERGE_JOIN(dt1, dt2) */ * from t1 dt1 inner join cte1 dt2 on dt2.c1 = dt1.c1 order by 1, 2;
c1	c1
1	1
1	1
1	1
1	1
2	2
2	2
2	2
2	2
// Sort should not exist, because tpk.c1 is pk. Not the best plan for now(#25674).
explain with cte1 as (select c1 from tpk) select /*+ MERGE_JOIN(dt1, dt2) */ * from tpk dt1 inner join cte1 dt2 on dt2.c1 = dt1.c1 order by 1, 2;
id	estRows	task	access object	operator info
MergeJoin_27	12500.00	root		inner join, left key:cte.tpk.c1, right key:cte.tpk.c1
├─TableReader_24(Build)	10000.00	root		data:TableFullScan_23
│ └─TableFullScan_23	10000.00	cop[tikv]	table:tpk	keep order:true, stats:pseudo
└─TableReader_22(Probe)	10000.00	root		data:TableFullScan_21
  └─TableFullScan_21	10000.00	cop[tikv]	table:dt1	keep order:true, stats:pseudo
with cte1 as (select c1 from tpk) select /*+ MERGE_JOIN(dt1, dt2) */ * from tpk dt1 inner join cte1 dt2 on dt2.c1 = dt1.c1 order by 1, 2;
c1	c1
1	1
2	2
3	3
// Sort should not exist, because we have order by in CTE definition. Not the best plan for now(#25674).
explain with cte1 as (select c1 from t1 order by c1) select /*+ MERGE_JOIN(dt1, dt2) */ * from t1 dt1 inner join cte1 dt2 on dt2.c1 = dt1.c1 order by 1, 2;
id	estRows	task	access object	operator info
MergeJoin_25	12487.50	root		inner join, left key:cte.t1.c1, right key:cte.t1.c1
├─Sort_23(Build)	9990.00	root		cte.t1.c1
│ └─TableReader_22	9990.00	root		data:Selection_21
│   └─Selection_21	9990.00	cop[tikv]		not(isnull(cte.t1.c1))
│     └─TableFullScan_20	10000.00	cop[tikv]	table:t1	keep order:false, stats:pseudo
└─Sort_19(Probe)	9990.00	root		cte.t1.c1
  └─TableReader_18	9990.00	root		data:Selection_17
    └─Selection_17	9990.00	cop[tikv]		not(isnull(cte.t1.c1))
      └─TableFullScan_16	10000.00	cop[tikv]	table:dt1	keep order:false, stats:pseudo
with cte1 as (select c1 from t1 order by c1) select /*+ MERGE_JOIN(dt1, dt2) */ * from t1 dt1 inner join cte1 dt2 on dt2.c1 = dt1.c1 order by 1, 2;
c1	c1
1	1
1	1
1	1
1	1
2	2
2	2
2	2
2	2
// Expect a Sort operator on CTE. Because it's recursive.
explain with recursive cte1 as (select c1 from t1 union select c1 +1 c1 from cte1 where c1 < 3) select /*+ MERGE_JOIN(dt1, dt2) */ * from t1 dt1 inner join cte1 dt2 on dt2.c1 = dt1.c1 order by 1, 2;
id	estRows	task	access object	operator info
MergeJoin_36	8001.00	root		inner join, left key:cte.t1.c1, right key:cte.t1.c1
├─Sort_34(Build)	6400.80	root		cte.t1.c1
│ └─Selection_32	6400.80	root		not(isnull(cte.t1.c1))
│   └─CTEFullScan_33	8001.00	root	CTE:cte1 AS dt2	data:CTE_0
└─Sort_30(Probe)	9990.00	root		cte.t1.c1
  └─TableReader_29	9990.00	root		data:Selection_28
    └─Selection_28	9990.00	cop[tikv]		not(isnull(cte.t1.c1))
      └─TableFullScan_27	10000.00	cop[tikv]	table:dt1	keep order:false, stats:pseudo
CTE_0	8001.00	root		Recursive CTE
├─TableReader_18(Seed Part)	10000.00	root		data:TableFullScan_17
│ └─TableFullScan_17	10000.00	cop[tikv]	table:t1	keep order:false, stats:pseudo
└─Projection_19(Recursive Part)	8000.00	root		cast(plus(cte.t1.c1, 1), int(11))->cte.t1.c1
  └─Selection_20	8000.00	root		lt(cte.t1.c1, 3)
    └─CTETable_21	10000.00	root		Scan on CTE_0
with recursive cte1 as (select c1 from t1 union select c1 +1 c1 from cte1 where c1 < 3) select /*+ MERGE_JOIN(dt1, dt2) */ * from t1 dt1 inner join cte1 dt2 on dt2.c1 = dt1.c1 order by 1, 2;
c1	c1
1	1
1	1
2	2
2	2
// Expect a Sort operator on CTE. Because it's recursive.
explain with recursive cte1 as (select c1 from tpk union select c1 +1 c1 from cte1 where c1 < 3) select /*+ MERGE_JOIN(dt1, dt2) */ * from t1 dt1 inner join cte1 dt2 on dt2.c1 = dt1.c1 order by 1, 2;
id	estRows	task	access object	operator info
MergeJoin_36	8001.00	root		inner join, left key:cte.t1.c1, right key:cte.tpk.c1
├─Sort_34(Build)	6400.80	root		cte.tpk.c1
│ └─Selection_32	6400.80	root		not(isnull(cte.tpk.c1))
│   └─CTEFullScan_33	8001.00	root	CTE:cte1 AS dt2	data:CTE_0
└─Sort_30(Probe)	9990.00	root		cte.t1.c1
  └─TableReader_29	9990.00	root		data:Selection_28
    └─Selection_28	9990.00	cop[tikv]		not(isnull(cte.t1.c1))
      └─TableFullScan_27	10000.00	cop[tikv]	table:dt1	keep order:false, stats:pseudo
CTE_0	8001.00	root		Recursive CTE
├─TableReader_18(Seed Part)	10000.00	root		data:TableFullScan_17
│ └─TableFullScan_17	10000.00	cop[tikv]	table:tpk	keep order:false, stats:pseudo
└─Projection_19(Recursive Part)	8000.00	root		cast(plus(cte.tpk.c1, 1), int(11))->cte.tpk.c1
  └─Selection_20	8000.00	root		lt(cte.tpk.c1, 3)
    └─CTETable_21	10000.00	root		Scan on CTE_0
with recursive cte1 as (select c1 from tpk union select c1 +1 c1 from cte1 where c1 < 3) select /*+ MERGE_JOIN(dt1, dt2) */ * from t1 dt1 inner join cte1 dt2 on dt2.c1 = dt1.c1 order by 1, 2;
c1	c1
1	1
1	1
2	2
2	2
// Got order by in CTE definition
// Expect Sort operator in CTE definition.
explain with cte1 as (select c1 from t1 order by c1) select /*+ MERGE_JOIN(dt1, dt2) */ * from t1 dt1 inner join cte1 dt2 on dt2.c1 = dt1.c1 order by 1, 2;
id	estRows	task	access object	operator info
MergeJoin_25	12487.50	root		inner join, left key:cte.t1.c1, right key:cte.t1.c1
├─Sort_23(Build)	9990.00	root		cte.t1.c1
│ └─TableReader_22	9990.00	root		data:Selection_21
│   └─Selection_21	9990.00	cop[tikv]		not(isnull(cte.t1.c1))
│     └─TableFullScan_20	10000.00	cop[tikv]	table:t1	keep order:false, stats:pseudo
└─Sort_19(Probe)	9990.00	root		cte.t1.c1
  └─TableReader_18	9990.00	root		data:Selection_17
    └─Selection_17	9990.00	cop[tikv]		not(isnull(cte.t1.c1))
      └─TableFullScan_16	10000.00	cop[tikv]	table:dt1	keep order:false, stats:pseudo
with cte1 as (select c1 from t1 order by c1) select /*+ MERGE_JOIN(dt1, dt2) */ * from t1 dt1 inner join cte1 dt2 on dt2.c1 = dt1.c1 order by 1, 2;
c1	c1
1	1
1	1
1	1
1	1
2	2
2	2
2	2
2	2
// Sort should not exist, because tpk is ordered. Not the best plan for now(#25674).
explain with cte1 as (select c1 from tpk order by c1) select /*+ MERGE_JOIN(dt1, dt2) */ * from t1 dt1 inner join cte1 dt2 on dt2.c1 = dt1.c1 order by 1, 2;
id	estRows	task	access object	operator info
MergeJoin_23	12487.50	root		inner join, left key:cte.t1.c1, right key:cte.tpk.c1
├─TableReader_21(Build)	10000.00	root		data:TableFullScan_20
│ └─TableFullScan_20	10000.00	cop[tikv]	table:tpk	keep order:true, stats:pseudo
└─Sort_19(Probe)	9990.00	root		cte.t1.c1
  └─TableReader_18	9990.00	root		data:Selection_17
    └─Selection_17	9990.00	cop[tikv]		not(isnull(cte.t1.c1))
      └─TableFullScan_16	10000.00	cop[tikv]	table:dt1	keep order:false, stats:pseudo
with cte1 as (select c1 from tpk order by c1) select /*+ MERGE_JOIN(dt1, dt2) */ * from t1 dt1 inner join cte1 dt2 on dt2.c1 = dt1.c1 order by 1, 2;
c1	c1
1	1
1	1
2	2
2	2
// HashJoin. No need to sort
explain with cte1 as (select c1 from t1) select /*+ HASH_JOIN(dt1, dt2) */ * from t1 dt1 inner join cte1 dt2 on dt2.c1 = 1 order by 1, 2;
id	estRows	task	access object	operator info
Sort_13	100000.00	root		cte.t1.c1, cte.t1.c1
└─Projection_16	100000.00	root		cte.t1.c1, cte.t1.c1
  └─HashJoin_18	100000.00	root		CARTESIAN inner join
    ├─TableReader_21(Build)	10.00	root		data:Selection_20
    │ └─Selection_20	10.00	cop[tikv]		eq(cte.t1.c1, 1)
    │   └─TableFullScan_19	10000.00	cop[tikv]	table:t1	keep order:false, stats:pseudo
    └─TableReader_23(Probe)	10000.00	root		data:TableFullScan_22
      └─TableFullScan_22	10000.00	cop[tikv]	table:dt1	keep order:false, stats:pseudo
with cte1 as (select c1 from t1) select /*+ HASH_JOIN(dt1, dt2) */ * from t1 dt1 inner join cte1 dt2 on dt2.c1 = 1 order by 1, 2;
c1	c1
1	1
1	1
1	1
1	1
2	1
2	1
2	1
2	1
explain with cte1 as (select c1 from tpk) select /*+ HASH_JOIN(dt1, dt2) */ * from t1 dt1 inner join cte1 dt2 on dt2.c1 = 1 order by 1, 2;
id	estRows	task	access object	operator info
Sort_13	10000.00	root		cte.t1.c1, cte.tpk.c1
└─Projection_16	10000.00	root		cte.t1.c1, cte.tpk.c1
  └─HashJoin_18	10000.00	root		CARTESIAN inner join
    ├─Point_Get_19(Build)	1.00	root	table:tpk	handle:1
    └─TableReader_21(Probe)	10000.00	root		data:TableFullScan_20
      └─TableFullScan_20	10000.00	cop[tikv]	table:dt1	keep order:false, stats:pseudo
with cte1 as (select c1 from tpk) select /*+ HASH_JOIN(dt1, dt2) */ * from t1 dt1 inner join cte1 dt2 on dt2.c1 = 1 order by 1, 2;
c1	c1
1	1
1	1
2	1
2	1
// Use same CTE.
drop table if exists tpk1, tpk;
create table tpk(c1 int primary key);
insert into tpk values(1), (2), (3);
create table tpk1(c1 int primary key);
insert into tpk1 values(1), (2), (3);
explain with cte1 as (select c1 from tpk) select /*+ merge_join(dt1, dt2) */ * from tpk1 dt1 inner join cte1 dt2 inner join cte1 dt3 on dt1.c1 = dt2.c1 and dt2.c1 = dt3.c1;
id	estRows	task	access object	operator info
HashJoin_19	12500.00	root		inner join, equal:[eq(cte.tpk.c1, cte.tpk.c1)]
├─Selection_28(Build)	8000.00	root		not(isnull(cte.tpk.c1))
│ └─CTEFullScan_29	10000.00	root	CTE:cte1 AS dt3	data:CTE_0
└─MergeJoin_21(Probe)	10000.00	root		inner join, left key:cte.tpk1.c1, right key:cte.tpk.c1
  ├─Sort_27(Build)	8000.00	root		cte.tpk.c1
  │ └─Selection_25	8000.00	root		not(isnull(cte.tpk.c1))
  │   └─CTEFullScan_26	10000.00	root	CTE:cte1 AS dt2	data:CTE_0
  └─TableReader_23(Probe)	10000.00	root		data:TableFullScan_22
    └─TableFullScan_22	10000.00	cop[tikv]	table:dt1	keep order:true, stats:pseudo
CTE_0	10000.00	root		Non-Recursive CTE
└─TableReader_15(Seed Part)	10000.00	root		data:TableFullScan_14
  └─TableFullScan_14	10000.00	cop[tikv]	table:tpk	keep order:false, stats:pseudo
with cte1 as (select c1 from tpk) select /*+ merge_join(dt1, dt2) */ * from tpk1 dt1 inner join cte1 dt2 inner join cte1 dt3 on dt1.c1 = dt2.c1 and dt2.c1 = dt3.c1;
c1	c1	c1
1	1	1
2	2	2
3	3	3
// Test CTE as inner side of Apply
drop table if exists t1, t2;
create table t1(c1 int, c2 int);
insert into t1 values(2, 1);
insert into t1 values(2, 2);
create table t2(c1 int, c2 int);
insert into t2 values(1, 1);
insert into t2 values(3, 2);
explain select * from t1 where c1 > all(with cte1 as (select c1 from t2 where t2.c2 = t1.c2) select c1 from cte1);
id	estRows	task	access object	operator info
Projection_16	10000.00	root		cte.t1.c1, cte.t1.c2
└─Apply_18	10000.00	root		CARTESIAN inner join, other cond:or(and(gt(cte.t1.c1, Column#11), if(ne(Column#12, 0), NULL, 1)), or(eq(Column#13, 0), if(isnull(cte.t1.c1), NULL, 0)))
  ├─TableReader_20(Build)	10000.00	root		data:TableFullScan_19
  │ └─TableFullScan_19	10000.00	cop[tikv]	table:t1	keep order:false, stats:pseudo
  └─StreamAgg_35(Probe)	10000.00	root		funcs:max(Column#19)->Column#11, funcs:sum(Column#20)->Column#12, funcs:count(Column#21)->Column#13
    └─TableReader_36	10000.00	root		data:StreamAgg_24
      └─StreamAgg_24	10000.00	cop[tikv]		funcs:max(cte.t2.c1)->Column#19, funcs:sum(isnull(cte.t2.c1))->Column#20, funcs:count(1)->Column#21
        └─Selection_34	100000.00	cop[tikv]		eq(cte.t2.c2, cte.t1.c2)
          └─TableFullScan_33	100000000.00	cop[tikv]	table:t2	keep order:false, stats:pseudo
select * from t1 where c1 > all(with cte1 as (select c1 from t2 where t2.c2 = t1.c2) select c1 from cte1);
c1	c2
2	1
// Test semi apply.
insert into t1 values(2, 3);
explain select * from t1 where exists(with cte1 as (select c1 from t2 where t2.c2 = t1.c2) select c1 from cte1);
id	estRows	task	access object	operator info
HashJoin_14	7992.00	root		semi join, equal:[eq(cte.t1.c2, cte.t2.c2)]
├─TableReader_20(Build)	9990.00	root		data:Selection_19
│ └─Selection_19	9990.00	cop[tikv]		not(isnull(cte.t2.c2))
│   └─TableFullScan_18	10000.00	cop[tikv]	table:t2	keep order:false, stats:pseudo
└─TableReader_17(Probe)	9990.00	root		data:Selection_16
  └─Selection_16	9990.00	cop[tikv]		not(isnull(cte.t1.c2))
    └─TableFullScan_15	10000.00	cop[tikv]	table:t1	keep order:false, stats:pseudo
select * from t1 where exists(with cte1 as (select c1 from t2 where t2.c2 = t1.c2) select c1 from cte1);
c1	c2
2	1
2	2
// Same as above, but test recursive cte.
explain select * from t1 where c1 > all(with recursive cte1 as (select c1 from t2 where t2.c2 = t1.c2 union all select c1+1 as c1 from cte1 limit 1) select c1 from cte1);
id	estRows	task	access object	operator info
Projection_30	10000.00	root		cte.t1.c1, cte.t1.c2
└─Apply_32	10000.00	root		CARTESIAN inner join, other cond:or(and(gt(cte.t1.c1, Column#14), if(ne(Column#15, 0), NULL, 1)), or(eq(Column#16, 0), if(isnull(cte.t1.c1), NULL, 0)))
  ├─TableReader_34(Build)	10000.00	root		data:TableFullScan_33
  │ └─TableFullScan_33	10000.00	cop[tikv]	table:t1	keep order:false, stats:pseudo
  └─HashAgg_35(Probe)	10000.00	root		funcs:max(Column#19)->Column#14, funcs:sum(Column#20)->Column#15, funcs:count(1)->Column#16
    └─Projection_39	200000.00	root		cte.t2.c1->Column#19, cast(isnull(cte.t2.c1), decimal(20,0) BINARY)->Column#20
      └─CTEFullScan_37	200000.00	root	CTE:cte1	data:CTE_0
CTE_0	20.00	root		Recursive CTE, limit(offset:0, count:1)
├─TableReader_26(Seed Part)	10.00	root		data:Projection_20
│ └─Projection_20	10.00	cop[tikv]		cte.t2.c1
│   └─Selection_25	10.00	cop[tikv]		eq(cte.t2.c2, cte.t1.c2)
│     └─TableFullScan_24	10000.00	cop[tikv]	table:t2	keep order:false, stats:pseudo
└─Projection_27(Recursive Part)	10.00	root		cast(plus(cte.t2.c1, 1), int(11))->cte.t2.c1
  └─CTETable_28	10.00	root		Scan on CTE_0
select * from t1 where c1 > all(with recursive cte1 as (select c1 from t2 where t2.c2 = t1.c2 union all select c1+1 as c1 from cte1 limit 1) select c1 from cte1);
c1	c2
2	1
2	3
explain select * from t1 where exists(with recursive cte1 as (select c1 from t2 where t2.c2 = t1.c2 union all select c1+1 as c1 from cte1 limit 10) select c1 from cte1);
id	estRows	task	access object	operator info
Apply_29	10000.00	root		CARTESIAN semi join
├─TableReader_31(Build)	10000.00	root		data:TableFullScan_30
│ └─TableFullScan_30	10000.00	cop[tikv]	table:t1	keep order:false, stats:pseudo
└─CTEFullScan_32(Probe)	200000.00	root	CTE:cte1	data:CTE_0
CTE_0	20.00	root		Recursive CTE, limit(offset:0, count:10)
├─TableReader_24(Seed Part)	10.00	root		data:Projection_18
│ └─Projection_18	10.00	cop[tikv]		cte.t2.c1
│   └─Selection_23	10.00	cop[tikv]		eq(cte.t2.c2, cte.t1.c2)
│     └─TableFullScan_22	10000.00	cop[tikv]	table:t2	keep order:false, stats:pseudo
└─Projection_25(Recursive Part)	10.00	root		cast(plus(cte.t2.c1, 1), int(11))->cte.t2.c1
  └─CTETable_26	10.00	root		Scan on CTE_0
select * from t1 where exists(with recursive cte1 as (select c1 from t2 where t2.c2 = t1.c2 union all select c1+1 as c1 from cte1 limit 10) select c1 from cte1);
c1	c2
2	1
2	2
// Test correlated col is in recursive part.
explain select * from t1 where c1 > all(with recursive cte1 as (select c1, c2 from t2 union all select c1+1 as c1, c2+1 as c2 from cte1 where cte1.c2=t1.c2) select c1 from cte1);
id	estRows	task	access object	operator info
Projection_24	10000.00	root		cte.t1.c1, cte.t1.c2
└─Apply_26	10000.00	root		CARTESIAN inner join, other cond:or(and(gt(cte.t1.c1, Column#18), if(ne(Column#19, 0), NULL, 1)), or(eq(Column#20, 0), if(isnull(cte.t1.c1), NULL, 0)))
  ├─TableReader_28(Build)	10000.00	root		data:TableFullScan_27
  │ └─TableFullScan_27	10000.00	cop[tikv]	table:t1	keep order:false, stats:pseudo
  └─HashAgg_29(Probe)	10000.00	root		funcs:max(Column#23)->Column#18, funcs:sum(Column#24)->Column#19, funcs:count(1)->Column#20
    └─Projection_33	180000000.00	root		cte.t2.c1->Column#23, cast(isnull(cte.t2.c1), decimal(20,0) BINARY)->Column#24
      └─CTEFullScan_31	180000000.00	root	CTE:cte1	data:CTE_0
CTE_0	18000.00	root		Recursive CTE
├─TableReader_19(Seed Part)	10000.00	root		data:TableFullScan_18
│ └─TableFullScan_18	10000.00	cop[tikv]	table:t2	keep order:false, stats:pseudo
└─Projection_20(Recursive Part)	8000.00	root		cast(plus(cte.t2.c1, 1), int(11))->cte.t2.c1, cast(plus(cte.t2.c2, 1), int(11))->cte.t2.c2
  └─Selection_21	8000.00	root		eq(cte.t2.c2, cte.t1.c2)
    └─CTETable_22	10000.00	root		Scan on CTE_0
select * from t1 where c1 > all(with recursive cte1 as (select c1, c2 from t2 union all select c1+1 as c1, c2+1 as c2 from cte1 where cte1.c2=t1.c2) select c1 from cte1);
c1	c2
explain select * from t1 where exists(with recursive cte1 as (select c1, c2 from t2 union all select c1+1 as c1, c2+1 as c2 from cte1 where cte1.c2=t1.c2) select c1 from cte1);
id	estRows	task	access object	operator info
Apply_23	10000.00	root		CARTESIAN semi join
├─TableReader_25(Build)	10000.00	root		data:TableFullScan_24
│ └─TableFullScan_24	10000.00	cop[tikv]	table:t1	keep order:false, stats:pseudo
└─CTEFullScan_26(Probe)	180000000.00	root	CTE:cte1	data:CTE_0
CTE_0	18000.00	root		Recursive CTE
├─TableReader_17(Seed Part)	10000.00	root		data:TableFullScan_16
│ └─TableFullScan_16	10000.00	cop[tikv]	table:t2	keep order:false, stats:pseudo
└─Projection_18(Recursive Part)	8000.00	root		cast(plus(cte.t2.c1, 1), int(11))->cte.t2.c1, cast(plus(cte.t2.c2, 1), int(11))->cte.t2.c2
  └─Selection_19	8000.00	root		eq(cte.t2.c2, cte.t1.c2)
    └─CTETable_20	10000.00	root		Scan on CTE_0
select * from t1 where exists(with recursive cte1 as (select c1, c2 from t2 union all select c1+1 as c1, c2+1 as c2 from cte1 where cte1.c2=t1.c2) select c1 from cte1);
c1	c2
2	1
2	2
2	3
use cte;
drop table if exists t1, t2;
drop view if exists v1;
create table t1 (a int);
insert into t1 values (0), (1), (2), (3), (4);
create table t2 (a int);
insert into t2 values (1), (2), (3), (4), (5);
drop view if exists v1,v2;
create view v1 as with t1 as (select a from t2 where t2.a=3 union select t2.a+1 from t1,t2 where t1.a=t2.a) select * from t1 order by a desc limit 5;
create view v2 as with recursive t1 as ( select a from t2 where t2.a=3 union select t2.a+1 from t1,t2 where t1.a=t2.a) select * from t1 order by a desc limit 5;
use cte1;
select * from cte.v1;
a
5
4
3
2
select * from cte.v2;
a
6
5
4
3
use cte;
drop table if exists t ,t1, t2;
create table t(a int);
insert into t values (0);
create table t1 (b int);
insert into t1 values (0);
create table t2 (c int);
insert into t2 values (0);
drop view if exists v1;
create view v1 as with t1 as (with t11 as (select * from t) select * from t1, t2) select * from t1;
use cte1;
select * from cte.v1;
b	c
0	0
use cte;
drop table if exists t11111;
create table t11111 (d int);
insert into t11111 values (123), (223), (323);
drop view if exists v1;
create view v1 as WITH t123 AS (WITH t11111 AS ( SELECT * FROM t1 ) SELECT ( WITH t2 AS ( SELECT ( WITH t23 AS ( SELECT * FROM t11111 ) SELECT * FROM t23 LIMIT 1 ) FROM t11111 ) SELECT *  FROM t2  LIMIT 1  )  FROM t11111, t2 ) SELECT * FROM t11111;
use cte1;
select * from cte.v1;
d
123
223
323
use cte;
drop table if exists t1;
create table t1 (a int);
insert into t1 values (1);
drop view if exists v1;
create view v1 as SELECT (WITH qn AS (SELECT 10*a as a FROM t1),qn2 AS (SELECT 3*a AS b FROM qn) SELECT * from qn2 LIMIT 1) FROM t1;
use cte1;
select * from cte.v1;
name_exp_1
30
use cte;
drop table if exists t1,t2;
create table t1 (a int);
insert into t1 values (0), (1);
create table t2 (b int);
insert into t2 values  (4), (5);
drop view if exists v1;
create view v1 as with t1 as (with t11 as (select * from t1) select * from t1, t2) select * from t1;
use cte1;
select * from cte.v1;
a	b
0	5
0	4
1	5
1	4
CREATE TABLE `t_cqmg3b` (
`wkey` int(11) DEFAULT NULL,
`pkey` int(11) NOT NULL,
`c_anpf_c` int(11) DEFAULT NULL,
`c_b_fp_c` text DEFAULT NULL,
`c_ndccfb` int(11) DEFAULT NULL,
`c_8rswc` int(11) DEFAULT NULL,
PRIMARY KEY (`pkey`) /*T![clustered_index] CLUSTERED */
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
INSERT INTO `t_cqmg3b` VALUES (102,556000,NULL,'vbwxgc',NULL,NULL),(102,557000,NULL,'bfblud',NULL,NULL),(102,558000,NULL,'c6drnb',NULL,NULL),(102,559000,NULL,'fo_ezc',NULL,NULL),(102,560000,NULL,'btdes',NULL,NULL),(102,561000,NULL,'gy6zc',NULL,NULL),(102,562000,NULL,'9cyx9c',NULL,NULL),(102,563000,NULL,NULL,NULL,NULL),(103,564000,NULL,NULL,NULL,NULL),(103,565000,NULL,NULL,NULL,NULL),(103,566000,NULL,NULL,NULL,NULL),(103,567000,NULL,NULL,NULL,NULL),(103,568000,NULL,NULL,NULL,NULL),(103,569000,NULL,NULL,NULL,NULL),(103,570000,NULL,NULL,NULL,NULL),(105,578000,NULL,'fmicvd',NULL,NULL),(105,579000,NULL,'_tflkc',NULL,NULL),(105,580000,NULL,'xhovz',NULL,NULL),(105,581000,NULL,'n5bak',NULL,NULL),(105,582000,NULL,'gszus',NULL,NULL),(105,583000,NULL,'ewvydd',NULL,NULL),(105,584000,NULL,'fbzr0d',NULL,NULL),(107,590000,NULL,'8kgdf',NULL,NULL),(107,591000,NULL,'28v4bc',NULL,NULL),(107,592000,NULL,'evujpb',NULL,NULL),(107,593000,NULL,'8nkbzd',NULL,NULL),(107,594000,NULL,NULL,NULL,NULL),(109,599000,NULL,'1zswm',NULL,NULL),(109,600000,NULL,'gxlzrc',NULL,NULL),(109,601000,NULL,'xmedjc',NULL,NULL),(110,602000,NULL,'jwym6',NULL,NULL),(110,603000,NULL,NULL,NULL,NULL),(110,604000,NULL,'pcckxd',NULL,NULL),(111,605000,NULL,'lhvvp',NULL,NULL),(111,606000,NULL,'5eyidd',NULL,NULL),(111,607000,NULL,'l8azic',NULL,NULL),(111,608000,NULL,'_lmxx',NULL,NULL),(112,609000,NULL,'cstovb',NULL,NULL),(112,610000,NULL,'9bcdjc',NULL,NULL),(112,611000,NULL,'7zofhc',NULL,NULL),(112,612000,NULL,'pe2a3',NULL,NULL),(112,613000,NULL,'xtoet',NULL,NULL),(112,614000,NULL,'unvnj',NULL,NULL),(112,615000,NULL,'fj4v1b',NULL,NULL);
CREATE TABLE `t_dnmxh` (
`wkey` int(11) DEFAULT NULL,
`pkey` int(11) NOT NULL,
`c_xhsndb` double DEFAULT NULL,
PRIMARY KEY (`pkey`) /*T![clustered_index] CLUSTERED */
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
INSERT INTO `t_dnmxh` VALUES (104,571000,NULL),(104,572000,44.37),(104,573000,59.91),(104,574000,91.5),(104,575000,9.53),(104,576000,92.4),(104,577000,47.96),(106,585000,NULL),(106,586000,NULL),(106,587000,NULL),(106,588000,NULL),(106,589000,NULL),(108,595000,13.35),(108,596000,13.51),(108,597000,47.51),(108,598000,NULL),(113,616000,24.73),(113,617000,NULL),(113,618000,92.6),(113,619000,NULL),(113,620000,91.65),(113,621000,100.46),(113,622000,31.3),(113,623000,63.81);
WITH cte_0 AS (select distinct ref_0.wkey as c0, ref_0.pkey as c1, ref_0.c_xhsndb as c2 from t_dnmxh as ref_0 where (1 <= ( select ref_1.pkey not in ( select ref_5.wkey as c0 from t_dnmxh as ref_5 where (ref_5.wkey < ( select ref_6.pkey as c0 from t_cqmg3b as ref_6 where 88 between 96 and 76)) ) as c0 from (t_cqmg3b as ref_1 left outer join t_dnmxh as ref_2 on (ref_1.wkey = ref_2.wkey )) where ref_0.c_xhsndb is NULL union select 33 <= 91 as c0 from t_cqmg3b as ref_8 ))), cte_1 AS (select ref_9.wkey as c0, ref_9.pkey as c1, ref_9.c_anpf_c as c2, ref_9.c_b_fp_c as c3, ref_9.c_ndccfb as c4, ref_9.c_8rswc as c5 from t_cqmg3b as ref_9) select count(1) from cte_0 as ref_10 where case when 56 < 50 then case when 100 in ( select distinct ref_11.c4 as c0 from cte_1 as ref_11 where (ref_11.c4 > ( select ref_13.pkey as c0 from t_dnmxh as ref_13 where (ref_13.wkey > ( select distinct ref_11.c1 as c0 from cte_0 as ref_14)) )) or (1 = 1)) then null else null end else '7mxv6' end not like 'ki4%vc';
count(1)
24
with cte1 as (select 1), cte2 as (select 2) select * from cte1 union (with cte2 as (select 3) select * from cte2 union all select * from cte2) order by 1;
1
1
3
drop table if exists tt, tt1, tt2, tt3, tt4, tt5;
create table tt(c1 int, c2 int);
create table tt1(c1 int, c2 int);
create table tt2(c1 int, c2 int);
create table tt3(c1 int, c2 int);
create table tt4(c1 int, c2 int);
create table tt5(c1 int, c2 int);
insert into tt values(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6);
insert into tt1 values(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6);
insert into tt2 values(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6);
insert into tt3 values(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6);
insert into tt4 values(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6);
insert into tt5 values(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6);
explain with recursive cte1 as (select c1 from tt union select c1 from cte1 where exists (select /*+ no_decorrelate() */ c1 from tt1 where tt1.c2 = cte1.c1)) select c1 from tt2 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt2.c1) order by 1;
id	estRows	task	access object	operator info
Sort_31	10000.00	root		cte1.tt2.c1
└─Apply_35	10000.00	root		CARTESIAN semi join
  ├─TableReader_37(Build)	10000.00	root		data:TableFullScan_36
  │ └─TableFullScan_36	10000.00	cop[tikv]	table:tt2	keep order:false, stats:pseudo
  └─Selection_38(Probe)	64008000.00	root		eq(cte1.tt.c1, cte1.tt2.c1)
    └─CTEFullScan_39	80010000.00	root	CTE:cte1	data:CTE_0
CTE_0	8001.00	root		Recursive CTE
├─TableReader_23(Seed Part)	10000.00	root		data:TableFullScan_22
│ └─TableFullScan_22	10000.00	cop[tikv]	table:tt	keep order:false, stats:pseudo
└─Apply_26(Recursive Part)	10000.00	root		CARTESIAN semi join
  ├─CTETable_27(Build)	10000.00	root		Scan on CTE_0
  └─TableReader_30(Probe)	100000.00	root		data:Selection_29
    └─Selection_29	100000.00	cop[tikv]		eq(cte1.tt1.c2, cte1.tt.c1)
      └─TableFullScan_28	100000000.00	cop[tikv]	table:tt1	keep order:false, stats:pseudo
with recursive cte1 as (select c1 from tt union select c1 from cte1 where exists (select /*+ no_decorrelate() */ c1 from tt1 where tt1.c2 = cte1.c1)) select c1 from tt2 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt2.c1) order by 1;
c1
1
2
3
4
5
6
explain with recursive cte1 as (select c1 from tt union select c1 from cte1 where exists (select /*+ no_decorrelate() */ c1 from tt1 where tt1.c2 = cte1.c1))
select c1 from tt2 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt2.c1) union select c1 from tt3 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt3.c1) union
select c1 from tt4 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt4.c1) union select c1 from tt5 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt5.c1) order by 1;
id	estRows	task	access object	operator info
Sort_58	32000.00	root		Column#28
└─HashAgg_60	32000.00	root		group by:Column#28, funcs:firstrow(Column#28)->Column#28
  └─Union_61	40000.00	root		
    ├─Apply_64	10000.00	root		CARTESIAN semi join
    │ ├─TableReader_66(Build)	10000.00	root		data:TableFullScan_65
    │ │ └─TableFullScan_65	10000.00	cop[tikv]	table:tt2	keep order:false, stats:pseudo
    │ └─Selection_67(Probe)	64008000.00	root		eq(cte1.tt.c1, cte1.tt2.c1)
    │   └─CTEFullScan_68	80010000.00	root	CTE:cte1	data:CTE_0
    ├─Apply_71	10000.00	root		CARTESIAN semi join
    │ ├─TableReader_73(Build)	10000.00	root		data:TableFullScan_72
    │ │ └─TableFullScan_72	10000.00	cop[tikv]	table:tt3	keep order:false, stats:pseudo
    │ └─Selection_74(Probe)	64008000.00	root		eq(cte1.tt.c1, cte1.tt3.c1)
    │   └─CTEFullScan_75	80010000.00	root	CTE:cte1	data:CTE_0
    ├─Apply_78	10000.00	root		CARTESIAN semi join
    │ ├─TableReader_80(Build)	10000.00	root		data:TableFullScan_79
    │ │ └─TableFullScan_79	10000.00	cop[tikv]	table:tt4	keep order:false, stats:pseudo
    │ └─Selection_81(Probe)	64008000.00	root		eq(cte1.tt.c1, cte1.tt4.c1)
    │   └─CTEFullScan_82	80010000.00	root	CTE:cte1	data:CTE_0
    └─Apply_85	10000.00	root		CARTESIAN semi join
      ├─TableReader_87(Build)	10000.00	root		data:TableFullScan_86
      │ └─TableFullScan_86	10000.00	cop[tikv]	table:tt5	keep order:false, stats:pseudo
      └─Selection_88(Probe)	64008000.00	root		eq(cte1.tt.c1, cte1.tt5.c1)
        └─CTEFullScan_89	80010000.00	root	CTE:cte1	data:CTE_0
CTE_0	8001.00	root		Recursive CTE
├─TableReader_50(Seed Part)	10000.00	root		data:TableFullScan_49
│ └─TableFullScan_49	10000.00	cop[tikv]	table:tt	keep order:false, stats:pseudo
└─Apply_53(Recursive Part)	10000.00	root		CARTESIAN semi join
  ├─CTETable_54(Build)	10000.00	root		Scan on CTE_0
  └─TableReader_57(Probe)	100000.00	root		data:Selection_56
    └─Selection_56	100000.00	cop[tikv]		eq(cte1.tt1.c2, cte1.tt.c1)
      └─TableFullScan_55	100000000.00	cop[tikv]	table:tt1	keep order:false, stats:pseudo
with recursive cte1 as (select c1 from tt union select c1 from cte1 where exists (select /*+ no_decorrelate() */ c1 from tt1 where tt1.c2 = cte1.c1))
select c1 from tt2 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt2.c1) union select c1 from tt3 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt3.c1) union
select c1 from tt4 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt4.c1) union select c1 from tt5 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt5.c1) order by 1;
c1
1
2
3
4
5
6
explain with cte1 as (with recursive cte2 as (select c1 from tt union all select c1 from cte2 where exists(select /*+ no_decorrelate() */ c1 from tt1 where tt1.c1 = cte2.c1) limit 300)
select c1 from tt union select c1 from cte2 where exists (select /*+ no_decorrelate() */ c1 from tt1 where tt1.c2 = cte2.c1))
select c1 from tt2 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt2.c1) union select c1 from tt3 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt3.c1) union
select c1 from tt4 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt4.c1) union select c1 from tt5 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt5.c1) order by 1;
id	estRows	task	access object	operator info
Sort_85	32000.00	root		Column#36
└─HashAgg_87	32000.00	root		group by:Column#36, funcs:firstrow(Column#36)->Column#36
  └─Union_88	40000.00	root		
    ├─Apply_91	10000.00	root		CARTESIAN semi join
    │ ├─TableReader_93(Build)	10000.00	root		data:TableFullScan_92
    │ │ └─TableFullScan_92	10000.00	cop[tikv]	table:tt2	keep order:false, stats:pseudo
    │ └─Selection_94(Probe)	128008000.00	root		eq(Column#23, cte1.tt2.c1)
    │   └─CTEFullScan_95	160010000.00	root	CTE:cte1	data:CTE_0
    ├─Apply_98	10000.00	root		CARTESIAN semi join
    │ ├─TableReader_100(Build)	10000.00	root		data:TableFullScan_99
    │ │ └─TableFullScan_99	10000.00	cop[tikv]	table:tt3	keep order:false, stats:pseudo
    │ └─Selection_101(Probe)	128008000.00	root		eq(Column#27, cte1.tt3.c1)
    │   └─CTEFullScan_102	160010000.00	root	CTE:cte1	data:CTE_0
    ├─Apply_105	10000.00	root		CARTESIAN semi join
    │ ├─TableReader_107(Build)	10000.00	root		data:TableFullScan_106
    │ │ └─TableFullScan_106	10000.00	cop[tikv]	table:tt4	keep order:false, stats:pseudo
    │ └─Selection_108(Probe)	128008000.00	root		eq(Column#31, cte1.tt4.c1)
    │   └─CTEFullScan_109	160010000.00	root	CTE:cte1	data:CTE_0
    └─Apply_112	10000.00	root		CARTESIAN semi join
      ├─TableReader_114(Build)	10000.00	root		data:TableFullScan_113
      │ └─TableFullScan_113	10000.00	cop[tikv]	table:tt5	keep order:false, stats:pseudo
      └─Selection_115(Probe)	128008000.00	root		eq(Column#35, cte1.tt5.c1)
        └─CTEFullScan_116	160010000.00	root	CTE:cte1	data:CTE_0
CTE_0	16001.00	root		Non-Recursive CTE
└─HashAgg_73(Seed Part)	16001.00	root		group by:Column#19, funcs:firstrow(Column#19)->Column#19
  └─Union_74	30000.00	root		
    ├─TableReader_77	10000.00	root		data:TableFullScan_76
    │ └─TableFullScan_76	10000.00	cop[tikv]	table:tt	keep order:false, stats:pseudo
    └─Apply_80	20000.00	root		CARTESIAN semi join
      ├─CTEFullScan_81(Build)	20000.00	root	CTE:cte2	data:CTE_1
      └─TableReader_84(Probe)	200000.00	root		data:Selection_83
        └─Selection_83	200000.00	cop[tikv]		eq(cte1.tt1.c2, cte1.tt.c1)
          └─TableFullScan_82	200000000.00	cop[tikv]	table:tt1	keep order:false, stats:pseudo
CTE_1	20000.00	root		Recursive CTE, limit(offset:0, count:300)
├─TableReader_65(Seed Part)	10000.00	root		data:TableFullScan_64
│ └─TableFullScan_64	10000.00	cop[tikv]	table:tt	keep order:false, stats:pseudo
└─Apply_68(Recursive Part)	10000.00	root		CARTESIAN semi join
  ├─CTETable_69(Build)	10000.00	root		Scan on CTE_1
  └─TableReader_72(Probe)	100000.00	root		data:Selection_71
    └─Selection_71	100000.00	cop[tikv]		eq(cte1.tt1.c1, cte1.tt.c1)
      └─TableFullScan_70	100000000.00	cop[tikv]	table:tt1	keep order:false, stats:pseudo
with cte1 as (with recursive cte2 as (select c1 from tt union all select c1 from cte2 where exists(select /*+ no_decorrelate() */ c1 from tt1 where tt1.c1 = cte2.c1) limit 300)
select c1 from tt union select c1 from cte2 where exists (select /*+ no_decorrelate() */ c1 from tt1 where tt1.c2 = cte2.c1))
select c1 from tt2 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt2.c1) union select c1 from tt3 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt3.c1) union
select c1 from tt4 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt4.c1) union select c1 from tt5 where exists (select /*+ no_decorrelate() */ * from cte1 where cte1.c1 = tt5.c1) order by 1;
c1
1
2
3
4
5
6
drop table if exists table_a, table_b, table_c, table_d, table_e;
CREATE TABLE `table_a` (
`col_1` varchar(40) DEFAULT NULL,
`col_2` varchar(40) DEFAULT NULL,
`col_3` varchar(500) DEFAULT NULL,
`col_4` varchar(500) DEFAULT NULL,
`col_5` varchar(500) DEFAULT NULL,
`col_6` varchar(500) DEFAULT NULL,
`col_7` decimal(38,6) DEFAULT NULL,
`col_8` decimal(38,6) DEFAULT NULL,
`col_9` decimal(38,6) DEFAULT NULL,
`col_10` decimal(38,6) DEFAULT NULL,
`col_11` decimal(38,6) DEFAULT NULL,
`col_12` decimal(38,6) DEFAULT NULL,
`col_13` decimal(38,6) DEFAULT NULL,
`col_14` decimal(38,6) DEFAULT NULL,
`col_15` decimal(38,6) DEFAULT NULL,
`col_16` decimal(38,6) DEFAULT NULL,
`col_17` decimal(38,6) DEFAULT NULL,
`col_18` decimal(38,6) DEFAULT NULL,
`col_19` varchar(40) DEFAULT NULL,
`col_20` varchar(100) DEFAULT NULL,
`col_21` varchar(100) DEFAULT NULL,
`created_at` timestamp DEFAULT CURRENT_TIMESTAMP,
KEY `index_col_1` (`col_1`),
KEY `index_col_2_3` (`col_2`,`col_3`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
CREATE TABLE `table_b` (
`col_1` varchar(8) NOT NULL,
`col_2` varchar(100) NOT NULL,
`col_3` varchar(200) DEFAULT NULL,
`col_4` varchar(10) NOT NULL,
`col_5` decimal(38,6) DEFAULT NULL,
`col_6` decimal(38,6) DEFAULT NULL,
`col_7` decimal(38,6) DEFAULT NULL,
`col_8` decimal(38,6) DEFAULT NULL,
`created_at` datetime DEFAULT CURRENT_TIMESTAMP,
KEY `index_col_1_2` (`col_1`,`col_2`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
CREATE TABLE `table_c` (
`col_1` varchar(50) DEFAULT NULL,
`col_2` varchar(50) DEFAULT NULL,
`col_3` varchar(30) DEFAULT NULL,
`col_4` varchar(100) DEFAULT NULL,
`col_5` varchar(50) DEFAULT NULL,
`col_6` varchar(100) DEFAULT NULL,
`col_7` decimal(38,6) DEFAULT NULL,
`col_8` decimal(38,6) DEFAULT NULL,
`col_9` decimal(38,6) DEFAULT NULL,
`col_10` decimal(38,6) DEFAULT NULL,
`col_11` decimal(38,6) DEFAULT NULL,
`col_12` decimal(38,6) DEFAULT NULL,
`col_13` decimal(38,6) DEFAULT NULL,
`col_14` decimal(38,6) DEFAULT NULL,
`col_15` decimal(38,6) DEFAULT NULL,
`col_16` decimal(38,6) DEFAULT NULL,
`col_17` varchar(50) DEFAULT NULL,
`col_18` varchar(50) DEFAULT NULL,
`col_19` varchar(50) DEFAULT NULL,
`created_at` timestamp DEFAULT CURRENT_TIMESTAMP,
KEY `index_col_1_3` (`col_1`,`col_3`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
CREATE TABLE `table_d` (
`col_1` decimal(10,0) DEFAULT NULL,
`col_2` varchar(1) DEFAULT NULL,
`col_3` date NOT NULL,
`col_4` varchar(13) DEFAULT NULL,
`col_5` varchar(6) DEFAULT NULL,
`col_6` varchar(255) DEFAULT NULL,
`col_7` decimal(10,0) DEFAULT NULL,
`col_8` varchar(12) DEFAULT NULL,
`col_9` decimal(10,0) DEFAULT NULL,
`col_10` varchar(17) DEFAULT NULL,
`col_11` decimal(10,0) DEFAULT NULL,
`col_12` varchar(7) DEFAULT NULL,
`col_13` date DEFAULT NULL,
`col_14` date DEFAULT NULL,
`col_15` date DEFAULT NULL,
`col_16` date DEFAULT NULL,
`col_17` date DEFAULT NULL,
`col_18` date DEFAULT NULL,
`col_19` date DEFAULT NULL,
`col_20` varchar(1) DEFAULT NULL,
`col_21` varchar(1) DEFAULT NULL,
`col_22` decimal(1,0) DEFAULT NULL,
`col_23` varchar(1) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
CREATE TABLE `table_e` (
`col_1` varchar(8) NOT NULL,
`col_2` varchar(100) NOT NULL,
`col_3` varchar(100) DEFAULT NULL,
`col_4` varchar(100) NOT NULL,
`col_5` varchar(100) DEFAULT NULL,
`col_6` varchar(100) DEFAULT NULL,
`col_7` decimal(38,12) DEFAULT NULL,
`col_8` varchar(100) DEFAULT NULL,
`col_9` varchar(100) DEFAULT NULL,
`col_10` varchar(100) DEFAULT NULL,
`col_11` varchar(100) DEFAULT NULL,
`col_12` varchar(8) DEFAULT NULL,
`col_13` decimal(38,12) DEFAULT NULL,
`col_14` varchar(100) DEFAULT NULL,
`created_at` timestamp DEFAULT CURRENT_TIMESTAMP,
`col_15` varchar(500) DEFAULT NULL,
PRIMARY KEY (`col_2`, `col_1`, `col_4`),
KEY `index_col_5_6` (`col_5`, `col_6`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
INSERT INTO `table_a`
(`col_1`, `col_2`, `col_3`, `col_4`, `col_5`, `col_6`, `col_7`,
`col_8`, `col_9`, `col_10`, `col_11`, `col_12`, `col_13`,
`col_14`, `col_15`, `col_16`, `col_17`, `col_18`, `col_19`,
`col_20`, `col_21`, `created_at`)
VALUES
('20230628', '20230628', 'Portfolio A', 'Product B', 'Direct', 'USD',
200000, 150000, 50000, 100000,
50000, 10000, 5000, 1.2, 0.1,
0.15, 0.08, 0.02, '2023-06-28',
'2023-06-28', '2025-06-28', CURRENT_TIMESTAMP);
INSERT INTO `table_b`
(`col_1`, `col_2`, `col_3`, `col_4`, `col_5`, `col_6`, `col_7`, `col_8`, `created_at`)
VALUES
('20240628', 'DR201800093', 'Product A', '申购', 1000, 100000, 95000, 1.1, CURRENT_TIMESTAMP);
INSERT INTO `table_c`
(`col_1`, `col_2`, `col_3`, `col_4`, `col_5`, `col_6`, `col_7`,
`col_8`, `col_9`, `col_10`, `col_11`, `col_12`, `col_13`,
`col_14`, `col_15`, `col_16`, `col_17`, `col_18`, `col_19`, `created_at`)
VALUES
('20230628', 'Dept A', 'DR201800093', 'Product A', '孵化', 'Strategy 1',
100000, 100000, 120000, 100, 1.2,
0.2, 0.15, 0.1, 0.05, 0.08,
'2023-06-28', '2025-06-28', '2Y', CURRENT_TIMESTAMP);
INSERT INTO `table_d`
(`col_1`, `col_2`, `col_3`, `col_4`, `col_5`, `col_6`, `col_7`,
`col_8`, `col_9`, `col_10`, `col_11`, `col_12`, `col_13`, `col_14`,
`col_15`, `col_16`, `col_17`, `col_18`, `col_19`, `col_20`, `col_21`,
`col_22`, `col_23`)
VALUES
('20240628', '1', '2024-06-28', 'Friday', '28', 'End of Month', 202406,
'June', 20242, 'Q2', 2024, '2024', '2024-06-27', '2024-05-28',
'2024-03-28', '2023-06-28', '2024-06-27', '2024-06-27', '2024-06-27',
'1', '1', '1', '1');
INSERT INTO `table_e`
(`col_1`, `col_2`, `col_3`, `col_4`, `col_5`, `col_6`, `col_7`,
`col_8`, `col_9`, `col_10`, `col_11`, `col_12`, `col_13`, `col_14`,
`created_at`, `col_15`)
VALUES
('20230628', 'CFETS_MID', 'Mid', 'USD/CNY', 'USD', 'CNY',
7.0, 'Source A', 'Unit A', 'Region A', '2023-06-28 15:00:00', '20230627',
6.9, 'user_001', CURRENT_TIMESTAMP, 'Exchange rate on 2023-06-28');
desc WITH date_table AS (
SELECT
d.col_1 AS date,
(SELECT MAX(col_1)
FROM table_c a
WHERE col_1 <=
CONCAT(YEAR(DATE_SUB(d.col_1, INTERVAL 1 YEAR)),
'1231')
AND EXISTS (SELECT 1
FROM table_d d
WHERE a.col_1 = d.col_1
AND d.col_2 = 1)) AS date1,
(SELECT MAX(col_1)
FROM table_a a
WHERE col_1 <= CONCAT(YEAR(DATE_SUB(d.col_1, INTERVAL 1 YEAR)),
'1231')
AND EXISTS (SELECT 1
FROM table_d d
WHERE a.col_1 = d.col_1
AND d.col_2 = 1)) AS date2,
(SELECT MAX(col_1)
FROM table_c
WHERE col_1 <= d.col_1) AS date3,
(SELECT MAX(col_1)
FROM table_a
WHERE col_1 <= d.col_1) AS date4
FROM table_d d
WHERE d.col_1 = '20240628'
),
rm_am_champs_ex_risk_portfolio_seed_money_1 AS (
SELECT b.col_2
FROM table_a b
LEFT JOIN table_e rb
ON rb.col_1 = b.col_19
AND b.col_6 = rb.col_3
WHERE b.col_2 = (SELECT date4 FROM date_table)
),
rm_am_champs_ex_risk_portfolio_seed_money_2 AS (
SELECT b.col_2
FROM table_a b
LEFT JOIN table_e rb
ON rb.col_1 = b.col_19
AND b.col_6 = rb.col_3
),
product_base AS (
SELECT DISTINCT t.col_3, col_4, 'ML' AS is_do
FROM table_c t
),
product_detail AS (
SELECT t.col_4,
"3集合" AS nature_investment
FROM product_base t
LEFT JOIN date_table dt
ON 1 = 1
LEFT JOIN table_c a
ON t.col_4 = a.col_4
AND a.col_1 = dt.date3
)
SELECT col_4
FROM (
SELECT col_4
FROM product_detail
UNION ALL
SELECT col_4
FROM product_detail
) a;
id	estRows	task	access object	operator info
Union_212	199600.20	root		
├─Projection_213	99800.10	root		cte1.table_c.col_4->Column#418
│ └─CTEFullScan_214	99800.10	root	CTE:product_detail	data:CTE_4
└─Projection_215	99800.10	root		cte1.table_c.col_4->Column#418
  └─CTEFullScan_216	99800.10	root	CTE:product_detail	data:CTE_4
CTE_4	99800.10	root		Non-Recursive CTE
└─Projection_174(Seed Part)	99800.10	root		cte1.table_c.col_4, 3集合->Column#413
  └─HashJoin_190	99800.10	root		left outer join, equal:[eq(cte1.table_c.col_4, cte1.table_c.col_4) eq(Column#390, cte1.table_c.col_1)]
    ├─TableReader_206(Build)	9980.01	root		data:Selection_205
    │ └─Selection_205	9980.01	cop[tikv]		not(isnull(cte1.table_c.col_1)), not(isnull(cte1.table_c.col_4))
    │   └─TableFullScan_204	10000.00	cop[tikv]	table:a	keep order:false, stats:pseudo
    └─HashJoin_192(Probe)	80000.00	root		CARTESIAN left outer join
      ├─CTEFullScan_202(Build)	10.00	root	CTE:date_table AS dt	data:CTE_0
      └─HashAgg_198(Probe)	8000.00	root		group by:cte1.table_c.col_3, cte1.table_c.col_4, funcs:firstrow(cte1.table_c.col_4)->cte1.table_c.col_4
        └─TableReader_199	8000.00	root		data:HashAgg_194
          └─HashAgg_194	8000.00	cop[tikv]		group by:cte1.table_c.col_3, cte1.table_c.col_4, 
            └─TableFullScan_197	10000.00	cop[tikv]	table:t	keep order:false, stats:pseudo
CTE_0	10.00	root		Non-Recursive CTE
└─Apply_97(Seed Part)	10.00	root		CARTESIAN left outer join
  ├─Apply_99(Build)	10.00	root		CARTESIAN left outer join
  │ ├─Apply_101(Build)	10.00	root		CARTESIAN left outer join
  │ │ ├─Apply_103(Build)	10.00	root		CARTESIAN left outer join
  │ │ │ ├─TableReader_106(Build)	10.00	root		data:Selection_105
  │ │ │ │ └─Selection_105	10.00	cop[tikv]		eq(cte1.table_d.col_1, 20240628)
  │ │ │ │   └─TableFullScan_104	10000.00	cop[tikv]	table:d	keep order:false, stats:pseudo
  │ │ │ └─StreamAgg_108(Probe)	10.00	root		funcs:max(cte1.table_c.col_1)->Column#159
  │ │ │   └─TopN_111	10.00	root		cte1.table_c.col_1:desc, offset:0, count:1
  │ │ │     └─HashJoin_116	63936.00	root		semi join, equal:[eq(Column#423, Column#424)]
  │ │ │       ├─Projection_121(Build)	80000.00	root		cast(cte1.table_d.col_1, double BINARY)->Column#424
  │ │ │       │ └─TableReader_124	80000.00	root		data:Selection_123
  │ │ │       │   └─Selection_123	80000.00	cop[tikv]		eq(cast(cte1.table_d.col_2, double BINARY), 1)
  │ │ │       │     └─TableFullScan_122	100000.00	cop[tikv]	table:d	keep order:false, stats:pseudo
  │ │ │       └─Projection_117(Probe)	79920.00	root		cte1.table_c.col_1, cast(cte1.table_c.col_1, double BINARY)->Column#423
  │ │ │         └─Selection_118	79920.00	root		le(cte1.table_c.col_1, concat(cast(year(cast(date_sub(cte1.table_d.col_1, 1, "YEAR"), datetime(6) BINARY)), var_string(20)), "1231"))
  │ │ │           └─IndexReader_120	99900.00	root		index:IndexFullScan_119
  │ │ │             └─IndexFullScan_119	99900.00	cop[tikv]	table:a, index:index_col_1_3(col_1, col_3)	keep order:false, stats:pseudo
  │ │ └─StreamAgg_126(Probe)	10.00	root		funcs:max(cte1.table_a.col_1)->Column#208
  │ │   └─TopN_129	10.00	root		cte1.table_a.col_1:desc, offset:0, count:1
  │ │     └─HashJoin_134	63936.00	root		semi join, equal:[eq(Column#429, Column#430)]
  │ │       ├─Projection_139(Build)	80000.00	root		cast(cte1.table_d.col_1, double BINARY)->Column#430
  │ │       │ └─TableReader_142	80000.00	root		data:Selection_141
  │ │       │   └─Selection_141	80000.00	cop[tikv]		eq(cast(cte1.table_d.col_2, double BINARY), 1)
  │ │       │     └─TableFullScan_140	100000.00	cop[tikv]	table:d	keep order:false, stats:pseudo
  │ │       └─Projection_135(Probe)	79920.00	root		cte1.table_a.col_1, cast(cte1.table_a.col_1, double BINARY)->Column#429
  │ │         └─Selection_136	79920.00	root		le(cte1.table_a.col_1, concat(cast(year(cast(date_sub(cte1.table_d.col_1, 1, "YEAR"), datetime(6) BINARY)), var_string(20)), "1231"))
  │ │           └─IndexReader_138	99900.00	root		index:IndexFullScan_137
  │ │             └─IndexFullScan_137	99900.00	cop[tikv]	table:a, index:index_col_1(col_1)	keep order:false, stats:pseudo
  │ └─StreamAgg_144(Probe)	10.00	root		funcs:max(cte1.table_c.col_1)->Column#230
  │   └─Limit_148	10.00	root		offset:0, count:1
  │     └─IndexReader_157	10.00	root		index:Limit_156
  │       └─Limit_156	10.00	cop[tikv]		offset:0, count:1
  │         └─Selection_155	10.00	cop[tikv]		le(cast(cte1.table_c.col_1, double BINARY), cast(cte1.table_d.col_1, double BINARY))
  │           └─IndexFullScan_154	12.50	cop[tikv]	table:table_c, index:index_col_1_3(col_1, col_3)	keep order:true, desc, stats:pseudo
  └─StreamAgg_159(Probe)	10.00	root		funcs:max(cte1.table_a.col_1)->Column#254
    └─Limit_163	10.00	root		offset:0, count:1
      └─IndexReader_172	10.00	root		index:Limit_171
        └─Limit_171	10.00	cop[tikv]		offset:0, count:1
          └─Selection_170	10.00	cop[tikv]		le(cast(cte1.table_a.col_1, double BINARY), cast(cte1.table_d.col_1, double BINARY))
            └─IndexFullScan_169	12.50	cop[tikv]	table:table_a, index:index_col_1(col_1)	keep order:true, desc, stats:pseudo
WITH date_table AS (
SELECT
d.col_1 AS date,
(SELECT MAX(col_1)
FROM table_c a
WHERE col_1 <=
CONCAT(YEAR(DATE_SUB(d.col_1, INTERVAL 1 YEAR)),
'1231')
AND EXISTS (SELECT 1
FROM table_d d
WHERE a.col_1 = d.col_1
AND d.col_2 = 1)) AS date1,
(SELECT MAX(col_1)
FROM table_a a
WHERE col_1 <= CONCAT(YEAR(DATE_SUB(d.col_1, INTERVAL 1 YEAR)),
'1231')
AND EXISTS (SELECT 1
FROM table_d d
WHERE a.col_1 = d.col_1
AND d.col_2 = 1)) AS date2,
(SELECT MAX(col_1)
FROM table_c
WHERE col_1 <= d.col_1) AS date3,
(SELECT MAX(col_1)
FROM table_a
WHERE col_1 <= d.col_1) AS date4
FROM table_d d
WHERE d.col_1 = '20240628'
),
rm_am_champs_ex_risk_portfolio_seed_money_1 AS (
SELECT b.col_2
FROM table_a b
LEFT JOIN table_e rb
ON rb.col_1 = b.col_19
AND b.col_6 = rb.col_3
WHERE b.col_2 = (SELECT date4 FROM date_table)
),
rm_am_champs_ex_risk_portfolio_seed_money_2 AS (
SELECT b.col_2
FROM table_a b
LEFT JOIN table_e rb
ON rb.col_1 = b.col_19
AND b.col_6 = rb.col_3
),
product_base AS (
SELECT DISTINCT t.col_3, col_4, 'ML' AS is_do
FROM table_c t
),
product_detail AS (
SELECT t.col_4,
"3集合" AS nature_investment
FROM product_base t
LEFT JOIN date_table dt
ON 1 = 1
LEFT JOIN table_c a
ON t.col_4 = a.col_4
AND a.col_1 = dt.date3
)
SELECT col_4
FROM (
SELECT col_4
FROM product_detail
UNION ALL
SELECT col_4
FROM product_detail
) a;
col_4
Product A
Product A
