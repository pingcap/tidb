create database list_push_down;
use list_push_down;
set tidb_cost_model_version=2;
drop table if exists tlist;
set tidb_enable_list_partition = 1;
create table tlist (a int) partition by list (a) (
partition p0 values in (0, 1, 2),
partition p1 values in (3, 4, 5));
create table tcollist (a int) partition by list columns(a) (
partition p0 values in (0, 1, 2),
partition p1 values in (3, 4, 5));
set @@tidb_partition_prune_mode = 'static';
explain format='brief' select a from tlist where a>=0 and a<=10;
id	estRows	task	access object	operator info
PartitionUnion	500.00	root		
├─TableReader	250.00	root		data:Selection
│ └─Selection	250.00	cop[tikv]		ge(list_push_down.tlist.a, 0), le(list_push_down.tlist.a, 10)
│   └─TableFullScan	10000.00	cop[tikv]	table:tlist, partition:p0	keep order:false, stats:pseudo
└─TableReader	250.00	root		data:Selection
  └─Selection	250.00	cop[tikv]		ge(list_push_down.tlist.a, 0), le(list_push_down.tlist.a, 10)
    └─TableFullScan	10000.00	cop[tikv]	table:tlist, partition:p1	keep order:false, stats:pseudo
explain format='brief' select avg(a) from tlist;
id	estRows	task	access object	operator info
HashAgg	1.00	root		funcs:avg(Column#4, Column#5)->Column#3
└─PartitionUnion	2.00	root		
  ├─HashAgg	1.00	root		funcs:count(Column#6)->Column#4, funcs:sum(Column#7)->Column#5
  │ └─TableReader	1.00	root		data:HashAgg
  │   └─HashAgg	1.00	cop[tikv]		funcs:count(list_push_down.tlist.a)->Column#6, funcs:sum(list_push_down.tlist.a)->Column#7
  │     └─TableFullScan	10000.00	cop[tikv]	table:tlist, partition:p0	keep order:false, stats:pseudo
  └─HashAgg	1.00	root		funcs:count(Column#10)->Column#4, funcs:sum(Column#11)->Column#5
    └─TableReader	1.00	root		data:HashAgg
      └─HashAgg	1.00	cop[tikv]		funcs:count(list_push_down.tlist.a)->Column#10, funcs:sum(list_push_down.tlist.a)->Column#11
        └─TableFullScan	10000.00	cop[tikv]	table:tlist, partition:p1	keep order:false, stats:pseudo
explain format='brief' select a from tlist limit 10;
id	estRows	task	access object	operator info
Limit	10.00	root		offset:0, count:10
└─PartitionUnion	10.00	root		
  ├─Limit	10.00	root		offset:0, count:10
  │ └─TableReader	10.00	root		data:Limit
  │   └─Limit	10.00	cop[tikv]		offset:0, count:10
  │     └─TableFullScan	10.00	cop[tikv]	table:tlist, partition:p0	keep order:false, stats:pseudo
  └─Limit	10.00	root		offset:0, count:10
    └─TableReader	10.00	root		data:Limit
      └─Limit	10.00	cop[tikv]		offset:0, count:10
        └─TableFullScan	10.00	cop[tikv]	table:tlist, partition:p1	keep order:false, stats:pseudo
explain format='brief' select a from tlist order by a limit 10;
id	estRows	task	access object	operator info
TopN	10.00	root		list_push_down.tlist.a, offset:0, count:10
└─PartitionUnion	20.00	root		
  ├─TopN	10.00	root		list_push_down.tlist.a, offset:0, count:10
  │ └─TableReader	10.00	root		data:TopN
  │   └─TopN	10.00	cop[tikv]		list_push_down.tlist.a, offset:0, count:10
  │     └─TableFullScan	10000.00	cop[tikv]	table:tlist, partition:p0	keep order:false, stats:pseudo
  └─TopN	10.00	root		list_push_down.tlist.a, offset:0, count:10
    └─TableReader	10.00	root		data:TopN
      └─TopN	10.00	cop[tikv]		list_push_down.tlist.a, offset:0, count:10
        └─TableFullScan	10000.00	cop[tikv]	table:tlist, partition:p1	keep order:false, stats:pseudo
explain format='brief' select a from tcollist where a>=0 and a<=10;
id	estRows	task	access object	operator info
PartitionUnion	500.00	root		
├─TableReader	250.00	root		data:Selection
│ └─Selection	250.00	cop[tikv]		ge(list_push_down.tcollist.a, 0), le(list_push_down.tcollist.a, 10)
│   └─TableFullScan	10000.00	cop[tikv]	table:tcollist, partition:p0	keep order:false, stats:pseudo
└─TableReader	250.00	root		data:Selection
  └─Selection	250.00	cop[tikv]		ge(list_push_down.tcollist.a, 0), le(list_push_down.tcollist.a, 10)
    └─TableFullScan	10000.00	cop[tikv]	table:tcollist, partition:p1	keep order:false, stats:pseudo
explain format='brief' select avg(a) from tcollist;
id	estRows	task	access object	operator info
HashAgg	1.00	root		funcs:avg(Column#4, Column#5)->Column#3
└─PartitionUnion	2.00	root		
  ├─HashAgg	1.00	root		funcs:count(Column#6)->Column#4, funcs:sum(Column#7)->Column#5
  │ └─TableReader	1.00	root		data:HashAgg
  │   └─HashAgg	1.00	cop[tikv]		funcs:count(list_push_down.tcollist.a)->Column#6, funcs:sum(list_push_down.tcollist.a)->Column#7
  │     └─TableFullScan	10000.00	cop[tikv]	table:tcollist, partition:p0	keep order:false, stats:pseudo
  └─HashAgg	1.00	root		funcs:count(Column#10)->Column#4, funcs:sum(Column#11)->Column#5
    └─TableReader	1.00	root		data:HashAgg
      └─HashAgg	1.00	cop[tikv]		funcs:count(list_push_down.tcollist.a)->Column#10, funcs:sum(list_push_down.tcollist.a)->Column#11
        └─TableFullScan	10000.00	cop[tikv]	table:tcollist, partition:p1	keep order:false, stats:pseudo
explain format='brief' select a from tcollist limit 10;
id	estRows	task	access object	operator info
Limit	10.00	root		offset:0, count:10
└─PartitionUnion	10.00	root		
  ├─Limit	10.00	root		offset:0, count:10
  │ └─TableReader	10.00	root		data:Limit
  │   └─Limit	10.00	cop[tikv]		offset:0, count:10
  │     └─TableFullScan	10.00	cop[tikv]	table:tcollist, partition:p0	keep order:false, stats:pseudo
  └─Limit	10.00	root		offset:0, count:10
    └─TableReader	10.00	root		data:Limit
      └─Limit	10.00	cop[tikv]		offset:0, count:10
        └─TableFullScan	10.00	cop[tikv]	table:tcollist, partition:p1	keep order:false, stats:pseudo
explain format='brief' select a from tcollist order by a limit 10;
id	estRows	task	access object	operator info
TopN	10.00	root		list_push_down.tcollist.a, offset:0, count:10
└─PartitionUnion	20.00	root		
  ├─TopN	10.00	root		list_push_down.tcollist.a, offset:0, count:10
  │ └─TableReader	10.00	root		data:TopN
  │   └─TopN	10.00	cop[tikv]		list_push_down.tcollist.a, offset:0, count:10
  │     └─TableFullScan	10000.00	cop[tikv]	table:tcollist, partition:p0	keep order:false, stats:pseudo
  └─TopN	10.00	root		list_push_down.tcollist.a, offset:0, count:10
    └─TableReader	10.00	root		data:TopN
      └─TopN	10.00	cop[tikv]		list_push_down.tcollist.a, offset:0, count:10
        └─TableFullScan	10000.00	cop[tikv]	table:tcollist, partition:p1	keep order:false, stats:pseudo
create database list_col_partition_types;
use list_col_partition_types;
drop table if exists tlist;
set tidb_enable_list_partition = 1;
create table tint (a int) partition by list columns(a) (partition p0 values in (0, 1), partition p1 values in (2, 3));
create table tdate (a date) partition by list columns(a) (partition p0 values in ('2000-01-01', '2000-01-02'), partition p1 values in ('2000-01-03', '2000-01-04'));
create table tstring (a varchar(32)) partition by list columns(a) (partition p0 values in ('a', 'b'), partition p1 values in ('c', 'd'));
create table tdouble (a double) partition by list columns(a) (partition p0 values in (0, 1), partition p1 values in (2, 3));
Error 1659 (HY000): Field 'a' is of a not allowed type for this type of partitioning
create table tdecimal (a decimal(30, 10)) partition by list columns(a) (partition p0 values in (0, 1), partition p1 values in (2, 3));
Error 1659 (HY000): Field 'a' is of a not allowed type for this type of partitioning
insert into tint values (0), (1), (2), (3);
insert into tdate values ('2000-01-01'), ('2000-01-02'), ('2000-01-03'), ('2000-01-04');
insert into tstring values ('a'), ('b'), ('c'), ('d');
analyze table tint;
analyze table tdate;
analyze table tstring;
explain format = 'brief' select * from tint where a<=1;
id	estRows	task	access object	operator info
TableReader	2.00	root		data:Selection
└─Selection	2.00	cop[tikv]		le(list_col_partition_types.tint.a, 1)
  └─TableFullScan	2.00	cop[tikv]	table:tint, partition:p0	keep order:false
explain format = 'brief' select * from tint where a in (0, 1);
id	estRows	task	access object	operator info
TableReader	2.00	root		data:Selection
└─Selection	2.00	cop[tikv]		in(list_col_partition_types.tint.a, 0, 1)
  └─TableFullScan	2.00	cop[tikv]	table:tint, partition:p0	keep order:false
select * from tint where a<=1 order by a;
a
0
1
select * from tint where a in (0, 1) order by a;
a
0
1
explain format = 'brief' select * from tdate where a<='2000-01-01';
id	estRows	task	access object	operator info
TableReader	1.00	root		data:Selection
└─Selection	1.00	cop[tikv]		le(list_col_partition_types.tdate.a, 2000-01-01 00:00:00.000000)
  └─TableFullScan	2.00	cop[tikv]	table:tdate, partition:p0	keep order:false
explain format = 'brief' select * from tdate where a in ('2000-01-01', '2000-01-02');
id	estRows	task	access object	operator info
TableReader	2.00	root		data:Selection
└─Selection	2.00	cop[tikv]		in(list_col_partition_types.tdate.a, 2000-01-01 00:00:00.000000, 2000-01-02 00:00:00.000000)
  └─TableFullScan	2.00	cop[tikv]	table:tdate, partition:p0	keep order:false
select * from tdate where a<='2000-01-01' order by a;
a
2000-01-01
select * from tdate where a in ('2000-01-01', '2000-01-02') order by a;
a
2000-01-01
2000-01-02
explain format = 'brief' select * from tstring where a<='b';
id	estRows	task	access object	operator info
TableReader	2.00	root		data:Selection
└─Selection	2.00	cop[tikv]		le(list_col_partition_types.tstring.a, "b")
  └─TableFullScan	2.00	cop[tikv]	table:tstring, partition:p0	keep order:false
explain format = 'brief' select * from tstring where a in ('a', 'b');
id	estRows	task	access object	operator info
TableReader	2.00	root		data:Selection
└─Selection	2.00	cop[tikv]		in(list_col_partition_types.tstring.a, "a", "b")
  └─TableFullScan	2.00	cop[tikv]	table:tstring, partition:p0	keep order:false
select * from tstring where a<='b' order by a;
a
a
b
select * from tstring where a in ('a', 'b') order by a;
a
a
b
create database list_partition_pruning;
use list_partition_pruning;
set tidb_enable_list_partition = 1;
set @@tidb_partition_prune_mode = 'static';
create table tabs (a int, b int) partition by list (ABS(a - b)) (partition p0 values in (0, 1, 2, 3), partition p1 values in (4, 5, 6, 7));
insert into tabs values (1, 1), (2, 2), (2, 1), (1, 2), (4, 8), (8, 4), (5, 10), (10, 5);
select * from tabs;
a	b
1	1
1	2
10	5
2	1
2	2
4	8
5	10
8	4
select * from tabs partition(p0);
a	b
1	1
1	2
2	1
2	2
create table tceil (a int, b int) partition by list (CEILING(a)) (partition p0 values in (0, 1, 2, 3), partition p1 values in (4, 5, 6, 7));
insert into tceil values (0.23, 1), (3.14, 4.33), (1.2, 30), (5.1, 4.23);
select * from tceil;
a	b
0	1
1	30
3	4
5	4
select * from tceil partition(p0);
a	b
0	1
1	30
3	4
create table tdatediff (a date, b datetime) partition by list (DATEDIFF(a, b)) (partition p0 values in (0, 10, 20), partition p1 values in (30, 40, 50));
insert into tdatediff values ('2019-02-01', '2019-02-01 18:00:00'), ('2019-03-30', '2019-03-20 23:59:59'), ('2020-06-01', '2020-04-12 18:00:00');
select * from tdatediff;
a	b
2019-02-01	2019-02-01 18:00:00
2019-03-30	2019-03-20 23:59:59
2020-06-01	2020-04-12 18:00:00
select * from tdatediff partition(p0);
a	b
2019-02-01	2019-02-01 18:00:00
2019-03-30	2019-03-20 23:59:59
create table tday (a date, b datetime) partition by list (DAY(a)) (partition p0 values in (0, 1, 2), partition p1 values in (3, 4, 5));
insert into tday values ('2008-01-01', '1990-01-01 22:00:01'), ('2008-01-03', '2008-01-03 23:59:30'), ('2019-02-01', '2017-03-30 23:59:30'), ('2019-04-05', '2019-04-01 23:59:59'), ('2020-07-01', '2020-04-15 18:00:00');
select * from tday;
a	b
2008-01-01	1990-01-01 22:00:01
2008-01-03	2008-01-03 23:59:30
2019-02-01	2017-03-30 23:59:30
2019-04-05	2019-04-01 23:59:59
2020-07-01	2020-04-15 18:00:00
select * from tday partition(p0);
a	b
2008-01-01	1990-01-01 22:00:01
2019-02-01	2017-03-30 23:59:30
2020-07-01	2020-04-15 18:00:00
create table tdayofmonth (a date, b datetime) partition by list (DAYOFMONTH(a)) (partition p0 values in (0, 1, 2), partition p1 values in (3, 4, 5));
insert into tdayofmonth values ('2008-01-01', '1990-01-01 22:00:01'), ('2008-01-03', '2008-01-03 23:59:30'), ('2019-02-01', '2017-03-30 23:59:30'), ('2019-04-05', '2019-04-01 23:59:59'), ('2020-07-01', '2020-04-15 18:00:00');
select * from tdayofmonth;
a	b
2008-01-01	1990-01-01 22:00:01
2008-01-03	2008-01-03 23:59:30
2019-02-01	2017-03-30 23:59:30
2019-04-05	2019-04-01 23:59:59
2020-07-01	2020-04-15 18:00:00
select * from tdayofmonth partition(p0);
a	b
2008-01-01	1990-01-01 22:00:01
2019-02-01	2017-03-30 23:59:30
2020-07-01	2020-04-15 18:00:00
create table tdayofweek (a date, b datetime) partition by list (DAYOFWEEK(a)) (partition p0 values in (0, 1, 2, 3), partition p1 values in (4, 5, 6, 7));
insert into tdayofweek values ('2008-01-01', '1990-01-01 22:00:01'), ('2008-01-03', '2008-01-03 23:59:30'), ('2019-02-01', '2017-03-30 23:59:30'), ('2019-04-05', '2019-04-01 23:59:59'), ('2020-07-01', '2020-04-15 18:00:00');
select * from tdayofweek;
a	b
2008-01-01	1990-01-01 22:00:01
2008-01-03	2008-01-03 23:59:30
2019-02-01	2017-03-30 23:59:30
2019-04-05	2019-04-01 23:59:59
2020-07-01	2020-04-15 18:00:00
select * from tdayofweek partition(p0);
a	b
2008-01-01	1990-01-01 22:00:01
create table tfloor (a int, b int) partition by list (FLOOR(a)) (partition p0 values in (0, 1, 2, 3), partition p1 values in (4, 5, 6, 7));
insert into tfloor values (0.23, 1), (3.14, 4.33), (6.2, 30), (7.1, 4.23);
select * from tfloor;
a	b
0	1
3	4
6	30
7	4
select * from tfloor partition(p0);
a	b
0	1
3	4
create table thour (a time, b time) partition by list (HOUR(a)) (partition p0 values in (0, 1, 2, 3, 4), partition p1 values in (5, 6, 7, 8));
insert into thour values ('03:09:34', '00:00:00'), ('01:23:34', '32:03:34'), ('08:39:20', '23:09:43'), ('03:00:00', '20:00:00');
select * from thour;
a	b
01:23:34	32:03:34
03:00:00	20:00:00
03:09:34	00:00:00
08:39:20	23:09:43
select * from thour partition(p0);
a	b
01:23:34	32:03:34
03:00:00	20:00:00
03:09:34	00:00:00
create table tminute (a datetime, b datetime) partition by list (MINUTE(a)) (partition p0 values in (0, 1, 2, 3), partition p1 values in (4, 5, 6, 7));
insert into tminute values ('2019-12-31 12:00:00', '2019-12-31 23:59:59'), ('2019-12-31 23:06:59', '2019-12-31 12:00:00');
select * from tminute;
a	b
2019-12-31 12:00:00	2019-12-31 23:59:59
2019-12-31 23:06:59	2019-12-31 12:00:00
select * from tminute partition(p0);
a	b
2019-12-31 12:00:00	2019-12-31 23:59:59
create table tmod (a int, b int) partition by list (MOD(a, b)) (partition p0 values in (0, 1, 2, 3), partition p1 values in (4, 5, 6, 7));
insert into tmod values (3, 1), (10, 3), (4, 4), (13, 7);
select * from tmod;
a	b
10	3
13	7
3	1
4	4
select * from tmod partition(p0);
a	b
10	3
3	1
4	4
create table tmonth (a date, b date) partition by list (MONTH(a)) (partition p0 values in (0, 1, 2, 3), partition p1 values in (4, 5, 6, 7));
insert into tmonth values ('2000-02-23', '2008-02-01'), ('2019-01-01', '2018-03-10'), ('2020-06-12', '2021-04-05'), ('2019-05-20', '2017-02-21');
select * from tmonth;
a	b
2000-02-23	2008-02-01
2019-01-01	2018-03-10
2019-05-20	2017-02-21
2020-06-12	2021-04-05
select * from tmonth partition(p0);
a	b
2000-02-23	2008-02-01
2019-01-01	2018-03-10
create table tquarter (a date, b date) partition by list (QUARTER(a)) (partition p0 values in (0, 1, 2), partition p1 values in (3, 4, 5));
insert into tquarter values ('2019-02-01', '2008-01-02'), ('2019-01-01', '2018-03-10'), ('2020-11-12', '2021-04-05'), ('2019-05-20', '2017-02-21');
select * from tquarter;
a	b
2019-01-01	2018-03-10
2019-02-01	2008-01-02
2019-05-20	2017-02-21
2020-11-12	2021-04-05
select * from tquarter partition(p0);
a	b
2019-01-01	2018-03-10
2019-02-01	2008-01-02
2019-05-20	2017-02-21
create table tto_seconds (a date, b datetime) partition by list (TO_SECONDS(a)) (partition p0 values in (0, 1, 2, 3, 63740649600), partition p1 values in (4, 5, 6, 7, 63744969600));
insert into tto_seconds values ('2019-12-31 12:00:00', '2019-12-31 23:59:59'), ('2019-11-11 23:06:59', '2019-12-31 12:00:00');
select * from tto_seconds;
a	b
2019-11-11	2019-12-31 12:00:00
2019-12-31	2019-12-31 23:59:59
select * from tto_seconds partition(p0);
a	b
2019-11-11	2019-12-31 12:00:00
set tidb_cost_model_version=2;
drop table if exists tlist;
set tidb_enable_list_partition = 1;
create table trange (a int, b int, c int, index ia(a), primary key (b) clustered)
partition by range(b) (
partition p1 values less than(100),
partition p2 values less than(200),
partition p3 values less than maxvalue);
create table tlist (a int, b int, c int, index ia(a), primary key (b) clustered)
partition by list (b) (
partition p0 values in (0, 1, 2),
partition p1 values in (3, 4, 5));
create table thash (a int, b int, c int, index ia(a), primary key (b) clustered)
partition by hash(b) partitions 4;
create table t (a int, b int, c int, index ia(a), primary key (b) clustered);
analyze table trange;
analyze table tlist;
analyze table thash;
analyze table t;
explain format='brief' select a from t use index (ia) where a > 10 order by a limit 10;
id	estRows	task	access object	operator info
Limit	10.00	root		offset:0, count:10
└─IndexReader	10.00	root		index:Limit
  └─Limit	10.00	cop[tikv]		offset:0, count:10
    └─IndexRangeScan	10.00	cop[tikv]	table:t, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
explain format='brief' select a from trange use index (ia) where a > 10 order by a limit 10;
id	estRows	task	access object	operator info
TopN	10.00	root		list_partition_pruning.trange.a, offset:0, count:10
└─PartitionUnion	30.00	root		
  ├─Limit	10.00	root		offset:0, count:10
  │ └─IndexReader	10.00	root		index:Limit
  │   └─Limit	10.00	cop[tikv]		offset:0, count:10
  │     └─IndexRangeScan	10.00	cop[tikv]	table:trange, partition:p1, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  ├─Limit	10.00	root		offset:0, count:10
  │ └─IndexReader	10.00	root		index:Limit
  │   └─Limit	10.00	cop[tikv]		offset:0, count:10
  │     └─IndexRangeScan	10.00	cop[tikv]	table:trange, partition:p2, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  └─Limit	10.00	root		offset:0, count:10
    └─IndexReader	10.00	root		index:Limit
      └─Limit	10.00	cop[tikv]		offset:0, count:10
        └─IndexRangeScan	10.00	cop[tikv]	table:trange, partition:p3, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
explain format='brief' select a from tlist use index (ia) where a > 10 order by a limit 10;
id	estRows	task	access object	operator info
TopN	10.00	root		list_partition_pruning.tlist.a, offset:0, count:10
└─PartitionUnion	20.00	root		
  ├─Limit	10.00	root		offset:0, count:10
  │ └─IndexReader	10.00	root		index:Limit
  │   └─Limit	10.00	cop[tikv]		offset:0, count:10
  │     └─IndexRangeScan	10.00	cop[tikv]	table:tlist, partition:p0, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  └─Limit	10.00	root		offset:0, count:10
    └─IndexReader	10.00	root		index:Limit
      └─Limit	10.00	cop[tikv]		offset:0, count:10
        └─IndexRangeScan	10.00	cop[tikv]	table:tlist, partition:p1, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
explain format='brief' select a from thash use index (ia) where a > 10 order by a limit 10;
id	estRows	task	access object	operator info
TopN	10.00	root		list_partition_pruning.thash.a, offset:0, count:10
└─PartitionUnion	40.00	root		
  ├─Limit	10.00	root		offset:0, count:10
  │ └─IndexReader	10.00	root		index:Limit
  │   └─Limit	10.00	cop[tikv]		offset:0, count:10
  │     └─IndexRangeScan	10.00	cop[tikv]	table:thash, partition:p0, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  ├─Limit	10.00	root		offset:0, count:10
  │ └─IndexReader	10.00	root		index:Limit
  │   └─Limit	10.00	cop[tikv]		offset:0, count:10
  │     └─IndexRangeScan	10.00	cop[tikv]	table:thash, partition:p1, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  ├─Limit	10.00	root		offset:0, count:10
  │ └─IndexReader	10.00	root		index:Limit
  │   └─Limit	10.00	cop[tikv]		offset:0, count:10
  │     └─IndexRangeScan	10.00	cop[tikv]	table:thash, partition:p2, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  └─Limit	10.00	root		offset:0, count:10
    └─IndexReader	10.00	root		index:Limit
      └─Limit	10.00	cop[tikv]		offset:0, count:10
        └─IndexRangeScan	10.00	cop[tikv]	table:thash, partition:p3, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
explain format='brief' select * from t use index (ia) where a > 10 order by a limit 10;
id	estRows	task	access object	operator info
IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
│ └─IndexRangeScan	10.00	cop[tikv]	table:t, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
└─TableRowIDScan(Probe)	10.00	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format='brief' select * from trange use index (ia) where a > 10 order by a limit 10;
id	estRows	task	access object	operator info
TopN	10.00	root		list_partition_pruning.trange.a, offset:0, count:10
└─PartitionUnion	30.00	root		
  ├─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
  │ ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
  │ │ └─IndexRangeScan	10.00	cop[tikv]	table:trange, partition:p1, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  │ └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:trange, partition:p1	keep order:false, stats:pseudo
  ├─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
  │ ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
  │ │ └─IndexRangeScan	10.00	cop[tikv]	table:trange, partition:p2, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  │ └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:trange, partition:p2	keep order:false, stats:pseudo
  └─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
    ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
    │ └─IndexRangeScan	10.00	cop[tikv]	table:trange, partition:p3, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
    └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:trange, partition:p3	keep order:false, stats:pseudo
explain format='brief' select * from tlist use index (ia) where a > 10 order by a limit 10;
id	estRows	task	access object	operator info
TopN	10.00	root		list_partition_pruning.tlist.a, offset:0, count:10
└─PartitionUnion	20.00	root		
  ├─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
  │ ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
  │ │ └─IndexRangeScan	10.00	cop[tikv]	table:tlist, partition:p0, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  │ └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:tlist, partition:p0	keep order:false, stats:pseudo
  └─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
    ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
    │ └─IndexRangeScan	10.00	cop[tikv]	table:tlist, partition:p1, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
    └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:tlist, partition:p1	keep order:false, stats:pseudo
explain format='brief' select * from thash use index (ia) where a > 10 order by a limit 10;
id	estRows	task	access object	operator info
TopN	10.00	root		list_partition_pruning.thash.a, offset:0, count:10
└─PartitionUnion	40.00	root		
  ├─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
  │ ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
  │ │ └─IndexRangeScan	10.00	cop[tikv]	table:thash, partition:p0, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  │ └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:thash, partition:p0	keep order:false, stats:pseudo
  ├─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
  │ ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
  │ │ └─IndexRangeScan	10.00	cop[tikv]	table:thash, partition:p1, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  │ └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:thash, partition:p1	keep order:false, stats:pseudo
  ├─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
  │ ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
  │ │ └─IndexRangeScan	10.00	cop[tikv]	table:thash, partition:p2, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  │ └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:thash, partition:p2	keep order:false, stats:pseudo
  └─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
    ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
    │ └─IndexRangeScan	10.00	cop[tikv]	table:thash, partition:p3, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
    └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:thash, partition:p3	keep order:false, stats:pseudo
explain format='brief' select * from t use index (ia) where a + 1 > 10 order by a limit 10;
id	estRows	task	access object	operator info
IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
│ └─Selection	10.00	cop[tikv]		gt(plus(list_partition_pruning.t.a, 1), 10)
│   └─IndexFullScan	12.50	cop[tikv]	table:t, index:ia(a)	keep order:true, stats:pseudo
└─TableRowIDScan(Probe)	10.00	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format='brief' select * from trange use index (ia) where a + 1 > 10 order by a limit 10;
id	estRows	task	access object	operator info
TopN	10.00	root		list_partition_pruning.trange.a, offset:0, count:10
└─PartitionUnion	30.00	root		
  ├─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
  │ ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
  │ │ └─Selection	10.00	cop[tikv]		gt(plus(list_partition_pruning.trange.a, 1), 10)
  │ │   └─IndexFullScan	12.50	cop[tikv]	table:trange, partition:p1, index:ia(a)	keep order:true, stats:pseudo
  │ └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:trange, partition:p1	keep order:false, stats:pseudo
  ├─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
  │ ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
  │ │ └─Selection	10.00	cop[tikv]		gt(plus(list_partition_pruning.trange.a, 1), 10)
  │ │   └─IndexFullScan	12.50	cop[tikv]	table:trange, partition:p2, index:ia(a)	keep order:true, stats:pseudo
  │ └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:trange, partition:p2	keep order:false, stats:pseudo
  └─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
    ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
    │ └─Selection	10.00	cop[tikv]		gt(plus(list_partition_pruning.trange.a, 1), 10)
    │   └─IndexFullScan	12.50	cop[tikv]	table:trange, partition:p3, index:ia(a)	keep order:true, stats:pseudo
    └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:trange, partition:p3	keep order:false, stats:pseudo
explain format='brief' select * from tlist use index (ia) where a + 1 > 10 order by a limit 10;
id	estRows	task	access object	operator info
TopN	10.00	root		list_partition_pruning.tlist.a, offset:0, count:10
└─PartitionUnion	20.00	root		
  ├─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
  │ ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
  │ │ └─Selection	10.00	cop[tikv]		gt(plus(list_partition_pruning.tlist.a, 1), 10)
  │ │   └─IndexFullScan	12.50	cop[tikv]	table:tlist, partition:p0, index:ia(a)	keep order:true, stats:pseudo
  │ └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:tlist, partition:p0	keep order:false, stats:pseudo
  └─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
    ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
    │ └─Selection	10.00	cop[tikv]		gt(plus(list_partition_pruning.tlist.a, 1), 10)
    │   └─IndexFullScan	12.50	cop[tikv]	table:tlist, partition:p1, index:ia(a)	keep order:true, stats:pseudo
    └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:tlist, partition:p1	keep order:false, stats:pseudo
explain format='brief' select * from thash use index (ia) where a + 1 > 10 order by a limit 10;
id	estRows	task	access object	operator info
TopN	10.00	root		list_partition_pruning.thash.a, offset:0, count:10
└─PartitionUnion	40.00	root		
  ├─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
  │ ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
  │ │ └─Selection	10.00	cop[tikv]		gt(plus(list_partition_pruning.thash.a, 1), 10)
  │ │   └─IndexFullScan	12.50	cop[tikv]	table:thash, partition:p0, index:ia(a)	keep order:true, stats:pseudo
  │ └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:thash, partition:p0	keep order:false, stats:pseudo
  ├─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
  │ ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
  │ │ └─Selection	10.00	cop[tikv]		gt(plus(list_partition_pruning.thash.a, 1), 10)
  │ │   └─IndexFullScan	12.50	cop[tikv]	table:thash, partition:p1, index:ia(a)	keep order:true, stats:pseudo
  │ └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:thash, partition:p1	keep order:false, stats:pseudo
  ├─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
  │ ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
  │ │ └─Selection	10.00	cop[tikv]		gt(plus(list_partition_pruning.thash.a, 1), 10)
  │ │   └─IndexFullScan	12.50	cop[tikv]	table:thash, partition:p2, index:ia(a)	keep order:true, stats:pseudo
  │ └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:thash, partition:p2	keep order:false, stats:pseudo
  └─IndexLookUp	10.00	root		limit embedded(offset:0, count:10)
    ├─Limit(Build)	10.00	cop[tikv]		offset:0, count:10
    │ └─Selection	10.00	cop[tikv]		gt(plus(list_partition_pruning.thash.a, 1), 10)
    │   └─IndexFullScan	12.50	cop[tikv]	table:thash, partition:p3, index:ia(a)	keep order:true, stats:pseudo
    └─TableRowIDScan(Probe)	10.00	cop[tikv]	table:thash, partition:p3	keep order:false, stats:pseudo
explain format='brief' select a from t use index (ia) where a > 10 and c = 10 order by a limit 10;
id	estRows	task	access object	operator info
Projection	3.33	root		list_partition_pruning.t.a
└─Limit	3.33	root		offset:0, count:10
  └─Projection	3.33	root		list_partition_pruning.t.a, list_partition_pruning.t.c
    └─IndexLookUp	3.33	root		
      ├─IndexRangeScan(Build)	3333.33	cop[tikv]	table:t, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
      └─Selection(Probe)	3.33	cop[tikv]		eq(list_partition_pruning.t.c, 10)
        └─TableRowIDScan	3333.33	cop[tikv]	table:t	keep order:false, stats:pseudo
explain format='brief' select a from trange use index (ia) where a > 10 and c = 10 order by a limit 10;
id	estRows	task	access object	operator info
TopN	10.00	root		list_partition_pruning.trange.a, offset:0, count:10
└─PartitionUnion	10.00	root		
  ├─Projection	3.33	root		list_partition_pruning.trange.a
  │ └─Limit	3.33	root		offset:0, count:10
  │   └─Projection	3.33	root		list_partition_pruning.trange.a, list_partition_pruning.trange.c
  │     └─IndexLookUp	3.33	root		
  │       ├─IndexRangeScan(Build)	3333.33	cop[tikv]	table:trange, partition:p1, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  │       └─Selection(Probe)	3.33	cop[tikv]		eq(list_partition_pruning.trange.c, 10)
  │         └─TableRowIDScan	3333.33	cop[tikv]	table:trange, partition:p1	keep order:false, stats:pseudo
  ├─Projection	3.33	root		list_partition_pruning.trange.a
  │ └─Limit	3.33	root		offset:0, count:10
  │   └─Projection	3.33	root		list_partition_pruning.trange.a, list_partition_pruning.trange.c
  │     └─IndexLookUp	3.33	root		
  │       ├─IndexRangeScan(Build)	3333.33	cop[tikv]	table:trange, partition:p2, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  │       └─Selection(Probe)	3.33	cop[tikv]		eq(list_partition_pruning.trange.c, 10)
  │         └─TableRowIDScan	3333.33	cop[tikv]	table:trange, partition:p2	keep order:false, stats:pseudo
  └─Projection	3.33	root		list_partition_pruning.trange.a
    └─Limit	3.33	root		offset:0, count:10
      └─Projection	3.33	root		list_partition_pruning.trange.a, list_partition_pruning.trange.c
        └─IndexLookUp	3.33	root		
          ├─IndexRangeScan(Build)	3333.33	cop[tikv]	table:trange, partition:p3, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
          └─Selection(Probe)	3.33	cop[tikv]		eq(list_partition_pruning.trange.c, 10)
            └─TableRowIDScan	3333.33	cop[tikv]	table:trange, partition:p3	keep order:false, stats:pseudo
explain format='brief' select a from tlist use index (ia) where a > 10 and c = 10 order by a limit 10;
id	estRows	task	access object	operator info
TopN	6.67	root		list_partition_pruning.tlist.a, offset:0, count:10
└─PartitionUnion	6.67	root		
  ├─Projection	3.33	root		list_partition_pruning.tlist.a
  │ └─Limit	3.33	root		offset:0, count:10
  │   └─Projection	3.33	root		list_partition_pruning.tlist.a, list_partition_pruning.tlist.c
  │     └─IndexLookUp	3.33	root		
  │       ├─IndexRangeScan(Build)	3333.33	cop[tikv]	table:tlist, partition:p0, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  │       └─Selection(Probe)	3.33	cop[tikv]		eq(list_partition_pruning.tlist.c, 10)
  │         └─TableRowIDScan	3333.33	cop[tikv]	table:tlist, partition:p0	keep order:false, stats:pseudo
  └─Projection	3.33	root		list_partition_pruning.tlist.a
    └─Limit	3.33	root		offset:0, count:10
      └─Projection	3.33	root		list_partition_pruning.tlist.a, list_partition_pruning.tlist.c
        └─IndexLookUp	3.33	root		
          ├─IndexRangeScan(Build)	3333.33	cop[tikv]	table:tlist, partition:p1, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
          └─Selection(Probe)	3.33	cop[tikv]		eq(list_partition_pruning.tlist.c, 10)
            └─TableRowIDScan	3333.33	cop[tikv]	table:tlist, partition:p1	keep order:false, stats:pseudo
explain format='brief' select a from thash use index (ia) where a > 10 and c = 10 order by a limit 10;
id	estRows	task	access object	operator info
TopN	10.00	root		list_partition_pruning.thash.a, offset:0, count:10
└─PartitionUnion	13.33	root		
  ├─Projection	3.33	root		list_partition_pruning.thash.a
  │ └─Limit	3.33	root		offset:0, count:10
  │   └─Projection	3.33	root		list_partition_pruning.thash.a, list_partition_pruning.thash.c
  │     └─IndexLookUp	3.33	root		
  │       ├─IndexRangeScan(Build)	3333.33	cop[tikv]	table:thash, partition:p0, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  │       └─Selection(Probe)	3.33	cop[tikv]		eq(list_partition_pruning.thash.c, 10)
  │         └─TableRowIDScan	3333.33	cop[tikv]	table:thash, partition:p0	keep order:false, stats:pseudo
  ├─Projection	3.33	root		list_partition_pruning.thash.a
  │ └─Limit	3.33	root		offset:0, count:10
  │   └─Projection	3.33	root		list_partition_pruning.thash.a, list_partition_pruning.thash.c
  │     └─IndexLookUp	3.33	root		
  │       ├─IndexRangeScan(Build)	3333.33	cop[tikv]	table:thash, partition:p1, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  │       └─Selection(Probe)	3.33	cop[tikv]		eq(list_partition_pruning.thash.c, 10)
  │         └─TableRowIDScan	3333.33	cop[tikv]	table:thash, partition:p1	keep order:false, stats:pseudo
  ├─Projection	3.33	root		list_partition_pruning.thash.a
  │ └─Limit	3.33	root		offset:0, count:10
  │   └─Projection	3.33	root		list_partition_pruning.thash.a, list_partition_pruning.thash.c
  │     └─IndexLookUp	3.33	root		
  │       ├─IndexRangeScan(Build)	3333.33	cop[tikv]	table:thash, partition:p2, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
  │       └─Selection(Probe)	3.33	cop[tikv]		eq(list_partition_pruning.thash.c, 10)
  │         └─TableRowIDScan	3333.33	cop[tikv]	table:thash, partition:p2	keep order:false, stats:pseudo
  └─Projection	3.33	root		list_partition_pruning.thash.a
    └─Limit	3.33	root		offset:0, count:10
      └─Projection	3.33	root		list_partition_pruning.thash.a, list_partition_pruning.thash.c
        └─IndexLookUp	3.33	root		
          ├─IndexRangeScan(Build)	3333.33	cop[tikv]	table:thash, partition:p3, index:ia(a)	range:(10,+inf], keep order:true, stats:pseudo
          └─Selection(Probe)	3.33	cop[tikv]		eq(list_partition_pruning.thash.c, 10)
            └─TableRowIDScan	3333.33	cop[tikv]	table:thash, partition:p3	keep order:false, stats:pseudo
explain format='brief' select a from t use index () where b > 10 order by b limit 10;
id	estRows	task	access object	operator info
Projection	10.00	root		list_partition_pruning.t.a
└─Limit	10.00	root		offset:0, count:10
  └─TableReader	10.00	root		data:Limit
    └─Limit	10.00	cop[tikv]		offset:0, count:10
      └─TableRangeScan	10.00	cop[tikv]	table:t	range:(10,+inf], keep order:true, stats:pseudo
explain format='brief' select a from trange use index () where b > 10 order by b limit 10;
id	estRows	task	access object	operator info
Projection	10.00	root		list_partition_pruning.trange.a
└─TopN	10.00	root		list_partition_pruning.trange.b, offset:0, count:10
  └─PartitionUnion	30.00	root		
    ├─Limit	10.00	root		offset:0, count:10
    │ └─TableReader	10.00	root		data:Limit
    │   └─Limit	10.00	cop[tikv]		offset:0, count:10
    │     └─TableRangeScan	10.00	cop[tikv]	table:trange, partition:p1	range:(10,+inf], keep order:true, stats:pseudo
    ├─Limit	10.00	root		offset:0, count:10
    │ └─TableReader	10.00	root		data:Limit
    │   └─Limit	10.00	cop[tikv]		offset:0, count:10
    │     └─TableRangeScan	10.00	cop[tikv]	table:trange, partition:p2	range:(10,+inf], keep order:true, stats:pseudo
    └─Limit	10.00	root		offset:0, count:10
      └─TableReader	10.00	root		data:Limit
        └─Limit	10.00	cop[tikv]		offset:0, count:10
          └─TableRangeScan	10.00	cop[tikv]	table:trange, partition:p3	range:(10,+inf], keep order:true, stats:pseudo
explain format='brief' select a from tlist use index () where b > 10 order by b limit 10;
id	estRows	task	access object	operator info
Projection	10.00	root		list_partition_pruning.tlist.a
└─TopN	10.00	root		list_partition_pruning.tlist.b, offset:0, count:10
  └─PartitionUnion	20.00	root		
    ├─Limit	10.00	root		offset:0, count:10
    │ └─TableReader	10.00	root		data:Limit
    │   └─Limit	10.00	cop[tikv]		offset:0, count:10
    │     └─TableRangeScan	10.00	cop[tikv]	table:tlist, partition:p0	range:(10,+inf], keep order:true, stats:pseudo
    └─Limit	10.00	root		offset:0, count:10
      └─TableReader	10.00	root		data:Limit
        └─Limit	10.00	cop[tikv]		offset:0, count:10
          └─TableRangeScan	10.00	cop[tikv]	table:tlist, partition:p1	range:(10,+inf], keep order:true, stats:pseudo
explain format='brief' select a from thash use index () where b > 10 order by b limit 10;
id	estRows	task	access object	operator info
Projection	10.00	root		list_partition_pruning.thash.a
└─TopN	10.00	root		list_partition_pruning.thash.b, offset:0, count:10
  └─PartitionUnion	40.00	root		
    ├─Limit	10.00	root		offset:0, count:10
    │ └─TableReader	10.00	root		data:Limit
    │   └─Limit	10.00	cop[tikv]		offset:0, count:10
    │     └─TableRangeScan	10.00	cop[tikv]	table:thash, partition:p0	range:(10,+inf], keep order:true, stats:pseudo
    ├─Limit	10.00	root		offset:0, count:10
    │ └─TableReader	10.00	root		data:Limit
    │   └─Limit	10.00	cop[tikv]		offset:0, count:10
    │     └─TableRangeScan	10.00	cop[tikv]	table:thash, partition:p1	range:(10,+inf], keep order:true, stats:pseudo
    ├─Limit	10.00	root		offset:0, count:10
    │ └─TableReader	10.00	root		data:Limit
    │   └─Limit	10.00	cop[tikv]		offset:0, count:10
    │     └─TableRangeScan	10.00	cop[tikv]	table:thash, partition:p2	range:(10,+inf], keep order:true, stats:pseudo
    └─Limit	10.00	root		offset:0, count:10
      └─TableReader	10.00	root		data:Limit
        └─Limit	10.00	cop[tikv]		offset:0, count:10
          └─TableRangeScan	10.00	cop[tikv]	table:thash, partition:p3	range:(10,+inf], keep order:true, stats:pseudo
explain format='brief' select a from t use index () where a > 10 order by b limit 10;
id	estRows	task	access object	operator info
Projection	10.00	root		list_partition_pruning.t.a
└─Limit	10.00	root		offset:0, count:10
  └─TableReader	10.00	root		data:Limit
    └─Limit	10.00	cop[tikv]		offset:0, count:10
      └─Selection	10.00	cop[tikv]		gt(list_partition_pruning.t.a, 10)
        └─TableFullScan	30.00	cop[tikv]	table:t	keep order:true, stats:pseudo
explain format='brief' select a from trange use index () where a > 10 order by b limit 10;
id	estRows	task	access object	operator info
Projection	10.00	root		list_partition_pruning.trange.a
└─TopN	10.00	root		list_partition_pruning.trange.b, offset:0, count:10
  └─PartitionUnion	30.00	root		
    ├─Limit	10.00	root		offset:0, count:10
    │ └─TableReader	10.00	root		data:Limit
    │   └─Limit	10.00	cop[tikv]		offset:0, count:10
    │     └─Selection	10.00	cop[tikv]		gt(list_partition_pruning.trange.a, 10)
    │       └─TableFullScan	30.00	cop[tikv]	table:trange, partition:p1	keep order:true, stats:pseudo
    ├─Limit	10.00	root		offset:0, count:10
    │ └─TableReader	10.00	root		data:Limit
    │   └─Limit	10.00	cop[tikv]		offset:0, count:10
    │     └─Selection	10.00	cop[tikv]		gt(list_partition_pruning.trange.a, 10)
    │       └─TableFullScan	30.00	cop[tikv]	table:trange, partition:p2	keep order:true, stats:pseudo
    └─Limit	10.00	root		offset:0, count:10
      └─TableReader	10.00	root		data:Limit
        └─Limit	10.00	cop[tikv]		offset:0, count:10
          └─Selection	10.00	cop[tikv]		gt(list_partition_pruning.trange.a, 10)
            └─TableFullScan	30.00	cop[tikv]	table:trange, partition:p3	keep order:true, stats:pseudo
explain format='brief' select a from tlist use index () where a > 10 order by b limit 10;
id	estRows	task	access object	operator info
Projection	10.00	root		list_partition_pruning.tlist.a
└─TopN	10.00	root		list_partition_pruning.tlist.b, offset:0, count:10
  └─PartitionUnion	20.00	root		
    ├─Limit	10.00	root		offset:0, count:10
    │ └─TableReader	10.00	root		data:Limit
    │   └─Limit	10.00	cop[tikv]		offset:0, count:10
    │     └─Selection	10.00	cop[tikv]		gt(list_partition_pruning.tlist.a, 10)
    │       └─TableFullScan	30.00	cop[tikv]	table:tlist, partition:p0	keep order:true, stats:pseudo
    └─Limit	10.00	root		offset:0, count:10
      └─TableReader	10.00	root		data:Limit
        └─Limit	10.00	cop[tikv]		offset:0, count:10
          └─Selection	10.00	cop[tikv]		gt(list_partition_pruning.tlist.a, 10)
            └─TableFullScan	30.00	cop[tikv]	table:tlist, partition:p1	keep order:true, stats:pseudo
explain format='brief' select a from thash use index () where a > 10 order by b limit 10;
id	estRows	task	access object	operator info
Projection	10.00	root		list_partition_pruning.thash.a
└─TopN	10.00	root		list_partition_pruning.thash.b, offset:0, count:10
  └─PartitionUnion	40.00	root		
    ├─Limit	10.00	root		offset:0, count:10
    │ └─TableReader	10.00	root		data:Limit
    │   └─Limit	10.00	cop[tikv]		offset:0, count:10
    │     └─Selection	10.00	cop[tikv]		gt(list_partition_pruning.thash.a, 10)
    │       └─TableFullScan	30.00	cop[tikv]	table:thash, partition:p0	keep order:true, stats:pseudo
    ├─Limit	10.00	root		offset:0, count:10
    │ └─TableReader	10.00	root		data:Limit
    │   └─Limit	10.00	cop[tikv]		offset:0, count:10
    │     └─Selection	10.00	cop[tikv]		gt(list_partition_pruning.thash.a, 10)
    │       └─TableFullScan	30.00	cop[tikv]	table:thash, partition:p1	keep order:true, stats:pseudo
    ├─Limit	10.00	root		offset:0, count:10
    │ └─TableReader	10.00	root		data:Limit
    │   └─Limit	10.00	cop[tikv]		offset:0, count:10
    │     └─Selection	10.00	cop[tikv]		gt(list_partition_pruning.thash.a, 10)
    │       └─TableFullScan	30.00	cop[tikv]	table:thash, partition:p2	keep order:true, stats:pseudo
    └─Limit	10.00	root		offset:0, count:10
      └─TableReader	10.00	root		data:Limit
        └─Limit	10.00	cop[tikv]		offset:0, count:10
          └─Selection	10.00	cop[tikv]		gt(list_partition_pruning.thash.a, 10)
            └─TableFullScan	30.00	cop[tikv]	table:thash, partition:p3	keep order:true, stats:pseudo
drop table if exists t;
create table t(col varchar(32) COLLATE utf8mb4_general_ci DEFAULT NULL) PARTITION BY KEY (`col`) PARTITIONS 7;
explain format = brief select * from t where col = 'linpin';
id	estRows	task	access object	operator info
TableReader	10.00	root		data:Selection
└─Selection	10.00	cop[tikv]		eq(list_partition_pruning.t.col, "linpin")
  └─TableFullScan	10000.00	cop[tikv]	table:t, partition:p4	keep order:false, stats:pseudo
explain format = brief select * from t where col = 'LINPIN';
id	estRows	task	access object	operator info
TableReader	10.00	root		data:Selection
└─Selection	10.00	cop[tikv]		eq(list_partition_pruning.t.col, "LINPIN")
  └─TableFullScan	10000.00	cop[tikv]	table:t, partition:p4	keep order:false, stats:pseudo
