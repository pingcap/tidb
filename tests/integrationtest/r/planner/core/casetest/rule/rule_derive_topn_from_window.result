set tidb_opt_derive_topn=1;
drop table if exists t;
create table t(a int, b int, c int, primary key(b,a));
drop table if exists tt;
create table tt(a int, b int, c int, primary key(b,a) nonclustered);
drop table if exists ti;
create table ti(a int, b int, c int unique);
drop table if exists td;
create table td(a int, b int as (a+1) stored, primary key(b,a));
explain format='plan_tree' select * from (select rank() over () as rank_order from t) DT where rank_order <= 3 -- rank not supported in pattern yet;
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		Column#7
└─Selection	root		le(Column#7, 3)
=======
Projection	root		Column
└─Selection	root		le(Column, 3)
>>>>>>> master
  └─Window	root		rank()->Column#7 over()
    └─IndexReader	root		index:IndexFullScan
      └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
explain format='plan_tree' select * from (select b, row_number() over () as rownumber from t) DT where rownumber <= 3 and b > 5 -- pattern is not applicable with complex filter on top of window;
id	task	access object	operator info
<<<<<<< HEAD
Selection	root		gt(planner__core__casetest__rule__rule_derive_topn_from_window.t.b, 5), le(Column#7, 3)
=======
Selection	root		gt(planner__core__casetest__rule__rule_derive_topn_from_window.t.b, 5), le(Column, 3)
>>>>>>> master
└─Window	root		row_number()->Column#7 over(rows between current row and current row)
  └─IndexReader	root		index:IndexFullScan
    └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
explain format='plan_tree' select * from (select b, row_number() over () as rownumber from t) DT where rownumber > 3  -- pattern is not applicable with filter is not < or <=;
id	task	access object	operator info
<<<<<<< HEAD
Selection	root		gt(Column#7, 3)
=======
Selection	root		gt(Column, 3)
>>>>>>> master
└─Window	root		row_number()->Column#7 over(rows between current row and current row)
  └─IndexReader	root		index:IndexFullScan
    └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
explain format='plan_tree' select * from (select a,b, row_number() over () as rownumber from t) DT where  a > b  -- pattern is not applicable with filter is not < or <=;
id	task	access object	operator info
Selection	root		gt(planner__core__casetest__rule__rule_derive_topn_from_window.t.a, planner__core__casetest__rule__rule_derive_topn_from_window.t.b)
└─Window	root		row_number()->Column#7 over(rows between current row and current row)
  └─IndexReader	root		index:IndexFullScan
    └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
explain format='plan_tree' select * from (select a,b, row_number() over () as rownumber from t) DT where  a <= 3 -- pattern is not applicable with filter is not on row number;
id	task	access object	operator info
Selection	root		le(planner__core__casetest__rule__rule_derive_topn_from_window.t.a, 3)
└─Window	root		row_number()->Column#7 over(rows between current row and current row)
  └─IndexReader	root		index:IndexFullScan
    └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
explain format='plan_tree' select * from (select a,b, row_number() over () as rownumber from t) DT where 3 >= rownumber  -- pattern is not applicable with filter is not < or <=;
id	task	access object	operator info
<<<<<<< HEAD
Selection	root		ge(3, Column#7)
=======
Selection	root		ge(3, Column)
>>>>>>> master
└─Window	root		row_number()->Column#7 over(rows between current row and current row)
  └─IndexReader	root		index:IndexFullScan
    └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
explain format='plan_tree' select * from (select a,b, row_number() over () as rownumber from t) DT where rownumber <= -4   -- pattern is not applicable with filter constant negative;
id	task	access object	operator info
<<<<<<< HEAD
Selection	root		le(Column#7, -4)
=======
Selection	root		le(Column, -4)
>>>>>>> master
└─Window	root		row_number()->Column#7 over(rows between current row and current row)
  └─IndexReader	root		index:IndexFullScan
    └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
explain format='plan_tree' select * from (select row_number() over () as rownumber from t) DT where rownumber <= 3 and rownumber >= 2 -- pattern is not applicable with complex filter;
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		Column#7
└─Selection	root		ge(Column#7, 2), le(Column#7, 3)
=======
Projection	root		Column
└─Selection	root		ge(Column, 2), le(Column, 3)
>>>>>>> master
  └─Window	root		row_number()->Column#7 over(rows between current row and current row)
    └─IndexReader	root		index:IndexFullScan
      └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
explain format='plan_tree' select row_number() over (partition by a) from t -- pattern missing filter on row number;
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		Column#7->Column#8
=======
Projection	root		Column
>>>>>>> master
└─Shuffle	root		execution info: concurrency:5, data sources:[IndexReader]
  └─Window	root		row_number()->Column#7 over(partition by planner__core__casetest__rule__rule_derive_topn_from_window.t.a rows between current row and current row)
    └─Sort	root		planner__core__casetest__rule__rule_derive_topn_from_window.t.a
      └─ShuffleReceiver	root		
        └─IndexReader	root		index:IndexFullScan
          └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
explain format='plan_tree' select * from (select row_number() over () as rownumber1, row_number() over (partition by a) as rownumber2 from t) DT where rownumber1 <= 3 -- pattern not applicable with multiple window functions;
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		Column#9, Column#8
└─Selection	root		le(Column#9, 3)
=======
Projection	root		Column, Column
└─Selection	root		le(Column, 3)
>>>>>>> master
  └─Window	root		row_number()->Column#9 over(rows between current row and current row)
    └─Shuffle	root		execution info: concurrency:5, data sources:[IndexReader]
      └─Window	root		row_number()->Column#8 over(partition by planner__core__casetest__rule__rule_derive_topn_from_window.t.a rows between current row and current row)
        └─Sort	root		planner__core__casetest__rule__rule_derive_topn_from_window.t.a
          └─ShuffleReceiver	root		
            └─IndexReader	root		index:IndexFullScan
              └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
explain format='plan_tree' select * from (select row_number() over (partition by a) as rownumber from t) DT where rownumber <= 3 -- pattern is not applicable with partition by not prefix of PK;
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		Column#7
└─Selection	root		le(Column#7, 3)
=======
Projection	root		Column
└─Selection	root		le(Column, 3)
>>>>>>> master
  └─Shuffle	root		execution info: concurrency:5, data sources:[IndexReader]
    └─Window	root		row_number()->Column#7 over(partition by planner__core__casetest__rule__rule_derive_topn_from_window.t.a rows between current row and current row)
      └─Sort	root		planner__core__casetest__rule__rule_derive_topn_from_window.t.a
        └─ShuffleReceiver	root		
          └─IndexReader	root		index:IndexFullScan
            └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
explain format='plan_tree' select * from (select row_number() over (partition by a) as rownumber from tt) DT where rownumber <= 3 -- pattern is not applicable with no clustered index on table;
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		Column#7
└─Selection	root		le(Column#7, 3)
=======
Projection	root		Column
└─Selection	root		le(Column, 3)
>>>>>>> master
  └─Shuffle	root		execution info: concurrency:5, data sources:[IndexReader]
    └─Window	root		row_number()->Column#7 over(partition by planner__core__casetest__rule__rule_derive_topn_from_window.tt.a rows between current row and current row)
      └─Sort	root		planner__core__casetest__rule__rule_derive_topn_from_window.tt.a
        └─ShuffleReceiver	root		
          └─IndexReader	root		index:IndexFullScan
            └─IndexFullScan	cop[tikv]	table:tt, index:PRIMARY(b, a)	keep order:false, stats:pseudo
explain format='plan_tree' select * from (select row_number() over (partition by a) as rownumber from ti) DT where rownumber <= 3 -- pattern is not applicable. ti clustered on 'c' and partition by 'a';
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		Column#7
└─Selection	root		le(Column#7, 3)
=======
Projection	root		Column
└─Selection	root		le(Column, 3)
>>>>>>> master
  └─Shuffle	root		execution info: concurrency:5, data sources:[TableReader]
    └─Window	root		row_number()->Column#7 over(partition by planner__core__casetest__rule__rule_derive_topn_from_window.ti.a rows between current row and current row)
      └─Sort	root		planner__core__casetest__rule__rule_derive_topn_from_window.ti.a
        └─ShuffleReceiver	root		
          └─TableReader	root		data:TableFullScan
            └─TableFullScan	cop[tikv]	table:ti	keep order:false, stats:pseudo
explain format='plan_tree' select * from (select a, row_number() over (partition by c) as rownumber from ti) DT where rownumber <= 1 -- pattern is applicable. ti clustered on 'c' and partition by 'c' - not supported yet;
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		planner__core__casetest__rule__rule_derive_topn_from_window.ti.a, Column#7
└─Selection	root		le(Column#7, 1)
=======
Projection	root		planner__core__casetest__rule__rule_derive_topn_from_window.ti.a, Column
└─Selection	root		le(Column, 1)
>>>>>>> master
  └─Shuffle	root		execution info: concurrency:5, data sources:[TableReader]
    └─Window	root		row_number()->Column#7 over(partition by planner__core__casetest__rule__rule_derive_topn_from_window.ti.c rows between current row and current row)
      └─Sort	root		planner__core__casetest__rule__rule_derive_topn_from_window.ti.c
        └─ShuffleReceiver	root		
          └─TableReader	root		data:TableFullScan
            └─TableFullScan	cop[tikv]	table:ti	keep order:false, stats:pseudo
explain format='plan_tree' with agg_t as (select count(*) cnt, a from t group by a) select * from (select row_number() over () as rownumber from agg_t) DT where rownumber <= 3 -- pattern on non-data source;
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		Column#16
└─Selection	root		le(Column#16, 3)
  └─Window	root		row_number()->Column#16 over(rows between current row and current row)
    └─HashAgg	root		group by:planner__core__casetest__rule__rule_derive_topn_from_window.t.a, funcs:count(Column#20)->Column#18
      └─IndexReader	root		index:HashAgg
        └─HashAgg	cop[tikv]		group by:planner__core__casetest__rule__rule_derive_topn_from_window.t.a, funcs:count(1)->Column#20
          └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
explain format='plan_tree' select * from (select row_number() over (partition by a+1) as rownumber from td) DT where rownumber <= 1 -- pattern is not applicable with expression in partition by;
id	task	access object	operator info
Projection	root		Column#7
└─Selection	root		le(Column#7, 1)
  └─Shuffle	root		execution info: concurrency:5, data sources:[Projection]
    └─Window	root		row_number()->Column#7 over(partition by Column#6 rows between current row and current row)
      └─Sort	root		Column#6
        └─ShuffleReceiver	root		
          └─Projection	root		plus(planner__core__casetest__rule__rule_derive_topn_from_window.td.a, 1)->Column#6
=======
Projection	root		Column
└─Selection	root		le(Column, 3)
  └─Window	root		row_number()->Column#16 over(rows between current row and current row)
    └─HashAgg	root		group by:planner__core__casetest__rule__rule_derive_topn_from_window.t.a, funcs:count(Column)->Column
      └─IndexReader	root		index:HashAgg
        └─HashAgg	cop[tikv]		group by:planner__core__casetest__rule__rule_derive_topn_from_window.t.a, funcs:count(1)->Column
          └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
explain format='plan_tree' select * from (select row_number() over (partition by a+1) as rownumber from td) DT where rownumber <= 1 -- pattern is not applicable with expression in partition by;
id	task	access object	operator info
Projection	root		Column
└─Selection	root		le(Column, 1)
  └─Shuffle	root		execution info: concurrency:5, data sources:[Projection]
    └─Window	root		row_number()->Column#7 over(partition by Column rows between current row and current row)
      └─Sort	root		Column
        └─ShuffleReceiver	root		
          └─Projection	root		plus(planner__core__casetest__rule__rule_derive_topn_from_window.td.a, 1)->Column
>>>>>>> master
            └─IndexReader	root		index:IndexFullScan
              └─IndexFullScan	cop[tikv]	table:td, index:PRIMARY(b, a)	keep order:false, stats:pseudo
set tidb_opt_derive_topn=1;
drop table if exists t;
create table t(a int, b int, primary key(b,a));
drop table if exists tt;
create table tt(a int, b int, c int, primary key(b,a) nonclustered);
drop table if exists ti;
create table ti(a int, b int, c int unique);
drop table if exists customer;
create table customer(primary_key VARBINARY(1024), secondary_key VARBINARY(1024), c_timestamp BIGINT, value MEDIUMBLOB, PRIMARY KEY (primary_key, secondary_key, c_timestamp) clustered);
drop table if exists td;
create table td(a int, b int as (a+1) stored, primary key(b,a));
insert into t values(1,1);
insert into t values(2,1);
insert into t values(3,2);
insert into t values(4,2);
insert into t values(5,2);
insert into tt select *,55 from t;
insert into ti select *,a from t;
insert into td(a) select a from t;
explain format='plan_tree' select * from (select a,b, row_number() over (order by a) as rownumber from t) DT where rownumber <= 3.5  -- pattern is applicable with N rounded down to an integer. No partition by;
id	task	access object	operator info
<<<<<<< HEAD
Selection	root		le(Column#6, 3)
=======
Selection	root		le(Column, 3)
>>>>>>> master
└─Window	root		row_number()->Column#6 over(order by planner__core__casetest__rule__rule_derive_topn_from_window.t.a rows between current row and current row)
  └─TopN	root		planner__core__casetest__rule__rule_derive_topn_from_window.t.a, offset:0, count:3
    └─IndexReader	root		index:TopN
      └─TopN	cop[tikv]		planner__core__casetest__rule__rule_derive_topn_from_window.t.a, offset:0, count:3
        └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
select * from (select a,b, row_number() over (order by a) as rownumber from t) DT where rownumber <= 3.5  -- pattern is applicable with N rounded down to an integer. No partition by;
a	b	rownumber
1	1	1
2	1	2
3	2	3
explain format='plan_tree' select * from (select row_number() over (order by a) as rownumber from t) DT where rownumber <= 3 -- pattern is applicable. No partition by;
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		Column#6
└─Selection	root		le(Column#6, 3)
=======
Projection	root		Column
└─Selection	root		le(Column, 3)
>>>>>>> master
  └─Window	root		row_number()->Column#6 over(order by planner__core__casetest__rule__rule_derive_topn_from_window.t.a rows between current row and current row)
    └─TopN	root		planner__core__casetest__rule__rule_derive_topn_from_window.t.a, offset:0, count:3
      └─IndexReader	root		index:TopN
        └─TopN	cop[tikv]		planner__core__casetest__rule__rule_derive_topn_from_window.t.a, offset:0, count:3
          └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
select * from (select row_number() over (order by a) as rownumber from t) DT where rownumber <= 3 -- pattern is applicable. No partition by;
rownumber
1
2
3
explain format='plan_tree' select * from (select row_number() over (order by a) as rownumber from t) DT where rownumber < 3 -- pattern is applicable. No partition by;
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		Column#6
└─Selection	root		lt(Column#6, 3)
=======
Projection	root		Column
└─Selection	root		lt(Column, 3)
>>>>>>> master
  └─Window	root		row_number()->Column#6 over(order by planner__core__casetest__rule__rule_derive_topn_from_window.t.a rows between current row and current row)
    └─TopN	root		planner__core__casetest__rule__rule_derive_topn_from_window.t.a, offset:0, count:2
      └─IndexReader	root		index:TopN
        └─TopN	cop[tikv]		planner__core__casetest__rule__rule_derive_topn_from_window.t.a, offset:0, count:2
          └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
select * from (select row_number() over (order by a) as rownumber from t) DT where rownumber < 3 -- pattern is applicable. No partition by;
rownumber
1
2
explain format='plan_tree' select * from (select row_number() over(rows between 1 preceding and 1 following) as rownumber from t) DT where rownumber <= 3 -- pattern is applicable. No partition by;
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		Column#6
└─Selection	root		le(Column#6, 3)
=======
Projection	root		Column
└─Selection	root		le(Column, 3)
>>>>>>> master
  └─Window	root		row_number()->Column#6 over(rows between current row and current row)
    └─Limit	root		offset:0, count:3
      └─IndexReader	root		index:Limit
        └─Limit	cop[tikv]		offset:0, count:3
          └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
select * from (select row_number() over(rows between 1 preceding and 1 following) as rownumber from t) DT where rownumber <= 3 -- pattern is applicable. No partition by;
rownumber
1
2
3
explain format='plan_tree' select * from (select a,row_number() over (order by a desc) as rownumber,b from t) DT where rownumber <= 3 -- pattern is applicable. Order by desc. No partition by;
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		planner__core__casetest__rule__rule_derive_topn_from_window.t.a, Column#6, planner__core__casetest__rule__rule_derive_topn_from_window.t.b
└─Selection	root		le(Column#6, 3)
=======
Projection	root		planner__core__casetest__rule__rule_derive_topn_from_window.t.a, Column, planner__core__casetest__rule__rule_derive_topn_from_window.t.b
└─Selection	root		le(Column, 3)
>>>>>>> master
  └─Window	root		row_number()->Column#6 over(order by planner__core__casetest__rule__rule_derive_topn_from_window.t.a desc rows between current row and current row)
    └─TopN	root		planner__core__casetest__rule__rule_derive_topn_from_window.t.a:desc, offset:0, count:3
      └─IndexReader	root		index:TopN
        └─TopN	cop[tikv]		planner__core__casetest__rule__rule_derive_topn_from_window.t.a:desc, offset:0, count:3
          └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
select * from (select a,row_number() over (order by a desc) as rownumber,b from t) DT where rownumber <= 3 -- pattern is applicable. Order by desc. No partition by;
a	rownumber	b
5	1	2
4	2	2
3	3	2
explain format='plan_tree' select count(*) from (select * from (select a,row_number() over (order by b) as rownumber,b from t) DT1 where rownumber <= 1) DT2  -- pattern is applicable. Window has column a + row_number;
id	task	access object	operator info
<<<<<<< HEAD
StreamAgg	root		funcs:count(1)->Column#7
└─Selection	root		le(Column#6, 1)
=======
StreamAgg	root		funcs:count(1)->Column
└─Selection	root		le(Column, 1)
>>>>>>> master
  └─Window	root		row_number()->Column#6 over(order by planner__core__casetest__rule__rule_derive_topn_from_window.t.b rows between current row and current row)
    └─Limit	root		offset:0, count:1
      └─IndexReader	root		index:Limit
        └─Limit	cop[tikv]		offset:0, count:1
          └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:true, stats:pseudo
select count(*) from (select * from (select a,row_number() over (order by b) as rownumber,b from t) DT1 where rownumber <= 1) DT2  -- pattern is applicable. Window has column a + row_number;
count(*)
1
explain format='plan_tree' select * from (select row_number() over (partition by b) as rownumber from t) DT where rownumber <= 1 -- pattern is applicable with partition by prefix of primary key;
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		Column#6
└─Selection	root		le(Column#6, 1)
=======
Projection	root		Column
└─Selection	root		le(Column, 1)
>>>>>>> master
  └─Window	root		row_number()->Column#6 over(partition by planner__core__casetest__rule__rule_derive_topn_from_window.t.b rows between current row and current row)
    └─IndexReader	root		index:IndexFullScan
      └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:true, stats:pseudo
select * from (select row_number() over (partition by b) as rownumber from t) DT where rownumber <= 1 -- pattern is applicable with partition by prefix of primary key;
rownumber
1
1
explain format='plan_tree' select * from (select row_number() over (partition by b order by a) as rownumber from t) DT where rownumber <= 1 -- pattern is applicable with order by, partition by prefix;
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		Column#6
└─Selection	root		le(Column#6, 1)
=======
Projection	root		Column
└─Selection	root		le(Column, 1)
>>>>>>> master
  └─Window	root		row_number()->Column#6 over(partition by planner__core__casetest__rule__rule_derive_topn_from_window.t.b order by planner__core__casetest__rule__rule_derive_topn_from_window.t.a rows between current row and current row)
    └─IndexReader	root		index:IndexFullScan
      └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:true, stats:pseudo
select * from (select row_number() over (partition by b order by a) as rownumber from t) DT where rownumber <= 1 -- pattern is applicable with order by, partition by prefix;
rownumber
1
1
explain format='plan_tree' select * from (select row_number() over (partition by b) as rownumber from t where a >= 2) DT where rownumber <= 3 order by rownumber  -- pattern is applicable with partition by prefix and filter on data source;
id	task	access object	operator info
<<<<<<< HEAD
Sort	root		Column#6
└─Projection	root		Column#6
  └─Selection	root		le(Column#6, 3)
=======
Sort	root		Column
└─Projection	root		Column
  └─Selection	root		le(Column, 3)
>>>>>>> master
    └─Window	root		row_number()->Column#6 over(partition by planner__core__casetest__rule__rule_derive_topn_from_window.t.b rows between current row and current row)
      └─IndexReader	root		index:Selection
        └─Selection	cop[tikv]		ge(planner__core__casetest__rule__rule_derive_topn_from_window.t.a, 2)
          └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:true, stats:pseudo
select * from (select row_number() over (partition by b) as rownumber from t where a >= 2) DT where rownumber <= 3 order by rownumber  -- pattern is applicable with partition by prefix and filter on data source;
rownumber
1
1
2
3
explain format='plan_tree' select * from (select row_number() over () as rownumber from tt) DT where rownumber <= 3 -- pattern is applicable with no partition on a non-clustered table;
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		Column#7
└─Selection	root		le(Column#7, 3)
=======
Projection	root		Column
└─Selection	root		le(Column, 3)
>>>>>>> master
  └─Window	root		row_number()->Column#7 over(rows between current row and current row)
    └─Limit	root		offset:0, count:3
      └─IndexReader	root		index:Limit
        └─Limit	cop[tikv]		offset:0, count:3
          └─IndexFullScan	cop[tikv]	table:tt, index:PRIMARY(b, a)	keep order:false, stats:pseudo
select * from (select row_number() over () as rownumber from tt) DT where rownumber <= 3 -- pattern is applicable with no partition on a non-clustered table;
rownumber
1
2
3
explain format='plan_tree' select * from (select *, row_number() over (partition by primary_key, secondary_key order by c_timestamp) as rownum from customer where primary_key = 0x002 and secondary_key >= 0x001 and c_timestamp >= 1661883508511000000) as nested where rownum <= 10 order by secondary_key desc;
id	task	access object	operator info
Sort	root		planner__core__casetest__rule__rule_derive_topn_from_window.customer.secondary_key:desc
<<<<<<< HEAD
└─Selection	root		le(Column#7, 10)
=======
└─Selection	root		le(Column, 10)
>>>>>>> master
  └─Window	root		row_number()->Column#7 over(partition by planner__core__casetest__rule__rule_derive_topn_from_window.customer.primary_key, planner__core__casetest__rule__rule_derive_topn_from_window.customer.secondary_key order by planner__core__casetest__rule__rule_derive_topn_from_window.customer.c_timestamp rows between current row and current row)
    └─Sort	root		planner__core__casetest__rule__rule_derive_topn_from_window.customer.primary_key, planner__core__casetest__rule__rule_derive_topn_from_window.customer.secondary_key, planner__core__casetest__rule__rule_derive_topn_from_window.customer.c_timestamp
      └─TableReader	root		data:TopN
        └─TopN	cop[tikv]		partition by planner__core__casetest__rule__rule_derive_topn_from_window.customer.primary_key, planner__core__casetest__rule__rule_derive_topn_from_window.customer.secondary_key order by planner__core__casetest__rule__rule_derive_topn_from_window.customer.c_timestamp, offset:0, count:10
          └─Selection	cop[tikv]		ge(planner__core__casetest__rule__rule_derive_topn_from_window.customer.c_timestamp, 1661883508511000000)
            └─TableRangeScan	cop[tikv]	table:customer	range:["\x00\x02" "\x00\x01","\x00\x02" +inf], keep order:false, stats:pseudo
select * from (select *, row_number() over (partition by primary_key, secondary_key order by c_timestamp) as rownum from customer where primary_key = 0x002 and secondary_key >= 0x001 and c_timestamp >= 1661883508511000000) as nested where rownum <= 10 order by secondary_key desc;
primary_key	secondary_key	c_timestamp	value	rownum
explain format='plan_tree' select * from (select row_number() over (partition by b) as rownumber from td) DT where rownumber <= 1 -- pattern is applicable with partition by prefix of primary key;
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		Column#6
└─Selection	root		le(Column#6, 1)
=======
Projection	root		Column
└─Selection	root		le(Column, 1)
>>>>>>> master
  └─Window	root		row_number()->Column#6 over(partition by planner__core__casetest__rule__rule_derive_topn_from_window.td.b rows between current row and current row)
    └─IndexReader	root		index:IndexFullScan
      └─IndexFullScan	cop[tikv]	table:td, index:PRIMARY(b, a)	keep order:true, stats:pseudo
select * from (select row_number() over (partition by b) as rownumber from td) DT where rownumber <= 1 -- pattern is applicable with partition by prefix of primary key;
rownumber
1
1
1
1
1
set tidb_opt_derive_topn=0;
drop table if exists t;
create table t(a int, b int, primary key(b,a));
explain format='plan_tree' select * from (select a,b, row_number() over (order by a) as rownumber from t) DT where rownumber <= 3.5  -- pattern is applicable but flag is turned off and rule not applied.;
id	task	access object	operator info
<<<<<<< HEAD
Selection	root		le(Column#6, 3)
=======
Selection	root		le(Column, 3)
>>>>>>> master
└─Window	root		row_number()->Column#6 over(order by planner__core__casetest__rule__rule_derive_topn_from_window.t.a rows between current row and current row)
  └─Sort	root		planner__core__casetest__rule__rule_derive_topn_from_window.t.a
    └─IndexReader	root		index:IndexFullScan
      └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
explain format='plan_tree' select * from (select row_number() over (order by a) as rownumber from t) DT where rownumber <= 3 -- pattern is applicable but flag is turned off and rule not applied.;
id	task	access object	operator info
<<<<<<< HEAD
Projection	root		Column#6
└─Selection	root		le(Column#6, 3)
=======
Projection	root		Column
└─Selection	root		le(Column, 3)
>>>>>>> master
  └─Window	root		row_number()->Column#6 over(order by planner__core__casetest__rule__rule_derive_topn_from_window.t.a rows between current row and current row)
    └─Sort	root		planner__core__casetest__rule__rule_derive_topn_from_window.t.a
      └─IndexReader	root		index:IndexFullScan
        └─IndexFullScan	cop[tikv]	table:t, index:PRIMARY(b, a)	keep order:false, stats:pseudo
