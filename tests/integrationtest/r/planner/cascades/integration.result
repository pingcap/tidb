set session tidb_enable_cascades_planner = 1;
explain format="plan_tree" select 1;
id	task	access object	operator info
Projection	root		1->Column#1
└─TableDual	root		rows:1
select 1;
1
1
drop table if exists t;
create table t(a int primary key, b int);
insert into t values(1,2),(3,4),(5,6);
set session tidb_enable_cascades_planner = 1;
explain format="plan_tree" select b from t where a > 1;
id	task	access object	operator info
TableReader	root		data:Projection
└─Projection	cop[tikv]		planner__cascades__integration.t.b
  └─TableRangeScan	cop[tikv]	table:t	range:(1,+inf], keep order:false, stats:pseudo
select b from t where a > 1;
b
4
6
explain format="plan_tree" select b from t where a > 1 and a < 3;
id	task	access object	operator info
TableReader	root		data:Projection
└─Projection	cop[tikv]		planner__cascades__integration.t.b
  └─TableRangeScan	cop[tikv]	table:t	range:(1,3), keep order:false, stats:pseudo
select b from t where a > 1 and a < 3;
b
explain format="plan_tree" select b from t where a > 1 and b < 6;
id	task	access object	operator info
TableReader	root		data:Projection
└─Projection	cop[tikv]		planner__cascades__integration.t.b
  └─Selection	cop[tikv]		lt(planner__cascades__integration.t.b, 6)
    └─TableRangeScan	cop[tikv]	table:t	range:(1,+inf], keep order:false, stats:pseudo
select b from t where a > 1 and b < 6;
b
4
explain format="plan_tree" select a from t where a * 3 + 1 > 9 and a < 5;
id	task	access object	operator info
TableReader	root		data:Selection
└─Selection	cop[tikv]		gt(plus(mul(planner__cascades__integration.t.a, 3), 1), 9)
  └─TableRangeScan	cop[tikv]	table:t	range:[-inf,5), keep order:false, stats:pseudo
select a from t where a * 3 + 1 > 9 and a < 5;
a
3
explain format="plan_tree" select a from t group by a having sum(b) > 4;
id	task	access object	operator info
TableReader	root		data:Projection
└─Projection	cop[tikv]		planner__cascades__integration.t.a
  └─Selection	cop[tikv]		gt(cast(planner__cascades__integration.t.b, decimal(32,0) BINARY), 4)
    └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select a from t group by a having sum(b) > 4;
a
5
drop table if exists t;
create table t(a int primary key, b int, c int, d int, index idx_b(b), index idx_c_b(c, b));
insert into t values(1,2,3,100),(4,5,6,200),(7,8,9,300);
set session tidb_enable_cascades_planner = 1;
explain format="plan_tree" select b from t;
id	task	access object	operator info
IndexReader	root		index:IndexFullScan
└─IndexFullScan	cop[tikv]	table:t, index:idx_b(b)	keep order:false, stats:pseudo
select b from t;
b
2
5
8
explain format="plan_tree" select a from t order by b;
id	task	access object	operator info
Projection	root		planner__cascades__integration.t.a
└─IndexReader	root		index:IndexFullScan
  └─IndexFullScan	cop[tikv]	table:t, index:idx_b(b)	keep order:true, stats:pseudo
select a from t order by b;
a
1
4
7
explain format="plan_tree" select c from t;
id	task	access object	operator info
IndexReader	root		index:IndexFullScan
└─IndexFullScan	cop[tikv]	table:t, index:idx_c_b(c, b)	keep order:false, stats:pseudo
select c from t;
c
3
6
9
explain format="plan_tree" select a from t order by c;
id	task	access object	operator info
Projection	root		planner__cascades__integration.t.a
└─IndexReader	root		index:IndexFullScan
  └─IndexFullScan	cop[tikv]	table:t, index:idx_c_b(c, b)	keep order:true, stats:pseudo
select a from t order by c;
a
1
4
7
explain format="plan_tree" select a, b from t where b > 5 order by b;
id	task	access object	operator info
IndexReader	root		index:IndexRangeScan
└─IndexRangeScan	cop[tikv]	table:t, index:idx_b(b)	range:(5,+inf], keep order:true, stats:pseudo
select a, b from t where b > 5 order by b;
a	b
7	8
explain format="plan_tree" select a, b, c from t where c = 3 and b > 1 order by b;
id	task	access object	operator info
IndexReader	root		index:IndexRangeScan
└─IndexRangeScan	cop[tikv]	table:t, index:idx_c_b(c, b)	range:(3 1,3 +inf], keep order:true, stats:pseudo
select a, b, c from t where c = 3 and b > 1 order by b;
a	b	c
1	2	3
explain format="plan_tree" select a, b from t where c > 1 and b > 1 order by c;
id	task	access object	operator info
Projection	root		planner__cascades__integration.t.a, planner__cascades__integration.t.b
└─IndexReader	root		index:Selection
  └─Selection	cop[tikv]		gt(planner__cascades__integration.t.b, 1)
    └─IndexRangeScan	cop[tikv]	table:t, index:idx_c_b(c, b)	range:(1,+inf], keep order:true, stats:pseudo
select a, b from t where c > 1 and b > 1 order by c;
a	b
1	2
4	5
7	8
drop table if exists t;
create table t(a int primary key, b int);
set session tidb_enable_cascades_planner = 1;
desc t;
Field	Type	Null	Key	Default	Extra
a	int	NO	PRI	NULL	
b	int	YES		NULL	
drop table if exists t;
create table t(a int primary key, b int);
insert into t values (1, 11), (4, 44), (2, 22), (3, 33);
set session tidb_enable_cascades_planner = 1;
explain format="plan_tree" select a from t order by a;
id	task	access object	operator info
TableReader	root		data:TableFullScan
└─TableFullScan	cop[tikv]	table:t	keep order:true, stats:pseudo
select a from t order by a;
a
1
2
3
4
explain format="plan_tree" select b from t order by b;
id	task	access object	operator info
Sort	root		planner__cascades__integration.t.b
└─TableReader	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select b from t order by b;
b
11
22
33
44
explain format="plan_tree" select b from t order by a+b;
id	task	access object	operator info
Projection	root		planner__cascades__integration.t.b
└─Projection	root		planner__cascades__integration.t.a, planner__cascades__integration.t.b
  └─Sort	root		Column#4
    └─Projection	root		planner__cascades__integration.t.a, planner__cascades__integration.t.b, plus(planner__cascades__integration.t.a, planner__cascades__integration.t.b)->Column#4
      └─TableReader	root		data:TableFullScan
        └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select b from t order by a+b;
b
11
22
33
44
explain format="plan_tree" select b from t order by b, a+b, a;
id	task	access object	operator info
Projection	root		planner__cascades__integration.t.b
└─Projection	root		planner__cascades__integration.t.a, planner__cascades__integration.t.b
  └─Sort	root		planner__cascades__integration.t.b, Column#4, planner__cascades__integration.t.a
    └─Projection	root		planner__cascades__integration.t.a, planner__cascades__integration.t.b, plus(planner__cascades__integration.t.a, planner__cascades__integration.t.b)->Column#4
      └─TableReader	root		data:TableFullScan
        └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select b from t order by b, a+b, a;
b
11
22
33
44
drop table if exists t;
create table t(a int primary key, b int);
insert into t values (1, 11), (4, 44), (2, 22), (3, 33);
set session tidb_enable_cascades_planner = 1;
set session tidb_executor_concurrency = 4;
set @@session.tidb_hash_join_concurrency = 5;
set @@session.tidb_distsql_scan_concurrency = 15;
explain format="plan_tree" select sum(a) from t;
id	task	access object	operator info
HashAgg	root		funcs:sum(Column#4)->Column#3
└─TableReader	root		data:HashAgg
  └─HashAgg	cop[tikv]		funcs:sum(planner__cascades__integration.t.a)->Column#4
    └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select sum(a) from t;
sum(a)
10
explain format="plan_tree" select max(a), min(b) from t;
id	task	access object	operator info
HashAgg	root		funcs:max(Column#5)->Column#3, funcs:min(Column#6)->Column#4
└─TableReader	root		data:HashAgg
  └─HashAgg	cop[tikv]		funcs:max(planner__cascades__integration.t.a)->Column#5, funcs:min(planner__cascades__integration.t.b)->Column#6
    └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select max(a), min(b) from t;
max(a)	min(b)
4	11
explain format="plan_tree" select b, avg(a) from t group by b order by b;
id	task	access object	operator info
Sort	root		planner__cascades__integration.t.b
└─Projection	root		planner__cascades__integration.t.b, Column#3
  └─HashAgg	root		group by:planner__cascades__integration.t.b, funcs:avg(Column#4, Column#5)->Column#3, funcs:firstrow(planner__cascades__integration.t.b)->planner__cascades__integration.t.b
    └─TableReader	root		data:HashAgg
      └─HashAgg	cop[tikv]		group by:planner__cascades__integration.t.b, funcs:count(planner__cascades__integration.t.a)->Column#4, funcs:sum(planner__cascades__integration.t.a)->Column#5
        └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select b, avg(a) from t group by b order by b;
b	avg(a)
11	1.0000
22	2.0000
33	3.0000
44	4.0000
explain format="plan_tree" select b, sum(a) from t group by b order by b;
id	task	access object	operator info
Sort	root		planner__cascades__integration.t.b
└─Projection	root		planner__cascades__integration.t.b, Column#3
  └─HashAgg	root		group by:planner__cascades__integration.t.b, funcs:sum(Column#4)->Column#3, funcs:firstrow(planner__cascades__integration.t.b)->planner__cascades__integration.t.b
    └─TableReader	root		data:HashAgg
      └─HashAgg	cop[tikv]		group by:planner__cascades__integration.t.b, funcs:sum(planner__cascades__integration.t.a)->Column#4
        └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select b, sum(a) from t group by b order by b;
b	sum(a)
11	1
22	2
33	3
44	4
explain format="plan_tree" select b, avg(a) from t group by b having sum(a) > 1 order by b;
id	task	access object	operator info
Projection	root		planner__cascades__integration.t.b, Column#3->Column#6
└─Sort	root		planner__cascades__integration.t.b
  └─Selection	root		gt(Column#4, 1)
    └─HashAgg	root		group by:Column#13, funcs:avg(Column#11)->Column#3, funcs:sum(Column#12)->Column#4, funcs:firstrow(Column#13)->planner__cascades__integration.t.b
      └─Projection	root		cast(planner__cascades__integration.t.a, decimal(10,0) BINARY)->Column#11, cast(planner__cascades__integration.t.a, decimal(10,0) BINARY)->Column#12, planner__cascades__integration.t.b->Column#13
        └─TableReader	root		data:TableFullScan
          └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select b, avg(a) from t group by b having sum(a) > 1 order by b;
b	avg(a)
22	2.0000
33	3.0000
44	4.0000
explain format="plan_tree" select max(a+b) from t;
id	task	access object	operator info
StreamAgg	root		funcs:max(Column#5)->Column#3
└─Projection	root		plus(planner__cascades__integration.t.a, planner__cascades__integration.t.b)->Column#5
  └─Projection	root		planner__cascades__integration.t.a, planner__cascades__integration.t.b
    └─TopN	root		Column#4:desc, offset:0, count:1
      └─Projection	root		planner__cascades__integration.t.a, planner__cascades__integration.t.b, plus(planner__cascades__integration.t.a, planner__cascades__integration.t.b)->Column#4
        └─TableReader	root		data:TopN
          └─TopN	cop[tikv]		plus(planner__cascades__integration.t.a, planner__cascades__integration.t.b):desc, offset:0, count:1
            └─Selection	cop[tikv]		not(isnull(plus(planner__cascades__integration.t.a, planner__cascades__integration.t.b)))
              └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select max(a+b) from t;
max(a+b)
48
explain format="plan_tree" select sum(a) from t group by a, a+b order by a;
id	task	access object	operator info
Projection	root		Column#3->Column#4
└─Projection	root		cast(planner__cascades__integration.t.a, decimal(32,0) BINARY)->Column#3, planner__cascades__integration.t.a
  └─TableReader	root		data:TableFullScan
    └─TableFullScan	cop[tikv]	table:t	keep order:true, stats:pseudo
select sum(a) from t group by a, a+b order by a;
sum(a)
1
2
3
4
explain format="plan_tree" select b, sum(a) from t group by b having b > 1 order by b;
id	task	access object	operator info
Sort	root		planner__cascades__integration.t.b
└─Projection	root		planner__cascades__integration.t.b, Column#3
  └─HashAgg	root		group by:planner__cascades__integration.t.b, funcs:sum(Column#4)->Column#3, funcs:firstrow(planner__cascades__integration.t.b)->planner__cascades__integration.t.b
    └─TableReader	root		data:HashAgg
      └─HashAgg	cop[tikv]		group by:planner__cascades__integration.t.b, funcs:sum(planner__cascades__integration.t.a)->Column#4
        └─Selection	cop[tikv]		gt(planner__cascades__integration.t.b, 1)
          └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select b, sum(a) from t group by b having b > 1 order by b;
b	sum(a)
11	1
22	2
33	3
44	4
explain format="plan_tree" select c, sum(a) from (select a+b as c, a from t) t1 group by c having c > 1 order by c;
id	task	access object	operator info
Sort	root		Column#3
└─Projection	root		Column#3, Column#4
  └─HashAgg	root		group by:Column#7, funcs:sum(Column#8)->Column#4, funcs:firstrow(Column#7)->Column#3
    └─TableReader	root		data:HashAgg
      └─HashAgg	cop[tikv]		group by:plus(planner__cascades__integration.t.a, planner__cascades__integration.t.b), funcs:sum(planner__cascades__integration.t.a)->Column#8
        └─Selection	cop[tikv]		gt(plus(planner__cascades__integration.t.a, planner__cascades__integration.t.b), 1)
          └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select c, sum(a) from (select a+b as c, a from t) t1 group by c having c > 1 order by c;
c	sum(a)
12	1
24	2
36	3
48	4
explain format="plan_tree" select max(a.a) from t a left join t b on a.a = b.a;
id	task	access object	operator info
StreamAgg	root		funcs:max(planner__cascades__integration.t.a)->Column#5
└─Limit	root		offset:0, count:1
  └─TableReader	root		data:Limit
    └─Limit	cop[tikv]		offset:0, count:1
      └─TableFullScan	cop[tikv]	table:a	keep order:true, desc, stats:pseudo
select max(a.a) from t a left join t b on a.a = b.a;
max(a.a)
4
explain format="plan_tree" select avg(a.b) from t a left join t b on a.a = b.a;
id	task	access object	operator info
HashAgg	root		funcs:avg(Column#6, Column#7)->Column#5
└─TableReader	root		data:HashAgg
  └─HashAgg	cop[tikv]		funcs:count(planner__cascades__integration.t.b)->Column#6, funcs:sum(planner__cascades__integration.t.b)->Column#7
    └─TableFullScan	cop[tikv]	table:a	keep order:false, stats:pseudo
select avg(a.b) from t a left join t b on a.a = b.a;
avg(a.b)
27.5000
explain format="plan_tree" select t1.a, max(t1.b) from t as t1 left join (select * from t) as t2 on t1.a = t2.a and t1.b = 3 group by t1.a order by a;
id	task	access object	operator info
TableReader	root		data:TableFullScan
└─TableFullScan	cop[tikv]	table:t1	keep order:true, stats:pseudo
select t1.a, max(t1.b) from t as t1 left join (select * from t) as t2 on t1.a = t2.a and t1.b = 3 group by t1.a order by a;
a	max(t1.b)
1	11
2	22
3	33
4	44
explain format="plan_tree" select t1.a, sum(distinct t1.b) from t as t1 left join (select * from t) as t2 on t1.b = t2.b group by t1.a order by a;
id	task	access object	operator info
Projection	root		planner__cascades__integration.t.a, Column#5
└─Projection	root		cast(planner__cascades__integration.t.b, decimal(32,0) BINARY)->Column#5, planner__cascades__integration.t.a
  └─TableReader	root		data:TableFullScan
    └─TableFullScan	cop[tikv]	table:t1	keep order:true, stats:pseudo
select t1.a, sum(distinct t1.b) from t as t1 left join (select * from t) as t2 on t1.b = t2.b group by t1.a order by a;
a	sum(distinct t1.b)
1	11
2	22
3	33
4	44
explain format="plan_tree" select t2.a, max(t2.b) from t as t1 right join (select * from t) as t2 on t1.a = t2.a group by t2.a order by a;
id	task	access object	operator info
TableReader	root		data:TableFullScan
└─TableFullScan	cop[tikv]	table:t	keep order:true, stats:pseudo
select t2.a, max(t2.b) from t as t1 right join (select * from t) as t2 on t1.a = t2.a group by t2.a order by a;
a	max(t2.b)
1	11
2	22
3	33
4	44
explain format="plan_tree" select t3.a, max(t3.b) from (select t1.a, t1.b from t as t1 left join t as t2 on t1.b = t2.b) t3 group by t3.a order by a;
id	task	access object	operator info
Projection	root		planner__cascades__integration.t.a, Column#5
└─Projection	root		planner__cascades__integration.t.b->Column#5, planner__cascades__integration.t.a
  └─TableReader	root		data:TableFullScan
    └─TableFullScan	cop[tikv]	table:t1	keep order:true, stats:pseudo
select t3.a, max(t3.b) from (select t1.a, t1.b from t as t1 left join t as t2 on t1.b = t2.b) t3 group by t3.a order by a;
a	max(t3.b)
1	11
2	22
3	33
4	44
explain format="plan_tree" select max(a) from t;
id	task	access object	operator info
StreamAgg	root		funcs:max(planner__cascades__integration.t.a)->Column#3
└─Limit	root		offset:0, count:1
  └─TableReader	root		data:Limit
    └─Limit	cop[tikv]		offset:0, count:1
      └─TableFullScan	cop[tikv]	table:t	keep order:true, desc, stats:pseudo
select max(a) from t;
max(a)
4
explain format="plan_tree" select sum(case when a > 0 and a <= 1000 then b else 0 end) from t;
id	task	access object	operator info
HashAgg	root		funcs:sum(Column#4)->Column#3
└─TableReader	root		data:HashAgg
  └─HashAgg	cop[tikv]		funcs:sum(case(and(gt(planner__cascades__integration.t.a, 0), le(planner__cascades__integration.t.a, 1000)), planner__cascades__integration.t.b, 0))->Column#4
    └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select sum(case when a > 0 and a <= 1000 then b else 0 end) from t;
sum(case when a > 0 and a <= 1000 then b else 0 end)
110
explain format="plan_tree" select sum(case when a > 0 then (case when a <= 1000 then b end) else 0 end) from t;
id	task	access object	operator info
HashAgg	root		funcs:sum(Column#4)->Column#3
└─TableReader	root		data:HashAgg
  └─HashAgg	cop[tikv]		funcs:sum(case(gt(planner__cascades__integration.t.a, 0), case(le(planner__cascades__integration.t.a, 1000), planner__cascades__integration.t.b), 0))->Column#4
    └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select sum(case when a > 0 then (case when a <= 1000 then b end) else 0 end) from t;
sum(case when a > 0 then (case when a <= 1000 then b end) else 0 end)
110
explain format="plan_tree" select sum(case when a <= 0 or a > 1000 then 0.0 else b end) from t;
id	task	access object	operator info
HashAgg	root		funcs:sum(Column#4)->Column#3
└─TableReader	root		data:HashAgg
  └─HashAgg	cop[tikv]		funcs:sum(case(or(le(planner__cascades__integration.t.a, 0), gt(planner__cascades__integration.t.a, 1000)), 0.0, cast(planner__cascades__integration.t.b, decimal(12,1) BINARY)))->Column#4
    └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select sum(case when a <= 0 or a > 1000 then 0.0 else b end) from t;
sum(case when a <= 0 or a > 1000 then 0.0 else b end)
110.0
explain format="plan_tree" select count(case when a > 0 and a <= 1000 then b end) from t;
id	task	access object	operator info
HashAgg	root		funcs:count(Column#4)->Column#3
└─TableReader	root		data:HashAgg
  └─HashAgg	cop[tikv]		funcs:count(case(and(gt(planner__cascades__integration.t.a, 0), le(planner__cascades__integration.t.a, 1000)), planner__cascades__integration.t.b))->Column#4
    └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select count(case when a > 0 and a <= 1000 then b end) from t;
count(case when a > 0 and a <= 1000 then b end)
4
explain format="plan_tree" select count(case when a <= 0 or a > 1000 then null else b end) from t;
id	task	access object	operator info
HashAgg	root		funcs:count(Column#4)->Column#3
└─TableReader	root		data:HashAgg
  └─HashAgg	cop[tikv]		funcs:count(case(or(le(planner__cascades__integration.t.a, 0), gt(planner__cascades__integration.t.a, 1000)), NULL, planner__cascades__integration.t.b))->Column#4
    └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select count(case when a <= 0 or a > 1000 then null else b end) from t;
count(case when a <= 0 or a > 1000 then null else b end)
4
explain format="plan_tree" select count(distinct case when a > 0 and a <= 1000 then b end) from t;
id	task	access object	operator info
HashAgg	root		funcs:count(distinct Column#6)->Column#3
└─Projection	root		case(and(gt(planner__cascades__integration.t.a, 0), le(planner__cascades__integration.t.a, 1000)), planner__cascades__integration.t.b)->Column#6
  └─TableReader	root		data:TableFullScan
    └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select count(distinct case when a > 0 and a <= 1000 then b end) from t;
count(distinct case when a > 0 and a <= 1000 then b end)
4
explain format="plan_tree" select approx_count_distinct(case when a > 0 and a <= 1000 then b end) from t;
id	task	access object	operator info
HashAgg	root		funcs:approx_count_distinct(Column#4)->Column#3
└─Projection	root		case(and(gt(planner__cascades__integration.t.a, 0), le(planner__cascades__integration.t.a, 1000)), planner__cascades__integration.t.b)->Column#4
  └─TableReader	root		data:TableFullScan
    └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select approx_count_distinct(case when a > 0 and a <= 1000 then b end) from t;
approx_count_distinct(case when a > 0 and a <= 1000 then b end)
4
explain format="plan_tree" select count(b), sum(b), avg(b), b, max(b), min(b), bit_and(b), bit_or(b), bit_xor(b) from t group by a having sum(b) >= 0 and count(b) >= 0 order by b;
id	task	access object	operator info
Projection	root		Column#3->Column#11, Column#4->Column#12, Column#5->Column#13, planner__cascades__integration.t.b, Column#6->Column#15, Column#7->Column#16, Column#8->Column#17, Column#9->Column#18, Column#10->Column#19
└─Sort	root		planner__cascades__integration.t.b
  └─Projection	root		if(isnull(planner__cascades__integration.t.b), 0, 1)->Column#3, cast(planner__cascades__integration.t.b, decimal(32,0) BINARY)->Column#4, cast(planner__cascades__integration.t.b, decimal(15,4) BINARY)->Column#5, planner__cascades__integration.t.b, planner__cascades__integration.t.b->Column#6, planner__cascades__integration.t.b->Column#7, ifnull(cast(planner__cascades__integration.t.b, bigint UNSIGNED BINARY), 18446744073709551615)->Column#8, ifnull(cast(planner__cascades__integration.t.b, bigint UNSIGNED BINARY), 0)->Column#9, ifnull(cast(planner__cascades__integration.t.b, bigint UNSIGNED BINARY), 0)->Column#10, cast(planner__cascades__integration.t.b, decimal(32,0) BINARY)->Column#4, if(isnull(planner__cascades__integration.t.b), 0, 1)->Column#3
    └─TableReader	root		data:Selection
      └─Selection	cop[tikv]		ge(cast(planner__cascades__integration.t.b, decimal(32,0) BINARY), 0), ge(if(isnull(planner__cascades__integration.t.b), 0, 1), 0)
        └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select count(b), sum(b), avg(b), b, max(b), min(b), bit_and(b), bit_or(b), bit_xor(b) from t group by a having sum(b) >= 0 and count(b) >= 0 order by b;
count(b)	sum(b)	avg(b)	b	max(b)	min(b)	bit_and(b)	bit_or(b)	bit_xor(b)
1	11	11.0000	11	11	11	11	11	11
1	22	22.0000	22	22	22	22	22	22
1	33	33.0000	33	33	33	33	33	33
1	44	44.0000	44	44	44	44	44	44
explain format="plan_tree" select group_concat(a, b), min(b), avg(a / b), a from t group by (a+b), a order by a;
id	task	access object	operator info
Sort	root		planner__cascades__integration.t.a
└─HashAgg	root		group by:Column#11, Column#12, funcs:group_concat(Column#7, Column#8 separator ",")->Column#3, funcs:min(Column#9)->Column#4, funcs:avg(Column#10)->Column#5, funcs:firstrow(Column#11)->planner__cascades__integration.t.a
  └─Projection	root		cast(planner__cascades__integration.t.a, var_string(20))->Column#7, cast(planner__cascades__integration.t.b, var_string(20))->Column#8, planner__cascades__integration.t.b->Column#9, div(cast(planner__cascades__integration.t.a, decimal(10,0) BINARY), cast(planner__cascades__integration.t.b, decimal(10,0) BINARY))->Column#10, planner__cascades__integration.t.a->Column#11, plus(planner__cascades__integration.t.a, planner__cascades__integration.t.b)->Column#12
    └─TableReader	root		data:TableFullScan
      └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select group_concat(a, b), min(b), avg(a / b), a from t group by (a+b), a order by a;
group_concat(a, b)	min(b)	avg(a / b)	a
111	11	0.09090909	1
222	22	0.09090909	2
333	33	0.09090909	3
444	44	0.09090909	4
explain format="plan_tree" select approx_percentile(a, 50) from t order by b;
id	task	access object	operator info
Projection	root		Column#3->Column#4
└─Sort	root		planner__cascades__integration.t.b
  └─HashAgg	root		funcs:approx_percentile(planner__cascades__integration.t.a, 50)->Column#3, funcs:firstrow(planner__cascades__integration.t.b)->planner__cascades__integration.t.b
    └─TableReader	root		data:TableFullScan
      └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select approx_percentile(a, 50) from t order by b;
approx_percentile(a, 50)
2
drop table if exists t;
create table t(a int, b int, c int, index(c));
insert into t values (1, 1, 1), (1, 1, 3), (1, 2, 3), (2, 1, 3), (1, 2, NULL);
set session sql_mode='';
set session tidb_hashagg_partial_concurrency=1;
set session tidb_hashagg_final_concurrency=1;
set session tidb_enable_cascades_planner = 1;
set @@session.tidb_opt_distinct_agg_push_down = 1;
explain format="plan_tree" select /*+ HASH_AGG() */ avg(distinct a) from t;
id	task	access object	operator info
HashAgg	root		funcs:avg(distinct Column#6)->Column#5
└─Projection	root		cast(planner__cascades__integration.t.a, decimal(10,0) BINARY)->Column#6
  └─TableReader	root		data:HashAgg
    └─HashAgg	cop[tikv]		group by:planner__cascades__integration.t.a, 
      └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select /*+ HASH_AGG() */ avg(distinct a) from t;
avg(distinct a)
1.5000
explain format="plan_tree" select /*+ HASH_AGG() */ a, count(distinct a) from t;
id	task	access object	operator info
Projection	root		planner__cascades__integration.t.a, Column#5
└─HashAgg	root		funcs:count(distinct planner__cascades__integration.t.a)->Column#5, funcs:firstrow(Column#6)->planner__cascades__integration.t.a
  └─TableReader	root		data:HashAgg
    └─HashAgg	cop[tikv]		group by:planner__cascades__integration.t.a, funcs:firstrow(planner__cascades__integration.t.a)->Column#6
      └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select /*+ HASH_AGG() */ a, count(distinct a) from t;
a	count(distinct a)
1	2
explain format="plan_tree" select /*+ HASH_AGG() */ avg(b), c, avg(b), count(distinct A, B),  count(distinct A), count(distinct c), sum(b) from t group by c;
id	task	access object	operator info
Projection	root		Column#5, planner__cascades__integration.t.c, Column#5, Column#6, Column#7, Column#8, Column#9
└─HashAgg	root		group by:planner__cascades__integration.t.c, funcs:avg(Column#10, Column#11)->Column#5, funcs:count(distinct planner__cascades__integration.t.a, planner__cascades__integration.t.b)->Column#6, funcs:count(distinct planner__cascades__integration.t.a)->Column#7, funcs:count(distinct planner__cascades__integration.t.c)->Column#8, funcs:sum(Column#12)->Column#9, funcs:firstrow(planner__cascades__integration.t.c)->planner__cascades__integration.t.c
  └─TableReader	root		data:HashAgg
    └─HashAgg	cop[tikv]		group by:planner__cascades__integration.t.a, planner__cascades__integration.t.b, planner__cascades__integration.t.c, funcs:count(planner__cascades__integration.t.b)->Column#10, funcs:sum(planner__cascades__integration.t.b)->Column#11, funcs:sum(planner__cascades__integration.t.b)->Column#12
      └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select /*+ HASH_AGG() */ avg(b), c, avg(b), count(distinct A, B),  count(distinct A), count(distinct c), sum(b) from t group by c;
avg(b)	c	avg(b)	count(distinct A, B)	count(distinct A)	count(distinct c)	sum(b)
1.0000	1	1.0000	1	1	1	1
1.3333	3	1.3333	3	2	1	4
2.0000	NULL	2.0000	1	1	0	2
explain format="plan_tree" select /*+ STREAM_AGG() */ count(distinct c) from t group by c;
id	task	access object	operator info
StreamAgg	root		group by:planner__cascades__integration.t.c, funcs:count(distinct planner__cascades__integration.t.c)->Column#5
└─IndexReader	root		index:StreamAgg
  └─StreamAgg	cop[tikv]		group by:planner__cascades__integration.t.c, 
    └─IndexFullScan	cop[tikv]	table:t, index:c(c)	keep order:true, stats:pseudo
select /*+ STREAM_AGG() */ count(distinct c) from t group by c;
count(distinct c)
0
1
1
explain format="plan_tree" select /*+ STREAM_AGG() */ count(distinct c) from t;
id	task	access object	operator info
StreamAgg	root		funcs:count(distinct planner__cascades__integration.t.c)->Column#5
└─IndexReader	root		index:IndexFullScan
  └─IndexFullScan	cop[tikv]	table:t, index:c(c)	keep order:false, stats:pseudo
select /*+ STREAM_AGG() */ count(distinct c) from t;
count(distinct c)
2
explain format="plan_tree" select /*+ HASH_AGG() */ count(distinct c) from t;
id	task	access object	operator info
HashAgg	root		funcs:count(distinct planner__cascades__integration.t.c)->Column#5
└─IndexReader	root		index:HashAgg
  └─HashAgg	cop[tikv]		group by:planner__cascades__integration.t.c, 
    └─IndexFullScan	cop[tikv]	table:t, index:c(c)	keep order:false, stats:pseudo
select /*+ HASH_AGG() */ count(distinct c) from t;
count(distinct c)
2
explain format="plan_tree" select count(distinct c) from t group by c;
id	task	access object	operator info
StreamAgg	root		group by:planner__cascades__integration.t.c, funcs:count(distinct planner__cascades__integration.t.c)->Column#5
└─IndexReader	root		index:StreamAgg
  └─StreamAgg	cop[tikv]		group by:planner__cascades__integration.t.c, 
    └─IndexFullScan	cop[tikv]	table:t, index:c(c)	keep order:true, stats:pseudo
select count(distinct c) from t group by c;
count(distinct c)
0
1
1
explain format="plan_tree" select count(distinct c) from t;
id	task	access object	operator info
HashAgg	root		funcs:count(distinct planner__cascades__integration.t.c)->Column#5
└─IndexReader	root		index:HashAgg
  └─HashAgg	cop[tikv]		group by:planner__cascades__integration.t.c, 
    └─IndexFullScan	cop[tikv]	table:t, index:c(c)	keep order:false, stats:pseudo
select count(distinct c) from t;
count(distinct c)
2
drop table if exists t;
create table t(a int, b int, c int, index(c));
insert into t values (1, 1, 1), (1, 1, 3), (1, 2, 3), (2, 1, 3), (1, 2, NULL);
set session sql_mode='';
set session tidb_hashagg_partial_concurrency=1;
set session tidb_hashagg_final_concurrency=1;
set session tidb_enable_cascades_planner = 1;
set @@session.tidb_opt_distinct_agg_push_down = 0;
explain format="plan_tree" select /*+ HASH_AGG(), AGG_TO_COP() */ avg(distinct a) from t;
id	task	access object	operator info
HashAgg	root		funcs:avg(distinct Column#6)->Column#5
└─Projection	root		cast(planner__cascades__integration.t.a, decimal(10,0) BINARY)->Column#6
  └─TableReader	root		data:TableFullScan
    └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select /*+ HASH_AGG(), AGG_TO_COP() */ avg(distinct a) from t;
avg(distinct a)
1.5000
explain format="plan_tree" select /*+ HASH_AGG(), AGG_TO_COP() */ a, count(distinct a) from t;
id	task	access object	operator info
Projection	root		planner__cascades__integration.t.a, Column#5
└─HashAgg	root		funcs:count(distinct planner__cascades__integration.t.a)->Column#5, funcs:firstrow(planner__cascades__integration.t.a)->planner__cascades__integration.t.a
  └─TableReader	root		data:TableFullScan
    └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select /*+ HASH_AGG(), AGG_TO_COP() */ a, count(distinct a) from t;
a	count(distinct a)
1	2
explain format="plan_tree" select /*+ HASH_AGG(), AGG_TO_COP() */ avg(b), c, avg(b), count(distinct A, B),  count(distinct A), count(distinct c), sum(b) from t group by c;
id	task	access object	operator info
Projection	root		Column#5, planner__cascades__integration.t.c, Column#5, Column#6, Column#7, Column#8, Column#9
└─HashAgg	root		group by:Column#18, funcs:avg(Column#14)->Column#5, funcs:count(distinct Column#15, Column#16)->Column#6, funcs:count(distinct Column#17)->Column#7, funcs:count(distinct Column#18)->Column#8, funcs:sum(Column#19)->Column#9, funcs:firstrow(Column#20)->planner__cascades__integration.t.c
  └─Projection	root		cast(planner__cascades__integration.t.b, decimal(10,0) BINARY)->Column#14, planner__cascades__integration.t.a->Column#15, planner__cascades__integration.t.b->Column#16, planner__cascades__integration.t.a->Column#17, planner__cascades__integration.t.c->Column#18, cast(planner__cascades__integration.t.b, decimal(10,0) BINARY)->Column#19, planner__cascades__integration.t.c->Column#20
    └─TableReader	root		data:TableFullScan
      └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select /*+ HASH_AGG(), AGG_TO_COP() */ avg(b), c, avg(b), count(distinct A, B),  count(distinct A), count(distinct c), sum(b) from t group by c;
avg(b)	c	avg(b)	count(distinct A, B)	count(distinct A)	count(distinct c)	sum(b)
1.0000	1	1.0000	1	1	1	1
1.3333	3	1.3333	3	2	1	4
2.0000	NULL	2.0000	1	1	0	2
explain format="plan_tree" select /*+ STREAM_AGG(), AGG_TO_COP() */ count(distinct c) from t group by c;
id	task	access object	operator info
StreamAgg	root		group by:planner__cascades__integration.t.c, funcs:count(distinct planner__cascades__integration.t.c)->Column#5
└─IndexReader	root		index:IndexFullScan
  └─IndexFullScan	cop[tikv]	table:t, index:c(c)	keep order:true, stats:pseudo
select /*+ STREAM_AGG(), AGG_TO_COP() */ count(distinct c) from t group by c;
count(distinct c)
0
1
1
explain format="plan_tree" select /*+ STREAM_AGG(), AGG_TO_COP() */ count(distinct c) from t;
id	task	access object	operator info
StreamAgg	root		funcs:count(distinct planner__cascades__integration.t.c)->Column#5
└─IndexReader	root		index:IndexFullScan
  └─IndexFullScan	cop[tikv]	table:t, index:c(c)	keep order:false, stats:pseudo
select /*+ STREAM_AGG(), AGG_TO_COP() */ count(distinct c) from t;
count(distinct c)
2
explain format="plan_tree" select /*+ HASH_AGG(), AGG_TO_COP() */ count(distinct c) from t;
id	task	access object	operator info
HashAgg	root		funcs:count(distinct planner__cascades__integration.t.c)->Column#5
└─IndexReader	root		index:IndexFullScan
  └─IndexFullScan	cop[tikv]	table:t, index:c(c)	keep order:false, stats:pseudo
select /*+ HASH_AGG(), AGG_TO_COP() */ count(distinct c) from t;
count(distinct c)
2
explain format="plan_tree" select /*+ AGG_TO_COP() */ count(distinct c) from t group by c;
id	task	access object	operator info
StreamAgg	root		group by:planner__cascades__integration.t.c, funcs:count(distinct planner__cascades__integration.t.c)->Column#5
└─IndexReader	root		index:IndexFullScan
  └─IndexFullScan	cop[tikv]	table:t, index:c(c)	keep order:true, stats:pseudo
select /*+ AGG_TO_COP() */ count(distinct c) from t group by c;
count(distinct c)
0
1
1
drop table if exists t;
create table t(a int primary key, b int);
insert into t values (1, 11), (4, 44), (2, 22), (3, 33);
set session tidb_enable_cascades_planner = 1;
explain format="plan_tree" select a from t limit 2;
id	task	access object	operator info
Limit	root		offset:0, count:2
└─TableReader	root		data:Limit
  └─Limit	cop[tikv]		offset:0, count:2
    └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select a from t limit 2;
a
1
2
explain format="plan_tree" select a from t limit 1 offset 2;
id	task	access object	operator info
Limit	root		offset:2, count:1
└─TableReader	root		data:Limit
  └─Limit	cop[tikv]		offset:0, count:3
    └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select a from t limit 1 offset 2;
a
3
explain format="plan_tree" select b from t order by b limit 3;
id	task	access object	operator info
TopN	root		planner__cascades__integration.t.b, offset:0, count:3
└─TableReader	root		data:TopN
  └─TopN	cop[tikv]		planner__cascades__integration.t.b, offset:0, count:3
    └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select b from t order by b limit 3;
b
11
22
33
explain format="plan_tree" select a from t order by a limit 1 offset 2;
id	task	access object	operator info
Limit	root		offset:2, count:1
└─TableReader	root		data:Limit
  └─Limit	cop[tikv]		offset:0, count:3
    └─TableFullScan	cop[tikv]	table:t	keep order:true, stats:pseudo
select a from t order by a limit 1 offset 2;
a
3
explain format="plan_tree" select * from ((select a as aa from t t1) union all (select b as aa from t t2)) as t3 order by aa;
id	task	access object	operator info
Sort	root		Column#5
└─Union	root		
  ├─TableReader	root		data:TableFullScan
  │ └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
  └─TableReader	root		data:TableFullScan
    └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
select * from ((select a as aa from t t1) union all (select b as aa from t t2)) as t3 order by aa;
aa
1
2
3
4
11
22
33
44
explain format="plan_tree" select a, b, lag(a,1) over (order by b) from t order by b;
id	task	access object	operator info
Window	root		lag(planner__cascades__integration.t.a, 1)->Column#4 over(order by planner__cascades__integration.t.b)
└─Sort	root		planner__cascades__integration.t.b
  └─TableReader	root		data:TableFullScan
    └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select a, b, lag(a,1) over (order by b) from t order by b;
a	b	lag(a,1) over (order by b)
1	11	NULL
2	22	1
3	33	2
4	44	3
explain format="plan_tree" select * from (select a+1 as c, a+b as d from t) as t1 order by c+d limit 10;
id	task	access object	operator info
Projection	root		plus(planner__cascades__integration.t.a, 1)->Column#3, plus(planner__cascades__integration.t.a, planner__cascades__integration.t.b)->Column#4
└─Projection	root		planner__cascades__integration.t.a, planner__cascades__integration.t.b
  └─TopN	root		Column#5, offset:0, count:10
    └─Projection	root		planner__cascades__integration.t.a, planner__cascades__integration.t.b, plus(plus(planner__cascades__integration.t.a, 1), plus(planner__cascades__integration.t.a, planner__cascades__integration.t.b))->Column#5
      └─TableReader	root		data:TopN
        └─TopN	cop[tikv]		plus(plus(planner__cascades__integration.t.a, 1), plus(planner__cascades__integration.t.a, planner__cascades__integration.t.b)), offset:0, count:10
          └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select * from (select a+1 as c, a+b as d from t) as t1 order by c+d limit 10;
c	d
2	12
3	24
4	36
5	48
explain format="plan_tree" select t1.a, t1.b from t as t1 left join t as t2 on t1.a = t2.a and t1.b = 3 order by a;
id	task	access object	operator info
TableReader	root		data:TableFullScan
└─TableFullScan	cop[tikv]	table:t1	keep order:true, stats:pseudo
select t1.a, t1.b from t as t1 left join t as t2 on t1.a = t2.a and t1.b = 3 order by a;
a	b
1	11
2	22
3	33
4	44
set @@session.tidb_executor_concurrency = 4;
set @@session.tidb_hash_join_concurrency = 5;
set @@session.tidb_distsql_scan_concurrency = 15;
drop table if exists t1;
drop table if exists t2;
create table t1(a int primary key, b int);
create table t2(a int primary key, b int);
insert into t1 values (1, 11), (4, 44), (2, 22), (3, 33);
insert into t2 values (1, 111), (2, 222), (3, 333), (5, 555);
set session tidb_enable_cascades_planner = 1;
explain format="plan_tree" select t1.a, t1.b from t1, t2 where t1.a = t2.a and t1.a > 2;
id	task	access object	operator info
MergeJoin	root		inner join, left key:planner__cascades__integration.t1.a, right key:planner__cascades__integration.t2.a
├─TableReader(Build)	root		data:TableRangeScan
│ └─TableRangeScan	cop[tikv]	table:t2	range:(2,+inf], keep order:true, stats:pseudo
└─TableReader(Probe)	root		data:TableRangeScan
  └─TableRangeScan	cop[tikv]	table:t1	range:(2,+inf], keep order:true, stats:pseudo
select t1.a, t1.b from t1, t2 where t1.a = t2.a and t1.a > 2;
a	b
3	33
explain format="plan_tree" select t1.a, t1.b from t1, t2 where t1.a > t2.a and t2.b > 200;
id	task	access object	operator info
HashJoin	root		CARTESIAN inner join, other cond:gt(planner__cascades__integration.t1.a, planner__cascades__integration.t2.a)
├─TableReader(Build)	root		data:Selection
│ └─Selection	cop[tikv]		gt(planner__cascades__integration.t2.b, 200)
│   └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
└─TableReader(Probe)	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
select t1.a, t1.b from t1, t2 where t1.a > t2.a and t2.b > 200;
a	b
3	33
4	44
4	44
explain format="plan_tree" select t1.a, t1.b from t1 left join t2 on t1.a = t2.a where t1.a > 2 and t2.b > 200;
id	task	access object	operator info
MergeJoin	root		inner join, left key:planner__cascades__integration.t2.a, right key:planner__cascades__integration.t1.a
├─TableReader(Build)	root		data:TableRangeScan
│ └─TableRangeScan	cop[tikv]	table:t1	range:(2,+inf], keep order:true, stats:pseudo
└─TableReader(Probe)	root		data:Selection
  └─Selection	cop[tikv]		gt(planner__cascades__integration.t2.b, 200)
    └─TableRangeScan	cop[tikv]	table:t2	range:(2,+inf], keep order:true, stats:pseudo
select t1.a, t1.b from t1 left join t2 on t1.a = t2.a where t1.a > 2 and t2.b > 200;
a	b
3	33
explain format="plan_tree" select t2.a, t2.b from t1 right join t2 on t1.a = t2.a where t1.a > 2 and t2.b > 200;
id	task	access object	operator info
MergeJoin	root		inner join, left key:planner__cascades__integration.t2.a, right key:planner__cascades__integration.t1.a
├─TableReader(Build)	root		data:TableRangeScan
│ └─TableRangeScan	cop[tikv]	table:t1	range:(2,+inf], keep order:true, stats:pseudo
└─TableReader(Probe)	root		data:Selection
  └─Selection	cop[tikv]		gt(planner__cascades__integration.t2.b, 200)
    └─TableRangeScan	cop[tikv]	table:t2	range:(2,+inf], keep order:true, stats:pseudo
select t2.a, t2.b from t1 right join t2 on t1.a = t2.a where t1.a > 2 and t2.b > 200;
a	b
3	333
explain format="plan_tree" select t1.a, t1.b from t1, t2 where t1.a = t2.a order by t1.a;
id	task	access object	operator info
MergeJoin	root		inner join, left key:planner__cascades__integration.t1.a, right key:planner__cascades__integration.t2.a
├─TableReader(Build)	root		data:TableFullScan
│ └─TableFullScan	cop[tikv]	table:t2	keep order:true, stats:pseudo
└─TableReader(Probe)	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t1	keep order:true, stats:pseudo
select t1.a, t1.b from t1, t2 where t1.a = t2.a order by t1.a;
a	b
1	11
2	22
3	33
explain format="plan_tree" select * from t1 join t2 on t1.a = t2.a;
id	task	access object	operator info
MergeJoin	root		inner join, left key:planner__cascades__integration.t1.a, right key:planner__cascades__integration.t2.a
├─TableReader(Build)	root		data:TableFullScan
│ └─TableFullScan	cop[tikv]	table:t2	keep order:true, stats:pseudo
└─TableReader(Probe)	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t1	keep order:true, stats:pseudo
select * from t1 join t2 on t1.a = t2.a;
a	b	a	b
1	11	1	111
2	22	2	222
3	33	3	333
explain format="plan_tree" select * from t1 join t2 on t1.a = t2.a and t1.a > 2;
id	task	access object	operator info
MergeJoin	root		inner join, left key:planner__cascades__integration.t1.a, right key:planner__cascades__integration.t2.a
├─TableReader(Build)	root		data:TableRangeScan
│ └─TableRangeScan	cop[tikv]	table:t2	range:(2,+inf], keep order:true, stats:pseudo
└─TableReader(Probe)	root		data:TableRangeScan
  └─TableRangeScan	cop[tikv]	table:t1	range:(2,+inf], keep order:true, stats:pseudo
select * from t1 join t2 on t1.a = t2.a and t1.a > 2;
a	b	a	b
3	33	3	333
drop table if exists t1, t2;
create table t1(a int primary key, b int);
create table t2(a int primary key, b int);
insert into t1 values (1, 11), (4, 44), (2, 22), (3, 33);
insert into t2 values (1, 11), (2, 22), (3, 33);
set session tidb_enable_cascades_planner = 1;
explain format="plan_tree" select a = (select a from t2 where t1.b = t2.b order by a limit 1) from t1;
id	task	access object	operator info
Projection	root		eq(planner__cascades__integration.t1.a, planner__cascades__integration.t2.a)->Column#7
└─Apply	root		CARTESIAN left outer join, left side:TableReader
  ├─TableReader(Build)	root		data:TableFullScan
  │ └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
  └─Limit(Probe)	root		offset:0, count:1
    └─TableReader	root		data:Limit
      └─Limit	cop[tikv]		offset:0, count:1
        └─Selection	cop[tikv]		eq(planner__cascades__integration.t1.b, planner__cascades__integration.t2.b)
          └─TableFullScan	cop[tikv]	table:t2	keep order:true, stats:pseudo
select a = (select a from t2 where t1.b = t2.b order by a limit 1) from t1;
a = (select a from t2 where t1.b = t2.b order by a limit 1)
1
1
1
NULL
explain format="plan_tree" select sum(a), (select t1.a from t1 where t1.a = t2.a limit 1), (select t1.b from t1 where t1.b = t2.b limit 1) from t2;
id	task	access object	operator info
Projection	root		Column#7, planner__cascades__integration.t1.a, planner__cascades__integration.t1.b
└─Apply	root		CARTESIAN left outer join, left side:Apply
  ├─Apply(Build)	root		CARTESIAN left outer join, left side:StreamAgg
  │ ├─StreamAgg(Build)	root		funcs:sum(Column#12)->Column#7, funcs:firstrow(Column#13)->planner__cascades__integration.t2.a, funcs:firstrow(Column#14)->planner__cascades__integration.t2.b
  │ │ └─Projection	root		cast(planner__cascades__integration.t2.a, decimal(10,0) BINARY)->Column#12, planner__cascades__integration.t2.a->Column#13, planner__cascades__integration.t2.b->Column#14
  │ │   └─TableReader	root		data:TableFullScan
  │ │     └─TableFullScan	cop[tikv]	table:t2	keep order:false, stats:pseudo
  │ └─Limit(Probe)	root		offset:0, count:1
  │   └─TableReader	root		data:Limit
  │     └─Limit	cop[tikv]		offset:0, count:1
  │       └─TableRangeScan	cop[tikv]	table:t1	range: decided by [eq(planner__cascades__integration.t1.a, planner__cascades__integration.t2.a)], keep order:false, stats:pseudo
  └─Limit(Probe)	root		offset:0, count:1
    └─TableReader	root		data:Limit
      └─Limit	cop[tikv]		offset:0, count:1
        └─Selection	cop[tikv]		eq(planner__cascades__integration.t1.b, planner__cascades__integration.t2.b)
          └─TableFullScan	cop[tikv]	table:t1	keep order:false, stats:pseudo
select sum(a), (select t1.a from t1 where t1.a = t2.a limit 1), (select t1.b from t1 where t1.b = t2.b limit 1) from t2;
sum(a)	(select t1.a from t1 where t1.a = t2.a limit 1)	(select t1.b from t1 where t1.b = t2.b limit 1)
6	1	11
explain format="plan_tree" select /*+ set_var(tidb_hash_join_version=legacy) */ a from t1 where exists(select 1 from t2 where t1.a = t2.a);
id	task	access object	operator info
MergeJoin	root		semi join, left side:TableReader, left key:planner__cascades__integration.t1.a, right key:planner__cascades__integration.t2.a
├─TableReader(Build)	root		data:TableFullScan
│ └─TableFullScan	cop[tikv]	table:t2	keep order:true, stats:pseudo
└─TableReader(Probe)	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t1	keep order:true, stats:pseudo
explain format="plan_tree" select /*+ set_var(tidb_hash_join_version=optimized) */ a from t1 where exists(select 1 from t2 where t1.a = t2.a);
id	task	access object	operator info
MergeJoin	root		semi join, left side:TableReader, left key:planner__cascades__integration.t1.a, right key:planner__cascades__integration.t2.a
├─TableReader(Build)	root		data:TableFullScan
│ └─TableFullScan	cop[tikv]	table:t2	keep order:true, stats:pseudo
└─TableReader(Probe)	root		data:TableFullScan
  └─TableFullScan	cop[tikv]	table:t1	keep order:true, stats:pseudo
select a from t1 where exists(select 1 from t2 where t1.a = t2.a);
a
1
2
3
set session tidb_enable_cascades_planner = 1;
explain format="plan_tree" select USER, DB, COMMAND, TIME, STATE, INFO, `DIGEST` from information_schema.processlist where DB = "planner__cascades__integration";
id	task	access object	operator info
Projection	root		Column#2, Column#4, Column#5, Column#6, Column#7, Column#8, Column#9
└─Selection	root		eq(Column#4, "planner__cascades__integration")
  └─MemTableScan	root	table:PROCESSLIST	
select USER, DB, COMMAND, TIME, STATE, INFO, `DIGEST` from information_schema.processlist where DB = "planner__cascades__integration";
USER	DB	COMMAND	TIME	STATE	INFO	DIGEST
root	planner__cascades__integration	Query	0	autocommit	select USER, DB, COMMAND, TIME, STATE, INFO, `DIGEST` from information_schema.processlist where DB = "planner__cascades__integration"	769773ab56dd2977858c3c36e76e503323bbbc62257bb2e18e0e10cd9df43973
drop table if exists t;
create table t(a int primary key, b int);
insert into t values (1, 11), (4, 44), (2, 22), (3, 33);
set session tidb_enable_cascades_planner = 1;
explain format="plan_tree" select a from (select a from t where b > 2 order by a limit 3 offset 1) as t1 order by a limit 2 offset 1;
id	task	access object	operator info
Limit	root		offset:1, count:2
└─Limit	root		offset:1, count:3
  └─TableReader	root		data:Limit
    └─Limit	cop[tikv]		offset:0, count:4
      └─Selection	cop[tikv]		gt(planner__cascades__integration.t.b, 2)
        └─TableFullScan	cop[tikv]	table:t	keep order:true, stats:pseudo
select a from (select a from t where b > 2 order by a limit 3 offset 1) as t1 order by a limit 2 offset 1;
a
3
4
explain format="plan_tree" select * from (select * from t order by a limit 3) as t1 order by a limit 5;
id	task	access object	operator info
Limit	root		offset:0, count:5
└─Limit	root		offset:0, count:3
  └─TableReader	root		data:Limit
    └─Limit	cop[tikv]		offset:0, count:3
      └─TableFullScan	cop[tikv]	table:t	keep order:true, stats:pseudo
select * from (select * from t order by a limit 3) as t1 order by a limit 5;
a	b
1	11
2	22
3	33
explain format="plan_tree" select b from (select b from t order by b limit 10 offset 10) as t1 order by b limit 10 offset 5;
id	task	access object	operator info
Limit	root		offset:5, count:10
└─TopN	root		planner__cascades__integration.t.b, offset:10, count:10
  └─TableReader	root		data:TopN
    └─TopN	cop[tikv]		planner__cascades__integration.t.b, offset:0, count:20
      └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select b from (select b from t order by b limit 10 offset 10) as t1 order by b limit 10 offset 5;
b
explain format="plan_tree" select b from (select b from t order by b limit 10 offset 2) as t1 order by b limit 3 offset 5;
id	task	access object	operator info
Limit	root		offset:5, count:3
└─TopN	root		planner__cascades__integration.t.b, offset:2, count:10
  └─TableReader	root		data:TopN
    └─TopN	cop[tikv]		planner__cascades__integration.t.b, offset:0, count:12
      └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select b from (select b from t order by b limit 10 offset 2) as t1 order by b limit 3 offset 5;
b
explain format="plan_tree" select a from (select a from t order by a limit 3 offset 5) as t1 order by a limit 3 offset 5;
id	task	access object	operator info
Limit	root		offset:5, count:3
└─Limit	root		offset:5, count:3
  └─TableReader	root		data:Limit
    └─Limit	cop[tikv]		offset:0, count:8
      └─TableFullScan	cop[tikv]	table:t	keep order:true, stats:pseudo
select a from (select a from t order by a limit 3 offset 5) as t1 order by a limit 3 offset 5;
a
explain format="plan_tree" select a from (select a from t where b > 2 order by a, b limit 3 offset 1) as t1 order by a limit 2 offset 1;
id	task	access object	operator info
Limit	root		offset:1, count:2
└─TopN	root		planner__cascades__integration.t.a, planner__cascades__integration.t.b, offset:1, count:3
  └─TableReader	root		data:TopN
    └─TopN	cop[tikv]		planner__cascades__integration.t.a, planner__cascades__integration.t.b, offset:0, count:4
      └─Selection	cop[tikv]		gt(planner__cascades__integration.t.b, 2)
        └─TableFullScan	cop[tikv]	table:t	keep order:false, stats:pseudo
select a from (select a from t where b > 2 order by a, b limit 3 offset 1) as t1 order by a limit 2 offset 1;
a
3
4
explain format="plan_tree" select * from (select * from t order by a limit 3) as t1 order by a, b limit 5;
id	task	access object	operator info
TopN	root		planner__cascades__integration.t.a, planner__cascades__integration.t.b, offset:0, count:5
└─Limit	root		offset:0, count:3
  └─TableReader	root		data:Limit
    └─Limit	cop[tikv]		offset:0, count:3
      └─TableFullScan	cop[tikv]	table:t	keep order:true, stats:pseudo
select * from (select * from t order by a limit 3) as t1 order by a, b limit 5;
a	b
1	11
2	22
3	33
SET SESSION tidb_opt_fix_control = '44262:ON';
drop table if exists pt1;
create table pt1(a bigint, b bigint) partition by hash(a) partitions 4;
insert into pt1 values(1,10);
insert into pt1 values(2,20);
insert into pt1 values(3,30);
insert into pt1 values(4,40);
insert into pt1 values(5,50);
set @@tidb_enable_cascades_planner = 1;
explain format="plan_tree" select * from pt1 order by a;
id	task	access object	operator info
Sort	root		planner__cascades__integration.pt1.a
└─TableReader	root	partition:all	data:TableFullScan
  └─TableFullScan	cop[tikv]	table:pt1	keep order:false, stats:pseudo
select * from pt1 order by a;
a	b
1	10
2	20
3	30
4	40
5	50
set session tidb_opt_fix_control = default;
set @@tidb_enable_cascades_planner = default;
