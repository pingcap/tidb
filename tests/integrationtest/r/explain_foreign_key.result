set @@foreign_key_checks=1;
drop table if exists t1,t2;
create table t1 (id int key);
create table t2 (id int key, foreign key fk(id) references t1(id) ON UPDATE CASCADE ON DELETE CASCADE);
create table t3 (id int, unique index idx(id));
create table t4 (id int, index idx_id(id),foreign key fk(id) references t3(id));
create table t5 (id int key, id2 int, id3 int, unique index idx2(id2), index idx3(id3));
create table t6 (id int,     id2 int, id3 int, index idx_id(id), index idx_id2(id2), foreign key fk_1 (id) references t5(id) ON UPDATE CASCADE ON DELETE CASCADE, foreign key fk_2 (id2) references t5(id2) ON UPDATE CASCADE, foreign key fk_3 (id3) references t5(id3) ON DELETE CASCADE);
explain format = 'plan_tree' insert into t2 values (1);
id	task	access object	operator info
Insert	root		N/A
└─Foreign_Key_Check	root	table:t1	foreign_key:fk, check_exist
explain format = 'plan_tree' update t2 set id=id+1 where id = 1;
id	task	access object	operator info
Update	root		N/A
├─Point_Get	root	table:t2	handle:1
└─Foreign_Key_Check	root	table:t1	foreign_key:fk, check_exist
explain format = 'plan_tree' delete from t1 where id > 1;
id	task	access object	operator info
Delete	root		N/A
├─TableReader	root		data:TableRangeScan
│ └─TableRangeScan	cop[tikv]	table:t1	range:(1,+inf], keep order:false, stats:pseudo
└─Foreign_Key_Cascade	root	table:t2	foreign_key:fk, on_delete:CASCADE
explain format = 'plan_tree' update t1 set id=id+1 where id = 1;
id	task	access object	operator info
Update	root		N/A
├─Point_Get	root	table:t1	handle:1
└─Foreign_Key_Cascade	root	table:t2	foreign_key:fk, on_update:CASCADE
explain format = 'plan_tree' insert into t1 values (1);
id	task	access object	operator info
Insert	root		N/A
explain format = 'plan_tree' insert into t1 values (1) on duplicate key update id = 100;
id	task	access object	operator info
Insert	root		N/A
└─Foreign_Key_Cascade	root	table:t2	foreign_key:fk, on_update:CASCADE
explain format = 'plan_tree' insert into t4 values (1);
id	task	access object	operator info
Insert	root		N/A
└─Foreign_Key_Check	root	table:t3, index:idx	foreign_key:fk, check_exist
explain format = 'plan_tree' update t4 set id=id+1 where id = 1;
id	task	access object	operator info
Update	root		N/A
├─IndexReader	root		index:IndexRangeScan
│ └─IndexRangeScan	cop[tikv]	table:t4, index:idx_id(id)	range:[1,1], keep order:false, stats:pseudo
└─Foreign_Key_Check	root	table:t3, index:idx	foreign_key:fk, check_exist
explain format = 'plan_tree' delete from t3 where id > 1;
id	task	access object	operator info
Delete	root		N/A
├─IndexReader	root		index:IndexRangeScan
│ └─IndexRangeScan	cop[tikv]	table:t3, index:idx(id)	range:(1,+inf], keep order:false, stats:pseudo
└─Foreign_Key_Check	root	table:t4, index:idx_id	foreign_key:fk, check_not_exist
explain format = 'plan_tree' update t3 set id=id+1 where id = 1;
id	task	access object	operator info
Update	root		N/A
├─Point_Get	root	table:t3, index:idx(id)	
└─Foreign_Key_Check	root	table:t4, index:idx_id	foreign_key:fk, check_not_exist
explain format = 'plan_tree' insert into t3 values (1);
id	task	access object	operator info
Insert	root		N/A
explain format = 'plan_tree' insert into t3 values (1) on duplicate key update id = 100;
id	task	access object	operator info
Insert	root		N/A
└─Foreign_Key_Check	root	table:t4, index:idx_id	foreign_key:fk, check_not_exist
explain format = 'plan_tree' insert into t6 values (1,1,1);
id	task	access object	operator info
Insert	root		N/A
├─Foreign_Key_Check	root	table:t5	foreign_key:fk_1, check_exist
├─Foreign_Key_Check	root	table:t5, index:idx2	foreign_key:fk_2, check_exist
└─Foreign_Key_Check	root	table:t5, index:idx3	foreign_key:fk_3, check_exist
explain format = 'plan_tree' update t6 set id=id+1, id3=id2+1 where id = 1;
id	task	access object	operator info
Update	root		N/A
├─IndexLookUp	root		
│ ├─IndexRangeScan(Build)	cop[tikv]	table:t6, index:idx_id(id)	range:[1,1], keep order:false, stats:pseudo
│ └─TableRowIDScan(Probe)	cop[tikv]	table:t6	keep order:false, stats:pseudo
├─Foreign_Key_Check	root	table:t5	foreign_key:fk_1, check_exist
└─Foreign_Key_Check	root	table:t5, index:idx3	foreign_key:fk_3, check_exist
explain format = 'plan_tree' delete from t5 where id > 1;
id	task	access object	operator info
Delete	root		N/A
├─TableReader	root		data:TableRangeScan
│ └─TableRangeScan	cop[tikv]	table:t5	range:(1,+inf], keep order:false, stats:pseudo
├─Foreign_Key_Check	root	table:t6, index:idx_id2	foreign_key:fk_2, check_not_exist
├─Foreign_Key_Cascade	root	table:t6, index:idx_id	foreign_key:fk_1, on_delete:CASCADE
└─Foreign_Key_Cascade	root	table:t6, index:fk_3	foreign_key:fk_3, on_delete:CASCADE
explain format = 'plan_tree' update t5 set id=id+1, id2=id2+1 where id = 1;
id	task	access object	operator info
Update	root		N/A
├─Point_Get	root	table:t5	handle:1
├─Foreign_Key_Cascade	root	table:t6, index:idx_id	foreign_key:fk_1, on_update:CASCADE
└─Foreign_Key_Cascade	root	table:t6, index:idx_id2	foreign_key:fk_2, on_update:CASCADE
explain format = 'plan_tree' update t5 set id=id+1, id2=id2+1, id3=id3+1 where id = 1;
id	task	access object	operator info
Update	root		N/A
├─Point_Get	root	table:t5	handle:1
├─Foreign_Key_Check	root	table:t6, index:fk_3	foreign_key:fk_3, check_not_exist
├─Foreign_Key_Cascade	root	table:t6, index:idx_id	foreign_key:fk_1, on_update:CASCADE
└─Foreign_Key_Cascade	root	table:t6, index:idx_id2	foreign_key:fk_2, on_update:CASCADE
explain format = 'plan_tree' insert into t5 values (1,1,1);
id	task	access object	operator info
Insert	root		N/A
explain format = 'plan_tree' insert into t5 values (1,1,1) on duplicate key update id = 100, id3=100;
id	task	access object	operator info
Insert	root		N/A
├─Foreign_Key_Check	root	table:t6, index:fk_3	foreign_key:fk_3, check_not_exist
└─Foreign_Key_Cascade	root	table:t6, index:idx_id	foreign_key:fk_1, on_update:CASCADE
explain format = 'plan_tree' insert into t5 values (1,1,1) on duplicate key update id = 100, id2=100, id3=100;
id	task	access object	operator info
Insert	root		N/A
├─Foreign_Key_Check	root	table:t6, index:fk_3	foreign_key:fk_3, check_not_exist
├─Foreign_Key_Cascade	root	table:t6, index:idx_id	foreign_key:fk_1, on_update:CASCADE
└─Foreign_Key_Cascade	root	table:t6, index:idx_id2	foreign_key:fk_2, on_update:CASCADE
drop table if exists t1,t2,t3,t4,t5,t6;
drop table if exists t_1,t_2,t_3,t_4;
create table t_1 (id int key);
create table t_2 (id int key);
create table t_3 (id int key, id2 int, foreign key fk_1(id) references t_1(id), foreign key fk_2(id2) references t_1(id), foreign key fk_3(id) references t_2(id) ON UPDATE CASCADE ON DELETE CASCADE);
create table t_4 (id int key, id2 int, foreign key fk_1(id) references t_2(id), foreign key fk_2(id2) references t_1(id), foreign key fk_3(id) references t_1(id) ON UPDATE CASCADE ON DELETE CASCADE);
explain format = 'plan_tree' update t_1,t_2 set t_1.id=2,t_2.id=2 where t_1.id=t_2.id and t_1.id=1;
id	task	access object	operator info
Update	root		N/A
├─MergeJoin	root		inner join, left key:explain_foreign_key.t_1.id, right key:explain_foreign_key.t_2.id
│ ├─Point_Get(Build)	root	table:t_2	handle:1
│ └─Point_Get(Probe)	root	table:t_1	handle:1
├─Foreign_Key_Check	root	table:t_3	foreign_key:fk_1, check_not_exist
├─Foreign_Key_Check	root	table:t_3, index:fk_2	foreign_key:fk_2, check_not_exist
├─Foreign_Key_Check	root	table:t_4, index:fk_2	foreign_key:fk_2, check_not_exist
├─Foreign_Key_Check	root	table:t_4	foreign_key:fk_1, check_not_exist
├─Foreign_Key_Cascade	root	table:t_4	foreign_key:fk_3, on_update:CASCADE
└─Foreign_Key_Cascade	root	table:t_3	foreign_key:fk_3, on_update:CASCADE
explain format = 'plan_tree' delete t_1,t_2 from t_1 join t_2 where t_1.id=t_2.id and t_1.id > 0;
id	task	access object	operator info
Delete	root		N/A
├─MergeJoin	root		inner join, left key:explain_foreign_key.t_1.id, right key:explain_foreign_key.t_2.id
│ ├─TableReader(Build)	root		data:TableRangeScan
│ │ └─TableRangeScan	cop[tikv]	table:t_2	range:(0,+inf], keep order:true, stats:pseudo
│ └─TableReader(Probe)	root		data:TableRangeScan
│   └─TableRangeScan	cop[tikv]	table:t_1	range:(0,+inf], keep order:true, stats:pseudo
├─Foreign_Key_Check	root	table:t_3	foreign_key:fk_1, check_not_exist
├─Foreign_Key_Check	root	table:t_3, index:fk_2	foreign_key:fk_2, check_not_exist
├─Foreign_Key_Check	root	table:t_4, index:fk_2	foreign_key:fk_2, check_not_exist
├─Foreign_Key_Check	root	table:t_4	foreign_key:fk_1, check_not_exist
├─Foreign_Key_Cascade	root	table:t_4	foreign_key:fk_3, on_delete:CASCADE
└─Foreign_Key_Cascade	root	table:t_3	foreign_key:fk_3, on_delete:CASCADE
set @@foreign_key_checks=0;
explain format = 'plan_tree' update t_1,t_2 set t_1.id=2,t_2.id=2 where t_1.id=t_2.id and t_1.id=1;
id	task	access object	operator info
Update	root		N/A
└─MergeJoin	root		inner join, left key:explain_foreign_key.t_1.id, right key:explain_foreign_key.t_2.id
  ├─Point_Get(Build)	root	table:t_2	handle:1
  └─Point_Get(Probe)	root	table:t_1	handle:1
explain format = 'plan_tree' delete t_1,t_2 from t_1 join t_2 where t_1.id=t_2.id and t_1.id > 0;
id	task	access object	operator info
Delete	root		N/A
└─MergeJoin	root		inner join, left key:explain_foreign_key.t_1.id, right key:explain_foreign_key.t_2.id
  ├─TableReader(Build)	root		data:TableRangeScan
  │ └─TableRangeScan	cop[tikv]	table:t_2	range:(0,+inf], keep order:true, stats:pseudo
  └─TableReader(Probe)	root		data:TableRangeScan
    └─TableRangeScan	cop[tikv]	table:t_1	range:(0,+inf], keep order:true, stats:pseudo
drop table if exists t_1,t_2,t_3,t_4;
set @@foreign_key_checks=0;
