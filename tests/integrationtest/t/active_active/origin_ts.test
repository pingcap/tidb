create table t (id int primary key, v int) softdelete retention 7 day, active_active = 'on';
insert into t (id, v, _tidb_origin_ts) values (1, 1, 123456), (2, 2, 7891011), (3, 3, 5768205);

# When duplicate key update involves multiple rows, the conflict rows should update their origin ts to <nil>
insert into t (id, v) values (2, 22), (3, 33), (4, 44) on duplicate key update v = 42;
select id, v, _tidb_origin_ts from t where id in (1, 2, 3, 4);

# reset
truncate table t;
insert into t (id, v, _tidb_origin_ts) values (1, 1, 123456), (2, 2, 7891011), (3, 3, 5768205);

# insert _tidb_origin_ts is legal
# when conflict, _tidb_origin_ts should not be updated?
insert into t (id, _tidb_origin_ts) values (1, 11111111) on duplicate key update v = 42;
select id, v, _tidb_origin_ts from t where id = 1;

# on duplicate, update _tidb_origin_ts is legal, and _tidb_origin_ts should be updated
insert into t (id, v) values (2, 22) on duplicate key update _tidb_origin_ts = 22222222;
select id, v, _tidb_origin_ts from t where id = 2;

# update should set _tidb_origin_ts as the given value if it is specified
# we should test both const and expression assignment
truncate table t;
insert into t (id, v, _tidb_origin_ts) values (1, 10, 123);
update t set _tidb_origin_ts = 567;
select id, v, _tidb_origin_ts from t;
update t set v=v+_tidb_origin_ts, _tidb_origin_ts=v*_tidb_origin_ts;
select id, v, _tidb_origin_ts from t;

# update should set _tidb_origin_ts to NULL if it's value is not specified
update t set v=200;
select id, v, _tidb_origin_ts from t;

# update should set _tidb_origin_ts to NULL if it's value is not specified,
# but the expression should still use the old _tidb_origin_ts to evaluate
update t set _tidb_origin_ts = 789;
select id, v, _tidb_origin_ts from t;
update t set v=_tidb_origin_ts*10;
select id, v, _tidb_origin_ts from t;

# reset
truncate table t;
insert into t (id, v, _tidb_origin_ts) values (1, 1, 123456), (2, 2, 7891011), (3, 3, 5768205);
create table t1 (id int primary key, v int) softdelete retention 7 day, active_active = 'on';
insert into t1 (id, v) values (1, 101);

# update join involve multiple tables, all _tidb_origin_ts should be updated
update t, t1 set t.v = t1.v, t1.v = 666 where t.id = t1.id;
select id, v, _tidb_origin_ts from t where id = 1;
select id, v, _tidb_origin_ts from t1 where id = 1;

# update join _tidb_origin_ts is legal, and _tidb_origin_ts should be updated
update t, t1 set t1._tidb_origin_ts = 9876543 where t.id = t1.id;
select id, v, _tidb_origin_ts from t1 where id = 1;

# reset
truncate table t;
insert into t (id, v) values (1, 1), (2, 2), (3, 3);
# if _tidb_origin_ts is set, it should be used.
replace into t (id, v, _tidb_origin_ts) values (1, 11, NULL), (2, 22, 222), (3, 33, 333);
select id, v, _tidb_origin_ts from t;
# _tidb_commit_ts should always greater than _tidb_origin_ts, otherwise the implementation is broken.
select * from t where _tidb_commit_ts > _tidb_origin_ts;
