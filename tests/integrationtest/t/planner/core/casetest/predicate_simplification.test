# TestRemoveRedundantPredicates
drop table if exists t;
create table t(a int, f int);
explain format = 'brief' select f from t use index() where f = 1 and f = 1 -- simple redundancy of exact condition;
explain format = 'brief' select f from t use index() where f = 1 and f = 2 -- unsatisfiable condition;
explain format = 'brief' select f from t use index() where f = 1 and f in (1,2,3)  -- intersection of in and =;
explain format = 'brief' select f from t use index() where f = 1 and f <> 1  -- intersection of = and <>;
explain format = 'brief' select f from t use index() where f not in (1,2,3) and f = 3 -- intersection of not in list and =;
explain format = 'brief' select f from t use index() where f <> 3 and f <> 3 -- intersection of two not in values.;
explain format = 'brief' select t1.f /* merge_join(t1, t2) */ from t t1, t t2 where t1.a=t2.a and t1.a=t2.a -- exact redundancy in joins;
explain format = 'brief' select f from t use index() where f in (1,2,3) and f in (3,4,5) -- intersection of two in. Not done yet;
explain format = 'brief' select f from t use index() where f not in (1,2,3) and f not in (3,4,5) -- intersection of two not in. Not done yet;
explain format = 'brief' select f from t use index() where f not in (1,2,3) and f in (1,2,3) -- intersection of in and not in. Not done yet;

# TestInListAndNotEqualSimplification
drop table if exists t;
create table t(a int, f int);
drop table if exists ts;
create table ts(a char(10), f char(10));
explain format = 'brief' select f from t use index() where f <> 1 and f in (1,2,3) -- Simple case;
explain format = 'brief' select f from t use index() where f <> 4 and f in (1,2,3) -- No intersection but <> is redundant;
explain format = 'brief' select f from t use index() where f in (1,2,3) and f <> 2 -- Simple case with different order. Test case for issue 39676;
explain format = 'brief' select f from t use index() where f <> 3 and f in (1,2,3) and f <> 2 -- Multiple <> values. All are in inlist;
explain format = 'brief' select f from t use index() where f in (1,2,3) and f <> 2 and f <> 99 -- Multiple <> values. Some are in inlist;
explain format = 'brief' select f from t use index() where f in (1,2,3) and f <> 5 and f <> 33  -- Multiple <> values. None are in inlist;
explain format = 'brief' select f from t use index() where f <> 3 and f in (1,2,3) and f <> 1 and f <> 2 -- Multiple <> values and cover whole inlist. We keep at least one in inlist;
explain format = 'brief' select 1 from t A, t B where A.f <> 3 and B.f in (1,2,3) and A.f <> 1 and A.f <> 2 -- on different columns. No simplification should be done.;
explain format = 'brief' select 1 from t A, t B where B.f <> 2 and A.f <> 3 and B.f in (1,2,3) and A.f in (3,1,4) and A.f <> 1 and A.f <> 2 -- simplification for two columns.;
explain format = 'brief' select f from ts use index() where f <> '1' and f in ('1','2','3') -- Simple case with string type;
explain format = 'brief' select count(*) cnt from ts where f <> '1' and f in ('1','2','3') group by a having cnt > 100  -- aggregate  ;
explain format = 'brief' select f from t where f <> NULL  and f in (1,2,3) -- Special case of NULL with no simplification.;
explain format = 'brief' select f from t where f != NULL  and f in (NULL,2,3) -- Special case of NULL with no simplification.;

# Test OR simplification start

drop table if exists dt;
drop table if exists it;

CREATE TABLE `dt` (
  `a` bigint(20) unsigned NOT NULL,
  `pk` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `b` longblob DEFAULT NULL,
  `c` int(11) unsigned NOT NULL,
  PRIMARY KEY (`pk`)
);

CREATE TABLE `it` (
  `pk` bigint(20) unsigned NOT NULL,
  `a` varbinary(767) DEFAULT NULL,
  `b` varbinary(767) DEFAULT NULL,
  `c` varbinary(767) DEFAULT NULL,
  `d` bigint(20) DEFAULT NULL,
  `e` varbinary(767) DEFAULT NULL,
  `f` int(11) unsigned NOT NULL,
  PRIMARY KEY (`pk`) ,
  KEY `a` (`a`,`d`,`c`,`pk`),
  KEY `b` (`b`,`pk`),
  KEY `c` (`d`,`pk`),
  KEY `d` (`e`,`pk`),
  KEY `e` (`c`,`pk`),
  KEY `f` (`a`,`pk`)
);

explain format='brief' SELECT
  dt.*
FROM
  it
  LEFT JOIN dt ON it.pk = dt.pk
WHERE
  it.a = "a"
  AND (
    (
      it.a > "a"
    )
    OR (
      it.a = "a" AND it.pk > 1
    )
  )
ORDER BY
  it.pk
LIMIT
  240;


explain  format='brief' SELECT * FROM
 (
SELECT
  dt.*
FROM
  it
  LEFT JOIN dt ON it.pk = dt.pk
WHERE it.a = "a"
      AND it.a = "a"
      AND it.pk > 1
) tb
ORDER BY
  tb.pk
LIMIT
  240;

# Other OR simplification tests

drop table if exists t1;
create table t1 (a1 int, b1 int, c1 char(2));
explain format='brief' select * from t1 where b1=1 and (b1>1 or b1 < 1);
explain format='brief' select * from t1 where a1=1 and (b1=1 or a1 < 1);
explain format='brief' select * from t1 where (b1=1 or a1 < 1) and a1=1;
explain format='brief' select * from t1 where a1 is null and (b1 = 1 or a1 > 5);
explain format='brief' select * from t1 where a1 is not null and (b1 = 1 or a1 > 5);
# negative tests
explain format='brief' select * from t1 where a1=1 and (b1=1 or a1 <= 1);
explain format='brief' select * from t1 where c1=1 and (b1=1 or c1 < 1);

drop table if exists t1;
drop table if exists t2;
CREATE TABLE t1 (code varchar(10)) charset utf8mb4;
CREATE TABLE t2 (id varchar(10) ) charset utf8mb4;
EXPLAIN format='brief' SELECT * FROM t1 INNER JOIN t2 ON code=id WHERE id='a12' AND (LENGTH(code)=5 OR code < 'a00');

drop table if exists t;
CREATE TABLE t (a int , b int);
explain format='brief' select a from t where (a between 2 and 1 or a < 1) and b < 1;
explain format='brief' select a from t where (a between 0 and 2 or a < 2) and b < 1;

drop table if exists IDT_MC21780;
CREATE TABLE IDT_MC21780 (
COL1 timestamp NULL DEFAULT NULL,
COL2 timestamp NULL DEFAULT NULL,
COL3 timestamp NULL DEFAULT NULL
);

explain
select* from IDT_MC21780 t1 where t1.col1 < "1976-09-09 20:21:11" and t1.col1 in ("2021-07-14 09:28:16", "1982-01-09 03:36:39", "1970-12-18 10:53:28");
explain
select/*+ hash_join(t1) */ * from IDT_MC21780 t1 join IDT_MC21780 t2 on t1.col1 = t2.col1
         where t1. col1 < "1976-09-09 20:21:11"
               and t2. col1 in ("2021-07-14 09:28:16", "1982-01-09 03:36:39", "1970-12-18 10:53:28");


# Test OR simplification end 

