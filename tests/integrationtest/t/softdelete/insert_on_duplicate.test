create table message (id int primary key, text varchar(10)) softdelete retention 7 day;
set @@tidb_translate_softdelete_sql = true;
insert into message values (1, '24h'), (2, '24h');
insert into message values (2, 'new') on duplicate key update text = 'new';
select * from message where id = 2;
select * from message order by id;

# Test INSERT ON DUPLICATE KEY UPDATE primary key should fail
-- error 1235
insert into message values (2, 'new') on duplicate key update id = 3;
drop table message;

create table t (id int primary key clustered, v int) softdelete retention 7 day;
insert into t (id, v) values (1, 1), (2, 2), (3, 3), (4, 4);
# soft delete (1, 1), (2, 2)
delete from t where id in (1, 2);

# multiple duplicate id = 3, 4, multiple tombstone id = 1, 2
insert into t (id, v) values (1, 11), (2, 12), (3, 13), (4, 14), (5, 15) on duplicate key update v = 666;
select id, v from t;
select * from t;

# test insert ignore + on duplicate
truncate table t;
insert into t (id, v) values (1, 1), (2, 2), (3, 3);
delete from t where id = 1;
-- error 1292
insert into t values (2, 222) on duplicate key update v = 'abcd';
insert ignore into t values (2, 222) on duplicate key update v = 'abcd';
show warnings;
select id, v from t;
# modify primary key is not supported on soft-delete table
-- error 1235
insert into t values (2, 22) on duplicate key update id = 3;
-- error 1235
insert ignore into t values (2, 22) on duplicate key update id = 3;
select id, v from t;

# What if the on duplicate key update row duplicates with soft-deleted row again?
# Currently we do not support changing the primary key, so this case would not happen.
# TODO: update here when changing primary key is supported
# tk.MustExec(`insert into t2 (id, v) values (1, 1), (2, 2)`)
# tk.MustExec(`update t2 set _tidb_softdelete_time = now() where id = 1`)
# tk.MustExec(`insert into t2 (id, v) values (2, 12) on duplicate key update id = 1`)
# tk.MustQuery(`select id, v from t2 where _tidb_softdelete_time is null`).Sort().Check(testkit.Rows("1 2"))
drop table t;

-- echo # test again with nonclustered
create table t (id int primary key nonclustered, v int) softdelete retention 7 day;
insert into t (id, v) values (1, 1), (2, 2), (3, 3), (4, 4);
# soft delete (1, 1), (2, 2)
delete from t where id in (1, 2);

# multiple duplicate id = 3, 4, multiple tombstone id = 1, 2
insert into t (id, v) values (1, 11), (2, 12), (3, 13), (4, 14), (5, 15) on duplicate key update v = 666;
select id, v from t;
# test insert ignore + on duplicate
truncate table t;
insert into t (id, v) values (1, 1), (2, 2), (3, 3);
delete from t where id = 1;
-- error 1292
insert into t values (2, 222) on duplicate key update v = 'abcd';
insert ignore into t values (2, 222) on duplicate key update v = 'abcd';
show warnings;
select id, v from t;
# modify primary key is not supported on soft-delete table
-- error 1235
insert into t values (2, 22) on duplicate key update id = 3;
-- error 1235
insert ignore into t values (2, 22) on duplicate key update id = 3;
select id, v from t;

# truncate table t;
# What if the on duplicate key update row duplicates with soft-deleted row again?
# Currently we do not support changing the primary key, so this case would not happen.
# TODO: update here when changing primary key is supported
# tk.MustExec(`insert into t2 (id, v) values (1, 1), (2, 2)`)
# tk.MustExec(`update t2 set _tidb_softdelete_time = now() where id = 1`)
# tk.MustExec(`insert into t2 (id, v) values (2, 12) on duplicate key update id = 1`)
# tk.MustQuery(`select id, v from t2 where _tidb_softdelete_time is null`).Sort().Check(testkit.Rows("1 2"))


create table t1 (id int primary key, v1 int unique, v2 int unique, v3 int unique) softdelete retention 7 day;
insert into t1 (id, v1, v2, v3) values (1, 1, 1, 1), (2, 2, 2, 2), (3, 3, 3, 3), (4, 4, 4, 4);
delete from t1 where id in (1, 2);
set @@tidb_translate_softdelete_sql = 0;
select id, v1, v2, v3, isnull(_tidb_softdelete_time) from t1;
insert into t1 (id, v1, v2, v3) values (1, 2, 3, 5) on duplicate key update v3 = 42;
select id, v1, v2, v3, isnull(_tidb_softdelete_time) from t1;
