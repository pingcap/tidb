# TestMaterializedViewLogDML

use test;

# INSERT / UPDATE / DELETE
drop table if exists t;
drop table if exists `$mlog$t`;
create table t (id int primary key, uk int unique, v int, extra int);
create materialized view log on t (id, uk, v);

insert into t values (1,10,100,1000);
select id, uk, v, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW` from `$mlog$t` order by id, uk, v, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW`;

drop materialized view log on t;
create materialized view log on t (id, uk, v);
update t set v=101 where id=1;
select id, uk, v, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW` from `$mlog$t` order by id, uk, v, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW`;

drop materialized view log on t;
create materialized view log on t (id, uk, v);
update t set extra=2000 where id=1;
select count(*) from `$mlog$t`;

drop materialized view log on t;
create materialized view log on t (id, uk, v);
delete from t where id=1;
select id, uk, v, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW` from `$mlog$t` order by id, uk, v, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW`;

# REPLACE
drop table if exists t;
drop table if exists `$mlog$t`;
create table t (id int primary key, uk int unique, v int);
insert into t values (1,10,100), (2,20,200);
create materialized view log on t (id, uk, v);

replace into t values (1,20,999);
select id, uk, v, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW` from `$mlog$t` order by id, uk, v, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW`;

# LOAD DATA
drop table if exists t;
drop table if exists `$mlog$t`;
create table t (id int primary key, uk int unique, v int);
insert into t values (1,10,100);
create materialized view log on t (id, uk, v);

load data local infile './t/executor/mview_log_dml.csv' ignore into table t fields terminated by ',' lines terminated by '\n' (id, uk, v);
select id, uk, v from t order by id;
select id, uk, v, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW` from `$mlog$t` order by id, uk, v, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW`;

# Handle-changed UPDATE (primary key change)
drop table if exists t;
drop table if exists `$mlog$t`;
create table t (id int primary key, v int);
insert into t values (1, 100);
create materialized view log on t (id, v);

update t set id = 2 where id = 1;
select id, v, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW` from `$mlog$t` order by id, v, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW`;

# IODKU without primary key change
drop table if exists t;
drop table if exists `$mlog$t`;
create table t (id int primary key, uk int unique, v int);
insert into t values (1, 10, 100);
create materialized view log on t (id, uk, v);

insert into t values (1, 10, 101) on duplicate key update v=values(v);
select id, uk, v, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW` from `$mlog$t` order by id, uk, v, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW`;

# IODKU with primary key change
drop materialized view log on t;
create materialized view log on t (id, uk, v);
insert into t values (1, 10, 200) on duplicate key update id = 3, v = values(v);
select id, uk, v from t order by id;
select id, uk, v, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW` from `$mlog$t` order by id, uk, v, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW`;


# DDL on non-tracked columns keeps mlog usable

drop table if exists t;
drop table if exists `$mlog$t`;
create table t (id int primary key, tracked int, untracked int);
create materialized view log on t (id, tracked);
insert into t values (1, 10, 100);
drop materialized view log on t;
create materialized view log on t (id, tracked);

alter table t add column c_new int default 0;
update t set untracked = 101 where id = 1;
select count(*) from `$mlog$t`;

insert into t (id, tracked, untracked) values (2, 20, 200);
select id, tracked, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW` from `$mlog$t` order by id, tracked, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW`;

alter table t drop column untracked;
update t set tracked = 11 where id = 1;
select id, tracked, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW` from `$mlog$t` order by id, tracked, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW`;

# Current behavior: DDL on tracked columns is not rejected up-front

drop table if exists t;
drop table if exists `$mlog$t`;
create table t (id int primary key, tracked int, untracked int);
create materialized view log on t (id, tracked);
alter table t drop column tracked;
--error 1105
insert into t values (1, 100);
--error 1105
update t set untracked = 101 where id = 1;
--error 1105
delete from t where id = 1;

# Test for issue #66245, the mlog table should not use the base table's auto-increment id by mistake.
drop table if exists t, `$mlog$t`;
create table t(a int);
create materialized view log on t (a);
insert into t values (1);
select _tidb_rowid, a from t;
select _tidb_rowid, a, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW` from `$mlog$t`;
update t set a = a+1 where a = 1;
insert into t values (2), (3);
select _tidb_rowid, a from t;
select _tidb_rowid, a, `_MLOG$_DML_TYPE`, `_MLOG$_OLD_NEW` from `$mlog$t`;

# Explicit DML on mlog table should be rejected
drop table if exists t;
drop table if exists `$mlog$t`;
create table t (a int primary key, b int);
create materialized view log on t (a, b);
--error 1288
insert into `$mlog$t` values (1, 2, 'I', 1);
--error 1288
replace into `$mlog$t` values (1, 2, 'I', 1);
--error 1288
update `$mlog$t` set a=1;
--error 1288
delete from `$mlog$t`;
select * from `$mlog$t`;

# Explicit DML on materialized view table should be rejected
drop table if exists t;
drop table if exists `$mlog$t`;
create table t (a int primary key, b int not null);
create materialized view log on t (a, b);
create materialized view v (a, s, cnt) as select a, sum(b), count(1) from t group by a;
--error 1288
insert into v values (1, 10, 1);
--error 1288
replace into v values (1, 10, 1);
--error 1288
update v set s=1;
--error 1288
delete from v;
drop materialized view v;

# Prepared DML on mlog table should be rejected
drop table if exists t;
drop table if exists `$mlog$t`;
create table t (a int primary key, b int);
create materialized view log on t (a, b);
--error 1288
prepare stmt_ins from 'insert into `$mlog$t` values (?, ?, ?, ?)';
--error 1288
prepare stmt_upd from 'update `$mlog$t` set a=?';
--error 1288
prepare stmt_del from 'delete from `$mlog$t` where a=?';

# Prepared DML on materialized view table should be rejected
drop table if exists t;
drop table if exists `$mlog$t`;
create table t (a int primary key, b int not null);
create materialized view log on t (a, b);
create materialized view v (a, s, cnt) as select a, sum(b), count(1) from t group by a;
--error 1288
prepare stmt_ins from 'insert into v values (?, ?, ?)';
--error 1288
prepare stmt_upd from 'update v set s=? where a=?';
--error 1288
prepare stmt_del from 'delete from v where a=?';
drop materialized view v;

# LOAD DATA on mlog table should be rejected
drop table if exists t;
drop table if exists `$mlog$t`;
create table t (a int primary key, b int);
create materialized view log on t (a, b);
--error 1288
load data local infile '/nonexistent.csv' into table `$mlog$t` fields terminated by ',';

# LOAD DATA on materialized view table should be rejected
drop table if exists t;
drop table if exists `$mlog$t`;
create table t (a int primary key, b int not null);
create materialized view log on t (a, b);
create materialized view v (a, s, cnt) as select a, sum(b), count(1) from t group by a;
--error 1288
load data local infile '/nonexistent.csv' into table v fields terminated by ',';
drop materialized view v;

# IMPORT INTO on mlog table should be rejected
drop table if exists t;
drop table if exists `$mlog$t`;
create table t (a int primary key, b int);
create materialized view log on t (a, b);
--error 1288
import into `$mlog$t` from '/nonexistent.csv';

# IMPORT INTO on materialized view table should be rejected
drop table if exists t;
drop table if exists `$mlog$t`;
create table t (a int primary key, b int not null);
create materialized view log on t (a, b);
create materialized view v (a, s, cnt) as select a, sum(b), count(1) from t group by a;
--error 1288
import into v from '/nonexistent.csv';
drop materialized view v;

# clean up
drop table if exists t, `$mlog$t`;
